From 07a12c9eb6e95d74472abb425cc5075406f46995 Mon Sep 17 00:00:00 2001
From: YuzukiTsuru <gloomyghost@gloomyghost.com>
Date: Fri, 25 Mar 2022 16:41:10 +0800
Subject: [PATCH 14/93] add sun20i sun50i sunxi and xpower ac codec

---
 sound/Makefile                                |    1 +
 sound/core/Kconfig                            |    7 -
 sound/core/compress_offload.c                 |    4 -
 sound/core/pcm_dmaengine.c                    |   47 +-
 sound/core/pcm_lib.c                          |    2 +
 sound/core/pcm_native.c                       |    1 +
 sound/soc/Kconfig                             |    1 +
 sound/soc/Makefile                            |    1 +
 sound/soc/codecs/Kconfig                      |   17 +
 sound/soc/codecs/Makefile                     |    8 +
 sound/soc/codecs/ac107.c                      | 2170 +++++++++++++
 sound/soc/codecs/ac107.h                      |  491 +++
 sound/soc/codecs/ac108.c                      | 2138 +++++++++++++
 sound/soc/codecs/ac108.h                      |  857 ++++++
 sound/soc/hisilicon/Kconfig                   |    8 +-
 sound/soc/hisilicon/Makefile                  |    1 +
 sound/soc/hisilicon/hi3660-i2s.c              |  448 +++
 sound/soc/hisilicon/hi3660-i2s.h              |   99 +
 sound/soc/soc-core.c                          |   33 +
 sound/soc/soc-pcm.c                           |   70 +
 sound/soc/sprd/Kconfig                        |    2 +-
 sound/soc/sprd/sprd-mcdt.h                    |    2 +-
 sound/soc/sunxi/Kconfig                       |  179 ++
 sound/soc/sunxi/Makefile                      |   51 +
 sound/soc/sunxi/sun20iw1-codec.c              | 2692 ++++++++++++++++
 sound/soc/sunxi/sun20iw1-codec.h              |  557 ++++
 sound/soc/sunxi/sun20iw1-sndcodec.c           |  900 ++++++
 sound/soc/sunxi/sun50iw10-codec.c             | 2013 ++++++++++++
 sound/soc/sunxi/sun50iw10-codec.h             |  448 +++
 sound/soc/sunxi/sun50iw10-sndcodec.c          | 1103 +++++++
 sound/soc/sunxi/sun50iw12-codec.c             | 2717 +++++++++++++++++
 sound/soc/sunxi/sun50iw12-codec.h             |  729 +++++
 sound/soc/sunxi/sun50iw12-sndcodec.c          |  891 ++++++
 sound/soc/sunxi/sun8iw20-codec.c              | 2692 ++++++++++++++++
 sound/soc/sunxi/sun8iw20-codec.h              |  557 ++++
 sound/soc/sunxi/sun8iw20-sndcodec.c           |  900 ++++++
 sound/soc/sunxi/sunxi-daudio.c                | 2281 ++++++++++++++
 sound/soc/sunxi/sunxi-daudio.h                |  496 +++
 sound/soc/sunxi/sunxi-dmic.c                  | 1074 +++++++
 sound/soc/sunxi/sunxi-dmic.h                  |  204 ++
 sound/soc/sunxi/sunxi-dummy-cpudai.c          |  250 ++
 sound/soc/sunxi/sunxi-hdmi.c                  |  359 +++
 sound/soc/sunxi/sunxi-pcm.c                   |  677 ++++
 sound/soc/sunxi/sunxi-pcm.h                   |   43 +
 sound/soc/sunxi/sunxi-rpaf/component/Kconfig  |    9 +
 sound/soc/sunxi/sunxi-rpaf/component/Makefile |    5 +
 .../sunxi-rpaf/component/component-core.c     | 1658 ++++++++++
 .../sunxi-rpaf/component/component-driver.c   |  177 ++
 sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/Kconfig |   65 +
 .../soc/sunxi/sunxi-rpaf/sunxi-hifi/Makefile  |   23 +
 .../sunxi-rpaf/sunxi-hifi/rpaf_flush_cache.S  |   78 +
 .../sunxi/sunxi-rpaf/sunxi-hifi/rpmsg_hifi.c  | 1474 +++++++++
 .../sunxi-rpaf/sunxi-hifi/sunxi-hifi-codec.c  |  317 ++
 .../sunxi-rpaf/sunxi-hifi/sunxi-hifi-codec.h  |   46 +
 .../sunxi-rpaf/sunxi-hifi/sunxi-hifi-cpudai.c | 1035 +++++++
 .../sunxi-rpaf/sunxi-hifi/sunxi-hifi-cpudai.h |   54 +
 .../sunxi-rpaf/sunxi-hifi/sunxi-hifi-daudio.c | 1451 +++++++++
 .../sunxi-rpaf/sunxi-hifi/sunxi-hifi-daudio.h |  125 +
 .../sunxi-rpaf/sunxi-hifi/sunxi-hifi-dmic.c   |  963 ++++++
 .../sunxi-rpaf/sunxi-hifi/sunxi-hifi-dmic.h   |   62 +
 .../sunxi-rpaf/sunxi-hifi/sunxi-hifi-pcm.c    |  454 +++
 .../sunxi-rpaf/sunxi-hifi/sunxi-hifi-pcm.h    |   68 +
 .../sunxi-hifi/sunxi-hifi-simple-card.c       |  523 ++++
 .../sunxi-hifi/sunxi-hifi-sndcodec.c          |  186 ++
 .../sunxi-hifi/sunxi-hifi-sndcodec.h          |   31 +
 sound/soc/sunxi/sunxi-rx-sync.c               |  256 ++
 sound/soc/sunxi/sunxi-rx-sync.h               |   55 +
 sound/soc/sunxi/sunxi-simple-card.c           |  566 ++++
 sound/soc/sunxi/sunxi-spdif.c                 | 1651 ++++++++++
 sound/soc/sunxi/sunxi-spdif.h                 |  322 ++
 sound/soc/sunxi/sunxi_sound_log.h             |   36 +
 sound/soc/sunxi_v2/Kconfig                    |   97 +
 sound/soc/sunxi_v2/Makefile                   |   43 +
 sound/soc/sunxi_v2/ahub/Makefile              |   10 +
 sound/soc/sunxi_v2/ahub/sunxi-hdmi.c          |  408 +++
 sound/soc/sunxi_v2/ahub/sunxi-pcm.c           |  637 ++++
 sound/soc/sunxi_v2/ahub/sunxi-pcm.h           |   34 +
 sound/soc/sunxi_v2/ahub/sunxi-sndahub.c       |  443 +++
 sound/soc/sunxi_v2/ahub/sunxi-snddaudio.c     |  560 ++++
 sound/soc/sunxi_v2/ahub/sunxi-sndhdmi.c       |  274 ++
 sound/soc/sunxi_v2/ahub/sunxi_ahub.c          | 1111 +++++++
 sound/soc/sunxi_v2/ahub/sunxi_ahub.h          |  320 ++
 sound/soc/sunxi_v2/ahub/sunxi_ahub_cpudai.c   |  546 ++++
 sound/soc/sunxi_v2/ahub/sunxi_ahub_daudio.c   | 1063 +++++++
 sound/soc/sunxi_v2/ahub/sunxi_netlink.c       |  266 ++
 sound/soc/sunxi_v2/snd_sun50iw9_codec.c       |  765 +++++
 sound/soc/sunxi_v2/snd_sun50iw9_codec.h       |  185 ++
 sound/soc/sunxi_v2/snd_sunxi_aaudio.c         |  236 ++
 sound/soc/sunxi_v2/snd_sunxi_adapter.c        |  603 ++++
 sound/soc/sunxi_v2/snd_sunxi_adapter.h        |  163 +
 sound/soc/sunxi_v2/snd_sunxi_ahub.c           |  235 ++
 sound/soc/sunxi_v2/snd_sunxi_ahub.h           |   16 +
 sound/soc/sunxi_v2/snd_sunxi_common.c         |  214 ++
 sound/soc/sunxi_v2/snd_sunxi_common.h         |   53 +
 sound/soc/sunxi_v2/snd_sunxi_dmic.c           |  148 +
 sound/soc/sunxi_v2/snd_sunxi_dmic.h           |   18 +
 sound/soc/sunxi_v2/snd_sunxi_dummy_codec.c    |  116 +
 sound/soc/sunxi_v2/snd_sunxi_internal_codec.c |  332 ++
 sound/soc/sunxi_v2/snd_sunxi_internal_codec.h |   19 +
 sound/soc/sunxi_v2/snd_sunxi_log.h            |   30 +
 sound/soc/sunxi_v2/snd_sunxi_mach.c           |  414 +++
 sound/soc/sunxi_v2/snd_sunxi_mach.h           |   17 +
 sound/soc/sunxi_v2/snd_sunxi_mach_utils.c     |  339 ++
 sound/soc/sunxi_v2/snd_sunxi_mach_utils.h     |  113 +
 sound/soc/sunxi_v2/snd_sunxi_pcm.c            |  416 +++
 sound/soc/sunxi_v2/snd_sunxi_pcm.h            |   38 +
 sound/soc/sunxi_v2/snd_sunxi_spdif.c          |  157 +
 sound/soc/sunxi_v2/snd_sunxi_spdif.h          |   16 +
 sound/usb/card.c                              |  192 ++
 sound/usb/card.h                              |   29 +-
 sound/usb/clock.c                             |    5 +
 sound/usb/pcm.c                               |  174 +-
 sound/usb/pcm.h                               |    2 +
 sound/usb/quirks.c                            |    3 -
 sound/usb/stream.c                            |    5 +-
 sound/usb/usbaudio.h                          |   49 +
 116 files changed, 50796 insertions(+), 29 deletions(-)
 create mode 100644 sound/soc/codecs/ac107.c
 create mode 100644 sound/soc/codecs/ac107.h
 create mode 100644 sound/soc/codecs/ac108.c
 create mode 100644 sound/soc/codecs/ac108.h
 create mode 100644 sound/soc/hisilicon/hi3660-i2s.c
 create mode 100644 sound/soc/hisilicon/hi3660-i2s.h
 create mode 100644 sound/soc/sunxi/sun20iw1-codec.c
 create mode 100644 sound/soc/sunxi/sun20iw1-codec.h
 create mode 100644 sound/soc/sunxi/sun20iw1-sndcodec.c
 create mode 100644 sound/soc/sunxi/sun50iw10-codec.c
 create mode 100644 sound/soc/sunxi/sun50iw10-codec.h
 create mode 100644 sound/soc/sunxi/sun50iw10-sndcodec.c
 create mode 100644 sound/soc/sunxi/sun50iw12-codec.c
 create mode 100644 sound/soc/sunxi/sun50iw12-codec.h
 create mode 100644 sound/soc/sunxi/sun50iw12-sndcodec.c
 create mode 100644 sound/soc/sunxi/sun8iw20-codec.c
 create mode 100644 sound/soc/sunxi/sun8iw20-codec.h
 create mode 100644 sound/soc/sunxi/sun8iw20-sndcodec.c
 create mode 100644 sound/soc/sunxi/sunxi-daudio.c
 create mode 100644 sound/soc/sunxi/sunxi-daudio.h
 create mode 100644 sound/soc/sunxi/sunxi-dmic.c
 create mode 100644 sound/soc/sunxi/sunxi-dmic.h
 create mode 100644 sound/soc/sunxi/sunxi-dummy-cpudai.c
 create mode 100644 sound/soc/sunxi/sunxi-hdmi.c
 create mode 100644 sound/soc/sunxi/sunxi-pcm.c
 create mode 100644 sound/soc/sunxi/sunxi-pcm.h
 create mode 100644 sound/soc/sunxi/sunxi-rpaf/component/Kconfig
 create mode 100644 sound/soc/sunxi/sunxi-rpaf/component/Makefile
 create mode 100644 sound/soc/sunxi/sunxi-rpaf/component/component-core.c
 create mode 100644 sound/soc/sunxi/sunxi-rpaf/component/component-driver.c
 create mode 100644 sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/Kconfig
 create mode 100644 sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/Makefile
 create mode 100644 sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/rpaf_flush_cache.S
 create mode 100644 sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/rpmsg_hifi.c
 create mode 100644 sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-codec.c
 create mode 100644 sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-codec.h
 create mode 100644 sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-cpudai.c
 create mode 100644 sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-cpudai.h
 create mode 100644 sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-daudio.c
 create mode 100644 sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-daudio.h
 create mode 100644 sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-dmic.c
 create mode 100644 sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-dmic.h
 create mode 100644 sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-pcm.c
 create mode 100644 sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-pcm.h
 create mode 100644 sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-simple-card.c
 create mode 100644 sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-sndcodec.c
 create mode 100644 sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-sndcodec.h
 create mode 100644 sound/soc/sunxi/sunxi-rx-sync.c
 create mode 100644 sound/soc/sunxi/sunxi-rx-sync.h
 create mode 100644 sound/soc/sunxi/sunxi-simple-card.c
 create mode 100644 sound/soc/sunxi/sunxi-spdif.c
 create mode 100644 sound/soc/sunxi/sunxi-spdif.h
 create mode 100644 sound/soc/sunxi/sunxi_sound_log.h
 create mode 100644 sound/soc/sunxi_v2/Kconfig
 create mode 100644 sound/soc/sunxi_v2/Makefile
 create mode 100644 sound/soc/sunxi_v2/ahub/Makefile
 create mode 100644 sound/soc/sunxi_v2/ahub/sunxi-hdmi.c
 create mode 100644 sound/soc/sunxi_v2/ahub/sunxi-pcm.c
 create mode 100644 sound/soc/sunxi_v2/ahub/sunxi-pcm.h
 create mode 100644 sound/soc/sunxi_v2/ahub/sunxi-sndahub.c
 create mode 100644 sound/soc/sunxi_v2/ahub/sunxi-snddaudio.c
 create mode 100644 sound/soc/sunxi_v2/ahub/sunxi-sndhdmi.c
 create mode 100644 sound/soc/sunxi_v2/ahub/sunxi_ahub.c
 create mode 100644 sound/soc/sunxi_v2/ahub/sunxi_ahub.h
 create mode 100644 sound/soc/sunxi_v2/ahub/sunxi_ahub_cpudai.c
 create mode 100644 sound/soc/sunxi_v2/ahub/sunxi_ahub_daudio.c
 create mode 100644 sound/soc/sunxi_v2/ahub/sunxi_netlink.c
 create mode 100644 sound/soc/sunxi_v2/snd_sun50iw9_codec.c
 create mode 100644 sound/soc/sunxi_v2/snd_sun50iw9_codec.h
 create mode 100644 sound/soc/sunxi_v2/snd_sunxi_aaudio.c
 create mode 100644 sound/soc/sunxi_v2/snd_sunxi_adapter.c
 create mode 100644 sound/soc/sunxi_v2/snd_sunxi_adapter.h
 create mode 100644 sound/soc/sunxi_v2/snd_sunxi_ahub.c
 create mode 100644 sound/soc/sunxi_v2/snd_sunxi_ahub.h
 create mode 100644 sound/soc/sunxi_v2/snd_sunxi_common.c
 create mode 100644 sound/soc/sunxi_v2/snd_sunxi_common.h
 create mode 100644 sound/soc/sunxi_v2/snd_sunxi_dmic.c
 create mode 100644 sound/soc/sunxi_v2/snd_sunxi_dmic.h
 create mode 100644 sound/soc/sunxi_v2/snd_sunxi_dummy_codec.c
 create mode 100644 sound/soc/sunxi_v2/snd_sunxi_internal_codec.c
 create mode 100644 sound/soc/sunxi_v2/snd_sunxi_internal_codec.h
 create mode 100644 sound/soc/sunxi_v2/snd_sunxi_log.h
 create mode 100644 sound/soc/sunxi_v2/snd_sunxi_mach.c
 create mode 100644 sound/soc/sunxi_v2/snd_sunxi_mach.h
 create mode 100644 sound/soc/sunxi_v2/snd_sunxi_mach_utils.c
 create mode 100644 sound/soc/sunxi_v2/snd_sunxi_mach_utils.h
 create mode 100644 sound/soc/sunxi_v2/snd_sunxi_pcm.c
 create mode 100644 sound/soc/sunxi_v2/snd_sunxi_pcm.h
 create mode 100644 sound/soc/sunxi_v2/snd_sunxi_spdif.c
 create mode 100644 sound/soc/sunxi_v2/snd_sunxi_spdif.h

diff --git a/sound/Makefile b/sound/Makefile
index 797ecdcd3..d83de0778 100644
--- a/sound/Makefile
+++ b/sound/Makefile
@@ -6,6 +6,7 @@ obj-$(CONFIG_SOUND) += soundcore.o
 obj-$(CONFIG_DMASOUND) += oss/dmasound/
 obj-$(CONFIG_SND) += core/ i2c/ drivers/ isa/ pci/ ppc/ arm/ sh/ synth/ usb/ \
 	firewire/ sparc/ spi/ parisc/ pcmcia/ mips/ soc/ atmel/ hda/ x86/ xen/
+
 obj-$(CONFIG_SND_AOA) += aoa/
 
 # This one must be compilable even if sound is configured out
diff --git a/sound/core/Kconfig b/sound/core/Kconfig
index 4ee79ad6a..a7655f660 100644
--- a/sound/core/Kconfig
+++ b/sound/core/Kconfig
@@ -38,15 +38,8 @@ config SND_JACK_INPUT_DEV
 	depends on SND_JACK
 	default y if INPUT=y || INPUT=SND
 
-config SND_OSSEMUL
-	bool "Enable OSS Emulation"
-	select SOUND_OSS_CORE
-	help
-	  This option enables the build of OSS emulation layer.
-
 config SND_MIXER_OSS
 	tristate "OSS Mixer API"
-	depends on SND_OSSEMUL
 	help
 	  To enable OSS mixer API emulation (/dev/mixer*), say Y here
 	  and read <file:Documentation/sound/designs/oss-emulation.rst>.
diff --git a/sound/core/compress_offload.c b/sound/core/compress_offload.c
index 1afa06b80..f34ce564d 100644
--- a/sound/core/compress_offload.c
+++ b/sound/core/compress_offload.c
@@ -722,9 +722,6 @@ static int snd_compr_stop(struct snd_compr_stream *stream)
 
 	retval = stream->ops->trigger(stream, SNDRV_PCM_TRIGGER_STOP);
 	if (!retval) {
-		/* clear flags and stop any drain wait */
-		stream->partial_drain = false;
-		stream->metadata_set = false;
 		snd_compr_drain_notify(stream);
 		stream->runtime->total_bytes_available = 0;
 		stream->runtime->total_bytes_transferred = 0;
@@ -882,7 +879,6 @@ static int snd_compr_partial_drain(struct snd_compr_stream *stream)
 	if (stream->next_track == false)
 		return -EPERM;
 
-	stream->partial_drain = true;
 	retval = stream->ops->trigger(stream, SND_COMPR_TRIGGER_PARTIAL_DRAIN);
 	if (retval) {
 		pr_debug("Partial drain returned failure\n");
diff --git a/sound/core/pcm_dmaengine.c b/sound/core/pcm_dmaengine.c
index 89a05926a..7c78ce4c3 100644
--- a/sound/core/pcm_dmaengine.c
+++ b/sound/core/pcm_dmaengine.c
@@ -17,6 +17,12 @@
 #include <sound/pcm_params.h>
 #include <sound/soc.h>
 
+#ifdef CONFIG_SND_SOC_SUNXI_AHUB_TMP
+#include "../soc/sunxi_v2/ahub/sunxi-pcm.h"
+#else
+#include <sound/simple_card.h>
+#endif
+
 #include <sound/dmaengine_pcm.h>
 
 struct dmaengine_pcm_runtime_data {
@@ -148,16 +154,49 @@ static int dmaengine_pcm_prepare_and_submit(struct snd_pcm_substream *substream)
 	enum dma_transfer_direction direction;
 	unsigned long flags = DMA_CTRL_ACK;
 
+	struct snd_card *card = substream->pcm->card;
+#ifdef CONFIG_SND_SOC_SUNXI_AHUB_TMP
+#else
+	struct snd_soc_pcm_runtime *rtd = NULL;
+	struct asoc_simple_priv *sndhdmi_priv = NULL;
+#endif
+	unsigned int raw_flag;
+
 	direction = snd_pcm_substream_to_dma_direction(substream);
 
 	if (!substream->runtime->no_period_wakeup)
 		flags |= DMA_PREP_INTERRUPT;
 
 	prtd->pos = 0;
-	desc = dmaengine_prep_dma_cyclic(chan,
-		substream->runtime->dma_addr,
-		snd_pcm_lib_buffer_bytes(substream),
-		snd_pcm_lib_period_bytes(substream), direction, flags);
+/* sunxi for hdmi dma transfer */
+#ifdef CONFIG_SND_SOC_SUNXI_AHUB_TMP
+	if (strcmp(card->shortname, "sndahub") == 0) {
+		raw_flag = sunxi_ahub_get_rawflag();
+#else
+	if (strcmp(card->shortname, "sndhdmi") == 0) {
+		rtd = substream->private_data;
+		sndhdmi_priv = snd_soc_card_get_drvdata(rtd->card);
+		raw_flag = sndhdmi_priv->hdmi_format;
+#endif
+		if (raw_flag > 1)
+			desc = dmaengine_prep_dma_cyclic(chan,
+				substream->runtime->dma_addr,
+				snd_pcm_lib_buffer_bytes(substream) * 2,
+				snd_pcm_lib_period_bytes(substream) * 2,
+				direction, flags);
+		else
+			desc = dmaengine_prep_dma_cyclic(chan,
+				substream->runtime->dma_addr,
+				snd_pcm_lib_buffer_bytes(substream),
+				snd_pcm_lib_period_bytes(substream),
+				direction, flags);
+	} else {
+		desc = dmaengine_prep_dma_cyclic(chan,
+			substream->runtime->dma_addr,
+			snd_pcm_lib_buffer_bytes(substream),
+			snd_pcm_lib_period_bytes(substream),
+			direction, flags);
+	}
 
 	if (!desc)
 		return -ENOMEM;
diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 1662573a4..816d665a7 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -2051,6 +2051,8 @@ static int pcm_sanity_check(struct snd_pcm_substream *substream)
 	struct snd_pcm_runtime *runtime;
 	if (PCM_RUNTIME_CHECK(substream))
 		return -ENXIO;
+	if (substream->hw_no_buffer)
+		snd_printd("%s: warning this PCM is host less\n", __func__);
 	runtime = substream->runtime;
 	if (snd_BUG_ON(!substream->ops->copy_user && !runtime->dma_area))
 		return -EINVAL;
diff --git a/sound/core/pcm_native.c b/sound/core/pcm_native.c
index ec501fbaa..ddb21945d 100644
--- a/sound/core/pcm_native.c
+++ b/sound/core/pcm_native.c
@@ -1214,6 +1214,7 @@ static int snd_pcm_pre_start(struct snd_pcm_substream *substream, int state)
 	if (runtime->status->state != SNDRV_PCM_STATE_PREPARED)
 		return -EBADFD;
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&
+	    !substream->hw_no_buffer &&
 	    !snd_pcm_playback_data(substream))
 		return -EPIPE;
 	runtime->trigger_tstamp_latched = false;
diff --git a/sound/soc/Kconfig b/sound/soc/Kconfig
index bdc305cec..9773a69e0 100644
--- a/sound/soc/Kconfig
+++ b/sound/soc/Kconfig
@@ -69,6 +69,7 @@ source "sound/soc/sprd/Kconfig"
 source "sound/soc/sti/Kconfig"
 source "sound/soc/stm/Kconfig"
 source "sound/soc/sunxi/Kconfig"
+source "sound/soc/sunxi_v2/Kconfig"
 source "sound/soc/tegra/Kconfig"
 source "sound/soc/ti/Kconfig"
 source "sound/soc/txx9/Kconfig"
diff --git a/sound/soc/Makefile b/sound/soc/Makefile
index 861a21b79..b8d848aed 100644
--- a/sound/soc/Makefile
+++ b/sound/soc/Makefile
@@ -52,6 +52,7 @@ obj-$(CONFIG_SND_SOC)	+= sprd/
 obj-$(CONFIG_SND_SOC)	+= sti/
 obj-$(CONFIG_SND_SOC)	+= stm/
 obj-$(CONFIG_SND_SOC)	+= sunxi/
+obj-$(CONFIG_SND_SOC)	+= sunxi_v2/
 obj-$(CONFIG_SND_SOC)	+= tegra/
 obj-$(CONFIG_SND_SOC)	+= ti/
 obj-$(CONFIG_SND_SOC)	+= txx9/
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index 229cc89f8..61b4f3616 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -1488,4 +1488,21 @@ config SND_SOC_TPA6130A2
 	tristate "Texas Instruments TPA6130A2 headphone amplifier"
 	depends on I2C
 
+config SND_SOC_AC107
+	tristate "Sunxi AC107 Codec"
+	depends on I2C
+	default n
+	help
+	  say Y or M if you want to add support for AC107.
+
+# Sunxi add AC108
+config SND_SOC_AC108
+        tristate "Sunxi AC108 Codec"
+	select MFD_AC108
+        depends on I2C
+        default n
+        help
+          AC108 now used as SUNXI external codec, Connect Through I2S.
+          Say Y or M if you want to add support external audio codec.
+
 endmenu
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index c498373dc..882f77073 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -280,6 +280,9 @@ snd-soc-max98504-objs := max98504.o
 snd-soc-simple-amplifier-objs := simple-amplifier.o
 snd-soc-tpa6130a2-objs := tpa6130a2.o
 snd-soc-tas2552-objs := tas2552.o
+# Sunxi
+snd-soc-ac107-objs := ac107.o
+snd-soc-ac108-objs := ac108.o
 
 obj-$(CONFIG_SND_SOC_88PM860X)	+= snd-soc-88pm860x.o
 obj-$(CONFIG_SND_SOC_AB8500_CODEC)	+= snd-soc-ab8500-codec.o
@@ -563,3 +566,8 @@ obj-$(CONFIG_SND_SOC_MAX9877)	+= snd-soc-max9877.o
 obj-$(CONFIG_SND_SOC_MAX98504)	+= snd-soc-max98504.o
 obj-$(CONFIG_SND_SOC_SIMPLE_AMPLIFIER)	+= snd-soc-simple-amplifier.o
 obj-$(CONFIG_SND_SOC_TPA6130A2)	+= snd-soc-tpa6130a2.o
+
+# Sunxi
+obj-$(CONFIG_SND_SOC_AC107)	+= snd-soc-ac107.o
+obj-$(CONFIG_SND_SOC_AC108)	+= snd-soc-ac108.o
+
diff --git a/sound/soc/codecs/ac107.c b/sound/soc/codecs/ac107.c
new file mode 100644
index 000000000..07f80b974
--- /dev/null
+++ b/sound/soc/codecs/ac107.c
@@ -0,0 +1,2170 @@
+/*
+ * ac107.c  --	ac107 ALSA Soc Audio driver
+ *
+ * Version: 1.0
+ *
+ * Author: panjunwen
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/firmware.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/regmap.h>
+#include <linux/debugfs.h>
+#include <linux/slab.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/initval.h>
+#include <linux/of.h>
+#include <sound/tlv.h>
+#include <linux/regulator/consumer.h>
+#include <linux/io.h>
+#include <linux/of_gpio.h>
+#include <linux/sunxi-gpio.h>
+#include <linux/gpio.h>
+#include "ac107.h"
+
+#define AC107_DEBUG_EN			1
+
+#if AC107_DEBUG_EN
+#define AC107_DEBUG(...)		printk(__VA_ARGS__)
+#else
+#define AC107_DEBUG(...)
+#endif
+
+#define AC107_ADC_PATTERN_SEL	ADC_PTN_NORMAL	/* 0:ADC normal,  1:0x5A5A5A,  2:0x123456,  3:0x000000,  4~7:I2S_RX_DATA,  other:reserved */
+
+/* AC107 config */
+#define AC107_CHIP_NUMS			1	/* range[1, 8] */
+#define AC107_CHIP_NUMS_MAX		8	/* range[1, 8] */
+#define AC107_SLOT_WIDTH		32	/* 8/12/16/20/24/28/32bit Slot Width */
+#define AC107_ENCODING_EN		0	/* TX Encoding mode enable */
+#define AC107_ENCODING_CH_NUMS	2	/* TX Encoding channel numbers, must be dual, range[1, 16] */
+#define AC107_ENCODING_FMT		0	/* TX Encoding format:	0:first channel number 0,  other:first channel number 1 */
+/*range[1, 1024], default PCM mode, I2S/LJ/RJ mode shall divide by 2 */
+//#define AC107_LRCK_PERIOD		(AC107_SLOT_WIDTH*(AC107_ENCODING_EN ? 2 : AC107_CHIP_NUMS*2))
+#define AC107_LRCK_PERIOD		(AC107_SLOT_WIDTH*(AC107_ENCODING_EN ? 2 : AC107_CHIP_NUMS))
+#define AC107_MATCH_DTS_EN		1	/* AC107 match method select: 0: i2c_detect, 1:devices tree */
+
+#define AC107_KCONTROL_EN		1
+#define AC107_DAPM_EN			0
+#define AC107_CODEC_RW_USER_EN	1
+#define AC107_PGA_GAIN			ADC_PGA_GAIN_28dB	//-6dB and 0dB, 3~30dB, 1dB step
+#define AC107_DMIC_EN			0	//0:ADC  1:DMIC
+#define AC107_PDM_EN			0	//0:I2S  1:PDM
+
+#define AC107_DVCC_NAME			"ac107_dvcc_1v8"
+#define AC107_AVCC_VCCIO_NAME	"ac107_avcc_vccio_3v3"
+#define AC107_RATES			(SNDRV_PCM_RATE_8000_48000 | SNDRV_PCM_RATE_KNOT)
+#define AC107_FORMATS			(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
+
+static int ac107_regulator_en;
+struct i2c_client *i2c_ctrl[AC107_CHIP_NUMS_MAX];
+
+struct ac107_voltage_supply {
+	struct regulator *dvcc_1v8;
+	struct regulator *avcc_vccio_3v3;
+};
+
+struct ac107_priv {
+	struct i2c_client *i2c;
+	struct snd_soc_component *component;
+	struct ac107_voltage_supply vol_supply;
+	int reset_gpio;
+};
+
+static const struct regmap_config ac107_regmap_config = {
+	.reg_bits = 8,		//Number of bits in a register address
+	.val_bits = 8,		//Number of bits in a register value
+};
+
+struct real_val_to_reg_val {
+	unsigned int real_val;
+	unsigned int reg_val;
+};
+
+struct reg_default_value {
+	u8 reg_addr;
+	u8 default_val;
+};
+
+struct pll_div {
+	u32 freq_in;
+	u32 freq_out;
+	u32 m1;
+	u32 m2;
+	u32 n;
+	u32 k1;
+	u32 k2;
+};
+
+static const struct real_val_to_reg_val ac107_sample_rate[] = {
+	{8000, 0},
+	{11025, 1},
+	{12000, 2},
+	{16000, 3},
+	{22050, 4},
+	{24000, 5},
+	{32000, 6},
+	{44100, 7},
+	{48000, 8},
+};
+
+static const struct real_val_to_reg_val ac107_bclk_div[] = {
+	{0, 0},
+	{1, 1},
+	{2, 2},
+	{4, 3},
+	{6, 4},
+	{8, 5},
+	{12, 6},
+	{16, 7},
+	{24, 8},
+	{32, 9},
+	{48, 10},
+	{64, 11},
+	{96, 12},
+	{128, 13},
+	{176, 14},
+	{192, 15},
+};
+
+//FOUT =(FIN * N) / [(M1+1) * (M2+1)*(K1+1)*(K2+1)] ;	M1[0,31],  M2[0,1],  N[0,1023],  K1[0,31],  K2[0,1]
+static const struct pll_div ac107_pll_div[] = {
+	{400000, 12288000, 0, 0, 983, 15, 1},	//<out: 12.2875M>
+	{512000, 12288000, 0, 0, 960, 19, 1},	//24576000/48
+	{768000, 12288000, 0, 0, 640, 19, 1},	//24576000/32
+	{800000, 12288000, 0, 0, 768, 24, 1},
+	{1024000, 12288000, 0, 0, 480, 19, 1},	//24576000/24
+	{1600000, 12288000, 0, 0, 384, 24, 1},
+	{2048000, 12288000, 0, 0, 240, 19, 1},	//24576000/12
+	{3072000, 12288000, 0, 0, 160, 19, 1},	//24576000/8
+	{4096000, 12288000, 0, 0, 120, 19, 1},	//24576000/6
+	{6000000, 12288000, 4, 0, 512, 24, 1},
+	{6144000, 12288000, 1, 0, 160, 19, 1},	//24576000/4
+	{12000000, 12288000, 9, 0, 512, 24, 1},
+	{13000000, 12288000, 12, 0, 639, 25, 1},	//<out: 12.2885M>
+	{15360000, 12288000, 9, 0, 320, 19, 1},
+	{16000000, 12288000, 9, 0, 384, 24, 1},
+	{19200000, 12288000, 11, 0, 384, 24, 1},
+	{19680000, 12288000, 15, 1, 999, 24, 1},	//<out: 12.2877M>
+	{24000000, 12288000, 9, 0, 256, 24, 1},
+
+	{400000, 11289600, 0, 0, 1016, 17, 1},	//<out: 11.2889M>
+	{512000, 11289600, 0, 0, 882, 19, 1},
+	{768000, 11289600, 0, 0, 588, 19, 1},
+	{800000, 11289600, 0, 0, 508, 17, 1},	//<out: 11.2889M>
+	{1024000, 11289600, 0, 0, 441, 19, 1},
+	{1600000, 11289600, 0, 0, 254, 17, 1},	//<out: 11.2889M>
+	{2048000, 11289600, 1, 0, 441, 19, 1},
+	{3072000, 11289600, 0, 0, 147, 19, 1},
+	{4096000, 11289600, 3, 0, 441, 19, 1},
+	{6000000, 11289600, 1, 0, 143, 18, 1},	//<out: 11.2895M>
+	{6144000, 11289600, 1, 0, 147, 19, 1},
+	{12000000, 11289600, 3, 0, 143, 18, 1},	//<out: 11.2895M>
+	{13000000, 11289600, 12, 0, 429, 18, 1},	//<out: 11.2895M>
+	{15360000, 11289600, 14, 0, 441, 19, 1},
+	{16000000, 11289600, 24, 0, 882, 24, 1},
+	{19200000, 11289600, 4, 0, 147, 24, 1},
+	{19680000, 11289600, 13, 1, 771, 23, 1},	//<out: 11.28964M>
+	{24000000, 11289600, 24, 0, 588, 24, 1},
+
+	{12288000, 12288000, 9, 0, 400, 19, 1},	//24576000/2
+	{11289600, 11289600, 9, 0, 400, 19, 1},	//22579200/2
+
+	{24576000 / 1, 12288000, 9, 0, 200, 19, 1},	//24576000
+	{24576000 / 16, 12288000, 0, 0, 320, 19, 1},	//1536000
+	{24576000 / 64, 12288000, 0, 0, 640, 9, 1},	//384000
+	{24576000 / 96, 12288000, 0, 0, 960, 9, 1},	//256000
+	{24576000 / 128, 12288000, 0, 0, 512, 3, 1},	//192000
+	{24576000 / 176, 12288000, 0, 0, 880, 4, 1},	//140000
+	{24576000 / 192, 12288000, 0, 0, 960, 4, 1},	//128000
+
+	{22579200 / 1, 11289600, 9, 0, 200, 19, 1},	//22579200
+	{22579200 / 4, 11289600, 4, 0, 400, 19, 1},	//5644800
+	{22579200 / 16, 11289600, 0, 0, 320, 19, 1},	//1411200
+	{22579200 / 64, 11289600, 0, 0, 640, 9, 1},	//352800
+	{22579200 / 96, 11289600, 0, 0, 960, 9, 1},	//235200
+	{22579200 / 128, 11289600, 0, 0, 512, 3, 1},	//176400
+	{22579200 / 176, 11289600, 0, 0, 880, 4, 1},	//128290
+	{22579200 / 192, 11289600, 0, 0, 960, 4, 1},	//117600
+
+	{22579200 / 6, 11289600, 2, 0, 360, 19, 1},	//3763200
+	{22579200 / 8, 11289600, 0, 0, 160, 19, 1},	//2822400
+	{22579200 / 12, 11289600, 0, 0, 240, 19, 1},	//1881600
+	{22579200 / 24, 11289600, 0, 0, 480, 19, 1},	//940800
+	{22579200 / 32, 11289600, 0, 0, 640, 19, 1},	//705600
+	{22579200 / 48, 11289600, 0, 0, 960, 19, 1},	//470400
+};
+
+const struct reg_default_value ac107_reg_default_value[] = {
+	/*** Chip reset ***/
+	{CHIP_AUDIO_RST, 0x4B},
+
+	/*** Power Control ***/
+	{PWR_CTRL1, 0x00},
+	{PWR_CTRL2, 0x11},
+
+	/*** PLL Configure Control ***/
+	{PLL_CTRL1, 0x48},
+	{PLL_CTRL2, 0x00},
+	{PLL_CTRL3, 0x03},
+	{PLL_CTRL4, 0x0D},
+	{PLL_CTRL5, 0x00},
+	{PLL_CTRL6, 0x0F},
+	{PLL_CTRL7, 0xD0},
+	{PLL_LOCK_CTRL, 0x00},
+
+	/*** System Clock Control ***/
+	{SYSCLK_CTRL, 0x00},
+	{MOD_CLK_EN, 0x00},
+	{MOD_RST_CTRL, 0x00},
+
+	/*** I2S Common Control ***/
+	{I2S_CTRL, 0x00},
+	{I2S_BCLK_CTRL, 0x00},
+	{I2S_LRCK_CTRL1, 0x00},
+	{I2S_LRCK_CTRL2, 0x00},
+	{I2S_FMT_CTRL1, 0x00},
+	{I2S_FMT_CTRL2, 0x55},
+	{I2S_FMT_CTRL3, 0x60},
+
+	/*** I2S TX Control ***/
+	{I2S_TX_CTRL1, 0x00},
+	{I2S_TX_CTRL2, 0x00},
+	{I2S_TX_CTRL3, 0x00},
+	{I2S_TX_CHMP_CTRL1, 0x00},
+	{I2S_TX_CHMP_CTRL2, 0x00},
+
+	/*** I2S RX Control ***/
+	{I2S_RX_CTRL1, 0x00},
+	{I2S_RX_CTRL2, 0x03},
+	{I2S_RX_CTRL3, 0x00},
+	{I2S_RX_CHMP_CTRL1, 0x00},
+	{I2S_RX_CHMP_CTRL2, 0x00},
+
+	/*** PDM Control ***/
+	{PDM_CTRL, 0x00},
+
+	/*** ADC Common Control ***/
+	{ADC_SPRC, 0x00},
+	{ADC_DIG_EN, 0x00},
+	{DMIC_EN, 0x00},
+	{HPF_EN, 0x03},
+
+	/*** ADC Digital Channel Volume Control ***/
+	{ADC1_DVOL_CTRL, 0xA0},
+	{ADC2_DVOL_CTRL, 0xA0},
+
+	/*** ADC Digital Mixer Source and Gain Control ***/
+	{ADC1_DMIX_SRC, 0x01},
+	{ADC2_DMIX_SRC, 0x02},
+
+	/*** ADC_DIG_DEBUG ***/
+	{ADC_DIG_DEBUG, 0x00},
+
+	/*** Pad Function and Drive Control ***/
+	{ADC_ANA_DEBUG1, 0x11},
+	{ADC_ANA_DEBUG2, 0x11},
+	{I2S_PADDRV_CTRL, 0x55},
+
+	/*** ADC1 Analog Control ***/
+	{ANA_ADC1_CTRL1, 0x00},
+	{ANA_ADC1_CTRL2, 0x00},
+	{ANA_ADC1_CTRL3, 0x00},
+	{ANA_ADC1_CTRL4, 0x00},
+	{ANA_ADC1_CTRL5, 0x00},
+
+	/*** ADC2 Analog Control ***/
+	{ANA_ADC2_CTRL1, 0x00},
+	{ANA_ADC2_CTRL2, 0x00},
+	{ANA_ADC2_CTRL3, 0x00},
+	{ANA_ADC2_CTRL4, 0x00},
+	{ANA_ADC2_CTRL5, 0x00},
+
+	/*** ADC Dither Control ***/
+	{ADC_DITHER_CTRL, 0x00},
+};
+
+const u8 ac107_kcontrol_dapm_reg[] = {
+#if AC107_KCONTROL_EN
+	ANA_ADC1_CTRL3, ANA_ADC2_CTRL3, ADC1_DVOL_CTRL, ADC2_DVOL_CTRL,
+	ADC1_DMIX_SRC, ADC2_DMIX_SRC, ADC_DIG_DEBUG,
+#endif
+
+#if AC107_DAPM_EN
+	DMIC_EN, ADC1_DMIX_SRC, ADC2_DMIX_SRC, I2S_TX_CHMP_CTRL1,
+	I2S_TX_CHMP_CTRL2, ANA_ADC1_CTRL5, ANA_ADC2_CTRL5, ADC_DIG_EN,
+#endif
+};
+
+static int ac107_read(u8 reg, u8 *rt_value, struct i2c_client *client);
+static int ac107_update_bits(u8 reg, u8 mask, u8 value,
+			     struct i2c_client *client);
+
+#define AC107_KCONTROL_FUNC(n) \
+int ac107_codec##n##_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\
+{\
+	struct soc_mixer_control *mc = (struct soc_mixer_control *)kcontrol->private_value;\
+	unsigned int reg = mc->reg;\
+	unsigned int shift = mc->shift;\
+	unsigned int max = mc->max;\
+	unsigned int mask = (1 << fls(max)) - 1;\
+	unsigned int invert = mc->invert;\
+	u8 reg_val;\
+\
+	ac107_read(reg, &reg_val, i2c_ctrl[n]);\
+	ucontrol->value.integer.value[0] = reg_val >> shift & mask;\
+	if (invert) {\
+		ucontrol->value.integer.value[0] = max - ucontrol->value.integer.value[0];\
+	} \
+	/*printk("read: REG-0x%02x, shift-%d, val-%d\n",reg,shift,ucontrol->value.integer.value[0]);*/\
+\
+	return 0;\
+} \
+\
+int ac107_codec##n##_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\
+{\
+	struct soc_mixer_control *mc = (struct soc_mixer_control *)kcontrol->private_value;\
+	unsigned int reg = mc->reg;\
+	unsigned int shift = mc->shift;\
+	unsigned int max = mc->max;\
+	unsigned int mask = (1 << fls(max)) - 1;\
+	unsigned int invert = mc->invert;\
+	u8 reg_val;\
+\
+	reg_val = ucontrol->value.integer.value[0] & mask;\
+	if (invert) {\
+		reg_val = max - reg_val;\
+	} \
+	ac107_update_bits(reg, mask<<shift, reg_val<<shift, i2c_ctrl[n]);\
+	/*printk("write: REG-0x%02x, shift-%d, val-%d\n",reg,shift,reg_val);*/\
+\
+	return 0;\
+}
+
+AC107_KCONTROL_FUNC(0);
+AC107_KCONTROL_FUNC(1);
+AC107_KCONTROL_FUNC(2);
+AC107_KCONTROL_FUNC(3);
+AC107_KCONTROL_FUNC(4);
+AC107_KCONTROL_FUNC(5);
+AC107_KCONTROL_FUNC(6);
+AC107_KCONTROL_FUNC(7);
+
+static const DECLARE_TLV_DB_SCALE(adc_pga_gain_tlv, 0, 100, 0);
+static const DECLARE_TLV_DB_SCALE(digital_vol_tlv, -11925, 75, 0);
+static const DECLARE_TLV_DB_SCALE(digital_mix_vol_tlv, -600, 600, 0);
+
+/*************************************** General(volume) controls *******************************************/
+//ac107 volume controls
+static const struct snd_kcontrol_new ac107_volume_controls[] = {
+	//Channels PGA Gain
+	SOC_SINGLE_EXT_TLV("Channel 1 PGA Gain", ANA_ADC1_CTRL3,
+			   RX1_PGA_GAIN_CTRL, 0x1f, 0, ac107_codec0_get,
+			   ac107_codec0_put, adc_pga_gain_tlv),
+	SOC_SINGLE_EXT_TLV("Channel 2 PGA Gain", ANA_ADC2_CTRL3,
+			   RX2_PGA_GAIN_CTRL, 0x1f, 0, ac107_codec0_get,
+			   ac107_codec0_put, adc_pga_gain_tlv),
+	SOC_SINGLE_EXT_TLV("Channel 3 PGA Gain", ANA_ADC1_CTRL3,
+			   RX1_PGA_GAIN_CTRL, 0x1f, 0, ac107_codec1_get,
+			   ac107_codec1_put, adc_pga_gain_tlv),
+	SOC_SINGLE_EXT_TLV("Channel 4 PGA Gain", ANA_ADC2_CTRL3,
+			   RX2_PGA_GAIN_CTRL, 0x1f, 0, ac107_codec1_get,
+			   ac107_codec1_put, adc_pga_gain_tlv),
+	SOC_SINGLE_EXT_TLV("Channel 5 PGA Gain", ANA_ADC1_CTRL3,
+			   RX1_PGA_GAIN_CTRL, 0x1f, 0, ac107_codec2_get,
+			   ac107_codec2_put, adc_pga_gain_tlv),
+	SOC_SINGLE_EXT_TLV("Channel 6 PGA Gain", ANA_ADC2_CTRL3,
+			   RX2_PGA_GAIN_CTRL, 0x1f, 0, ac107_codec2_get,
+			   ac107_codec2_put, adc_pga_gain_tlv),
+	SOC_SINGLE_EXT_TLV("Channel 7 PGA Gain", ANA_ADC1_CTRL3,
+			   RX1_PGA_GAIN_CTRL, 0x1f, 0, ac107_codec3_get,
+			   ac107_codec3_put, adc_pga_gain_tlv),
+	SOC_SINGLE_EXT_TLV("Channel 8 PGA Gain", ANA_ADC2_CTRL3,
+			   RX2_PGA_GAIN_CTRL, 0x1f, 0, ac107_codec3_get,
+			   ac107_codec3_put, adc_pga_gain_tlv),
+	SOC_SINGLE_EXT_TLV("Channel 9 PGA Gain", ANA_ADC1_CTRL3,
+			   RX1_PGA_GAIN_CTRL, 0x1f, 0, ac107_codec4_get,
+			   ac107_codec4_put, adc_pga_gain_tlv),
+	SOC_SINGLE_EXT_TLV("Channel 10 PGA Gain", ANA_ADC2_CTRL3,
+			   RX2_PGA_GAIN_CTRL, 0x1f, 0, ac107_codec4_get,
+			   ac107_codec4_put, adc_pga_gain_tlv),
+	SOC_SINGLE_EXT_TLV("Channel 11 PGA Gain", ANA_ADC1_CTRL3,
+			   RX1_PGA_GAIN_CTRL, 0x1f, 0, ac107_codec5_get,
+			   ac107_codec5_put, adc_pga_gain_tlv),
+	SOC_SINGLE_EXT_TLV("Channel 12 PGA Gain", ANA_ADC2_CTRL3,
+			   RX2_PGA_GAIN_CTRL, 0x1f, 0, ac107_codec5_get,
+			   ac107_codec5_put, adc_pga_gain_tlv),
+	SOC_SINGLE_EXT_TLV("Channel 13 PGA Gain", ANA_ADC1_CTRL3,
+			   RX1_PGA_GAIN_CTRL, 0x1f, 0, ac107_codec6_get,
+			   ac107_codec6_put, adc_pga_gain_tlv),
+	SOC_SINGLE_EXT_TLV("Channel 14 PGA Gain", ANA_ADC2_CTRL3,
+			   RX2_PGA_GAIN_CTRL, 0x1f, 0, ac107_codec6_get,
+			   ac107_codec6_put, adc_pga_gain_tlv),
+	SOC_SINGLE_EXT_TLV("Channel 15 PGA Gain", ANA_ADC1_CTRL3,
+			   RX1_PGA_GAIN_CTRL, 0x1f, 0, ac107_codec7_get,
+			   ac107_codec7_put, adc_pga_gain_tlv),
+	SOC_SINGLE_EXT_TLV("Channel 16 PGA Gain", ANA_ADC2_CTRL3,
+			   RX2_PGA_GAIN_CTRL, 0x1f, 0, ac107_codec7_get,
+			   ac107_codec7_put, adc_pga_gain_tlv),
+
+	//Channels Digital Volume
+	SOC_SINGLE_EXT_TLV("Channel 1 Digital Volume", ADC1_DVOL_CTRL, 0, 0xff,
+			   0, ac107_codec0_get, ac107_codec0_put,
+			   digital_vol_tlv),
+	SOC_SINGLE_EXT_TLV("Channel 2 Digital Volume", ADC2_DVOL_CTRL, 0, 0xff,
+			   0, ac107_codec0_get, ac107_codec0_put,
+			   digital_vol_tlv),
+	SOC_SINGLE_EXT_TLV("Channel 3 Digital Volume", ADC1_DVOL_CTRL, 0, 0xff,
+			   0, ac107_codec1_get, ac107_codec1_put,
+			   digital_vol_tlv),
+	SOC_SINGLE_EXT_TLV("Channel 4 Digital Volume", ADC2_DVOL_CTRL, 0, 0xff,
+			   0, ac107_codec1_get, ac107_codec1_put,
+			   digital_vol_tlv),
+	SOC_SINGLE_EXT_TLV("Channel 5 Digital Volume", ADC1_DVOL_CTRL, 0, 0xff,
+			   0, ac107_codec2_get, ac107_codec2_put,
+			   digital_vol_tlv),
+	SOC_SINGLE_EXT_TLV("Channel 6 Digital Volume", ADC2_DVOL_CTRL, 0, 0xff,
+			   0, ac107_codec2_get, ac107_codec2_put,
+			   digital_vol_tlv),
+	SOC_SINGLE_EXT_TLV("Channel 7 Digital Volume", ADC1_DVOL_CTRL, 0, 0xff,
+			   0, ac107_codec3_get, ac107_codec3_put,
+			   digital_vol_tlv),
+	SOC_SINGLE_EXT_TLV("Channel 8 Digital Volume", ADC2_DVOL_CTRL, 0, 0xff,
+			   0, ac107_codec3_get, ac107_codec3_put,
+			   digital_vol_tlv),
+	SOC_SINGLE_EXT_TLV("Channel 9 Digital Volume", ADC1_DVOL_CTRL, 0, 0xff,
+			   0, ac107_codec4_get, ac107_codec4_put,
+			   digital_vol_tlv),
+	SOC_SINGLE_EXT_TLV("Channel 10 Digital Volume", ADC2_DVOL_CTRL, 0, 0xff,
+			   0, ac107_codec4_get, ac107_codec4_put,
+			   digital_vol_tlv),
+	SOC_SINGLE_EXT_TLV("Channel 11 Digital Volume", ADC1_DVOL_CTRL, 0, 0xff,
+			   0, ac107_codec5_get, ac107_codec5_put,
+			   digital_vol_tlv),
+	SOC_SINGLE_EXT_TLV("Channel 12 Digital Volume", ADC2_DVOL_CTRL, 0, 0xff,
+			   0, ac107_codec5_get, ac107_codec5_put,
+			   digital_vol_tlv),
+	SOC_SINGLE_EXT_TLV("Channel 13 Digital Volume", ADC1_DVOL_CTRL, 0, 0xff,
+			   0, ac107_codec6_get, ac107_codec6_put,
+			   digital_vol_tlv),
+	SOC_SINGLE_EXT_TLV("Channel 14 Digital Volume", ADC2_DVOL_CTRL, 0, 0xff,
+			   0, ac107_codec6_get, ac107_codec6_put,
+			   digital_vol_tlv),
+	SOC_SINGLE_EXT_TLV("Channel 15 Digital Volume", ADC1_DVOL_CTRL, 0, 0xff,
+			   0, ac107_codec7_get, ac107_codec7_put,
+			   digital_vol_tlv),
+	SOC_SINGLE_EXT_TLV("Channel 16 Digital Volume", ADC2_DVOL_CTRL, 0, 0xff,
+			   0, ac107_codec7_get, ac107_codec7_put,
+			   digital_vol_tlv),
+};
+
+//ac107 common controls
+static const struct snd_kcontrol_new ac107_controls[] = {
+#if 0
+	SOC_SINGLE_TLV("ADC1 PGA Gain", ANA_ADC1_CTRL3, RX1_PGA_GAIN_CTRL, 0x1f,
+		       0, adc_pga_gain_tlv),
+	SOC_SINGLE_TLV("ADC2 PGA Gain", ANA_ADC2_CTRL3, RX2_PGA_GAIN_CTRL, 0x1f,
+		       0, adc_pga_gain_tlv),
+
+	SOC_SINGLE_TLV("CH1 Digital Volume", ADC1_DVOL_CTRL, 0, 0xff, 0,
+		       digital_vol_tlv),
+	SOC_SINGLE_TLV("CH2 Digital Volume", ADC2_DVOL_CTRL, 0, 0xff, 0,
+		       digital_vol_tlv),
+
+	SOC_SINGLE_TLV("CH1 ch1 Mixer Volume", ADC1_DMIX_SRC, ADC1_ADC1_DMXL_GC,
+		       1, 0, digital_mix_vol_tlv),
+	SOC_SINGLE_TLV("CH1 ch2 Mixer Volume", ADC1_DMIX_SRC, ADC1_ADC2_DMXL_GC,
+		       1, 0, digital_mix_vol_tlv),
+
+	SOC_SINGLE_TLV("CH2 ch1 Mixer Volume", ADC2_DMIX_SRC, ADC2_ADC1_DMXL_GC,
+		       1, 0, digital_mix_vol_tlv),
+	SOC_SINGLE_TLV("CH2 ch2 Mixer Volume", ADC2_DMIX_SRC, ADC2_ADC2_DMXL_GC,
+		       1, 0, digital_mix_vol_tlv),
+#endif
+	//debug control
+	SOC_SINGLE("ADC Pattern Sel", ADC_DIG_DEBUG, ADC_PTN_SEL, 0x7, 0),
+	//SOC_SINGLE("MCLK Drive Sel", I2S_PADDRV_CTRL, MCLK_DRV, 0x3, 0),
+	//SOC_SINGLE("SYSCLK Hold Time Sel", PLL_LOCK_CTRL, SYSCLK_HOLD_TIME, 0x7, 0),
+};
+
+/*************************************** DAPM controls *******************************************/
+//ADC DMIC Source Select MUX
+static const char *adc_dmic_src_mux_text[] = {
+	"ADC switch", "DMIC switch"
+};
+
+static const struct soc_enum adc_dmic_src_mux_enum =
+SOC_ENUM_SINGLE(DMIC_EN, DIG_MIC_EN, 2, adc_dmic_src_mux_text);
+static const struct snd_kcontrol_new adc_dmic_src_mux =
+SOC_DAPM_ENUM("ADC DMIC MUX", adc_dmic_src_mux_enum);
+
+//ADC1 Digital Source Control Mixer
+static const struct snd_kcontrol_new adc1_digital_src_mixer[] = {
+	SOC_DAPM_SINGLE("ADC1 DAT switch", ADC1_DMIX_SRC, ADC1_ADC1_DMXL_SRC, 1,
+			0),
+	SOC_DAPM_SINGLE("ADC2 DAT switch", ADC1_DMIX_SRC, ADC1_ADC2_DMXL_SRC, 1,
+			0),
+};
+
+//ADC2 Digital Source Control Mixer
+static const struct snd_kcontrol_new adc2_digital_src_mixer[] = {
+	SOC_DAPM_SINGLE("ADC1 DAT switch", ADC2_DMIX_SRC, ADC2_ADC1_DMXL_SRC, 1,
+			0),
+	SOC_DAPM_SINGLE("ADC2 DAT switch", ADC2_DMIX_SRC, ADC2_ADC2_DMXL_SRC, 1,
+			0),
+};
+
+//I2S TX Ch1 Mapping Mux
+static const char *i2s_tx_ch1_map_mux_text[] = {
+	"ADC1 Sample switch", "ADC2 Sample switch"
+};
+
+static const struct soc_enum i2s_tx_ch1_map_mux_enum =
+SOC_ENUM_SINGLE(I2S_TX_CHMP_CTRL1, TX_CH1_MAP, 2, i2s_tx_ch1_map_mux_text);
+static const struct snd_kcontrol_new i2s_tx_ch1_map_mux =
+SOC_DAPM_ENUM("I2S TX CH1 MUX", i2s_tx_ch1_map_mux_enum);
+
+//I2S TX Ch2 Mapping Mux
+static const char *i2s_tx_ch2_map_mux_text[] = {
+	"ADC1 Sample switch", "ADC2 Sample switch"
+};
+
+static const struct soc_enum i2s_tx_ch2_map_mux_enum =
+SOC_ENUM_SINGLE(I2S_TX_CHMP_CTRL1, TX_CH2_MAP, 2, i2s_tx_ch2_map_mux_text);
+static const struct snd_kcontrol_new i2s_tx_ch2_map_mux =
+SOC_DAPM_ENUM("I2S TX CH2 MUX", i2s_tx_ch2_map_mux_enum);
+
+//I2S TX Ch3 Mapping Mux
+static const char *i2s_tx_ch3_map_mux_text[] = {
+	"ADC1 Sample switch", "ADC2 Sample switch"
+};
+
+static const struct soc_enum i2s_tx_ch3_map_mux_enum =
+SOC_ENUM_SINGLE(I2S_TX_CHMP_CTRL1, TX_CH3_MAP, 2, i2s_tx_ch3_map_mux_text);
+static const struct snd_kcontrol_new i2s_tx_ch3_map_mux =
+SOC_DAPM_ENUM("I2S TX CH3 MUX", i2s_tx_ch3_map_mux_enum);
+
+//I2S TX Ch4 Mapping Mux
+static const char *i2s_tx_ch4_map_mux_text[] = {
+	"ADC1 Sample switch", "ADC2 Sample switch"
+};
+
+static const struct soc_enum i2s_tx_ch4_map_mux_enum =
+SOC_ENUM_SINGLE(I2S_TX_CHMP_CTRL1, TX_CH4_MAP, 2, i2s_tx_ch4_map_mux_text);
+static const struct snd_kcontrol_new i2s_tx_ch4_map_mux =
+SOC_DAPM_ENUM("I2S TX CH4 MUX", i2s_tx_ch4_map_mux_enum);
+
+//I2S TX Ch5 Mapping Mux
+static const char *i2s_tx_ch5_map_mux_text[] = {
+	"ADC1 Sample switch", "ADC2 Sample switch"
+};
+
+static const struct soc_enum i2s_tx_ch5_map_mux_enum =
+SOC_ENUM_SINGLE(I2S_TX_CHMP_CTRL1, TX_CH5_MAP, 2, i2s_tx_ch5_map_mux_text);
+static const struct snd_kcontrol_new i2s_tx_ch5_map_mux =
+SOC_DAPM_ENUM("I2S TX CH5 MUX", i2s_tx_ch5_map_mux_enum);
+
+//I2S TX Ch6 Mapping Mux
+static const char *i2s_tx_ch6_map_mux_text[] = {
+	"ADC1 Sample switch", "ADC2 Sample switch"
+};
+
+static const struct soc_enum i2s_tx_ch6_map_mux_enum =
+SOC_ENUM_SINGLE(I2S_TX_CHMP_CTRL1, TX_CH6_MAP, 2, i2s_tx_ch6_map_mux_text);
+static const struct snd_kcontrol_new i2s_tx_ch6_map_mux =
+SOC_DAPM_ENUM("I2S TX CH6 MUX", i2s_tx_ch6_map_mux_enum);
+
+//I2S TX Ch7 Mapping Mux
+static const char *i2s_tx_ch7_map_mux_text[] = {
+	"ADC1 Sample switch", "ADC2 Sample switch"
+};
+
+static const struct soc_enum i2s_tx_ch7_map_mux_enum =
+SOC_ENUM_SINGLE(I2S_TX_CHMP_CTRL1, TX_CH7_MAP, 2, i2s_tx_ch7_map_mux_text);
+static const struct snd_kcontrol_new i2s_tx_ch7_map_mux =
+SOC_DAPM_ENUM("I2S TX CH7 MUX", i2s_tx_ch7_map_mux_enum);
+
+//I2S TX Ch8 Mapping Mux
+static const char *i2s_tx_ch8_map_mux_text[] = {
+	"ADC1 Sample switch", "ADC2 Sample switch"
+};
+
+static const struct soc_enum i2s_tx_ch8_map_mux_enum =
+SOC_ENUM_SINGLE(I2S_TX_CHMP_CTRL1, TX_CH8_MAP, 2, i2s_tx_ch8_map_mux_text);
+static const struct snd_kcontrol_new i2s_tx_ch8_map_mux =
+SOC_DAPM_ENUM("I2S TX CH8 MUX", i2s_tx_ch8_map_mux_enum);
+
+//I2S TX Ch9 Mapping Mux
+static const char *i2s_tx_ch9_map_mux_text[] = {
+	"ADC1 Sample switch", "ADC2 Sample switch"
+};
+
+static const struct soc_enum i2s_tx_ch9_map_mux_enum =
+SOC_ENUM_SINGLE(I2S_TX_CHMP_CTRL2, TX_CH9_MAP, 2, i2s_tx_ch9_map_mux_text);
+static const struct snd_kcontrol_new i2s_tx_ch9_map_mux =
+SOC_DAPM_ENUM("I2S TX CH9 MUX", i2s_tx_ch9_map_mux_enum);
+
+//I2S TX Ch10 Mapping Mux
+static const char *i2s_tx_ch10_map_mux_text[] = {
+	"ADC1 Sample switch", "ADC2 Sample switch"
+};
+
+static const struct soc_enum i2s_tx_ch10_map_mux_enum =
+SOC_ENUM_SINGLE(I2S_TX_CHMP_CTRL2, TX_CH10_MAP, 2, i2s_tx_ch10_map_mux_text);
+static const struct snd_kcontrol_new i2s_tx_ch10_map_mux =
+SOC_DAPM_ENUM("I2S TX CH10 MUX", i2s_tx_ch10_map_mux_enum);
+
+//I2S TX Ch11 Mapping Mux
+static const char *i2s_tx_ch11_map_mux_text[] = {
+	"ADC1 Sample switch", "ADC2 Sample switch"
+};
+
+static const struct soc_enum i2s_tx_ch11_map_mux_enum =
+SOC_ENUM_SINGLE(I2S_TX_CHMP_CTRL2, TX_CH11_MAP, 2, i2s_tx_ch11_map_mux_text);
+static const struct snd_kcontrol_new i2s_tx_ch11_map_mux =
+SOC_DAPM_ENUM("I2S TX CH11 MUX", i2s_tx_ch11_map_mux_enum);
+
+//I2S TX Ch12 Mapping Mux
+static const char *i2s_tx_ch12_map_mux_text[] = {
+	"ADC1 Sample switch", "ADC2 Sample switch"
+};
+
+static const struct soc_enum i2s_tx_ch12_map_mux_enum =
+SOC_ENUM_SINGLE(I2S_TX_CHMP_CTRL2, TX_CH12_MAP, 2, i2s_tx_ch12_map_mux_text);
+static const struct snd_kcontrol_new i2s_tx_ch12_map_mux =
+SOC_DAPM_ENUM("I2S TX CH12 MUX", i2s_tx_ch12_map_mux_enum);
+
+//I2S TX Ch13 Mapping Mux
+static const char *i2s_tx_ch13_map_mux_text[] = {
+	"ADC1 Sample switch", "ADC2 Sample switch"
+};
+
+static const struct soc_enum i2s_tx_ch13_map_mux_enum =
+SOC_ENUM_SINGLE(I2S_TX_CHMP_CTRL2, TX_CH13_MAP, 2, i2s_tx_ch13_map_mux_text);
+static const struct snd_kcontrol_new i2s_tx_ch13_map_mux =
+SOC_DAPM_ENUM("I2S TX CH13 MUX", i2s_tx_ch13_map_mux_enum);
+
+//I2S TX Ch14 Mapping Mux
+static const char *i2s_tx_ch14_map_mux_text[] = {
+	"ADC1 Sample switch", "ADC2 Sample switch"
+};
+
+static const struct soc_enum i2s_tx_ch14_map_mux_enum =
+SOC_ENUM_SINGLE(I2S_TX_CHMP_CTRL2, TX_CH14_MAP, 2, i2s_tx_ch14_map_mux_text);
+static const struct snd_kcontrol_new i2s_tx_ch14_map_mux =
+SOC_DAPM_ENUM("I2S TX CH14 MUX", i2s_tx_ch14_map_mux_enum);
+
+//I2S TX Ch15 Mapping Mux
+static const char *i2s_tx_ch15_map_mux_text[] = {
+	"ADC1 Sample switch", "ADC2 Sample switch"
+};
+
+static const struct soc_enum i2s_tx_ch15_map_mux_enum =
+SOC_ENUM_SINGLE(I2S_TX_CHMP_CTRL2, TX_CH15_MAP, 2, i2s_tx_ch15_map_mux_text);
+static const struct snd_kcontrol_new i2s_tx_ch15_map_mux =
+SOC_DAPM_ENUM("I2S TX CH15 MUX", i2s_tx_ch15_map_mux_enum);
+
+//I2S TX Ch16 Mapping Mux
+static const char *i2s_tx_ch16_map_mux_text[] = {
+	"ADC1 Sample switch", "ADC2 Sample switch"
+};
+
+static const struct soc_enum i2s_tx_ch16_map_mux_enum =
+SOC_ENUM_SINGLE(I2S_TX_CHMP_CTRL2, TX_CH16_MAP, 2, i2s_tx_ch16_map_mux_text);
+static const struct snd_kcontrol_new i2s_tx_ch16_map_mux =
+SOC_DAPM_ENUM("I2S TX CH16 MUX", i2s_tx_ch16_map_mux_enum);
+
+/*************************************** DAPM widgets *******************************************/
+//ac107 dapm widgets
+static const struct snd_soc_dapm_widget ac107_dapm_widgets[] = {
+	//input widgets
+	SND_SOC_DAPM_INPUT("MIC1P"),
+	SND_SOC_DAPM_INPUT("MIC1N"),
+
+	SND_SOC_DAPM_INPUT("MIC2P"),
+	SND_SOC_DAPM_INPUT("MIC2N"),
+
+	SND_SOC_DAPM_INPUT("DMIC"),
+
+	//MIC PGA
+	SND_SOC_DAPM_PGA("MIC1 PGA", ANA_ADC1_CTRL5, RX1_GLOBAL_EN, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("MIC2 PGA", ANA_ADC2_CTRL5, RX2_GLOBAL_EN, 0, NULL, 0),
+
+	//DMIC PGA
+	SND_SOC_DAPM_PGA("DMICL PGA", SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("DMICR PGA", SND_SOC_NOPM, 0, 0, NULL, 0),
+
+	//ADC DMIC MUX
+	SND_SOC_DAPM_MUX("ADC DMIC MUX", ADC_DIG_EN, DG_EN, 0,
+			 &adc_dmic_src_mux),
+
+	//ADC1 VIR PGA
+	SND_SOC_DAPM_PGA("ADC1 VIR PGA", ADC_DIG_EN, ENAD1, 0, NULL, 0),
+
+	//ADC2 VIR PGA
+	SND_SOC_DAPM_PGA("ADC2 VIR PGA", ADC_DIG_EN, ENAD2, 0, NULL, 0),
+
+	//ADC1 DIG MIXER
+	SND_SOC_DAPM_MIXER("ADC1 DIG MIXER", SND_SOC_NOPM, 0, 0,
+			   adc1_digital_src_mixer,
+			   ARRAY_SIZE(adc1_digital_src_mixer)),
+
+	//ADC2 DIG MIXER
+	SND_SOC_DAPM_MIXER("ADC2 DIG MIXER", SND_SOC_NOPM, 0, 0,
+			   adc2_digital_src_mixer,
+			   ARRAY_SIZE(adc2_digital_src_mixer)),
+
+	//I2S TX CH1 MUX
+	SND_SOC_DAPM_MUX("I2S TX CH1 MUX", SND_SOC_NOPM, 0, 0,
+			 &i2s_tx_ch1_map_mux),
+
+	//I2S TX CH2 MUX
+	SND_SOC_DAPM_MUX("I2S TX CH2 MUX", SND_SOC_NOPM, 0, 0,
+			 &i2s_tx_ch2_map_mux),
+
+	//I2S TX CH3 MUX
+	SND_SOC_DAPM_MUX("I2S TX CH3 MUX", SND_SOC_NOPM, 0, 0,
+			 &i2s_tx_ch3_map_mux),
+
+	//I2S TX CH4 MUX
+	SND_SOC_DAPM_MUX("I2S TX CH4 MUX", SND_SOC_NOPM, 0, 0,
+			 &i2s_tx_ch4_map_mux),
+
+	//I2S TX CH5 MUX
+	SND_SOC_DAPM_MUX("I2S TX CH5 MUX", SND_SOC_NOPM, 0, 0,
+			 &i2s_tx_ch5_map_mux),
+
+	//I2S TX CH6 MUX
+	SND_SOC_DAPM_MUX("I2S TX CH6 MUX", SND_SOC_NOPM, 0, 0,
+			 &i2s_tx_ch6_map_mux),
+
+	//I2S TX CH7 MUX
+	SND_SOC_DAPM_MUX("I2S TX CH7 MUX", SND_SOC_NOPM, 0, 0,
+			 &i2s_tx_ch7_map_mux),
+
+	//I2S TX CH8 MUX
+	SND_SOC_DAPM_MUX("I2S TX CH8 MUX", SND_SOC_NOPM, 0, 0,
+			 &i2s_tx_ch8_map_mux),
+
+	//I2S TX CH9 MUX
+	SND_SOC_DAPM_MUX("I2S TX CH9 MUX", SND_SOC_NOPM, 0, 0,
+			 &i2s_tx_ch9_map_mux),
+
+	//I2S TX CH10 MUX
+	SND_SOC_DAPM_MUX("I2S TX CH10 MUX", SND_SOC_NOPM, 0, 0,
+			 &i2s_tx_ch10_map_mux),
+
+	//I2S TX CH11 MUX
+	SND_SOC_DAPM_MUX("I2S TX CH11 MUX", SND_SOC_NOPM, 0, 0,
+			 &i2s_tx_ch11_map_mux),
+
+	//I2S TX CH12 MUX
+	SND_SOC_DAPM_MUX("I2S TX CH12 MUX", SND_SOC_NOPM, 0, 0,
+			 &i2s_tx_ch12_map_mux),
+
+	//I2S TX CH13 MUX
+	SND_SOC_DAPM_MUX("I2S TX CH13 MUX", SND_SOC_NOPM, 0, 0,
+			 &i2s_tx_ch13_map_mux),
+
+	//I2S TX CH14 MUX
+	SND_SOC_DAPM_MUX("I2S TX CH14 MUX", SND_SOC_NOPM, 0, 0,
+			 &i2s_tx_ch14_map_mux),
+
+	//I2S TX CH15 MUX
+	SND_SOC_DAPM_MUX("I2S TX CH15 MUX", SND_SOC_NOPM, 0, 0,
+			 &i2s_tx_ch15_map_mux),
+
+	//I2S TX CH16 MUX
+	SND_SOC_DAPM_MUX("I2S TX CH16 MUX", SND_SOC_NOPM, 0, 0,
+			 &i2s_tx_ch16_map_mux),
+
+	//AIF OUT -> (stream widget, stname must be same with codec dai_driver stream_name, which will be used to build dai widget)
+	SND_SOC_DAPM_AIF_OUT("AIF ADC OUT", "Capture", 0, SND_SOC_NOPM, 0, 0),
+};
+
+/*************************************** DAPM routes *******************************************/
+//ac107 dapm routes
+static const struct snd_soc_dapm_route ac107_dapm_routes[] = {
+	//MIC1 PGA
+	{"MIC1 PGA", NULL, "MIC1P"},
+	{"MIC1 PGA", NULL, "MIC1N"},
+
+	//MIC2 PGA
+	{"MIC2 PGA", NULL, "MIC2P"},
+	{"MIC2 PGA", NULL, "MIC2N"},
+
+	//DMIC PGA
+	{"DMICL PGA", NULL, "DMIC"},
+	{"DMICR PGA", NULL, "DMIC"},
+
+	//ADC DMIC MUX
+	{"ADC DMIC MUX", "ADC switch", "MIC1 PGA"},
+	{"ADC DMIC MUX", "ADC switch", "MIC2 PGA"},
+	{"ADC DMIC MUX", "DMIC switch", "DMICL PGA"},
+	{"ADC DMIC MUX", "DMIC switch", "DMICR PGA"},
+
+	//ADC1 VIR PGA
+	{"ADC1 VIR PGA", NULL, "ADC DMIC MUX"},
+
+	//ADC2 VIR PGA
+	{"ADC2 VIR PGA", NULL, "ADC DMIC MUX"},
+
+	//ADC1 DIG MIXER
+	{"ADC1 DIG MIXER", "ADC1 DAT switch", "ADC1 VIR PGA"},
+	{"ADC1 DIG MIXER", "ADC2 DAT switch", "ADC2 VIR PGA"},
+
+	//ADC2 DIG MIXER
+	{"ADC2 DIG MIXER", "ADC1 DAT switch", "ADC1 VIR PGA"},
+	{"ADC2 DIG MIXER", "ADC2 DAT switch", "ADC2 VIR PGA"},
+
+	//I2S TX CH1 MUX
+	{"I2S TX CH1 MUX", "ADC1 Sample switch", "ADC1 DIG MIXER"},
+	{"I2S TX CH1 MUX", "ADC2 Sample switch", "ADC2 DIG MIXER"},
+
+	//I2S TX CH2 MUX
+	{"I2S TX CH2 MUX", "ADC1 Sample switch", "ADC1 DIG MIXER"},
+	{"I2S TX CH2 MUX", "ADC2 Sample switch", "ADC2 DIG MIXER"},
+
+	//I2S TX CH3 MUX
+	{"I2S TX CH3 MUX", "ADC1 Sample switch", "ADC1 DIG MIXER"},
+	{"I2S TX CH3 MUX", "ADC2 Sample switch", "ADC2 DIG MIXER"},
+
+	//I2S TX CH4 MUX
+	{"I2S TX CH4 MUX", "ADC1 Sample switch", "ADC1 DIG MIXER"},
+	{"I2S TX CH4 MUX", "ADC2 Sample switch", "ADC2 DIG MIXER"},
+
+	//I2S TX CH5 MUX
+	{"I2S TX CH5 MUX", "ADC1 Sample switch", "ADC1 DIG MIXER"},
+	{"I2S TX CH5 MUX", "ADC2 Sample switch", "ADC2 DIG MIXER"},
+
+	//I2S TX CH6 MUX
+	{"I2S TX CH6 MUX", "ADC1 Sample switch", "ADC1 DIG MIXER"},
+	{"I2S TX CH6 MUX", "ADC2 Sample switch", "ADC2 DIG MIXER"},
+
+	//I2S TX CH7 MUX
+	{"I2S TX CH7 MUX", "ADC1 Sample switch", "ADC1 DIG MIXER"},
+	{"I2S TX CH7 MUX", "ADC2 Sample switch", "ADC2 DIG MIXER"},
+
+	//I2S TX CH8 MUX
+	{"I2S TX CH8 MUX", "ADC1 Sample switch", "ADC1 DIG MIXER"},
+	{"I2S TX CH8 MUX", "ADC2 Sample switch", "ADC2 DIG MIXER"},
+
+	//I2S TX CH9 MUX
+	{"I2S TX CH9 MUX", "ADC1 Sample switch", "ADC1 DIG MIXER"},
+	{"I2S TX CH9 MUX", "ADC2 Sample switch", "ADC2 DIG MIXER"},
+
+	//I2S TX CH10 MUX
+	{"I2S TX CH10 MUX", "ADC1 Sample switch", "ADC1 DIG MIXER"},
+	{"I2S TX CH10 MUX", "ADC2 Sample switch", "ADC2 DIG MIXER"},
+
+	//I2S TX CH11 MUX
+	{"I2S TX CH11 MUX", "ADC1 Sample switch", "ADC1 DIG MIXER"},
+	{"I2S TX CH11 MUX", "ADC2 Sample switch", "ADC2 DIG MIXER"},
+
+	//I2S TX CH12 MUX
+	{"I2S TX CH12 MUX", "ADC1 Sample switch", "ADC1 DIG MIXER"},
+	{"I2S TX CH12 MUX", "ADC2 Sample switch", "ADC2 DIG MIXER"},
+
+	//I2S TX CH13 MUX
+	{"I2S TX CH13 MUX", "ADC1 Sample switch", "ADC1 DIG MIXER"},
+	{"I2S TX CH13 MUX", "ADC2 Sample switch", "ADC2 DIG MIXER"},
+
+	//I2S TX CH14 MUX
+	{"I2S TX CH14 MUX", "ADC1 Sample switch", "ADC1 DIG MIXER"},
+	{"I2S TX CH14 MUX", "ADC2 Sample switch", "ADC2 DIG MIXER"},
+
+	//I2S TX CH15 MUX
+	{"I2S TX CH15 MUX", "ADC1 Sample switch", "ADC1 DIG MIXER"},
+	{"I2S TX CH15 MUX", "ADC2 Sample switch", "ADC2 DIG MIXER"},
+
+	//I2S TX CH16 MUX
+	{"I2S TX CH16 MUX", "ADC1 Sample switch", "ADC1 DIG MIXER"},
+	{"I2S TX CH16 MUX", "ADC2 Sample switch", "ADC2 DIG MIXER"},
+
+	//AIF ADC OUT
+	{"AIF ADC OUT", NULL, "I2S TX CH1 MUX"},
+	{"AIF ADC OUT", NULL, "I2S TX CH2 MUX"},
+	{"AIF ADC OUT", NULL, "I2S TX CH3 MUX"},
+	{"AIF ADC OUT", NULL, "I2S TX CH4 MUX"},
+	{"AIF ADC OUT", NULL, "I2S TX CH5 MUX"},
+	{"AIF ADC OUT", NULL, "I2S TX CH6 MUX"},
+	{"AIF ADC OUT", NULL, "I2S TX CH7 MUX"},
+	{"AIF ADC OUT", NULL, "I2S TX CH8 MUX"},
+	{"AIF ADC OUT", NULL, "I2S TX CH9 MUX"},
+	{"AIF ADC OUT", NULL, "I2S TX CH10 MUX"},
+	{"AIF ADC OUT", NULL, "I2S TX CH11 MUX"},
+	{"AIF ADC OUT", NULL, "I2S TX CH12 MUX"},
+	{"AIF ADC OUT", NULL, "I2S TX CH13 MUX"},
+	{"AIF ADC OUT", NULL, "I2S TX CH14 MUX"},
+	{"AIF ADC OUT", NULL, "I2S TX CH15 MUX"},
+	{"AIF ADC OUT", NULL, "I2S TX CH16 MUX"},
+};
+
+static int ac107_read(u8 reg, u8 *rt_value, struct i2c_client *client)
+{
+	int ret;
+	u8 read_cmd[3] = { 0 };
+	u8 cmd_len = 0;
+
+	read_cmd[0] = reg;
+	cmd_len = 1;
+
+	if (client == NULL || client->adapter == NULL) {
+		pr_err("ac107_read client or client->adapter is NULL\n");
+		return -1;
+	}
+
+	ret = i2c_master_send(client, read_cmd, cmd_len);
+	if (ret != cmd_len) {
+		pr_err("ac107_read error1->[REG-0x%02x]\n", reg);
+		return -1;
+	}
+
+	ret = i2c_master_recv(client, rt_value, 1);
+	if (ret != 1) {
+		pr_err("ac107_read error2->[REG-0x%02x], ret=%d\n", reg, ret);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int ac107_write(u8 reg, unsigned char value, struct i2c_client *client)
+{
+	int ret = 0;
+	u8 write_cmd[2] = { 0 };
+
+	write_cmd[0] = reg;
+	write_cmd[1] = value;
+
+	if (client == NULL || client->adapter == NULL) {
+		pr_err("ac107_write client or client->adapter is NULL\n");
+		return -1;
+	}
+
+	ret = i2c_master_send(client, write_cmd, 2);
+	if (ret != 2) {
+		pr_err("ac107_write error->[REG-0x%02x,val-0x%02x]\n", reg,
+		       value);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int ac107_update_bits(u8 reg, u8 mask, u8 value,
+			     struct i2c_client *client)
+{
+	u8 val_old, val_new;
+
+	ac107_read(reg, &val_old, client);
+	val_new = (val_old & ~mask) | (value & mask);
+	if (val_new != val_old) {
+		ac107_write(reg, val_new, client);
+	}
+
+	return 0;
+}
+
+#if 0
+static int ac107_multi_chips_read(u8 reg, unsigned char *rt_value)
+{
+	u8 i;
+
+	for (i = 0; i < AC107_CHIP_NUMS; i++) {
+		ac107_read(reg, rt_value++, i2c_ctrl[i]);
+	}
+
+	return 0;
+}
+#endif
+
+static int ac107_multi_chips_write(u8 reg, unsigned char value)
+{
+	u8 i;
+
+	for (i = 0; i < AC107_CHIP_NUMS; i++) {
+		ac107_write(reg, value, i2c_ctrl[i]);
+	}
+
+	return 0;
+}
+
+static int ac107_multi_chips_update_bits(u8 reg, u8 mask, u8 value)
+{
+	u8 i;
+
+	for (i = 0; i < AC107_CHIP_NUMS; i++) {
+		ac107_update_bits(reg, mask, value, i2c_ctrl[i]);
+	}
+
+	return 0;
+}
+
+static void ac107_hw_init(struct i2c_client *i2c)
+{
+	u8 reg_val;
+
+	/*** Analog voltage enable ***/
+	ac107_write(PWR_CTRL1, 0x80, i2c);	/*0x01=0x80: VREF Enable */
+	ac107_write(PWR_CTRL2, 0x55, i2c);	/*0x02=0x55: MICBIAS1&2 Enable */
+
+	/*** SYSCLK Config ***/
+	ac107_update_bits(SYSCLK_CTRL, 0x1 << SYSCLK_EN, 0x1 << SYSCLK_EN, i2c);	/*SYSCLK Enable */
+	ac107_write(MOD_CLK_EN, 0x07, i2c);	/*0x21=0x07: Module clock enable<I2S, ADC digital,  ADC analog> */
+	ac107_write(MOD_RST_CTRL, 0x03, i2c);	/*0x22=0x03: Module reset de-asserted<I2S, ADC digital> */
+
+	/*** I2S Common Config ***/
+	ac107_update_bits(I2S_CTRL, 0x1 << SDO_EN, 0x1 << SDO_EN, i2c);	/*SDO enable */
+	ac107_update_bits(I2S_BCLK_CTRL, 0x1 << EDGE_TRANSFER, 0x0 << EDGE_TRANSFER, i2c);	/*SDO drive data and SDI sample data at the different BCLK edge */
+	ac107_update_bits(I2S_LRCK_CTRL1, 0x3 << LRCK_PERIODH,
+			  ((AC107_LRCK_PERIOD - 1) >> 8) << LRCK_PERIODH, i2c);
+	ac107_write(I2S_LRCK_CTRL2, (u8) (AC107_LRCK_PERIOD - 1), i2c);	/*config LRCK period */
+	/*Encoding mode format select 0~N-1, Encoding mode enable, Turn to hi-z state (TDM) when not transferring slot */
+	ac107_update_bits(I2S_FMT_CTRL1,
+			0x1 << ENCD_FMT | 0x1 << ENCD_SEL | 0x1 << TX_SLOT_HIZ
+			| 0x1 << TX_STATE,
+			!!AC107_ENCODING_FMT << ENCD_FMT |
+			!!AC107_ENCODING_EN << ENCD_SEL | 0x0 << TX_SLOT_HIZ
+			| 0x1 << TX_STATE, i2c);
+	ac107_update_bits(I2S_FMT_CTRL2, 0x7 << SLOT_WIDTH_SEL, (AC107_SLOT_WIDTH / 4 - 1) << SLOT_WIDTH_SEL, i2c);	/*8/12/16/20/24/28/32bit Slot Width */
+	/*0x36=0x60: TX MSB first, SDOUT normal, PCM frame type, Linear PCM Data Mode */
+	ac107_update_bits(I2S_FMT_CTRL3,
+			0x1 << TX_MLS | 0x1 << SDOUT_MUTE | 0x1 << LRCK_WIDTH
+			| 0x3 << TX_PDM,
+			0x0 << TX_MLS | 0x0 << SDOUT_MUTE | 0x0 << LRCK_WIDTH
+			| 0x0 << TX_PDM, i2c);
+
+	ac107_update_bits(I2S_TX_CHMP_CTRL1, !AC107_DAPM_EN * 0xff, 0xaa, i2c);	/*0x3c=0xaa: TX CH1/3/5/7 map to adc1, TX CH2/4/6/8 map to adc2 */
+	ac107_update_bits(I2S_TX_CHMP_CTRL2, !AC107_DAPM_EN * 0xff, 0xaa, i2c);	/*0x3d=0xaa: TX CH9/11/13/15 map to adc1, TX CH10/12/14/16 map to adc2 */
+
+	/*PDM Interface Latch ADC1 data on rising clock edge. Latch ADC2 data on falling clock edge, PDM Enable */
+	ac107_update_bits(PDM_CTRL, 0x1 << PDM_TIMING | 0x1 << PDM_EN,
+			  0x0 << PDM_TIMING | !!AC107_PDM_EN << PDM_EN, i2c);
+
+	/*** ADC DIG part Config***/
+	ac107_update_bits(ADC_DIG_EN, !AC107_DAPM_EN * 0x7, 0x7, i2c);	/*0x61=0x07: Digital part globe enable, ADCs digital part enable */
+	ac107_update_bits(DMIC_EN, !AC107_DAPM_EN * 0x1, !!AC107_DMIC_EN, i2c);	/*DMIC Enable */
+
+	/* ADC pattern select */
+#if AC107_KCONTROL_EN
+	ac107_read(ADC_DIG_DEBUG, &reg_val, i2c);
+	ac107_write(HPF_EN, !(reg_val & 0x7) * 0x03, i2c);
+#else
+	ac107_write(HPF_EN, !AC107_ADC_PATTERN_SEL * 0x03, i2c);
+	ac107_update_bits(ADC_DIG_DEBUG, 0x7 << ADC_PTN_SEL,
+			  (AC107_ADC_PATTERN_SEL & 0x7) << ADC_PTN_SEL, i2c);
+#endif
+
+	//ADC Digital Volume Config
+	ac107_update_bits(ADC1_DVOL_CTRL, !AC107_KCONTROL_EN * 0xff, 0xA0, i2c);
+	ac107_update_bits(ADC2_DVOL_CTRL, !AC107_KCONTROL_EN * 0xff, 0xA0, i2c);
+
+	/*** ADCs analog PGA gain Config***/
+	ac107_update_bits(ANA_ADC1_CTRL3,
+			  !AC107_KCONTROL_EN * 0x1f << RX1_PGA_GAIN_CTRL,
+			  AC107_PGA_GAIN << RX1_PGA_GAIN_CTRL, i2c);
+	ac107_update_bits(ANA_ADC2_CTRL3,
+			  !AC107_KCONTROL_EN * 0x1f << RX2_PGA_GAIN_CTRL,
+			  AC107_PGA_GAIN << RX2_PGA_GAIN_CTRL, i2c);
+
+	/*** ADCs analog global Enable***/
+	ac107_update_bits(ANA_ADC1_CTRL5, !AC107_DAPM_EN * 0x1 << RX1_GLOBAL_EN,
+			  0x1 << RX1_GLOBAL_EN, i2c);
+	ac107_update_bits(ANA_ADC2_CTRL5, !AC107_DAPM_EN * 0x1 << RX2_GLOBAL_EN,
+			  0x1 << RX2_GLOBAL_EN, i2c);
+
+	//VREF Fast Start-up Disable
+	ac107_update_bits(PWR_CTRL1, 0x1 << VREF_FSU_DISABLE,
+			  0x1 << VREF_FSU_DISABLE, i2c);
+}
+
+static int ac107_set_sysclk(struct snd_soc_dai *dai, int clk_id,
+			    unsigned int freq, int dir)
+{
+	AC107_DEBUG("\n--->%s\n", __FUNCTION__);
+
+	switch (clk_id) {
+	case SYSCLK_SRC_MCLK:
+		AC107_DEBUG("AC107 SYSCLK source select MCLK\n\n");
+		ac107_multi_chips_update_bits(SYSCLK_CTRL, 0x3 << SYSCLK_SRC, SYSCLK_SRC_MCLK << SYSCLK_SRC);	//System Clock Source Select MCLK
+		break;
+	case SYSCLK_SRC_BCLK:
+		AC107_DEBUG("AC107 SYSCLK source select BCLK\n\n");
+		ac107_multi_chips_update_bits(SYSCLK_CTRL, 0x3 << SYSCLK_SRC, SYSCLK_SRC_BCLK << SYSCLK_SRC);	//System Clock Source Select BCLK
+		break;
+	case SYSCLK_SRC_PLL:
+		AC107_DEBUG("AC107 SYSCLK source select PLL\n\n");
+		ac107_multi_chips_update_bits(SYSCLK_CTRL, 0x3 << SYSCLK_SRC, SYSCLK_SRC_PLL << SYSCLK_SRC);	//System Clock Source Select PLL
+		break;
+	default:
+		pr_err("AC107 SYSCLK source config error:%d\n\n", clk_id);
+		return -EINVAL;
+	}
+
+	//SYSCLK Enable
+	ac107_multi_chips_update_bits(SYSCLK_CTRL, 0x1 << SYSCLK_EN,
+				      0x1 << SYSCLK_EN);
+	return 0;
+}
+
+static int ac107_set_pll(struct snd_soc_dai *dai, int pll_id, int source,
+			 unsigned int freq_in, unsigned int freq_out)
+{
+	u32 i, m1, m2, n, k1, k2;
+	AC107_DEBUG("\n--->%s\n", __FUNCTION__);
+
+	freq_in = freq_in / 2;
+	if (!freq_out)
+		return 0;
+
+	if (freq_in < 128000 || freq_in > 24576000) {
+		pr_err
+		    ("AC107 PLLCLK source input freq only support [128K,24M],while now %u\n\n",
+		     freq_in);
+		return -EINVAL;
+	} else if ((freq_in == 12288000 || freq_in == 11289600)
+		   && (pll_id == PLLCLK_SRC_MCLK || pll_id == PLLCLK_SRC_BCLK)) {
+		//System Clock Source Select MCLK/BCLK, SYSCLK Enable
+		AC107_DEBUG
+		    ("AC107 don't need to use PLL, SYSCLK source select %s\n\n",
+		     pll_id ? "BCLK" : "MCLK");
+		ac107_multi_chips_update_bits(SYSCLK_CTRL,
+					      0x3 << SYSCLK_SRC | 0x1 <<
+					      SYSCLK_EN,
+					      pll_id << SYSCLK_SRC | 0x1 <<
+					      SYSCLK_EN);
+		return 0;	//Don't need to use PLL
+	}
+	//PLL Clock Source Select
+	switch (pll_id) {
+	case PLLCLK_SRC_MCLK:
+		AC107_DEBUG("AC107 PLLCLK input source select MCLK\n");
+		ac107_multi_chips_update_bits(SYSCLK_CTRL, 0x3 << PLLCLK_SRC,
+					      PLLCLK_SRC_MCLK << PLLCLK_SRC);
+		break;
+	case PLLCLK_SRC_BCLK:
+		AC107_DEBUG("AC107 PLLCLK input source select BCLK\n");
+		ac107_multi_chips_update_bits(SYSCLK_CTRL, 0x3 << PLLCLK_SRC,
+					      PLLCLK_SRC_BCLK << PLLCLK_SRC);
+		break;
+	case PLLCLK_SRC_PDMCLK:
+		AC107_DEBUG("AC107 PLLCLK input source select PDMCLK\n");
+		ac107_multi_chips_update_bits(SYSCLK_CTRL, 0x3 << PLLCLK_SRC,
+					      PLLCLK_SRC_PDMCLK << PLLCLK_SRC);
+		break;
+	default:
+		pr_err("AC107 PLLCLK source config error:%d\n\n", pll_id);
+		return -EINVAL;
+	}
+
+	//FOUT =(FIN * N) / [(M1+1) * (M2+1)*(K1+1)*(K2+1)] ;
+	for (i = 0; i < ARRAY_SIZE(ac107_pll_div); i++) {
+		if (ac107_pll_div[i].freq_in == freq_in
+		    && ac107_pll_div[i].freq_out == freq_out) {
+			m1 = ac107_pll_div[i].m1;
+			m2 = ac107_pll_div[i].m2;
+			n = ac107_pll_div[i].n;
+			k1 = ac107_pll_div[i].k1;
+			k2 = ac107_pll_div[i].k2;
+			AC107_DEBUG
+			    ("AC107 PLL freq_in match:%u, freq_out:%u\n\n",
+			     freq_in, freq_out);
+			break;
+		}
+	}
+
+	if (i == ARRAY_SIZE(ac107_pll_div)) {
+		pr_err
+		    ("AC107 don't match PLLCLK freq_in and freq_out table\n\n");
+		return -EINVAL;
+	}
+	//Config PLL DIV param M1/M2/N/K1/K2
+	ac107_multi_chips_update_bits(PLL_CTRL2,
+				      0x1f << PLL_PREDIV1 | 0x1 << PLL_PREDIV2,
+				      m1 << PLL_PREDIV1 | m2 << PLL_PREDIV2);
+	ac107_multi_chips_update_bits(PLL_CTRL3, 0x3 << PLL_LOOPDIV_MSB,
+				      (n >> 8) << PLL_LOOPDIV_MSB);
+	ac107_multi_chips_update_bits(PLL_CTRL4, 0xff << PLL_LOOPDIV_LSB,
+				      (u8) n << PLL_LOOPDIV_LSB);
+	ac107_multi_chips_update_bits(PLL_CTRL5,
+				      0x1f << PLL_POSTDIV1 | 0x1 <<
+				      PLL_POSTDIV2,
+				      k1 << PLL_POSTDIV1 | k2 << PLL_POSTDIV2);
+
+	//Config PLL module current
+	//ac107_multi_chips_update_bits(PLL_CTRL1, 0x7<<PLL_IBIAS, 0x4<<PLL_IBIAS);
+	//ac107_multi_chips_update_bits(PLL_CTRL6, 0x1f<<PLL_CP, 0xf<<PLL_CP);
+
+	//PLL module enable
+	ac107_multi_chips_update_bits(PLL_LOCK_CTRL, 0x1 << PLL_LOCK_EN, 0x1 << PLL_LOCK_EN);	//PLL CLK lock enable
+	//ac107_multi_chips_update_bits(PLL_CTRL1, 0x1<<PLL_EN | 0x1<<PLL_COM_EN, 0x1<<PLL_EN | 0x1<<PLL_COM_EN);	//PLL Common voltage Enable, PLL Enable
+
+	//PLLCLK Enable, SYSCLK Enable
+	ac107_multi_chips_update_bits(SYSCLK_CTRL,
+				      0x1 << PLLCLK_EN | 0x1 << SYSCLK_EN,
+				      0x1 << PLLCLK_EN | 0x1 << SYSCLK_EN);
+
+	return 0;
+}
+
+static int ac107_set_clkdiv(struct snd_soc_dai *dai, int div_id, int div)
+{
+	u32 i, bclk_div, bclk_div_reg_val;
+	AC107_DEBUG("\n--->%s\n", __FUNCTION__);
+
+	if (!div_id) {		//use div_id to judge Master/Slave mode,  0: Slave mode, 1: Master mode
+		AC107_DEBUG
+		    ("AC107 work as Slave mode, don't need to config BCLK_DIV\n\n");
+		return 0;
+	}
+
+	//bclk_div = div / (AC107_LRCK_PERIOD);	//default PCM mode
+	bclk_div = div/(2*AC107_LRCK_PERIOD); //I2S/LJ/RJ mode
+
+	for (i = 0; i < ARRAY_SIZE(ac107_bclk_div); i++) {
+		if (ac107_bclk_div[i].real_val == bclk_div) {
+			bclk_div_reg_val = ac107_bclk_div[i].reg_val;
+			AC107_DEBUG("AC107 set BCLK_DIV_[%u]\n\n", bclk_div);
+			break;
+		}
+	}
+
+	if (i == ARRAY_SIZE(ac107_bclk_div)) {
+		pr_err("AC107 don't support BCLK_DIV_[%u]\n\n", bclk_div);
+		return -EINVAL;
+	}
+	//AC107 set BCLK DIV
+	ac107_multi_chips_update_bits(I2S_BCLK_CTRL, 0xf << BCLKDIV,
+				      bclk_div_reg_val << BCLKDIV);
+	return 0;
+}
+
+static int ac107_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+{
+	u8 i, tx_offset, i2s_mode, sign_ext, lrck_polarity, brck_polarity;
+	struct ac107_priv *ac107 = dev_get_drvdata(dai->dev);
+	AC107_DEBUG("\n--->%s\n", __FUNCTION__);
+
+	//AC107 config Master/Slave mode
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:	//AC107 Master
+		AC107_DEBUG("AC107 set to work as Master\n");
+		ac107_update_bits(I2S_CTRL, 0x3 << LRCK_IOEN, 0x3 << LRCK_IOEN, ac107->i2c);	//BCLK & LRCK output
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:	//AC107 Slave
+		AC107_DEBUG("AC107 set to work as Slave\n");
+		ac107_update_bits(I2S_CTRL, 0x3 << LRCK_IOEN, 0x0 << LRCK_IOEN, ac107->i2c);	//BCLK & LRCK input
+		break;
+	default:
+		pr_err("AC107 Master/Slave mode config error:%u\n\n",
+		       (fmt & SND_SOC_DAIFMT_MASTER_MASK) >> 12);
+		return -EINVAL;
+	}
+	for (i = 0; i < AC107_CHIP_NUMS; i++) {	//multi_chips: only one chip set as Master, and the others also need to set as Slave
+		if (i2c_ctrl[i] == ac107->i2c)
+			continue;
+		ac107_update_bits(I2S_CTRL, 0x3 << LRCK_IOEN, 0x0 << LRCK_IOEN,
+				  i2c_ctrl[i]);
+	}
+
+	//AC107 config I2S/LJ/RJ/PCM format
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		AC107_DEBUG("AC107 config I2S format\n");
+		i2s_mode = LEFT_JUSTIFIED_FORMAT;
+		tx_offset = 1;
+		sign_ext = TRANSFER_ZERO_AFTER;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		AC107_DEBUG("AC107 config RIGHT-JUSTIFIED format\n");
+		i2s_mode = RIGHT_JUSTIFIED_FORMAT;
+		tx_offset = 0;
+		sign_ext = SIGN_EXTENSION_MSB;
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		AC107_DEBUG("AC107 config LEFT-JUSTIFIED format\n");
+		i2s_mode = LEFT_JUSTIFIED_FORMAT;
+		tx_offset = 0;
+		sign_ext = TRANSFER_ZERO_AFTER;
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		AC107_DEBUG("AC107 config PCM-A format\n");
+		i2s_mode = PCM_FORMAT;
+		tx_offset = 1;
+		sign_ext = TRANSFER_ZERO_AFTER;
+		break;
+	case SND_SOC_DAIFMT_DSP_B:
+		AC107_DEBUG("AC107 config PCM-B format\n");
+		i2s_mode = PCM_FORMAT;
+		tx_offset = 0;
+		sign_ext = TRANSFER_ZERO_AFTER;
+		break;
+	default:
+		pr_err("AC107 I2S format config error:%u\n\n",
+		       fmt & SND_SOC_DAIFMT_FORMAT_MASK);
+		return -EINVAL;
+	}
+	ac107_multi_chips_update_bits(I2S_FMT_CTRL1,
+				      0x3 << MODE_SEL | 0x1 << TX_OFFSET,
+				      i2s_mode << MODE_SEL | tx_offset <<
+				      TX_OFFSET);
+	ac107_multi_chips_update_bits(I2S_FMT_CTRL3, 0x3 << SEXT,
+				      sign_ext << SEXT);
+
+	//AC107 config BCLK&LRCK polarity
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		AC107_DEBUG
+		    ("AC107 config BCLK&LRCK polarity: BCLK_normal,LRCK_normal\n");
+		brck_polarity = BCLK_NORMAL_DRIVE_N_SAMPLE_P;
+		lrck_polarity = LRCK_LEFT_LOW_RIGHT_HIGH;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		AC107_DEBUG
+		    ("AC107 config BCLK&LRCK polarity: BCLK_normal,LRCK_invert\n");
+		brck_polarity = BCLK_NORMAL_DRIVE_N_SAMPLE_P;
+		lrck_polarity = LRCK_LEFT_HIGH_RIGHT_LOW;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		AC107_DEBUG
+		    ("AC107 config BCLK&LRCK polarity: BCLK_invert,LRCK_normal\n");
+		brck_polarity = BCLK_INVERT_DRIVE_P_SAMPLE_N;
+		lrck_polarity = LRCK_LEFT_LOW_RIGHT_HIGH;
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		AC107_DEBUG
+		    ("AC107 config BCLK&LRCK polarity: BCLK_invert,LRCK_invert\n");
+		brck_polarity = BCLK_INVERT_DRIVE_P_SAMPLE_N;
+		lrck_polarity = LRCK_LEFT_HIGH_RIGHT_LOW;
+		break;
+	default:
+		pr_err("AC107 config BCLK/LRCLK polarity error:%u\n\n",
+		       (fmt & SND_SOC_DAIFMT_INV_MASK) >> 8);
+		return -EINVAL;
+	}
+	ac107_multi_chips_update_bits(I2S_BCLK_CTRL, 0x1 << BCLK_POLARITY,
+				      brck_polarity << BCLK_POLARITY);
+	ac107_multi_chips_update_bits(I2S_LRCK_CTRL1, 0x1 << LRCK_POLARITY,
+				      lrck_polarity << LRCK_POLARITY);
+
+	return 0;
+}
+
+static int ac107_hw_params(struct snd_pcm_substream *substream,
+			   struct snd_pcm_hw_params *params,
+			   struct snd_soc_dai *dai)
+{
+	u16 i, channels, channels_en, sample_resolution;
+	struct ac107_priv *ac107 = dev_get_drvdata(dai->dev);
+	AC107_DEBUG("\n--->%s\n", __FUNCTION__);
+
+	//AC107 hw init
+	for (i = 0; i < AC107_CHIP_NUMS; i++) {
+		ac107_hw_init(i2c_ctrl[i]);
+	}
+
+	//AC107 set sample rate
+	for (i = 0; i < ARRAY_SIZE(ac107_sample_rate); i++) {
+		if (ac107_sample_rate[i].real_val ==
+		    params_rate(params) /
+		    (AC107_ENCODING_EN ? AC107_ENCODING_CH_NUMS / 2 : 1)) {
+			ac107_multi_chips_update_bits(ADC_SPRC,
+						      0xf << ADC_FS_I2S,
+						      ac107_sample_rate
+						      [i].reg_val <<
+						      ADC_FS_I2S);
+			break;
+		}
+	}
+
+	//AC107 set channels
+	channels =
+	    params_channels(params) *
+	    (AC107_ENCODING_EN ? AC107_ENCODING_CH_NUMS / 2 : 1);
+	for (i = 0; i < (channels + 1) / 2; i++) {
+		channels_en =
+		    (channels >=
+		     2 * (i + 1)) ? 0x0003 << (2 * i) : ((1 << (channels % 2)) -
+							 1) << (2 * i);
+		ac107_write(I2S_TX_CTRL1, channels - 1, i2c_ctrl[i]);
+		ac107_write(I2S_TX_CTRL2, (u8) channels_en, i2c_ctrl[i]);
+		ac107_write(I2S_TX_CTRL3, channels_en >> 8, i2c_ctrl[i]);
+	}
+	for (; i < AC107_CHIP_NUMS; i++) {
+		ac107_write(I2S_TX_CTRL1, 0, i2c_ctrl[i]);
+		ac107_write(I2S_TX_CTRL2, 0, i2c_ctrl[i]);
+		ac107_write(I2S_TX_CTRL3, 0, i2c_ctrl[i]);
+	}
+
+	//AC107 set sample resorution
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S8:
+		sample_resolution = 8;
+		break;
+	case SNDRV_PCM_FORMAT_S16_LE:
+		sample_resolution = 16;
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+		sample_resolution = 20;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		sample_resolution = 24;
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		sample_resolution = 32;
+		break;
+	default:
+		dev_err(dai->dev,
+			"AC107 don't supported the sample resolution: %u\n",
+			params_format(params));
+		return -EINVAL;
+	}
+	ac107_multi_chips_update_bits(I2S_FMT_CTRL2, 0x7 << SAMPLE_RESOLUTION,
+				      (sample_resolution / 4 -
+				       1) << SAMPLE_RESOLUTION);
+
+	//AC107 TX enable, Globle enable
+	ac107_multi_chips_update_bits(I2S_CTRL, 0x1 << TXEN | 0x1 << GEN,
+				      0x1 << TXEN | 0x1 << GEN);
+
+	//AC107 PLL Enable and through MCLK Pin output Enable
+	ac107_read(SYSCLK_CTRL, (u8 *)&i, ac107->i2c);
+	if (i & 0x80) {		//PLLCLK Enable
+		if (!(i & 0x0c)) {	//SYSCLK select MCLK
+			//MCLK output Clock 24MHz from DPLL
+			ac107_update_bits(I2S_CTRL, 0x1 << MCLK_IOEN,
+					  0x1 << MCLK_IOEN, ac107->i2c);
+			ac107_update_bits(I2S_PADDRV_CTRL, 0x03 << MCLK_DRV,
+					  0x03 << MCLK_DRV, ac107->i2c);
+			for (i = 0; i < AC107_CHIP_NUMS; i++) {	//multi_chips: only one chip MCLK output PLL_test, and the others MCLK config as input
+				if (i2c_ctrl[i] == ac107->i2c)
+					continue;
+				ac107_update_bits(I2S_CTRL, 0x1 << MCLK_IOEN,
+						  0x0 << MCLK_IOEN,
+						  i2c_ctrl[i]);
+			}
+			//the chip which MCLK config as output, should select PLL as its SYCCLK source
+			ac107_update_bits(SYSCLK_CTRL, 0x3 << SYSCLK_SRC,
+					  SYSCLK_SRC_PLL << SYSCLK_SRC,
+					  ac107->i2c);
+			//the chip which MCLK config as output, PLL Common voltage Enable, PLL Enable
+			ac107_update_bits(PLL_CTRL1,
+					  0x1 << PLL_EN | 0x1 << PLL_COM_EN,
+					  0x1 << PLL_EN | 0x1 << PLL_COM_EN,
+					  ac107->i2c);
+		} else if ((i & 0x0c) >> 2 == 0x2) {	//SYSCLK select PLL
+			ac107_multi_chips_update_bits(PLL_LOCK_CTRL,
+						      0x7 << SYSCLK_HOLD_TIME,
+						      0x3 << SYSCLK_HOLD_TIME);
+			//All chips PLL Common voltage Enable, PLL Enable
+			ac107_multi_chips_update_bits(PLL_CTRL1,
+						      0x1 << PLL_EN | 0x1 <<
+						      PLL_COM_EN,
+						      0x1 << PLL_EN | 0x1 <<
+						      PLL_COM_EN);
+		}
+	}
+
+	return 0;
+}
+
+static int ac107_hw_free(struct snd_pcm_substream *substream,
+			 struct snd_soc_dai *dai)
+{
+	u8 i, j;
+	AC107_DEBUG("\n--->%s\n", __FUNCTION__);
+
+	//AC107 I2S Globle disable
+	ac107_multi_chips_update_bits(I2S_CTRL, 0x1 << GEN, 0x0 << GEN);
+
+#if AC107_KCONTROL_EN || AC107_DAPM_EN
+	for (i = 0; i < ARRAY_SIZE(ac107_reg_default_value); i++) {
+		for (j = 0; j < sizeof(ac107_kcontrol_dapm_reg); j++) {
+			if (ac107_reg_default_value[i].reg_addr ==
+			    ac107_kcontrol_dapm_reg[j])
+				break;
+		}
+		if (j == sizeof(ac107_kcontrol_dapm_reg)) {
+			ac107_multi_chips_write(ac107_reg_default_value
+						[i].reg_addr,
+						ac107_reg_default_value
+						[i].default_val);
+		}
+	}
+
+#else
+
+	AC107_DEBUG("AC107 reset all register to their default value\n\n");
+	ac107_multi_chips_write(CHIP_AUDIO_RST, 0x12);
+#endif
+
+	return 0;
+}
+
+/*** define  ac107  dai_ops  struct ***/
+static const struct snd_soc_dai_ops ac107_dai_ops = {
+	/*DAI clocking configuration */
+	.set_sysclk = ac107_set_sysclk,
+	.set_pll = ac107_set_pll,
+	.set_clkdiv = ac107_set_clkdiv,
+
+	/*ALSA PCM audio operations */
+	.hw_params = ac107_hw_params,
+	.hw_free = ac107_hw_free,
+
+	/*DAI format configuration */
+	.set_fmt = ac107_set_fmt,
+};
+
+/*** define  ac107  dai_driver struct ***/
+static struct snd_soc_dai_driver ac107_dai0 = {
+	.name = "ac107-pcm0",
+	.capture = {
+		    .stream_name = "Capture",
+		    .channels_min = 1,
+		    .channels_max = AC107_CHIP_NUMS * 2,
+		    .rates = AC107_RATES,
+		    .formats = AC107_FORMATS,
+		    },
+	.ops = &ac107_dai_ops,
+};
+
+static struct snd_soc_dai_driver ac107_dai1 = {
+	.name = "ac107-pcm1",
+	.capture = {
+		    .stream_name = "Capture",
+		    .channels_min = 1,
+		    .channels_max = AC107_CHIP_NUMS * 2,
+		    .rates = AC107_RATES,
+		    .formats = AC107_FORMATS,
+		    },
+	.ops = &ac107_dai_ops,
+};
+
+static struct snd_soc_dai_driver ac107_dai2 = {
+	.name = "ac107-pcm2",
+	.capture = {
+		    .stream_name = "Capture",
+		    .channels_min = 1,
+		    .channels_max = AC107_CHIP_NUMS * 2,
+		    .rates = AC107_RATES,
+		    .formats = AC107_FORMATS,
+		    },
+	.ops = &ac107_dai_ops,
+};
+
+static struct snd_soc_dai_driver ac107_dai3 = {
+	.name = "ac107-pcm3",
+	.capture = {
+		    .stream_name = "Capture",
+		    .channels_min = 1,
+		    .channels_max = AC107_CHIP_NUMS * 2,
+		    .rates = AC107_RATES,
+		    .formats = AC107_FORMATS,
+		    },
+	.ops = &ac107_dai_ops,
+};
+
+static struct snd_soc_dai_driver ac107_dai4 = {
+	.name = "ac107-pcm4",
+	.capture = {
+		    .stream_name = "Capture",
+		    .channels_min = 1,
+		    .channels_max = AC107_CHIP_NUMS * 2,
+		    .rates = AC107_RATES,
+		    .formats = AC107_FORMATS,
+		    },
+	.ops = &ac107_dai_ops,
+};
+
+static struct snd_soc_dai_driver ac107_dai5 = {
+	.name = "ac107-pcm5",
+	.capture = {
+		    .stream_name = "Capture",
+		    .channels_min = 1,
+		    .channels_max = AC107_CHIP_NUMS * 2,
+		    .rates = AC107_RATES,
+		    .formats = AC107_FORMATS,
+		    },
+	.ops = &ac107_dai_ops,
+};
+
+static struct snd_soc_dai_driver ac107_dai6 = {
+	.name = "ac107-pcm6",
+	.capture = {
+		    .stream_name = "Capture",
+		    .channels_min = 1,
+		    .channels_max = AC107_CHIP_NUMS * 2,
+		    .rates = AC107_RATES,
+		    .formats = AC107_FORMATS,
+		    },
+	.ops = &ac107_dai_ops,
+};
+
+static struct snd_soc_dai_driver ac107_dai7 = {
+	.name = "ac107-pcm7",
+	.capture = {
+		    .stream_name = "Capture",
+		    .channels_min = 1,
+		    .channels_max = AC107_CHIP_NUMS * 2,
+		    .rates = AC107_RATES,
+		    .formats = AC107_FORMATS,
+		    },
+	.ops = &ac107_dai_ops,
+};
+
+static struct snd_soc_dai_driver *ac107_dai[] = {
+	&ac107_dai0,
+	&ac107_dai1,
+	&ac107_dai2,
+	&ac107_dai3,
+	&ac107_dai4,
+	&ac107_dai5,
+	&ac107_dai6,
+	&ac107_dai7,
+};
+
+static int ac107_probe(struct snd_soc_component *component)
+{
+	struct ac107_priv *ac107 = dev_get_drvdata(component->dev);
+	int ret = 0;
+
+	component->regmap =
+	    devm_regmap_init_i2c(ac107->i2c, &ac107_regmap_config);
+	ret = PTR_RET(component->regmap);
+	if (ret) {
+		dev_err(component->dev, "AC107 regmap init I2C Failed: %d\n", ret);
+		return ret;
+	}
+	ac107->component = component;
+
+#if AC107_KCONTROL_EN
+	ac107_multi_chips_update_bits(ANA_ADC1_CTRL3, 0x1f << RX1_PGA_GAIN_CTRL, AC107_PGA_GAIN << RX1_PGA_GAIN_CTRL);	//ADC1 PGA Gain default
+	ac107_multi_chips_update_bits(ANA_ADC2_CTRL3, 0x1f << RX2_PGA_GAIN_CTRL, AC107_PGA_GAIN << RX2_PGA_GAIN_CTRL);	//ADC2 PGA Gain default
+	snd_soc_add_component_controls(component, ac107_volume_controls, AC107_CHIP_NUMS * 2);	//PGA Gain Control
+	snd_soc_add_component_controls(component, ac107_volume_controls + 16, AC107_CHIP_NUMS * 2);	//Digital Volume Control
+#endif
+
+#if AC107_DAPM_EN
+	ac107_multi_chips_write(I2S_TX_CHMP_CTRL1, 0xaa);	//defatul map:	TX CH1/3/5/7 map to adc1, TX CH2/4/6/8 map to adc2
+	ac107_multi_chips_write(I2S_TX_CHMP_CTRL2, 0xaa);	//defatul map:	TX CH9/11/13/15 map to adc1, TX CH10/12/14/16 map to adc2
+#endif
+
+	return 0;
+}
+
+static void ac107_remove(struct snd_soc_component *component)
+{
+	return;
+}
+
+static int ac107_suspend(struct snd_soc_component *component)
+{
+	struct ac107_priv *ac107 = dev_get_drvdata(component->dev);
+
+#if AC107_MATCH_DTS_EN
+	if ((ac107_regulator_en & 0x1) && !IS_ERR(ac107->vol_supply.dvcc_1v8)) {
+		regulator_disable(ac107->vol_supply.dvcc_1v8);
+		ac107_regulator_en &= ~0x1;
+	}
+
+	if ((ac107_regulator_en & 0x2)
+	    && !IS_ERR(ac107->vol_supply.avcc_vccio_3v3)) {
+		regulator_disable(ac107->vol_supply.avcc_vccio_3v3);
+		ac107_regulator_en &= ~0x2;
+	}
+	if (gpio_is_valid(ac107->reset_gpio)) {
+		gpio_set_value(ac107->reset_gpio, 0);
+		gpio_free(ac107->reset_gpio);
+	}
+#endif
+
+	return 0;
+}
+
+static int ac107_resume(struct snd_soc_component *component)
+{
+	struct ac107_priv *ac107 = dev_get_drvdata(component->dev);
+	int ret;
+
+#if AC107_MATCH_DTS_EN
+	if ((ac107_regulator_en & 0x1) && !IS_ERR(ac107->vol_supply.dvcc_1v8)) {
+		ret = regulator_enable(ac107->vol_supply.dvcc_1v8);
+		if (ret != 0)
+			pr_err
+			    ("[AC107] %s: some error happen, fail to enable regulator dvcc_1v8!\n",
+			     __func__);
+		ac107_regulator_en |= 0x1;
+	}
+
+	if ((ac107_regulator_en & 0x2)
+	    && !IS_ERR(ac107->vol_supply.avcc_vccio_3v3)) {
+		ret = regulator_enable(ac107->vol_supply.avcc_vccio_3v3);
+		if (ret != 0)
+			pr_err
+			    ("[AC107] %s: some error happen, fail to enable regulator avcc_vccio_3v3!\n",
+			     __func__);
+		ac107_regulator_en |= 0x2;
+	}
+	if (gpio_is_valid(ac107->reset_gpio)) {
+		ret = gpio_request(ac107->reset_gpio, "reset gpio");
+		if (!ret) {
+			gpio_direction_output(ac107->reset_gpio, 1);
+			gpio_set_value(ac107->reset_gpio, 1);
+			msleep(20);
+		}
+	}
+#endif
+
+	return 0;
+}
+
+static unsigned int ac107_component_read(struct snd_soc_component *component,
+				     unsigned int reg)
+{
+	//AC107_DEBUG("\n--->%s\n",__FUNCTION__);
+	u8 val_r;
+	struct ac107_priv *ac107 = dev_get_drvdata(component->dev);
+
+	ac107_read(reg, &val_r, ac107->i2c);
+	return val_r;
+}
+
+static int ac107_component_write(struct snd_soc_component *component, unsigned int reg,
+			     unsigned int value)
+{
+	//AC107_DEBUG("\n--->%s\n",__FUNCTION__);
+	ac107_multi_chips_write(reg, value);
+	return 0;
+}
+
+/*** define  ac107  codec_driver struct ***/
+static const struct snd_soc_component_driver ac107_soc_component_driver = {
+	.probe = ac107_probe,
+	.remove = ac107_remove,
+	.suspend = ac107_suspend,
+	.resume = ac107_resume,
+
+#if AC107_CODEC_RW_USER_EN
+	.read = ac107_component_read,
+	.write = ac107_component_write,
+#endif
+/*
+#if AC107_KCONTROL_EN
+	.controls = ac107_controls,
+	.num_controls = ARRAY_SIZE(ac107_controls),
+#endif
+*/
+#if AC107_DAPM_EN
+	.dapm_widgets = ac107_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(ac107_dapm_widgets),
+	.dapm_routes = ac107_dapm_routes,
+	.num_dapm_routes = ARRAY_SIZE(ac107_dapm_routes),
+#endif
+};
+
+static ssize_t ac107_store(struct device *dev, struct device_attribute *attr,
+			   const char *buf, size_t count)
+{
+	int val = 0, flag = 0;
+	u8 i = 0, reg, num, value_w, value_r;
+
+	struct ac107_priv *ac107 = dev_get_drvdata(dev);
+	val = simple_strtol(buf, NULL, 16);
+	flag = (val >> 16) & 0xFF;
+
+	if (flag) {
+		reg = (val >> 8) & 0xFF;
+		value_w = val & 0xFF;
+		printk("\nWrite: start REG:0x%02x,val:0x%02x,count:0x%02x\n",
+		       reg, value_w, flag);
+		while (flag--) {
+			ac107_write(reg, value_w, ac107->i2c);
+			printk("Write 0x%02x to REG:0x%02x\n", value_w, reg);
+			reg++;
+		}
+	} else {
+		reg = (val >> 8) & 0xFF;
+		num = val & 0xff;
+		printk("\nRead: start REG:0x%02x,count:0x%02x\n", reg, num);
+
+		do {
+			value_r = 0;
+			ac107_read(reg, &value_r, ac107->i2c);
+			printk("REG[0x%02x]: 0x%02x;  ", reg, value_r);
+			reg++;
+			i++;
+			if ((i == num) || (i % 4 == 0))
+				printk("\n");
+		} while (i < num);
+	}
+
+	return count;
+}
+
+static ssize_t ac107_show(struct device *dev, struct device_attribute *attr,
+			  char *buf)
+{
+	printk("/*** AC107 driver version: V1.0 ***/\n");
+	printk("echo flag|reg|val > ac107\n");
+	printk("eg->read start addres=0x00,count=0xff: echo 00ff >ac107\n");
+	printk
+	    ("eg->write start addres=0x70,value=0xa0,count=0x2: echo 270a0 >ac107\n");
+	//printk("eg write value:0xfe to address:0x06 :echo 106fe > ac107\n");
+	return 0;
+}
+
+static DEVICE_ATTR(ac107, 0644, ac107_show, ac107_store);
+
+static struct attribute *ac107_debug_attrs[] = {
+	&dev_attr_ac107.attr,
+	NULL,
+};
+
+static struct attribute_group ac107_debug_attr_group = {
+	.name = "ac107_debug",
+	.attrs = ac107_debug_attrs,
+};
+
+static int ac107_i2c_probe(struct i2c_client *i2c,
+			   const struct i2c_device_id *i2c_id)
+{
+	struct ac107_priv *ac107;
+	struct device_node *np = i2c->dev.of_node;
+	const char *regulator_name = NULL;
+	int ret = 0;
+	struct gpio_config config;
+
+	ac107 = devm_kzalloc(&i2c->dev, sizeof(struct ac107_priv), GFP_KERNEL);
+	if (ac107 == NULL) {
+		dev_err(&i2c->dev, "Unable to allocate ac107 private data\n");
+		return -ENOMEM;
+	}
+
+	ac107->i2c = i2c;
+	dev_set_drvdata(&i2c->dev, ac107);
+
+#if AC107_MATCH_DTS_EN
+	if (!ac107_regulator_en) {
+		ret = of_property_read_string(np, AC107_DVCC_NAME, &regulator_name);	//(const char**)
+		if (ret) {
+			pr_err("get ac107 DVCC regulator name failed \n");
+		} else {
+			ac107->vol_supply.dvcc_1v8 =
+			    regulator_get(NULL, regulator_name);
+			if (IS_ERR(ac107->vol_supply.dvcc_1v8)
+			    || !ac107->vol_supply.dvcc_1v8) {
+				pr_err("get ac107 dvcc_1v8 failed, return!\n");
+				return -EFAULT;
+			}
+			regulator_set_voltage(ac107->vol_supply.dvcc_1v8,
+					      1800000, 1800000);
+			ret = regulator_enable(ac107->vol_supply.dvcc_1v8);
+			if (ret != 0)
+				pr_err
+				    ("[AC107] %s: some error happen, fail to enable regulator dvcc_1v8!\n",
+				     __func__);
+			ac107_regulator_en |= 0x1;
+		}
+
+		ret = of_property_read_string(np, AC107_AVCC_VCCIO_NAME, &regulator_name);	//(const char**)
+		if (ret) {
+			pr_err("get ac107 AVCC_VCCIO regulator name failed \n");
+		} else {
+			ac107->vol_supply.avcc_vccio_3v3 =
+			    regulator_get(NULL, regulator_name);
+			if (IS_ERR(ac107->vol_supply.avcc_vccio_3v3)
+			    || !ac107->vol_supply.avcc_vccio_3v3) {
+				pr_err
+				    ("get ac107 avcc_vccio_3v3 failed, return!\n");
+				return -EFAULT;
+			}
+			regulator_set_voltage(ac107->vol_supply.avcc_vccio_3v3,
+					      3300000, 3300000);
+			ret =
+			    regulator_enable(ac107->vol_supply.avcc_vccio_3v3);
+			if (ret != 0)
+				pr_err
+				    ("[AC107] %s: some error happen, fail to enable regulator avcc_vccio_3v3!\n",
+				     __func__);
+			ac107_regulator_en |= 0x2;
+		}
+
+		/*gpio reset enable */
+		ac107->reset_gpio = of_get_named_gpio_flags(np,
+							    "gpio-reset", 0,
+							    (enum of_gpio_flags
+							     *)&config);
+		if (gpio_is_valid(ac107->reset_gpio)) {
+			ret = gpio_request(ac107->reset_gpio, "reset gpio");
+			if (!ret) {
+				gpio_direction_output(ac107->reset_gpio, 1);
+				gpio_set_value(ac107->reset_gpio, 1);
+				msleep(20);
+			} else {
+				pr_err
+				    ("%s, line:%d, failed request reset gpio: %d!\n",
+				     __func__, __LINE__, ac107->reset_gpio);
+			}
+		}
+	}
+#endif
+
+	if (i2c_id->driver_data < AC107_CHIP_NUMS) {
+		i2c_ctrl[i2c_id->driver_data] = i2c;
+		ret = snd_soc_register_component(&i2c->dev, &ac107_soc_component_driver,
+					ac107_dai[i2c_id->driver_data], 1);
+		if (ret < 0) {
+			dev_err(&i2c->dev,
+				"Failed to register ac107 codec: %d\n", ret);
+		}
+	} else {
+		pr_err("The wrong i2c_id number :%d\n",
+		       (int)(i2c_id->driver_data));
+	}
+
+	ret = sysfs_create_group(&i2c->dev.kobj, &ac107_debug_attr_group);
+	if (ret) {
+		pr_err("failed to create attr group\n");
+	}
+
+	return ret;
+}
+
+static int ac107_i2c_remove(struct i2c_client *i2c)
+{
+	snd_soc_unregister_component(&i2c->dev);
+	return 0;
+}
+
+#if !AC107_MATCH_DTS_EN
+static int ac107_i2c_detect(struct i2c_client *client,
+			    struct i2c_board_info *info)
+{
+	u8 ac107_chip_id;
+	struct i2c_adapter *adapter = client->adapter;
+
+	ac107_read(CHIP_AUDIO_RST, &ac107_chip_id, client);
+	AC107_DEBUG("\nAC107_Chip_ID on I2C-%d:0x%02X\n", adapter->nr,
+		    ac107_chip_id);
+
+	if (ac107_chip_id == 0x4B) {
+		if (client->addr == 0x36) {
+			strlcpy(info->type, "ac107_0", I2C_NAME_SIZE);
+			return 0;
+		} else if (client->addr == 0x37) {
+			strlcpy(info->type, "ac107_1", I2C_NAME_SIZE);
+			return 0;
+		} else if (client->addr == 0x38) {
+			strlcpy(info->type, "ac107_2", I2C_NAME_SIZE);
+			return 0;
+		} else if (client->addr == 0x39) {
+			strlcpy(info->type, "ac107_3", I2C_NAME_SIZE);
+			return 0;
+		}
+	}
+
+	return -ENODEV;
+}
+#endif
+
+static const unsigned short ac107_i2c_addr[] = {
+#if AC107_CHIP_NUMS > 0
+	0x36,
+#endif
+
+#if AC107_CHIP_NUMS > 1
+	0x37,
+#endif
+
+#if AC107_CHIP_NUMS > 2
+	0x38,
+#endif
+
+#if AC107_CHIP_NUMS > 3
+	0x39,
+#endif
+
+#if AC107_CHIP_NUMS > 4
+	0x36,
+#endif
+
+#if AC107_CHIP_NUMS > 5
+	0x37,
+#endif
+
+#if AC107_CHIP_NUMS > 6
+	0x38,
+#endif
+
+#if AC107_CHIP_NUMS > 7
+	0x39,
+#endif
+
+	I2C_CLIENT_END,
+};
+
+static struct i2c_board_info const ac107_i2c_board_info[] = {
+#if AC107_CHIP_NUMS > 0
+	{I2C_BOARD_INFO("ac107_0", 0x36),},
+#endif
+
+#if AC107_CHIP_NUMS > 1
+	{I2C_BOARD_INFO("ac107_1", 0x37),},
+#endif
+
+#if AC107_CHIP_NUMS > 2
+	{I2C_BOARD_INFO("ac107_2", 0x38),},
+#endif
+
+#if AC107_CHIP_NUMS > 3
+	{I2C_BOARD_INFO("ac107_3", 0x39),},
+#endif
+
+#if AC107_CHIP_NUMS > 4
+	{I2C_BOARD_INFO("ac107_4", 0x36),},
+#endif
+
+#if AC107_CHIP_NUMS > 5
+	{I2C_BOARD_INFO("ac107_5", 0x37),},
+#endif
+
+#if AC107_CHIP_NUMS > 6
+	{I2C_BOARD_INFO("ac107_6", 0x38),},
+#endif
+
+#if AC107_CHIP_NUMS > 7
+	{I2C_BOARD_INFO("ac107_7", 0x39),},
+#endif
+
+};
+
+static const struct i2c_device_id ac107_i2c_id[] = {
+#if AC107_CHIP_NUMS > 0
+	{"ac107_0", 0},
+#endif
+
+#if AC107_CHIP_NUMS > 1
+	{"ac107_1", 1},
+#endif
+
+#if AC107_CHIP_NUMS > 2
+	{"ac107_2", 2},
+#endif
+
+#if AC107_CHIP_NUMS > 3
+	{"ac107_3", 3},
+#endif
+
+#if AC107_CHIP_NUMS > 4
+	{"ac107_4", 4},
+#endif
+
+#if AC107_CHIP_NUMS > 5
+	{"ac107_5", 5},
+#endif
+
+#if AC107_CHIP_NUMS > 6
+	{"ac107_6", 6},
+#endif
+
+#if AC107_CHIP_NUMS > 7
+	{"ac107_7", 7},
+#endif
+
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, ac107_i2c_id);
+
+static struct of_device_id ac107_dt_ids[] = {
+#if AC107_CHIP_NUMS > 0
+	{.compatible = "ac107_0",},
+#endif
+
+#if AC107_CHIP_NUMS > 1
+	{.compatible = "ac107_1",},
+#endif
+
+#if AC107_CHIP_NUMS > 2
+	{.compatible = "ac107_2",},
+#endif
+
+#if AC107_CHIP_NUMS > 3
+	{.compatible = "ac107_3",},
+#endif
+
+#if AC107_CHIP_NUMS > 4
+	{.compatible = "ac107_4",},
+#endif
+
+#if AC107_CHIP_NUMS > 5
+	{.compatible = "ac107_5",},
+#endif
+
+#if AC107_CHIP_NUMS > 6
+	{.compatible = "ac107_6",},
+#endif
+
+#if AC107_CHIP_NUMS > 7
+	{.compatible = "ac107_7",},
+#endif
+	{},
+};
+MODULE_DEVICE_TABLE(of, ac107_dt_ids);
+
+static struct i2c_driver ac107_i2c_driver = {
+	.class = I2C_CLASS_HWMON,
+	.driver = {
+		   .name = "ac107",
+		   .owner = THIS_MODULE,
+#if AC107_MATCH_DTS_EN
+		   .of_match_table = ac107_dt_ids,
+#endif
+		   },
+	.probe = ac107_i2c_probe,
+	.remove = ac107_i2c_remove,
+	.id_table = ac107_i2c_id,
+#if !AC107_MATCH_DTS_EN
+	.address_list = ac107_i2c_addr,
+	.detect = ac107_i2c_detect,
+#endif
+};
+
+static int __init ac107_init(void)
+{
+	int ret;
+	ret = i2c_add_driver(&ac107_i2c_driver);
+	if (ret != 0)
+		pr_err("Failed to register ac107 i2c driver : %d \n", ret);
+
+	return ret;
+}
+
+module_init(ac107_init);
+
+static void __exit ac107_exit(void)
+{
+	i2c_del_driver(&ac107_i2c_driver);
+}
+
+module_exit(ac107_exit);
+
+MODULE_DESCRIPTION("ASoC ac107 codec driver");
+MODULE_AUTHOR("panjunwen");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/codecs/ac107.h b/sound/soc/codecs/ac107.h
new file mode 100644
index 000000000..92a71c149
--- /dev/null
+++ b/sound/soc/codecs/ac107.h
@@ -0,0 +1,491 @@
+/*
+ * ac107.h --  ac107 ALSA Soc Audio driver
+ *
+ * Version: 1.0
+ *
+ * Author: panjunwen
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef _AC107_H
+#define _AC107_H
+
+
+/*** AC107 Codec Register Define***/
+
+//Chip Reset
+#define CHIP_AUDIO_RST		0x00
+
+//Power Control
+#define PWR_CTRL1			0x01
+#define PWR_CTRL2			0x02
+
+//PLL Configure Control
+#define PLL_CTRL1			0x10
+#define PLL_CTRL2			0x11
+#define PLL_CTRL3			0x12
+#define PLL_CTRL4			0x13
+#define PLL_CTRL5			0x14
+#define PLL_CTRL6			0x16
+#define PLL_CTRL7			0x17
+#define PLL_LOCK_CTRL		0x18
+
+//System Clock Control
+#define SYSCLK_CTRL			0x20
+#define MOD_CLK_EN			0x21
+#define MOD_RST_CTRL		0x22
+
+//I2S Common Control
+#define I2S_CTRL			0x30
+#define I2S_BCLK_CTRL		0x31
+#define I2S_LRCK_CTRL1		0x32
+#define I2S_LRCK_CTRL2		0x33
+#define I2S_FMT_CTRL1		0x34
+#define I2S_FMT_CTRL2		0x35
+#define I2S_FMT_CTRL3		0x36
+
+//I2S TX Control
+#define I2S_TX_CTRL1		0x38
+#define I2S_TX_CTRL2		0x39
+#define I2S_TX_CTRL3		0x3A
+#define I2S_TX_CHMP_CTRL1	0x3C
+#define I2S_TX_CHMP_CTRL2	0x3D
+
+//I2S RX Control
+#define I2S_RX_CTRL1		0x50
+#define I2S_RX_CTRL2		0x51
+#define I2S_RX_CTRL3		0x52
+#define I2S_RX_CHMP_CTRL1	0x54
+#define I2S_RX_CHMP_CTRL2	0x55
+
+//PDM Control
+#define PDM_CTRL			0x59
+
+//ADC Common Control
+#define ADC_SPRC			0x60
+#define ADC_DIG_EN			0x61
+#define DMIC_EN				0x62
+#define HPF_EN				0x66
+
+//ADC Digital Channel Volume Control
+#define ADC1_DVOL_CTRL		0x70
+#define ADC2_DVOL_CTRL		0x71
+
+//ADC Digital Mixer Source and Gain Control
+#define ADC1_DMIX_SRC		0x76
+#define ADC2_DMIX_SRC		0x77
+
+//ADC Digital Debug Control
+#define ADC_DIG_DEBUG		0x7F
+
+//IO Function and Drive Control
+#define ADC_ANA_DEBUG1		0x80
+#define ADC_ANA_DEBUG2		0x81
+#define I2S_PADDRV_CTRL		0x82
+
+//ADC1 Analog Control
+#define ANA_ADC1_CTRL1		0xA0
+#define ANA_ADC1_CTRL2		0xA1
+#define ANA_ADC1_CTRL3		0xA2
+#define ANA_ADC1_CTRL4		0xA3
+#define ANA_ADC1_CTRL5		0xA4
+
+//ADC2 Analog Control
+#define ANA_ADC2_CTRL1		0xA5
+#define ANA_ADC2_CTRL2		0xA6
+#define ANA_ADC2_CTRL3		0xA7
+#define ANA_ADC2_CTRL4		0xA8
+#define ANA_ADC2_CTRL5		0xA9
+
+//ADC Dither Control
+#define ADC_DITHER_CTRL		0xAA
+
+
+
+/*** AC107 Codec Register Bit Define***/
+
+/* PWR_CTRL1 */
+#define VREF_ENABLE			7
+#define VREF_LPMODE			6
+#define VREF_FSU_DISABLE	5
+#define VREF_RESCTRL		3
+#define IGEN_TRIM			0
+
+/* PWR_CTRL2 */
+#define VREF_SEL			7
+#define MICBIAS2_EN			6
+#define MICBIAS2_VCTRL		4
+#define MICBIAS1_EN			2
+#define MICBIAS1_VCTRL		0
+
+
+/*PLL_CTRL1*/
+#define PLL_IBIAS			4
+#define PLL_NDET			3
+#define PLL_LOCKED_STATUS	2
+#define PLL_COM_EN			1
+#define PLL_EN				0
+
+/*PLL_CTRL2*/
+#define PLL_PREDIV2			5
+#define PLL_PREDIV1			0
+
+/*PLL_CTRL3*/
+#define PLL_LOOPDIV_MSB		0
+
+/*PLL_CTRL4*/
+#define PLL_LOOPDIV_LSB		0
+
+/*PLL_CTRL5*/
+#define PLL_POSTDIV2		5
+#define PLL_POSTDIV1		0
+
+/*PLL_CTRL6*/
+#define PLL_LDO				6
+#define PLL_CP				0
+
+/*PLL_CTRL7*/
+#define PLL_CAP				6
+#define PLL_RES				4
+
+/*PLL_LOCK_CTRL*/
+#define SYSCLK_HOLD_TIME	4
+#define LOCK_LEVEL1			2
+#define LOCK_LEVEL2			1
+#define PLL_LOCK_EN			0
+
+
+/* SYSCLK_CTRL */
+#define PLLCLK_EN			7
+#define PLLCLK_SRC			4
+#define SYSCLK_SRC			2
+#define SYSCLK_EN			0
+
+/* MOD_CLK_EN & MOD_RST_CTRL */
+#define I2S_RST				4
+#define ADC_ANALOG			2
+#define ADC_DIGITAL			1
+#define I2S					0
+
+
+/* I2S_CTRL */
+#define BCLK_IOEN			7
+#define LRCK_IOEN			6
+#define MCLK_IOEN			5
+#define SDO_EN				4
+#define TXEN				2
+#define RXEN				1
+#define GEN					0
+
+/* I2S_BCLK_CTRL */
+#define EDGE_TRANSFER		5
+#define BCLK_POLARITY		4
+#define BCLKDIV				0
+
+/* I2S_LRCK_CTRL1 */
+#define LRCK_POLARITY		4
+#define LRCK_PERIODH		0
+
+/* I2S_LRCK_CTRL2 */
+#define LRCK_PERIODL		0
+
+/* I2S_FMT_CTRL1 */
+#define ENCD_FMT			7
+#define ENCD_SEL			6
+#define MODE_SEL			4
+#define TX_OFFSET			2
+#define TX_SLOT_HIZ			1
+#define TX_STATE			0
+
+/* I2S_FMT_CTRL2 */
+#define SLOT_WIDTH_SEL		4
+#define SAMPLE_RESOLUTION	0
+
+/* I2S_FMT_CTRL3 */
+#define TX_MLS				7
+#define SEXT				5
+#define SDOUT_MUTE			3
+#define LRCK_WIDTH			2
+#define TX_PDM				0
+
+
+/* I2S_TX_CTRL1 */
+#define TX_CHSEL			0
+
+/* I2S_TX_CTRL2 */
+#define TX_CH8_EN			7
+#define TX_CH7_EN			6
+#define TX_CH6_EN			5
+#define TX_CH5_EN			4
+#define TX_CH4_EN			3
+#define TX_CH3_EN			2
+#define TX_CH2_EN			1
+#define TX_CH1_EN			0
+
+/* I2S_TX_CTRL3 */
+#define TX_CH16_EN			7
+#define TX_CH15_EN			6
+#define TX_CH14_EN			5
+#define TX_CH13_EN			4
+#define TX_CH12_EN			3
+#define TX_CH11_EN			2
+#define TX_CH10_EN			1
+#define TX_CH9_EN			0
+
+/*  I2S_TX_CHMP_CTRL1 */
+#define TX_CH8_MAP			7
+#define TX_CH7_MAP			6
+#define TX_CH6_MAP			5
+#define TX_CH5_MAP			4
+#define TX_CH4_MAP			3
+#define TX_CH3_MAP			2
+#define TX_CH2_MAP			1
+#define TX_CH1_MAP			0
+
+/*  I2S_TX_CHMP_CTRL2 */
+#define TX_CH16_MAP			7
+#define TX_CH15_MAP			6
+#define TX_CH14_MAP			5
+#define TX_CH13_MAP			4
+#define TX_CH12_MAP			3
+#define TX_CH11_MAP			2
+#define TX_CH10_MAP			1
+#define TX_CH9_MAP			0
+
+
+/* I2S_RX_CTRL1 */
+#define RX_CHSEL			0
+
+/* I2S_RX_CTRL2 */
+#define RX_CH8_EN			7
+#define RX_CH7_EN			6
+#define RX_CH6_EN			5
+#define RX_CH5_EN			4
+#define RX_CH4_EN			3
+#define RX_CH3_EN			2
+#define RX_CH2_EN			1
+#define RX_CH1_EN			0
+
+/* I2S_RX_CTRL3 */
+#define RX_CH16_EN			7
+#define RX_CH15_EN			6
+#define RX_CH14_EN			5
+#define RX_CH13_EN			4
+#define RX_CH12_EN			3
+#define RX_CH11_EN			2
+#define RX_CH10_EN			1
+#define RX_CH9_EN			0
+
+/*  I2S_RX_CHMP_CTRL1 */
+#define RX_CH8_MAP			7
+#define RX_CH7_MAP			6
+#define RX_CH6_MAP			5
+#define RX_CH5_MAP			4
+#define RX_CH4_MAP			3
+#define RX_CH3_MAP			2
+#define RX_CH2_MAP			1
+#define RX_CH1_MAP			0
+
+/*  I2S_RX_CHMP_CTRL2 */
+#define RX_CH16_MAP			7
+#define RX_CH15_MAP			6
+#define RX_CH14_MAP			5
+#define RX_CH13_MAP			4
+#define RX_CH12_MAP			3
+#define RX_CH11_MAP			2
+#define RX_CH10_MAP			1
+#define RX_CH9_MAP			0
+
+
+/* PDM_CTRL */
+#define PDM_TIMING			1
+#define PDM_EN				0
+
+
+/*ADC_SPRC*/
+#define ADC_FS_I2S			0
+
+/* ADC_DIG_EN */
+#define REQ_WIDTH			4
+#define REQ_EN				3
+#define DG_EN				2
+#define ENAD2				1
+#define ENAD1				0
+
+/* DMIC_EN */
+#define DIG_MIC_EN			0
+
+/* HPF_EN */
+#define DIG_ADC2_HPF_EN		1
+#define DIG_ADC1_HPF_EN		0
+
+/* ADC1_DMIX_SRC */
+#define ADC1_ADC2_DMXL_GC	3
+#define ADC1_ADC1_DMXL_GC	2
+#define ADC1_ADC2_DMXL_SRC	1
+#define ADC1_ADC1_DMXL_SRC	0
+
+/* ADC2_DMIX_SRC */
+#define ADC2_ADC2_DMXL_GC	3
+#define ADC2_ADC1_DMXL_GC	2
+#define ADC2_ADC2_DMXL_SRC	1
+#define ADC2_ADC1_DMXL_SRC	0
+
+
+/* ADC_DIG_DEBUG */
+#define I2S_LPB_DEBUG		3
+#define ADC_PTN_SEL			0
+
+
+/* ADC_ANA_DEBUG1 */
+#define DMIC_CLK_PAD_SEL	4
+#define DMIC_DAT_PAD_SEL	0
+
+/* ADC_ANA_DEBUG2 */
+#define DEV_ID1_PAD_SEL		4
+#define DEV_ID0_PAD_SEL		0
+
+/* I2S_PADDRV_CTRL */
+#define MCLK_DRV			6
+#define BCLK_DRV			4
+#define LRCK_DRV			2
+#define SDOUT_DRV			0
+
+
+/* ANA_ADC1_CTRL1 */
+#define RX1_PGA_OI_CTRL			5
+#define RX1_PGA_AMP_IB_SEL		2
+#define RX1_PGA_IN_VCM_CTRL		0
+
+/* ANA_ADC1_CTRL2 */
+#define RX1_PGA_OI_NM_CTRL		3
+#define RX1_PGA_NMAMP_IB_SEL		0
+
+/* ANA_ADC1_CTRL3 */
+#define RX1_PGA_CTRL_RCM		5
+#define RX1_PGA_GAIN_CTRL		0
+
+/* ANA_ADC1_CTRL4 */
+#define RX1_DSM_OTA_IB_SEL		5
+#define RX1_DSM_COMP_IB_SEL		2
+#define RX1_DSM_OTA_CTRL		0
+
+/* ANA_ADC1_CTRL5 */
+#define RX1_GLOBAL_EN			6
+#define RX1_DSM_DISABLE			5
+#define RX1_DSM_DEMOFF			4
+#define RX1_SEL_OUT_EDGE		3
+#define RX1_DSM_VRP_LPMODE		2
+#define RX1_DSM_VRP_OUTCTRL		0
+
+
+/* ANA_ADC2_CTRL1 */
+#define RX2_PGA_OI_CTRL			5
+#define RX2_PGA_AMP_IB_SEL		2
+#define RX2_PGA_IN_VCM_CTRL		0
+
+/* ANA_ADC2_CTRL2 */
+#define RX2_PGA_OI_NM_CTRL		3
+#define RX2_PGA_NMAMP_IB_SEL		0
+
+/* ANA_ADC2_CTRL3 */
+#define RX2_PGA_CTRL_RCM		5
+#define RX2_PGA_GAIN_CTRL		0
+
+/* ANA_ADC2_CTRL4 */
+#define RX2_DSM_OTA_IB_SEL		5
+#define RX2_DSM_COMP_IB_SEL		2
+#define RX2_DSM_OTA_CTRL		0
+
+/* ANA_ADC2_CTRL5 */
+#define RX2_GLOBAL_EN			6
+#define RX2_DSM_DISABLE			5
+#define RX2_DSM_DEMOFF			4
+#define RX2_SEL_OUT_EDGE		3
+#define RX2_DSM_VRP_LPMODE		2
+#define RX2_DSM_VRP_OUTCTRL		0
+
+
+/* ADC_DITHER_CTRL */
+#define DSM_DITHER_CTRL			4
+#define DSM_DITHER_EN			3
+#define DSM_DITHER_LVL			0
+
+
+
+/*** Some Config Value ***/
+
+//PLLCLK_SRC
+#define PLLCLK_SRC_MCLK			0
+#define PLLCLK_SRC_BCLK			1
+#define PLLCLK_SRC_PDMCLK		2
+
+//SYSCLK_SRC
+#define SYSCLK_SRC_MCLK			0
+#define SYSCLK_SRC_BCLK			1
+#define SYSCLK_SRC_PLL			2
+
+//I2S BCLK POLARITY Control
+#define BCLK_NORMAL_DRIVE_N_SAMPLE_P	0
+#define BCLK_INVERT_DRIVE_P_SAMPLE_N	1
+
+//I2S LRCK POLARITY Control
+#define	LRCK_LEFT_LOW_RIGHT_HIGH		0
+#define LRCK_LEFT_HIGH_RIGHT_LOW		1
+
+//I2S Format Selection
+#define PCM_FORMAT						0
+#define LEFT_JUSTIFIED_FORMAT			1
+#define RIGHT_JUSTIFIED_FORMAT			2
+
+//I2S Sign Extend in slot
+#define ZERO_OR_AUDIIO_GAIN_PADDING_LSB	0
+#define SIGN_EXTENSION_MSB				1
+#define TRANSFER_ZERO_AFTER				3
+
+//ADC Digital Debug Control
+#define ADC_PTN_NORMAL					0
+#define ADC_PTN_0x5A5A5A				1
+#define ADC_PTN_0x123456				2
+#define ADC_PTN_ZERO					3
+#define ADC_PTN_I2S_RX_DATA				4
+
+//ADC PGA GAIN Control
+#define ADC_PGA_GAIN_MINUS_6dB			0
+#define ADC_PGA_GAIN_0dB				1
+#define ADC_PGA_GAIN_3dB				4
+#define ADC_PGA_GAIN_4dB				5
+#define ADC_PGA_GAIN_5dB				6
+#define ADC_PGA_GAIN_6dB				7
+#define ADC_PGA_GAIN_7dB				8
+#define ADC_PGA_GAIN_8dB				9
+#define ADC_PGA_GAIN_9dB				10
+#define ADC_PGA_GAIN_10dB				11
+#define ADC_PGA_GAIN_11dB				12
+#define ADC_PGA_GAIN_12dB				13
+#define ADC_PGA_GAIN_13dB				14
+#define ADC_PGA_GAIN_14dB				15
+#define ADC_PGA_GAIN_15dB				16
+#define ADC_PGA_GAIN_16dB				17
+#define ADC_PGA_GAIN_17dB				18
+#define ADC_PGA_GAIN_18dB				19
+#define ADC_PGA_GAIN_19dB				20
+#define ADC_PGA_GAIN_20dB				21
+#define ADC_PGA_GAIN_21dB				22
+#define ADC_PGA_GAIN_22dB				23
+#define ADC_PGA_GAIN_23dB				24
+#define ADC_PGA_GAIN_24dB				25
+#define ADC_PGA_GAIN_25dB				26
+#define ADC_PGA_GAIN_26dB				27
+#define ADC_PGA_GAIN_27dB				28
+#define ADC_PGA_GAIN_28dB				29
+#define ADC_PGA_GAIN_29dB				30
+#define ADC_PGA_GAIN_30dB				31
+
+
+#endif
+
diff --git a/sound/soc/codecs/ac108.c b/sound/soc/codecs/ac108.c
new file mode 100644
index 000000000..3dd6f322e
--- /dev/null
+++ b/sound/soc/codecs/ac108.c
@@ -0,0 +1,2138 @@
+/*
+ * ac108.c  --	ac108 ALSA Soc Audio driver
+ *
+ * Version: 3.0
+ *
+ * Author: panjunwen
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/firmware.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/regmap.h>
+#include <linux/debugfs.h>
+#include <linux/slab.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/initval.h>
+#include <linux/of.h>
+#include <sound/tlv.h>
+#include <linux/regulator/consumer.h>
+#include <linux/io.h>
+
+#include "ac108.h"
+
+#undef AC108_DEBUG_EN
+#define AC108_PLAYBACK_DEBUG
+
+#ifdef AC108_DEBUG_EN
+#define AC108_DEBUG(...)		pr_err(__VA_ARGS__)
+#else
+#define AC108_DEBUG(...)
+#endif
+
+//test config
+#undef AC108_DAPM_TEST_EN
+#define AC108_CODEC_RW_TEST_EN
+
+//0:ADC normal,  1:0x5A5A5A,  2:0x123456,  3:0x000000,
+//4~7:I2S_RX_DATA,  other:reserved
+#define AC108_ADC_PATTERN_SEL	ADC_PTN_0x5A5A5A
+
+//AC108 config
+#define AC108_NUM_MAX			4
+#define AC108_CHANNELS_MAX		8
+//16bit or 32bit slot width, other value will be reserved
+#define AC108_SLOT_WIDTH		32
+//TX Encoding mode enable
+#define AC108_ENCODING_EN		0
+//TX Encoding channel numbers, must be dual, range[1, 16]
+#define AC108_ENCODING_CH_NUMS		8
+
+//0dB~30dB and -6dB, except 1~2dB
+#define AC108_PGA_GAIN			ADC_PGA_GAIN_28dB
+
+//range[1, 1024], default PCM mode, I2S/LJ/RJ mode shall divide by 2
+//#define AC108_LRCK_PERIOD		(AC108_SLOT_WIDTH * (AC108_ENCODING_EN ? 2 : AC108_CHANNELS_MAX))
+#define AC108_LRCK_PERIOD		((AC108_SLOT_WIDTH * (AC108_ENCODING_EN ? 2 : AC108_CHANNELS_MAX))/2)
+//AC108 SDO2/TX2 Enable (SDO1 has be enabled default)
+#define AC108_SDO2_EN			0
+#define AC108_DMIC_EN			0	//0:ADC	 1:DMIC
+
+/*
+ * maybe waiting the i2c status idle(about 5s).
+ * IDLE_RESET_EN and POWERON_RESET_EN should be defined at the same time.
+ */
+//reset AC108 when in idle time
+#undef AC108_IDLE_RESET_EN
+//AC108 poweron soft reset enable
+#undef AC108_POWERON_RESET_EN
+
+//AC108 match method select: [undef]: i2c_detect, [define]: devices tree
+#define AC108_MATCH_DTS_EN
+#define AC108_REGMAP_EN
+
+#define AC108_REGULATOR_NAME		"regulator_name"
+#define AC108_RATES			(SNDRV_PCM_RATE_8000_96000 | SNDRV_PCM_RATE_KNOT)
+#define AC108_FORMATS			(SNDRV_PCM_FMTBIT_S16_LE | \
+					SNDRV_PCM_FMTBIT_S20_3LE | \
+					SNDRV_PCM_FMTBIT_S24_LE | \
+					SNDRV_PCM_FMTBIT_S32_LE)
+
+struct ac108_public_config ac108_pub_cfg;
+struct i2c_client *i2c_clt[AC108_NUM_MAX];
+
+static const struct regmap_config ac108_regmap_config = {
+	.reg_bits = 8,	//Number of bits in a register address
+	.val_bits = 8,	//Number of bits in a register value
+	.max_register = AC108_REG_MAX,
+	.cache_type = REGCACHE_NONE,
+};
+
+struct real_val_to_reg_val {
+	unsigned int real_val;
+	unsigned int reg_val;
+};
+
+struct pll_div {
+	u32 freq_in;
+	u32 freq_out;
+	u32 m1;
+	u32 m2;
+	u32 n;
+	u32 k1;
+	u32 k2;
+};
+
+static const struct real_val_to_reg_val ac108_sample_rate[] = {
+	{8000,	0},
+	{11025, 1},
+	{12000, 2},
+	{16000, 3},
+	{22050, 4},
+	{24000, 5},
+	{32000, 6},
+	{44100, 7},
+	{48000, 8},
+	{96000, 9},
+};
+
+static const struct real_val_to_reg_val ac108_sample_resolution[] = {
+	{8,  1},
+	{12, 2},
+	{16, 3},
+	{20, 4},
+	{24, 5},
+	{28, 6},
+	{32, 7},
+};
+
+static const struct real_val_to_reg_val ac108_bclk_div[] = {
+	{0,   0},
+	{1,   1},
+	{2,   2},
+	{4,   3},
+	{6,   4},
+	{8,   5},
+	{12,  6},
+	{16,  7},
+	{24,  8},
+	{32,  9},
+	{48,  10},
+	{64,  11},
+	{96,  12},
+	{128, 13},
+	{176, 14},
+	{192, 15},
+};
+
+//FOUT =(FIN * N) / [(M1+1) * (M2+1)*(K1+1)*(K2+1)] ;
+//M1[0,31],  M2[0,1],  N[0,1023],  K1[0,31],  K2[0,1]
+static const struct pll_div ac108_pll_div[] = {
+	{400000,   24576000, 0,  0, 983,  7,  1},	//<out: 24.575M>
+	{512000,   24576000, 0,  0, 960,  9,  1},	//24576000/48
+	{768000,   24576000, 0,  0, 640,  9,  1},	//24576000/32
+	{800000,   24576000, 0,  0, 768,  24, 0},
+	{1024000,  24576000, 0,  0, 480,  9,  1},	//24576000/24
+	{1600000,  24576000, 0,  0, 384,  24, 0},
+	{2048000,  24576000, 0,  0, 240,  9,  1},	//24576000/12
+	{3072000,  24576000, 0,  0, 160,  9,  1},	//24576000/8
+	{4096000,  24576000, 0,  0, 120,  9,  1},	//24576000/6
+	{6000000,  24576000, 4,  0, 512,  24, 0},
+	{12000000, 24576000, 9,  0, 512,  24, 0},
+	{13000000, 24576000, 12, 0, 639,  12, 1},	//<out: 24.577M>
+	{15360000, 24576000, 9,  0, 320,  9,  1},
+	{16000000, 24576000, 9,  0, 384,  24, 0},
+	{19200000, 24576000, 11, 0, 384,  24, 0},
+	{19680000, 24576000, 15, 1, 999,  24, 0},	//<out: 24.575M>
+	{24000000, 24576000, 9,  0, 256,  24, 0},
+
+	{400000,   22579200, 0,  0, 1016, 8,  1},	//<out: 22.5778M>
+	{512000,   22579200, 0,  0, 882,  9,  1},
+	{768000,   22579200, 0,  0, 588,  9,  1},
+	{800000,   22579200, 0,  0, 508,  8,  1},	//<out: 22.5778M>
+	{1024000,  22579200, 0,  0, 441,  9,  1},
+	{1600000,  22579200, 0,  0, 254,  8,  1},	//<out: 22.5778M>
+	{2048000,  22579200, 1,  0, 441,  9,  1},
+	{3072000,  22579200, 2,  0, 441,  9,  1},
+	{4096000,  22579200, 3,  0, 441,  9,  1},
+	{6000000,  22579200, 5,  0, 429,  18, 0},	//<out: 22.5789M>
+	{12000000, 22579200, 11, 0, 429,  18, 0},	//<out: 22.5789M>
+	{13000000, 22579200, 12, 0, 429,  18, 0},	//<out: 22.5789M>
+	{15360000, 22579200, 14, 0, 441,  9,  1},
+	{16000000, 22579200, 24, 0, 882,  24, 0},
+	{19200000, 22579200, 4,  0, 147,  24, 0},
+	{19680000, 22579200, 13, 1, 771,  23, 0},	//<out: 22.5793M>
+	{24000000, 22579200, 24, 0, 588,  24, 0},
+
+	{12288000, 24576000, 9,  0, 400,  9,  1},	//24576000/2
+	{11289600, 22579200, 9,  0, 400,  9,  1},	//22579200/2
+
+	{24576000/1,   24576000, 9,  0, 200, 9, 1},	//24576000
+	{24576000/4,   24576000, 4,  0, 400, 9, 1},	//6144000
+	{24576000/16,  24576000, 0,  0, 320, 9, 1},	//1536000
+	{24576000/64,  24576000, 0,  0, 640, 4, 1},	//384000
+	{24576000/96,  24576000, 0,  0, 960, 4, 1},	//256000
+	{24576000/128, 24576000, 0,  0, 512, 1, 1},	//192000
+	{24576000/176, 24576000, 0,  0, 880, 4, 0},	//140000
+	{24576000/192, 24576000, 0,  0, 960, 4, 0},	//128000
+
+	{22579200/1,   22579200, 9,  0, 200, 9, 1},	//22579200
+	{22579200/4,   22579200, 4,  0, 400, 9, 1},	//5644800
+	{22579200/16,  22579200, 0,  0, 320, 9, 1},	//1411200
+	{22579200/64,  22579200, 0,  0, 640, 4, 1},	//352800
+	{22579200/96,  22579200, 0,  0, 960, 4, 1},	//235200
+	{22579200/128, 22579200, 0,  0, 512, 1, 1},	//176400
+	{22579200/176, 22579200, 0,  0, 880, 4, 0},	//128290
+	{22579200/192, 22579200, 0,  0, 960, 4, 0},	//117600
+
+	{22579200/6,   22579200, 2,  0, 360, 9, 1},	//3763200
+	{22579200/8,   22579200, 0,  0, 160, 9, 1},	//2822400
+	{22579200/12,  22579200, 0,  0, 240, 9, 1},	//1881600
+	{22579200/24,  22579200, 0,  0, 480, 9, 1},	//940800
+	{22579200/32,  22579200, 0,  0, 640, 9, 1},	//705600
+	{22579200/48,  22579200, 0,  0, 960, 9, 1},	//470400
+};
+
+static const DECLARE_TLV_DB_SCALE(adc1_pga_gain_tlv, 0, 100, 0);
+static const DECLARE_TLV_DB_SCALE(adc2_pga_gain_tlv, 0, 100, 0);
+static const DECLARE_TLV_DB_SCALE(adc3_pga_gain_tlv, 0, 100, 0);
+static const DECLARE_TLV_DB_SCALE(adc4_pga_gain_tlv, 0, 100, 0);
+
+static const DECLARE_TLV_DB_SCALE(ch1_digital_vol_tlv, -11925, 75, 0);
+static const DECLARE_TLV_DB_SCALE(ch2_digital_vol_tlv, -11925, 75, 0);
+static const DECLARE_TLV_DB_SCALE(ch3_digital_vol_tlv, -11925, 75, 0);
+static const DECLARE_TLV_DB_SCALE(ch4_digital_vol_tlv, -11925, 75, 0);
+
+static const DECLARE_TLV_DB_SCALE(channel1_ch1_dig_mix_vol_tlv, -600, 600, 0);
+static const DECLARE_TLV_DB_SCALE(channel1_ch2_dig_mix_vol_tlv, -600, 600, 0);
+static const DECLARE_TLV_DB_SCALE(channel1_ch3_dig_mix_vol_tlv, -600, 600, 0);
+static const DECLARE_TLV_DB_SCALE(channel1_ch4_dig_mix_vol_tlv, -600, 600, 0);
+
+static const DECLARE_TLV_DB_SCALE(channel2_ch1_dig_mix_vol_tlv, -600, 600, 0);
+static const DECLARE_TLV_DB_SCALE(channel2_ch2_dig_mix_vol_tlv, -600, 600, 0);
+static const DECLARE_TLV_DB_SCALE(channel2_ch3_dig_mix_vol_tlv, -600, 600, 0);
+static const DECLARE_TLV_DB_SCALE(channel2_ch4_dig_mix_vol_tlv, -600, 600, 0);
+
+static const DECLARE_TLV_DB_SCALE(channel3_ch1_dig_mix_vol_tlv, -600, 600, 0);
+static const DECLARE_TLV_DB_SCALE(channel3_ch2_dig_mix_vol_tlv, -600, 600, 0);
+static const DECLARE_TLV_DB_SCALE(channel3_ch3_dig_mix_vol_tlv, -600, 600, 0);
+static const DECLARE_TLV_DB_SCALE(channel3_ch4_dig_mix_vol_tlv, -600, 600, 0);
+
+static const DECLARE_TLV_DB_SCALE(channel4_ch1_dig_mix_vol_tlv, -600, 600, 0);
+static const DECLARE_TLV_DB_SCALE(channel4_ch2_dig_mix_vol_tlv, -600, 600, 0);
+static const DECLARE_TLV_DB_SCALE(channel4_ch3_dig_mix_vol_tlv, -600, 600, 0);
+static const DECLARE_TLV_DB_SCALE(channel4_ch4_dig_mix_vol_tlv, -600, 600, 0);
+
+//static const DECLARE_TLV_DB_SCALE(adc_pga_gain_tlv,0,100,0);
+//static const DECLARE_TLV_DB_SCALE(digital_vol_tlv,-11925,75,0);
+//static const DECLARE_TLV_DB_SCALE(digital_mix_vol_tlv,-600,600,0);
+
+/******************** General(volume) controls **************************/
+//ac108 common controls
+static const struct snd_kcontrol_new ac108_controls[] = {
+	SOC_SINGLE_TLV("ADC1 PGA gain", ANA_PGA1_CTRL, ADC1_ANALOG_PGA,
+			0x1f, 0, adc1_pga_gain_tlv),
+	SOC_SINGLE_TLV("ADC2 PGA gain", ANA_PGA2_CTRL, ADC2_ANALOG_PGA,
+			0x1f, 0, adc2_pga_gain_tlv),
+	SOC_SINGLE_TLV("ADC3 PGA gain", ANA_PGA3_CTRL, ADC3_ANALOG_PGA,
+			0x1f, 0, adc3_pga_gain_tlv),
+	SOC_SINGLE_TLV("ADC4 PGA gain", ANA_PGA4_CTRL, ADC4_ANALOG_PGA,
+			0x1f, 0, adc4_pga_gain_tlv),
+
+	SOC_SINGLE_TLV("CH1 digital volume", ADC1_DVOL_CTRL, 0, 0xff, 0,
+			ch1_digital_vol_tlv),
+	SOC_SINGLE_TLV("CH2 digital volume", ADC2_DVOL_CTRL, 0, 0xff, 0,
+			ch2_digital_vol_tlv),
+	SOC_SINGLE_TLV("CH3 digital volume", ADC3_DVOL_CTRL, 0, 0xff, 0,
+			ch3_digital_vol_tlv),
+	SOC_SINGLE_TLV("CH4 digital volume", ADC4_DVOL_CTRL, 0, 0xff, 0,
+			ch4_digital_vol_tlv),
+
+	SOC_SINGLE_TLV("CH1 ch1 mixer gain", ADC1_DMIX_SRC, ADC1_ADC1_DMXL_GC,
+			1, 0, channel1_ch1_dig_mix_vol_tlv),
+	SOC_SINGLE_TLV("CH1 ch2 mixer gain", ADC1_DMIX_SRC, ADC1_ADC2_DMXL_GC,
+			1, 0, channel1_ch2_dig_mix_vol_tlv),
+	SOC_SINGLE_TLV("CH1 ch3 mixer gain", ADC1_DMIX_SRC, ADC1_ADC3_DMXL_GC,
+			1, 0, channel1_ch3_dig_mix_vol_tlv),
+	SOC_SINGLE_TLV("CH1 ch4 mixer gain", ADC1_DMIX_SRC, ADC1_ADC4_DMXL_GC,
+			1, 0, channel1_ch4_dig_mix_vol_tlv),
+
+	SOC_SINGLE_TLV("CH2 ch1 mixer gain", ADC2_DMIX_SRC, ADC2_ADC1_DMXL_GC,
+			1, 0, channel2_ch1_dig_mix_vol_tlv),
+	SOC_SINGLE_TLV("CH2 ch2 mixer gain", ADC2_DMIX_SRC, ADC2_ADC2_DMXL_GC,
+			1, 0, channel2_ch2_dig_mix_vol_tlv),
+	SOC_SINGLE_TLV("CH2 ch3 mixer gain", ADC2_DMIX_SRC, ADC2_ADC3_DMXL_GC,
+			1, 0, channel2_ch3_dig_mix_vol_tlv),
+	SOC_SINGLE_TLV("CH2 ch4 mixer gain", ADC2_DMIX_SRC, ADC2_ADC4_DMXL_GC,
+			1, 0, channel2_ch4_dig_mix_vol_tlv),
+
+	SOC_SINGLE_TLV("CH3 ch1 mixer gain", ADC3_DMIX_SRC, ADC3_ADC1_DMXL_GC,
+			1, 0, channel3_ch1_dig_mix_vol_tlv),
+	SOC_SINGLE_TLV("CH3 ch2 mixer gain", ADC3_DMIX_SRC, ADC3_ADC2_DMXL_GC,
+			1, 0, channel3_ch2_dig_mix_vol_tlv),
+	SOC_SINGLE_TLV("CH3 ch3 mixer gain", ADC3_DMIX_SRC, ADC3_ADC3_DMXL_GC,
+			1, 0, channel3_ch3_dig_mix_vol_tlv),
+	SOC_SINGLE_TLV("CH3 ch4 mixer gain", ADC3_DMIX_SRC, ADC3_ADC4_DMXL_GC,
+			1, 0, channel3_ch4_dig_mix_vol_tlv),
+
+	SOC_SINGLE_TLV("CH4 ch1 mixer gain", ADC4_DMIX_SRC, ADC4_ADC1_DMXL_GC,
+			1, 0, channel4_ch1_dig_mix_vol_tlv),
+	SOC_SINGLE_TLV("CH4 ch2 mixer gain", ADC4_DMIX_SRC, ADC4_ADC2_DMXL_GC,
+			1, 0, channel4_ch2_dig_mix_vol_tlv),
+	SOC_SINGLE_TLV("CH4 ch3 mixer gain", ADC4_DMIX_SRC, ADC4_ADC3_DMXL_GC,
+			1, 0, channel4_ch3_dig_mix_vol_tlv),
+	SOC_SINGLE_TLV("CH4 ch4 mixer gain", ADC4_DMIX_SRC, ADC4_ADC4_DMXL_GC,
+			1, 0, channel4_ch4_dig_mix_vol_tlv),
+
+	//SOC_SINGLE_TLV("CH1 mixer gain", ADC1_DMIX_SRC, ADC1_ADC1_DMXL_GC,
+	//		0x0f, 0, digital_mix_vol_tlv),
+	//SOC_SINGLE_TLV("CH2 mixer gain", ADC2_DMIX_SRC, ADC2_ADC1_DMXL_GC,
+	//		0x0f, 0, digital_mix_vol_tlv),
+	//SOC_SINGLE_TLV("CH3 mixer gain", ADC3_DMIX_SRC, ADC3_ADC1_DMXL_GC,
+	//		0x0f, 0, digital_mix_vol_tlv),
+	//SOC_SINGLE_TLV("CH4 mixer gain", ADC4_DMIX_SRC, ADC4_ADC1_DMXL_GC,
+	//		0x0f, 0, digital_mix_vol_tlv),
+};
+
+/*************************** DAPM controls ********************************/
+//ADC12 DMIC1 Source Select Mux
+static const char * const adc12_dmic1_src_mux_text[] = {
+	"ADC12 switch", "DMIC1 switch"
+};
+static const struct soc_enum adc12_dmic1_src_mux_enum =
+	SOC_ENUM_SINGLE(DMIC_EN, DMIC1_EN, 2, adc12_dmic1_src_mux_text);
+static const struct snd_kcontrol_new adc12_dmic1_src_mux =
+	SOC_DAPM_ENUM("ADC12 DMIC1 MUX", adc12_dmic1_src_mux_enum);
+
+//ADC34 DMIC2 Source Select Mux
+static const char * const adc34_dmic2_src_mux_text[] = {
+	"ADC34 switch", "DMIC2 switch"
+};
+static const struct soc_enum adc34_dmic2_src_mux_enum =
+	SOC_ENUM_SINGLE(DMIC_EN, DMIC2_EN, 2, adc34_dmic2_src_mux_text);
+static const struct snd_kcontrol_new adc34_dmic2_src_mux =
+	SOC_DAPM_ENUM("ADC34 DMIC2 MUX", adc34_dmic2_src_mux_enum);
+
+//ADC1 Digital Source Select Mux
+static const char * const adc1_digital_src_mux_text[] = {
+	"ADC1 switch", "ADC2 switch", "ADC3 switch", "ADC4 switch"
+};
+static const struct soc_enum adc1_digital_src_mux_enum =
+	SOC_ENUM_SINGLE(ADC_DSR, DIG_ADC1_SRS, 4, adc1_digital_src_mux_text);
+static const struct snd_kcontrol_new adc1_digital_src_mux =
+	SOC_DAPM_ENUM("ADC1 DIG MUX", adc1_digital_src_mux_enum);
+
+//ADC2 Digital Source Select Mux
+static const char * const adc2_digital_src_mux_text[] = {
+	"ADC1 switch", "ADC2 switch", "ADC3 switch", "ADC4 switch"
+};
+static const struct soc_enum adc2_digital_src_mux_enum =
+	SOC_ENUM_SINGLE(ADC_DSR, DIG_ADC2_SRS, 4, adc2_digital_src_mux_text);
+static const struct snd_kcontrol_new adc2_digital_src_mux =
+	SOC_DAPM_ENUM("ADC2 DIG MUX", adc2_digital_src_mux_enum);
+
+//ADC3 Digital Source Select Mux
+static const char * const adc3_digital_src_mux_text[] = {
+	"ADC1 switch", "ADC2 switch", "ADC3 switch", "ADC4 switch"
+};
+static const struct soc_enum adc3_digital_src_mux_enum =
+	SOC_ENUM_SINGLE(ADC_DSR, DIG_ADC3_SRS, 4, adc3_digital_src_mux_text);
+static const struct snd_kcontrol_new adc3_digital_src_mux =
+	SOC_DAPM_ENUM("ADC3 DIG MUX", adc3_digital_src_mux_enum);
+
+//ADC4 Digital Source Select Mux
+static const char * const adc4_digital_src_mux_text[] = {
+	"ADC1 switch", "ADC2 switch", "ADC3 switch", "ADC4 switch"
+};
+static const struct soc_enum adc4_digital_src_mux_enum =
+	SOC_ENUM_SINGLE(ADC_DSR, DIG_ADC4_SRS, 4, adc4_digital_src_mux_text);
+static const struct snd_kcontrol_new adc4_digital_src_mux =
+	SOC_DAPM_ENUM("ADC4 DIG MUX", adc4_digital_src_mux_enum);
+
+//ADC1 Digital Source Control Mixer
+static const struct snd_kcontrol_new adc1_digital_src_mixer[] = {
+	SOC_DAPM_SINGLE("ADC1 DAT switch", ADC1_DMIX_SRC, ADC1_ADC1_DMXL_SRC, 1, 0),
+	SOC_DAPM_SINGLE("ADC2 DAT switch", ADC1_DMIX_SRC, ADC1_ADC2_DMXL_SRC, 1, 0),
+	SOC_DAPM_SINGLE("ADC3 DAT switch", ADC1_DMIX_SRC, ADC1_ADC3_DMXL_SRC, 1, 0),
+	SOC_DAPM_SINGLE("ADC4 DAT switch", ADC1_DMIX_SRC, ADC1_ADC4_DMXL_SRC, 1, 0),
+};
+
+//ADC2 Digital Source Control Mixer
+static const struct snd_kcontrol_new adc2_digital_src_mixer[] = {
+	SOC_DAPM_SINGLE("ADC1 DAT switch", ADC2_DMIX_SRC, ADC2_ADC1_DMXL_SRC, 1, 0),
+	SOC_DAPM_SINGLE("ADC2 DAT switch", ADC2_DMIX_SRC, ADC2_ADC2_DMXL_SRC, 1, 0),
+	SOC_DAPM_SINGLE("ADC3 DAT switch", ADC2_DMIX_SRC, ADC2_ADC3_DMXL_SRC, 1, 0),
+	SOC_DAPM_SINGLE("ADC4 DAT switch", ADC2_DMIX_SRC, ADC2_ADC4_DMXL_SRC, 1, 0),
+};
+
+//ADC3 Digital Source Control Mixer
+static const struct snd_kcontrol_new adc3_digital_src_mixer[] = {
+	SOC_DAPM_SINGLE("ADC1 DAT switch", ADC3_DMIX_SRC, ADC3_ADC1_DMXL_SRC, 1, 0),
+	SOC_DAPM_SINGLE("ADC2 DAT switch", ADC3_DMIX_SRC, ADC3_ADC2_DMXL_SRC, 1, 0),
+	SOC_DAPM_SINGLE("ADC3 DAT switch", ADC3_DMIX_SRC, ADC3_ADC3_DMXL_SRC, 1, 0),
+	SOC_DAPM_SINGLE("ADC4 DAT switch", ADC3_DMIX_SRC, ADC3_ADC4_DMXL_SRC, 1, 0),
+};
+
+//ADC4 Digital Source Control Mixer
+static const struct snd_kcontrol_new adc4_digital_src_mixer[] = {
+	SOC_DAPM_SINGLE("ADC1 DAT switch", ADC4_DMIX_SRC, ADC4_ADC1_DMXL_SRC, 1, 0),
+	SOC_DAPM_SINGLE("ADC2 DAT switch", ADC4_DMIX_SRC, ADC4_ADC2_DMXL_SRC, 1, 0),
+	SOC_DAPM_SINGLE("ADC3 DAT switch", ADC4_DMIX_SRC, ADC4_ADC3_DMXL_SRC, 1, 0),
+	SOC_DAPM_SINGLE("ADC4 DAT switch", ADC4_DMIX_SRC, ADC4_ADC4_DMXL_SRC, 1, 0),
+};
+
+//I2S TX1 Ch1 Mapping Mux
+static const char *i2s_tx1_ch1_map_mux_text[] = {
+	"ADC1 Sample switch", "ADC2 Sample switch",
+	"ADC3 Sample switch", "ADC4 Sample switch"
+};
+static const struct soc_enum i2s_tx1_ch1_map_mux_enum =
+	SOC_ENUM_SINGLE(I2S_TX1_CHMP_CTRL1, TX1_CH1_MAP, 4, i2s_tx1_ch1_map_mux_text);
+static const struct snd_kcontrol_new i2s_tx1_ch1_map_mux =
+	SOC_DAPM_ENUM("I2S TX1 CH1 MUX", i2s_tx1_ch1_map_mux_enum);
+
+//I2S TX1 Ch2 Mapping Mux
+static const char *i2s_tx1_ch2_map_mux_text[] = {
+	"ADC1 Sample switch", "ADC2 Sample switch",
+	"ADC3 Sample switch", "ADC4 Sample switch"
+};
+static const struct soc_enum i2s_tx1_ch2_map_mux_enum =
+	SOC_ENUM_SINGLE(I2S_TX1_CHMP_CTRL1, TX1_CH2_MAP, 4, i2s_tx1_ch2_map_mux_text);
+static const struct snd_kcontrol_new i2s_tx1_ch2_map_mux =
+	SOC_DAPM_ENUM("I2S TX1 CH2 MUX", i2s_tx1_ch2_map_mux_enum);
+
+//I2S TX1 Ch3 Mapping Mux
+static const char *i2s_tx1_ch3_map_mux_text[] = {
+	"ADC1 Sample switch", "ADC2 Sample switch",
+	"ADC3 Sample switch", "ADC4 Sample switch"
+};
+static const struct soc_enum i2s_tx1_ch3_map_mux_enum =
+	SOC_ENUM_SINGLE(I2S_TX1_CHMP_CTRL1, TX1_CH3_MAP, 4, i2s_tx1_ch3_map_mux_text);
+static const struct snd_kcontrol_new i2s_tx1_ch3_map_mux =
+	SOC_DAPM_ENUM("I2S TX1 CH3 MUX", i2s_tx1_ch3_map_mux_enum);
+
+//I2S TX1 Ch4 Mapping Mux
+static const char *i2s_tx1_ch4_map_mux_text[] = {
+	"ADC1 Sample switch", "ADC2 Sample switch",
+	"ADC3 Sample switch", "ADC4 Sample switch"
+};
+static const struct soc_enum i2s_tx1_ch4_map_mux_enum =
+	SOC_ENUM_SINGLE(I2S_TX1_CHMP_CTRL1, TX1_CH4_MAP, 4, i2s_tx1_ch4_map_mux_text);
+static const struct snd_kcontrol_new i2s_tx1_ch4_map_mux =
+	SOC_DAPM_ENUM("I2S TX1 CH4 MUX", i2s_tx1_ch4_map_mux_enum);
+
+/************************* DAPM widgets **********************************/
+//ac108 dapm widgets
+static const struct snd_soc_dapm_widget ac108_dapm_widgets[] = {
+	//input widgets
+	SND_SOC_DAPM_INPUT("MIC1P"),
+	SND_SOC_DAPM_INPUT("MIC1N"),
+
+	SND_SOC_DAPM_INPUT("MIC2P"),
+	SND_SOC_DAPM_INPUT("MIC2N"),
+
+	SND_SOC_DAPM_INPUT("MIC3P"),
+	SND_SOC_DAPM_INPUT("MIC3N"),
+
+	SND_SOC_DAPM_INPUT("MIC4P"),
+	SND_SOC_DAPM_INPUT("MIC4N"),
+
+	SND_SOC_DAPM_INPUT("DMIC1"),
+	SND_SOC_DAPM_INPUT("DMIC2"),
+
+
+	//MIC PGA
+	SND_SOC_DAPM_PGA("MIC1 PGA", ANA_ADC1_CTRL1, ADC1_PGA_ENABLE, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("MIC2 PGA", ANA_ADC2_CTRL1, ADC2_PGA_ENABLE, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("MIC3 PGA", ANA_ADC3_CTRL1, ADC3_PGA_ENABLE, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("MIC4 PGA", ANA_ADC4_CTRL1, ADC4_PGA_ENABLE, 0, NULL, 0),
+
+	//DMIC PGA
+	SND_SOC_DAPM_PGA("DMIC1L PGA", SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("DMIC1R PGA", SND_SOC_NOPM, 0, 0, NULL, 0),
+
+	SND_SOC_DAPM_PGA("DMIC2L PGA", SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("DMIC2R PGA", SND_SOC_NOPM, 0, 0, NULL, 0),
+
+
+	//ADC1 DIG MUX
+	SND_SOC_DAPM_MUX("ADC1 DIG MUX", ADC_DIG_EN, ENAD1, 0, &adc1_digital_src_mux),
+
+	//ADC2 DIG MUX
+	SND_SOC_DAPM_MUX("ADC2 DIG MUX", ADC_DIG_EN, ENAD2, 0, &adc2_digital_src_mux),
+
+	//ADC3 DIG MUX
+	SND_SOC_DAPM_MUX("ADC3 DIG MUX", ADC_DIG_EN, ENAD3, 0, &adc3_digital_src_mux),
+
+	//ADC4 DIG MUX
+	SND_SOC_DAPM_MUX("ADC4 DIG MUX", ADC_DIG_EN, ENAD4, 0, &adc4_digital_src_mux),
+
+
+	//ADC12 DMIC1 MUX
+	SND_SOC_DAPM_MUX("ADC12 DMIC1 MUX", SND_SOC_NOPM, 0, 0, &adc12_dmic1_src_mux),
+
+	//ADC34 DMIC2 MUX
+	SND_SOC_DAPM_MUX("ADC34 DMIC2 MUX", SND_SOC_NOPM, 0, 0, &adc34_dmic2_src_mux),
+
+
+	//ADC1 VIR PGA
+	SND_SOC_DAPM_PGA("ADC1 VIR PGA", ANA_ADC1_CTRL1, ADC1_DSM_ENABLE, 0, NULL, 0),
+
+	//ADC2 VIR PGA
+	SND_SOC_DAPM_PGA("ADC2 VIR PGA", ANA_ADC2_CTRL1, ADC2_DSM_ENABLE, 0, NULL, 0),
+
+	//ADC3 VIR PGA
+	SND_SOC_DAPM_PGA("ADC3 VIR PGA", ANA_ADC3_CTRL1, ADC3_DSM_ENABLE, 0, NULL, 0),
+
+	//ADC4 VIR PGA
+	SND_SOC_DAPM_PGA("ADC4 VIR PGA", ANA_ADC4_CTRL1, ADC4_DSM_ENABLE, 0, NULL, 0),
+
+
+	//ADC1 DIG MIXER
+	SND_SOC_DAPM_MIXER("ADC1 DIG MIXER", SND_SOC_NOPM, 0, 0,
+		    adc1_digital_src_mixer, ARRAY_SIZE(adc1_digital_src_mixer)),
+
+	//ADC2 DIG MIXER
+	SND_SOC_DAPM_MIXER("ADC2 DIG MIXER", SND_SOC_NOPM, 0, 0,
+		    adc2_digital_src_mixer, ARRAY_SIZE(adc2_digital_src_mixer)),
+
+	//ADC3 DIG MIXER
+	SND_SOC_DAPM_MIXER("ADC3 DIG MIXER", SND_SOC_NOPM, 0, 0,
+		    adc3_digital_src_mixer, ARRAY_SIZE(adc3_digital_src_mixer)),
+
+	//ADC4 DIG MIXER
+	SND_SOC_DAPM_MIXER("ADC4 DIG MIXER", SND_SOC_NOPM, 0, 0,
+		    adc4_digital_src_mixer, ARRAY_SIZE(adc4_digital_src_mixer)),
+
+
+	//I2S TX1 CH1 MUX
+	SND_SOC_DAPM_MUX("I2S TX1 CH1 MUX", SND_SOC_NOPM, 0, 0,
+			&i2s_tx1_ch1_map_mux),
+
+	//I2S TX1 CH2 MUX
+	SND_SOC_DAPM_MUX("I2S TX1 CH2 MUX", SND_SOC_NOPM, 0, 0,
+			&i2s_tx1_ch2_map_mux),
+
+	//I2S TX1 CH3 MUX
+	SND_SOC_DAPM_MUX("I2S TX1 CH3 MUX", SND_SOC_NOPM, 0, 0,
+			&i2s_tx1_ch3_map_mux),
+
+	//I2S TX1 CH4 MUX
+	SND_SOC_DAPM_MUX("I2S TX1 CH4 MUX", SND_SOC_NOPM, 0, 0,
+			&i2s_tx1_ch4_map_mux),
+
+
+	//AIF OUT -> (stream widget, stname must be same with
+	//codec dai_driver stream_name, which will be used to build dai widget)
+	SND_SOC_DAPM_AIF_OUT("AIF ADC OUT", "Capture", 0, SND_SOC_NOPM, 0, 0),
+};
+
+
+/***************************** DAPM routes ********************************/
+//ac108 dapm routes
+static const struct snd_soc_dapm_route ac108_dapm_routes[] = {
+	//MIC
+	{"MIC1 PGA", NULL, "MIC1P"},
+	{"MIC1 PGA", NULL, "MIC1N"},
+
+	{"MIC2 PGA", NULL, "MIC2P"},
+	{"MIC2 PGA", NULL, "MIC2N"},
+
+	{"MIC3 PGA", NULL, "MIC3P"},
+	{"MIC3 PGA", NULL, "MIC3N"},
+
+	{"MIC4 PGA", NULL, "MIC4P"},
+	{"MIC4 PGA", NULL, "MIC4N"},
+
+	//DMIC
+	{"DMIC1L PGA", NULL, "DMIC1"},
+	{"DMIC1R PGA", NULL, "DMIC1"},
+
+	{"DMIC2L PGA", NULL, "DMIC2"},
+	{"DMIC2R PGA", NULL, "DMIC2"},
+
+
+	//ADC1 DIG MUX
+	{"ADC1 DIG MUX", "ADC1 switch", "MIC1 PGA"},
+	{"ADC1 DIG MUX", "ADC2 switch", "MIC2 PGA"},
+	{"ADC1 DIG MUX", "ADC3 switch", "MIC3 PGA"},
+	{"ADC1 DIG MUX", "ADC4 switch", "MIC4 PGA"},
+
+	//ADC2 DIG MUX
+	{"ADC2 DIG MUX", "ADC1 switch", "MIC1 PGA"},
+	{"ADC2 DIG MUX", "ADC2 switch", "MIC2 PGA"},
+	{"ADC2 DIG MUX", "ADC3 switch", "MIC3 PGA"},
+	{"ADC2 DIG MUX", "ADC4 switch", "MIC4 PGA"},
+
+	//ADC3 DIG MUX
+	{"ADC3 DIG MUX", "ADC1 switch", "MIC1 PGA"},
+	{"ADC3 DIG MUX", "ADC2 switch", "MIC2 PGA"},
+	{"ADC3 DIG MUX", "ADC3 switch", "MIC3 PGA"},
+	{"ADC3 DIG MUX", "ADC4 switch", "MIC4 PGA"},
+
+	//ADC4 DIG MUX
+	{"ADC4 DIG MUX", "ADC1 switch", "MIC1 PGA"},
+	{"ADC4 DIG MUX", "ADC2 switch", "MIC2 PGA"},
+	{"ADC4 DIG MUX", "ADC3 switch", "MIC3 PGA"},
+	{"ADC4 DIG MUX", "ADC4 switch", "MIC4 PGA"},
+
+
+	//ADC12 DMIC1 MUX
+	{"ADC12 DMIC1 MUX", "ADC12 switch", "ADC1 DIG MUX"},
+	{"ADC12 DMIC1 MUX", "ADC12 switch", "ADC2 DIG MUX"},
+	{"ADC12 DMIC1 MUX", "DMIC1 switch", "DMIC1L PGA"},
+	{"ADC12 DMIC1 MUX", "DMIC1 switch", "DMIC1R PGA"},
+
+	//ADC34 DMIC2 MUX
+	{"ADC34 DMIC2 MUX", "ADC34 switch", "ADC3 DIG MUX"},
+	{"ADC34 DMIC2 MUX", "ADC34 switch", "ADC4 DIG MUX"},
+	{"ADC34 DMIC2 MUX", "DMIC2 switch", "DMIC2L PGA"},
+	{"ADC34 DMIC2 MUX", "DMIC2 switch", "DMIC2R PGA"},
+
+
+	//ADC1 VIR PGA
+	{"ADC1 VIR PGA", NULL, "ADC12 DMIC1 MUX"},
+
+	//ADC2 VIR PGA
+	{"ADC2 VIR PGA", NULL, "ADC12 DMIC1 MUX"},
+
+	//ADC3 VIR PGA
+	{"ADC3 VIR PGA", NULL, "ADC34 DMIC2 MUX"},
+
+	//ADC4 VIR PGA
+	{"ADC4 VIR PGA", NULL, "ADC34 DMIC2 MUX"},
+
+
+	//ADC1 DIG MIXER
+	{"ADC1 DIG MIXER", "ADC1 DAT switch", "ADC1 VIR PGA"},
+	{"ADC1 DIG MIXER", "ADC2 DAT switch", "ADC2 VIR PGA"},
+	{"ADC1 DIG MIXER", "ADC3 DAT switch", "ADC3 VIR PGA"},
+	{"ADC1 DIG MIXER", "ADC4 DAT switch", "ADC4 VIR PGA"},
+
+	//ADC2 DIG MIXER
+	{"ADC2 DIG MIXER", "ADC1 DAT switch", "ADC1 VIR PGA"},
+	{"ADC2 DIG MIXER", "ADC2 DAT switch", "ADC2 VIR PGA"},
+	{"ADC2 DIG MIXER", "ADC3 DAT switch", "ADC3 VIR PGA"},
+	{"ADC2 DIG MIXER", "ADC4 DAT switch", "ADC4 VIR PGA"},
+
+	//ADC3 DIG MIXER
+	{"ADC3 DIG MIXER", "ADC1 DAT switch", "ADC1 VIR PGA"},
+	{"ADC3 DIG MIXER", "ADC2 DAT switch", "ADC2 VIR PGA"},
+	{"ADC3 DIG MIXER", "ADC3 DAT switch", "ADC3 VIR PGA"},
+	{"ADC3 DIG MIXER", "ADC4 DAT switch", "ADC4 VIR PGA"},
+
+	//ADC4 DIG MIXER
+	{"ADC4 DIG MIXER", "ADC1 DAT switch", "ADC1 VIR PGA"},
+	{"ADC4 DIG MIXER", "ADC2 DAT switch", "ADC2 VIR PGA"},
+	{"ADC4 DIG MIXER", "ADC3 DAT switch", "ADC3 VIR PGA"},
+	{"ADC4 DIG MIXER", "ADC4 DAT switch", "ADC4 VIR PGA"},
+
+
+	//I2S TX1 CH1 MUX
+	{"I2S TX1 CH1 MUX", "ADC1 Sample switch", "ADC1 DIG MIXER"},
+	{"I2S TX1 CH1 MUX", "ADC2 Sample switch", "ADC2 DIG MIXER"},
+	{"I2S TX1 CH1 MUX", "ADC3 Sample switch", "ADC3 DIG MIXER"},
+	{"I2S TX1 CH1 MUX", "ADC4 Sample switch", "ADC4 DIG MIXER"},
+
+	//I2S TX1 CH2 MUX
+	{"I2S TX1 CH2 MUX", "ADC1 Sample switch", "ADC1 DIG MIXER"},
+	{"I2S TX1 CH2 MUX", "ADC2 Sample switch", "ADC2 DIG MIXER"},
+	{"I2S TX1 CH2 MUX", "ADC3 Sample switch", "ADC3 DIG MIXER"},
+	{"I2S TX1 CH2 MUX", "ADC4 Sample switch", "ADC4 DIG MIXER"},
+
+	//I2S TX1 CH3 MUX
+	{"I2S TX1 CH3 MUX", "ADC1 Sample switch", "ADC1 DIG MIXER"},
+	{"I2S TX1 CH3 MUX", "ADC2 Sample switch", "ADC2 DIG MIXER"},
+	{"I2S TX1 CH3 MUX", "ADC3 Sample switch", "ADC3 DIG MIXER"},
+	{"I2S TX1 CH3 MUX", "ADC4 Sample switch", "ADC4 DIG MIXER"},
+
+	//I2S TX1 CH4 MUX
+	{"I2S TX1 CH4 MUX", "ADC1 Sample switch", "ADC1 DIG MIXER"},
+	{"I2S TX1 CH4 MUX", "ADC2 Sample switch", "ADC2 DIG MIXER"},
+	{"I2S TX1 CH4 MUX", "ADC3 Sample switch", "ADC3 DIG MIXER"},
+	{"I2S TX1 CH4 MUX", "ADC4 Sample switch", "ADC4 DIG MIXER"},
+
+
+	//AIF OUT
+	{"AIF ADC OUT", NULL, "I2S TX1 CH1 MUX"},
+	{"AIF ADC OUT", NULL, "I2S TX1 CH2 MUX"},
+	{"AIF ADC OUT", NULL, "I2S TX1 CH3 MUX"},
+	{"AIF ADC OUT", NULL, "I2S TX1 CH4 MUX"},
+};
+
+
+static int ac108_read(u8 reg, u8 *rt_value, struct i2c_client *client)
+{
+#ifdef AC108_REGMAP_EN
+	unsigned int tmp, ret;
+	struct ac108_priv *ac108 = dev_get_drvdata(&client->dev);
+
+	ret = regmap_read(ac108->regmap, (unsigned int)reg, &tmp);
+	*rt_value = (u8)tmp;
+	return ret;
+#else
+	int ret;
+	u8 read_cmd[3] = {0};
+	u8 cmd_len = 0;
+
+	read_cmd[0] = reg;
+	cmd_len = 1;
+
+	if (client->adapter == NULL)
+		pr_err("ac108_read client->adapter==NULL\n");
+
+	ret = i2c_master_send(client, read_cmd, cmd_len);
+	if (ret != cmd_len) {
+		pr_err("ac108_read error1\n");
+		return -1;
+	}
+
+	ret = i2c_master_recv(client, rt_value, 1);
+	if (ret != 1) {
+		pr_err("ac108_read error2, ret = %d.\n", ret);
+		return -1;
+	}
+
+	return 0;
+#endif
+}
+
+static int ac108_write(u8 reg, unsigned char value, struct i2c_client *client)
+{
+#ifdef AC108_REGMAP_EN
+	struct ac108_priv *ac108 = dev_get_drvdata(&client->dev);
+	return regmap_write(ac108->regmap, (unsigned int)reg, (unsigned int)value);
+#else
+	int ret = 0;
+	u8 write_cmd[2] = {0};
+
+	write_cmd[0] = reg;
+	write_cmd[1] = value;
+
+	ret = i2c_master_send(client, write_cmd, 2);
+	if (ret != 2) {
+		pr_err("ac108_write error->[REG-0x%02x,val-0x%02x]\n", reg, value);
+		return -1;
+	}
+
+	return 0;
+#endif
+}
+
+static int ac108_update_bits(u8 reg, u8 mask, u8 value,
+			struct i2c_client *client)
+{
+	u8 val_old = 0;
+	u8 val_new = 0;
+
+	ac108_read(reg, &val_old, client);
+	val_new = (val_old & ~mask) | (value & mask);
+	if (val_new != val_old)
+		ac108_write(reg, val_new, client);
+
+	return 0;
+}
+
+#if 0
+static int ac108_multi_chips_read(u8 reg, unsigned char *rt_value)
+{
+	u8 i;
+
+	for (i = 0; i < ac108_pub_cfg.ac108_nums; i++)
+		ac108_read(reg, rt_value++, i2c_clt[i]);
+
+	return 0;
+}
+#endif
+
+#ifdef AC108_IDLE_RESET_EN
+static int ac108_multi_chips_write(u8 reg, unsigned char value)
+{
+	u8 i;
+
+	for (i = 0; i < ac108_pub_cfg.ac108_nums; i++)
+		ac108_write(reg, value, i2c_clt[i]);
+
+	return 0;
+}
+#endif
+
+static int ac108_multi_chips_update_bits(u8 reg, u8 mask, u8 value)
+{
+	u8 i;
+
+	for (i = 0; i < ac108_pub_cfg.ac108_nums; i++)
+		ac108_update_bits(reg, mask, value, i2c_clt[i]);
+
+	return 0;
+}
+
+static void ac108_set_pga_gain(struct i2c_client *i2c)
+{
+	struct ac108_priv *ac108 = dev_get_drvdata(&i2c->dev);
+	u32 i;
+
+	if (ac108->ref_cfg.ref_pga.used) {
+		dev_info(&i2c->dev, "ref_cfg.ref_channel:0x%x, set ref_pga_gain:%d\n",
+			 ac108->ref_cfg.ref_channel, ac108->ref_cfg.ref_pga.val);
+		/* set the gain for referenced channels, always used for aec */
+		for (i = 0; i < 4; i++) {
+			if ((ac108->ref_cfg.ref_channel >> i) & 0x1) {
+				ac108_write(ANA_PGA1_CTRL + i,
+					ac108->ref_cfg.ref_pga.val << 0x1, i2c);
+			} else
+				ac108_write(ANA_PGA1_CTRL + i, ac108->pga_gain << 0x1, i2c);
+		}
+	} else {
+		for (i = 0; i < 4; i++)
+			ac108_write(ANA_PGA1_CTRL + i, ac108->pga_gain, i2c);
+	}
+}
+
+static void ac108_hw_init(struct i2c_client *i2c)
+{
+	struct ac108_priv *ac108 = dev_get_drvdata(&i2c->dev);
+
+	/*** Chip reset ***/
+	/*0x00=0x12: reset all registers to their default state*/
+	//ac108_write(CHIP_AUDIO_RST, 0x12, i2c);
+
+#if !AC108_DMIC_EN
+	/*** Analog voltage enable ***/
+	/*0x06=0x01: Enable Analog LDO*/
+	ac108_write(PWR_CTRL6, 0x01, i2c);
+	/*
+	 * 0x07=0x9b: VREF faststart Enable,
+	 * Enable VREF @ 3.4V (5V) or 3.1V (3.3V)
+	 * (needed for Analog LDO and MICBIAS)
+	 */
+	ac108_write(PWR_CTRL7, 0x9b, i2c);
+	/*
+	 * 0x09=0x81: VREFP faststart Enable, Enable VREFP_FASTSTART_ENABLE
+	 * (needed by all audio input channels)
+	 */
+	ac108_write(PWR_CTRL9, 0x81, i2c);
+	/*
+	 * DSM low power mode enable, Control bias current for
+	 * DSM integrator opamps
+	 */
+	ac108_write(ANA_ADC3_CTRL7, 0x0b, i2c);
+#endif
+	/*** SYSCLK Config ***/
+	/*SYSCLK Enable*/
+	ac108_update_bits(SYSCLK_CTRL, 0x1 << SYSCLK_EN, 0x1 << SYSCLK_EN, i2c);
+	/*
+	 * 0x21=0x93: Module clock enable<I2S, ADC digital,
+	 * MIC offset Calibration, ADC analog>
+	 */
+	ac108_write(MOD_CLK_EN, 0x93, i2c);
+	/*
+	 * 0x22=0x93: Module reset de-asserted
+	 * <I2S, ADC digital, MIC offset Calibration, ADC analog>
+	 */
+	ac108_write(MOD_RST_CTRL, 0x93, i2c);
+	/*** I2S Common Config ***/
+	/*SDO1 enable, SDO2 Enable*/
+	ac108_update_bits(I2S_CTRL, ((0x1 << SDO1_EN) | (0x1 << SDO2_EN)),
+			((0x1 << SDO1_EN) | (!!AC108_SDO2_EN << SDO2_EN)), i2c);
+	/*SDO drive data and SDI sample data at the different BCLK edge*/
+	ac108_update_bits(I2S_BCLK_CTRL, (0x1 << EDGE_TRANSFER),
+			(0x0 << EDGE_TRANSFER), i2c);
+	ac108_update_bits(I2S_LRCK_CTRL1, 0x3 << LRCK_PERIODH,
+			(((ac108->lrck_period - 1) >> 8) << LRCK_PERIODH), i2c);
+
+	/*
+	 * config LRCK period:
+	 * 16bit * 8ch = 128,
+	 * 32bit * 8ch = 256,
+	 * 32bit *16ch = 512
+	 */
+	ac108_write(I2S_LRCK_CTRL2, (ac108->lrck_period - 1) & 0xFF, i2c);
+	/*
+	 * Encoding mode enable, Turn to hi-z state (TDM)
+	 * when not transferring slot
+	 */
+	ac108_update_bits(I2S_FMT_CTRL1,
+		0x1 << ENCD_SEL | 0x1 << TX_SLOT_HIZ | 0x1 << TX_STATE,
+		!!AC108_ENCODING_EN << ENCD_SEL | 0x0 << TX_SLOT_HIZ | 0x1 << TX_STATE, i2c);
+	/* 8/12/16/20/24/28/32bit Slot Width */
+	ac108_update_bits(I2S_FMT_CTRL2, 0x7 << SLOT_WIDTH_SEL,
+			(ac108->slot_width / 4 - 1) << SLOT_WIDTH_SEL, i2c);
+	/*
+	 * 0x36=0x70: TX MSB first, TX2 Mute, Transfer 0 after
+	 * each sample in each slot(sample resolution < slot width),
+	 * LRCK = 1 BCLK width (short frame), Linear PCM Data Mode
+	 */
+	ac108_write(I2S_FMT_CTRL3, AC108_SDO2_EN ? 0x60 : 0x70, i2c);
+
+	/*0x3C=0xe4: TX1 CHn Map to CHn adc sample, n=[1,4]*/
+	ac108_write(I2S_TX1_CHMP_CTRL1, 0xe4, i2c);
+	/*0x3D=0xe4: TX1 CHn Map to CH(n-4) adc sample, n=[5,8]*/
+	ac108_write(I2S_TX1_CHMP_CTRL2, 0xe4, i2c);
+	/*0x3E=0xe4: TX1 CHn Map to CH(n-8) adc sample, n=[9,12]*/
+	ac108_write(I2S_TX1_CHMP_CTRL3, 0xe4, i2c);
+	/*0x3F=0xe4: TX1 CHn Map to CH(n-12) adc sample, n=[13,16]*/
+	ac108_write(I2S_TX1_CHMP_CTRL4, 0xe4, i2c);
+
+#if AC108_SDO2_EN
+	/*
+	 * 0x44=0x4e: TX2 CH1/2 Map to CH3/4 adc sample,
+	 * TX2 CH3/4 Map to CH1/2 adc sample
+	 */
+	ac108_write(I2S_TX2_CHMP_CTRL1, 0x4e, i2c);
+	/*0x45=0xe4: TX2 CHn Map to CH(n-4) adc sample, n=[5,8]*/
+	ac108_write(I2S_TX2_CHMP_CTRL2, 0xe4, i2c);
+	/*0x46=0xe4: TX2 CHn Map to CH(n-8) adc sample, n=[9,12]*/
+	ac108_write(I2S_TX2_CHMP_CTRL3, 0xe4, i2c);
+	/*0x47=0xe4: TX2 CHn Map to CH(n-12) adc sample, n=[13,16]*/
+	ac108_write(I2S_TX2_CHMP_CTRL4, 0xe4, i2c);
+#endif
+
+	/*** ADC DIG part Config***/
+	/*0x60=0x03: ADC Sample Rate 16KHz*/
+	//ac108_write(ADC_SPRC, 0x03, i2c);
+	/*0x61=0x1f: Digital part globe enable, ADCs digital part enable*/
+	ac108_write(ADC_DIG_EN, 0x1f, i2c);
+	/*0xBB=0x0f: Gating ADCs CLK de-asserted (ADCs CLK Enable)*/
+	ac108_write(ANA_ADC4_CTRL7, 0x0f, i2c);
+
+	if (ac108->debug_mode) {
+		/*0x66=0x00: Digital ADCs channel HPF disable*/
+		ac108_write(HPF_EN, 0x00, i2c);
+	}
+	/*
+	 * 0X7F=0x00: ADC pattern select: 0:ADC normal, 1:0x5A5A5A,
+	 * 2:0x123456, 3:0x00, 4~7:I2S RX data
+	 */
+	ac108_write(ADC_DIG_DEBUG, ac108->debug_mode & 0x7, i2c);
+
+#if !AC108_DMIC_EN
+	/*** ADCs analog PGA gain Config***/
+	ac108_set_pga_gain(i2c);
+
+	/*** enable AAF/ADC/PGA  and UnMute Config ***/
+	/*
+	 * 0xA0=0x07: ADC1 AAF & ADC enable, ADC1 PGA enable,
+	 * ADC1 MICBIAS enable and UnMute
+	 */
+	ac108_write(ANA_ADC1_CTRL1, 0x07, i2c);
+	/*
+	 * 0xA7=0x07: ADC2 AAF & ADC enable, ADC2 PGA enable,
+	 * ADC2 MICBIAS enable and UnMute
+	 */
+	ac108_write(ANA_ADC2_CTRL1, 0x07, i2c);
+	/*
+	 * 0xAE=0x07: ADC3 AAF & ADC enable, ADC3 PGA enable,
+	 * ADC3 MICBIAS enable and UnMute
+	 */
+	ac108_write(ANA_ADC3_CTRL1, 0x07, i2c);
+	/*
+	 * 0xB5=0x07: ADC4 AAF & ADC enable, ADC4 PGA enable,
+	 * ADC4 MICBIAS enable and UnMute
+	 */
+	ac108_write(ANA_ADC4_CTRL1, 0x07, i2c);
+
+	/*
+	 * delay 50ms to let VREF/VRP faststart powerup stable,
+	 * then disable faststart
+	 */
+	msleep(50);
+	/* VREF faststart disable */
+	ac108_update_bits(PWR_CTRL7, 0x1 << VREF_FASTSTART_ENABLE,
+			0x0 << VREF_FASTSTART_ENABLE, i2c);
+	/*VREFP faststart disable*/
+	ac108_update_bits(PWR_CTRL9, 0x1 << VREFP_FASTSTART_ENABLE,
+			0x0 << VREFP_FASTSTART_ENABLE, i2c);
+#else
+	/*** DMIC module Enable ***/
+	/*DMIC1/2 Enable, while ADC DIG source select DMIC1/2*/
+	ac108_write(DMIC_EN, 0x03, i2c);
+	/*GPIO1 as DMIC1_DAT, GPIO2 as DMIC_CLK*/
+	ac108_write(GPIO_CFG1, 0xee, i2c);
+	/*GPIO3 as DMIC2_DAT*/
+	ac108_write(GPIO_CFG2, 0x7e, i2c);
+#endif
+}
+
+static int ac108_set_sysclk(struct snd_soc_dai *dai, int clk_id,
+			unsigned int freq, int dir)
+{
+	switch (clk_id) {
+	case SYSCLK_SRC_MCLK:
+		AC108_DEBUG("AC108 SYSCLK source select MCLK\n\n");
+		//System Clock Source Select MCLK
+		ac108_multi_chips_update_bits(SYSCLK_CTRL, 0x1 << SYSCLK_SRC,
+					0x0 << SYSCLK_SRC);
+	break;
+	case SYSCLK_SRC_PLL:
+		AC108_DEBUG("AC108 SYSCLK source select PLL\n\n");
+		//System Clock Source Select PLL
+		ac108_multi_chips_update_bits(SYSCLK_CTRL, 0x1 << SYSCLK_SRC,
+					0x1 << SYSCLK_SRC);
+	break;
+	default:
+		pr_err("AC108 SYSCLK source config error:%d\n\n", clk_id);
+	return -EINVAL;
+	}
+
+	//SYSCLK Enable
+	ac108_multi_chips_update_bits(SYSCLK_CTRL, 0x1<<SYSCLK_EN,
+					0x1<<SYSCLK_EN);
+	return 0;
+}
+
+static int ac108_set_pll(struct snd_soc_dai *dai, int pll_id, int source,
+			unsigned int freq_in, unsigned int freq_out)
+{
+	u32 i = 0;
+	u32 m1 = 0;
+	u32 m2 = 0;
+	u32 n = 0;
+	u32 k1 = 0;
+	u32 k2 = 0;
+
+	if (!freq_out)
+		return 0;
+
+	if (freq_in < 128000 || freq_in > 24576000) {
+		pr_err("AC108 PLLCLK source input freq only support [128K,24M],while now %u\n\n", freq_in);
+		return -EINVAL;
+	} else if ((freq_in == 24576000 || freq_in == 22579200) &&
+		pll_id == SYSCLK_SRC_MCLK) {
+		//System Clock Source Select MCLK, SYSCLK Enable
+		AC108_DEBUG("AC108 don't need to use PLL\n\n");
+		ac108_multi_chips_update_bits(SYSCLK_CTRL,
+				0x1 << SYSCLK_SRC | 0x1 << SYSCLK_EN,
+				0x0 << SYSCLK_SRC | 0x1 << SYSCLK_EN);
+		return 0;	//Don't need to use PLL
+	}
+
+	//PLL Clock Source Select
+	switch (pll_id) {
+	case PLLCLK_SRC_MCLK:
+		AC108_DEBUG("AC108 PLLCLK input source select MCLK\n");
+		ac108_multi_chips_update_bits(SYSCLK_CTRL, 0x3 << PLLCLK_SRC,
+					0x0 << PLLCLK_SRC);
+	break;
+	case PLLCLK_SRC_BCLK:
+		AC108_DEBUG("AC108 PLLCLK input source select BCLK\n");
+		ac108_multi_chips_update_bits(SYSCLK_CTRL, 0x3 << PLLCLK_SRC,
+					0x1 << PLLCLK_SRC);
+	break;
+	case PLLCLK_SRC_GPIO2:
+		AC108_DEBUG("AC108 PLLCLK input source select GPIO2\n");
+		ac108_multi_chips_update_bits(SYSCLK_CTRL, 0x3 << PLLCLK_SRC,
+					0x2 << PLLCLK_SRC);
+	break;
+	case PLLCLK_SRC_GPIO3:
+		AC108_DEBUG("AC108 PLLCLK input source select GPIO3\n");
+		ac108_multi_chips_update_bits(SYSCLK_CTRL, 0x3 << PLLCLK_SRC,
+					0x3 << PLLCLK_SRC);
+	break;
+	default:
+		pr_err("AC108 PLLCLK source config error:%d\n\n", pll_id);
+	return -EINVAL;
+	}
+
+	//FOUT =(FIN * N) / [(M1+1) * (M2+1)*(K1+1)*(K2+1)] ;
+	for (i = 0; i < ARRAY_SIZE(ac108_pll_div); i++) {
+		if (ac108_pll_div[i].freq_in == freq_in &&
+			ac108_pll_div[i].freq_out == freq_out) {
+			m1 = ac108_pll_div[i].m1;
+			m2 = ac108_pll_div[i].m2;
+			n = ac108_pll_div[i].n;
+			k1 = ac108_pll_div[i].k1;
+			k2 = ac108_pll_div[i].k2;
+			AC108_DEBUG("AC108 PLL freq_in match:%u, freq_out:%u\n\n",
+				freq_in, freq_out);
+			break;
+		}
+	}
+
+	if (i == ARRAY_SIZE(ac108_pll_div)) {
+		pr_err("AC108 don't match PLLCLK freq_in and freq_out table\n\n");
+		return -EINVAL;
+	}
+
+	//Config PLL DIV param M1/M2/N/K1/K2
+	ac108_multi_chips_update_bits(PLL_CTRL2,
+			0x1f << PLL_PREDIV1 | 0x1 << PLL_PREDIV2,
+			m1 << PLL_PREDIV1 | m2 << PLL_PREDIV2);
+	ac108_multi_chips_update_bits(PLL_CTRL3, 0x3 << PLL_LOOPDIV_MSB,
+				(n >> 8) << PLL_LOOPDIV_MSB);
+	ac108_multi_chips_update_bits(PLL_CTRL4, 0xff << PLL_LOOPDIV_LSB,
+				(u8)n << PLL_LOOPDIV_LSB);
+	ac108_multi_chips_update_bits(PLL_CTRL5,
+				(0x1f << PLL_POSTDIV1) | (0x1 << PLL_POSTDIV2),
+				k1 << PLL_POSTDIV1 | (k2 << PLL_POSTDIV2));
+
+	//Config PLL module current
+	//ac108_multi_chips_update_bits(PLL_CTRL1, 0x7<<PLL_IBIAS, 0x4<<PLL_IBIAS);
+	//ac108_multi_chips_update_bits(PLL_CTRL6, 0x1f<<PLL_CP, 0xf<<PLL_CP);
+
+	//PLL module enable
+	//PLL CLK lock enable
+	ac108_multi_chips_update_bits(PLL_LOCK_CTRL, 0x1 << PLL_LOCK_EN,
+				0x1 << PLL_LOCK_EN);
+	//PLL Common voltage Enable, PLL Enable
+	//ac108_multi_chips_update_bits(PLL_CTRL1,
+	//			0x1 << PLL_EN | 0x1 << PLL_COM_EN,
+	//			0x1<<PLL_EN | 0x1<<PLL_COM_EN);
+
+	//PLLCLK Enable, SYSCLK Enable
+	//0x1<<SYSCLK_SRC
+	ac108_multi_chips_update_bits(SYSCLK_CTRL,
+				0x1 << PLLCLK_EN | 0x1 << SYSCLK_EN,
+				0x1 << PLLCLK_EN | 0x1 << SYSCLK_EN);
+
+	return 0;
+}
+
+static int ac108_set_clkdiv(struct snd_soc_dai *dai, int div_id, int div)
+{
+	struct ac108_priv *ac108 = dev_get_drvdata(dai->dev);
+	u32 i = 0;
+	u32 bclk_div = 0;
+	u32 bclk_div_reg_val = 0;
+
+	if (!div_id) {
+		/*
+		 * use div_id to judge Master/Slave mode,
+		 * 0: Slave mode, 1: Master mode
+		 */
+		AC108_DEBUG("AC108 work as Slave mode, don't need to config BCLK_DIV\n\n");
+		return 0;
+	}
+
+	//default PCM mode
+	bclk_div = div / ac108->lrck_period;
+	//bclk_div = div/(2*AC108_LRCK_PERIOD);	//I2S/LJ/RJ mode
+
+	for (i = 0; i < ARRAY_SIZE(ac108_bclk_div); i++) {
+		if (ac108_bclk_div[i].real_val == bclk_div) {
+			bclk_div_reg_val = ac108_bclk_div[i].reg_val;
+			AC108_DEBUG("AC108 set BCLK_DIV_[%u]\n\n", bclk_div);
+			break;
+		}
+	}
+
+	if (i == ARRAY_SIZE(ac108_bclk_div)) {
+		pr_err("AC108 don't support BCLK_DIV_[%u]\n\n", bclk_div);
+		return -EINVAL;
+	}
+
+	//AC108 set BCLK DIV
+	ac108_multi_chips_update_bits(I2S_BCLK_CTRL, 0xf << BCLKDIV,
+				bclk_div_reg_val << BCLKDIV);
+	return 0;
+}
+
+static int ac108_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+{
+	u8 i = 0;
+	u8 tx_offset = 0;
+	u8 i2s_mode = 0;
+	u8 lrck_polarity = 0;
+	u8 brck_polarity = 0;
+	struct ac108_priv *ac108 = dev_get_drvdata(dai->dev);
+
+	//AC108 config Master/Slave mode
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:	//AC108 Master
+		AC108_DEBUG("AC108 set to work as Master\n");
+		//BCLK & LRCK output
+		ac108_update_bits(I2S_CTRL, 0x3 << LRCK_IOEN,
+				0x3 << LRCK_IOEN, ac108->i2c);
+	break;
+	case SND_SOC_DAIFMT_CBS_CFS:	//AC108 Slave
+		AC108_DEBUG("AC108 set to work as Slave\n");
+		//BCLK & LRCK input
+		ac108_update_bits(I2S_CTRL, 0x3 << LRCK_IOEN,
+				0x0<<LRCK_IOEN, ac108->i2c);
+	break;
+	default:
+		pr_err("AC108 Master/Slave mode config error:%u\n\n",
+			(fmt & SND_SOC_DAIFMT_MASTER_MASK) >> 12);
+	return -EINVAL;
+	}
+
+	for (i = 0; i < ac108_pub_cfg.ac108_nums; i++) {
+		/*
+		 * multi_chips: only one chip set as Master,
+		 * and the others also need to set as Slave
+		 */
+		if (i2c_clt[i] == ac108->i2c)
+			continue;
+		ac108_update_bits(I2S_CTRL, 0x3 << LRCK_IOEN,
+				0x0 << LRCK_IOEN, i2c_clt[i]);
+	}
+
+	//AC108 config I2S/LJ/RJ/PCM format
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		AC108_DEBUG("AC108 config I2S format\n");
+		i2s_mode = LEFT_JUSTIFIED_FORMAT;
+		tx_offset = 1;
+	break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		AC108_DEBUG("AC108 config RIGHT-JUSTIFIED format\n");
+		i2s_mode = RIGHT_JUSTIFIED_FORMAT;
+		tx_offset = 0;
+	break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		AC108_DEBUG("AC108 config LEFT-JUSTIFIED format\n");
+		i2s_mode = LEFT_JUSTIFIED_FORMAT;
+		tx_offset = 0;
+	break;
+	case SND_SOC_DAIFMT_DSP_A:
+		AC108_DEBUG("AC108 config PCM-A format\n");
+		i2s_mode = PCM_FORMAT;
+		tx_offset = 1;
+	break;
+	case SND_SOC_DAIFMT_DSP_B:
+		AC108_DEBUG("AC108 config PCM-B format\n");
+		i2s_mode = PCM_FORMAT;
+		tx_offset = 0;
+	break;
+	default:
+		pr_err("AC108 I2S format config error:%u\n\n",
+			fmt & SND_SOC_DAIFMT_FORMAT_MASK);
+	return -EINVAL;
+	}
+	ac108_multi_chips_update_bits(I2S_FMT_CTRL1,
+		0x3 << MODE_SEL | 0x1 << TX2_OFFSET | 0x1 << TX1_OFFSET,
+		i2s_mode<<MODE_SEL | tx_offset<<TX2_OFFSET | tx_offset << TX1_OFFSET);
+
+	//AC108 config BCLK&LRCK polarity
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		AC108_DEBUG("AC108 config BCLK&LRCK polarity: BCLK_normal,LRCK_normal\n");
+		brck_polarity = BCLK_NORMAL_DRIVE_N_SAMPLE_P;
+		lrck_polarity = LRCK_LEFT_LOW_RIGHT_HIGH;
+	break;
+	case SND_SOC_DAIFMT_NB_IF:
+		AC108_DEBUG("AC108 config BCLK&LRCK polarity: BCLK_normal,LRCK_invert\n");
+		brck_polarity = BCLK_NORMAL_DRIVE_N_SAMPLE_P;
+		lrck_polarity = LRCK_LEFT_HIGH_RIGHT_LOW;
+	break;
+	case SND_SOC_DAIFMT_IB_NF:
+		AC108_DEBUG("AC108 config BCLK&LRCK polarity: BCLK_invert,LRCK_normal\n");
+		brck_polarity = BCLK_INVERT_DRIVE_P_SAMPLE_N;
+		lrck_polarity = LRCK_LEFT_LOW_RIGHT_HIGH;
+	break;
+	case SND_SOC_DAIFMT_IB_IF:
+		AC108_DEBUG("AC108 config BCLK&LRCK polarity: BCLK_invert,LRCK_invert\n");
+		brck_polarity = BCLK_INVERT_DRIVE_P_SAMPLE_N;
+		lrck_polarity = LRCK_LEFT_HIGH_RIGHT_LOW;
+		break;
+	default:
+		pr_err("AC108 config BCLK/LRCLK polarity error:%u\n\n",
+			(fmt & SND_SOC_DAIFMT_INV_MASK) >> 8);
+	return -EINVAL;
+	}
+	ac108_multi_chips_update_bits(I2S_BCLK_CTRL,  0x1<<BCLK_POLARITY,
+				brck_polarity << BCLK_POLARITY);
+	ac108_multi_chips_update_bits(I2S_LRCK_CTRL1, 0x1<<LRCK_POLARITY,
+				lrck_polarity << LRCK_POLARITY);
+
+	return 0;
+}
+
+static int ac108_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	u8 reg_val = 0;
+	u16 i = 0;
+	u16 channels = 0;
+	u16 channels_en = 0;
+	u16 sample_resolution = 0;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		AC108_DEBUG("AC108 not need playback.\n");
+		return 0;
+	}
+
+	//FIXME:AC108 hw init
+	for (i = 0; i < ac108_pub_cfg.ac108_nums; i++)
+		ac108_hw_init(i2c_clt[i]);
+
+	//AC108 set sample rate
+	for (i = 0; i < ARRAY_SIZE(ac108_sample_rate); i++) {
+		if (ac108_sample_rate[i].real_val ==
+			params_rate(params) / (AC108_ENCODING_EN ? AC108_ENCODING_CH_NUMS / 2 : 1)) {
+			ac108_multi_chips_update_bits(ADC_SPRC,
+				0xf << ADC_FS_I2S1,
+				ac108_sample_rate[i].reg_val << ADC_FS_I2S1);
+			break;
+		}
+	}
+
+	//AC108 set channels
+#if !AC108_SDO2_EN
+	channels = params_channels(params) *
+			(AC108_ENCODING_EN ? AC108_ENCODING_CH_NUMS/2 : 1);
+	for (i = 0; i < (channels + 3) / 4; i++) {
+		channels_en = (channels >= 4 * (i + 1)) ? 0x000f << (4 * i) :
+				((1 << (channels % 4)) - 1) << (4 * i);
+		ac108_write(I2S_TX1_CTRL1, channels - 1, i2c_clt[i]);
+		ac108_write(I2S_TX1_CTRL2, (u8)channels_en, i2c_clt[i]);
+		ac108_write(I2S_TX1_CTRL3, channels_en >> 8, i2c_clt[i]);
+	}
+
+	for (; i < ac108_pub_cfg.ac108_nums; i++) {
+		ac108_write(I2S_TX1_CTRL1, 0, i2c_clt[i]);
+		ac108_write(I2S_TX1_CTRL2, 0, i2c_clt[i]);
+		ac108_write(I2S_TX1_CTRL3, 0, i2c_clt[i]);
+	}
+#else
+	channels = params_channels(params);
+	for (i = 0; i < (channels + 3) / 4; i++) {
+		//(2 >= 4*(i+1)) ? 0x000f<<(4*i) : ((1<<(2%4))-1)<<(4*i);
+		channels_en = 0x03;
+		ac108_write(I2S_TX1_CTRL1, 2 - 1, i2c_clt[i]);
+		ac108_write(I2S_TX1_CTRL2, (u8)channels_en, i2c_clt[i]);
+		ac108_write(I2S_TX1_CTRL3, channels_en >> 8, i2c_clt[i]);
+	}
+	for (; i < ac108_pub_cfg.ac108_nums; i++) {
+		ac108_write(I2S_TX1_CTRL1, 0, i2c_clt[i]);
+		ac108_write(I2S_TX1_CTRL2, 0, i2c_clt[i]);
+		ac108_write(I2S_TX1_CTRL3, 0, i2c_clt[i]);
+	}
+
+	for (i = 0; i < (channels + 3) / 4; i++) {
+		//(2 >= 4*(i+1)) ? 0x000f<<(4*i) : ((1<<(2%4))-1)<<(4*i);
+		channels_en = 0x03;
+		ac108_write(I2S_TX2_CTRL1, 2 - 1, i2c_clt[i]);
+		ac108_write(I2S_TX2_CTRL2, (u8)channels_en, i2c_clt[i]);
+		ac108_write(I2S_TX2_CTRL3, channels_en >> 8, i2c_clt[i]);
+	}
+	for (; i < ac108_pub_cfg.ac108_nums; i++) {
+		ac108_write(I2S_TX2_CTRL1, 0, i2c_clt[i]);
+		ac108_write(I2S_TX2_CTRL2, 0, i2c_clt[i]);
+		ac108_write(I2S_TX2_CTRL3, 0, i2c_clt[i]);
+	}
+#endif
+
+	//AC108 set sample resorution
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S8:
+		sample_resolution = 8;
+	break;
+	case SNDRV_PCM_FORMAT_S16_LE:
+		sample_resolution = 16;
+	break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+		sample_resolution = 20;
+	break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		sample_resolution = 24;
+	break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		sample_resolution = 32;
+	break;
+	default:
+		dev_err(dai->dev, "AC108 don't supported the sample resolution: %u\n",
+			params_format(params));
+	return -EINVAL;
+	}
+
+#if 0
+	//AC108_ENCODING_EN
+	//TX Encoding mode, SR add 4bits to mark channel number
+	if ((sample_resolution <= 24) && (sample_resolution != 16))
+		sample_resolution += 4;
+#endif
+	for (i = 0; i < ARRAY_SIZE(ac108_sample_resolution); i++) {
+		if (ac108_sample_resolution[i].real_val == sample_resolution) {
+			ac108_multi_chips_update_bits(I2S_FMT_CTRL2,
+				0x7 << SAMPLE_RESOLUTION,
+				ac108_sample_resolution[i].reg_val << SAMPLE_RESOLUTION);
+			break;
+		}
+	}
+
+	ac108_read(SYSCLK_CTRL, &reg_val, i2c_clt[0]);
+	if (reg_val & 0x80) {
+		//PLLCLK Enable
+		//PLL Common voltage Enable, PLL Enable
+		ac108_multi_chips_update_bits(PLL_CTRL1,
+				0x1 << PLL_EN | 0x1<<PLL_COM_EN,
+				0x1 << PLL_EN | 0x1<<PLL_COM_EN);
+		if (!(reg_val & 0x08)) {
+			//SYSCLK select MCLK
+			//GPIO4 output Clock 24MHz from DPLL
+			ac108_multi_chips_update_bits(GPIO_CFG2,
+				0xf << GPIO4_SELECT, 0x9 << GPIO4_SELECT);
+		}
+	}
+
+	//AC108 TX enable, Globle enable
+	ac108_multi_chips_update_bits(I2S_CTRL, 0x1 << TXEN | 0x1 << GEN,
+				0x1 << TXEN | 0x1 << GEN);
+
+	return 0;
+}
+
+static int ac108_hw_free(struct snd_pcm_substream *substream,
+			struct snd_soc_dai *dai)
+{
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		AC108_DEBUG("AC108 not need playback.\n");
+		return 0;
+	}
+
+	//AC108 I2S Globle disable
+	ac108_multi_chips_update_bits(I2S_CTRL, 0x1 << GEN, 0x0 << GEN);
+
+#ifdef AC108_IDLE_RESET_EN
+	AC108_DEBUG("AC108 reset all register to their default value\n");
+	ac108_multi_chips_write(CHIP_AUDIO_RST, 0x12);
+#else
+	//repair PLL version no sync problem && Encoding no DAT
+	ac108_multi_chips_update_bits(PLL_CTRL1,
+				0x1 << PLL_EN | 0x1 << PLL_COM_EN,
+				0x0 << PLL_EN | 0x0 << PLL_COM_EN);
+	ac108_multi_chips_update_bits(MOD_CLK_EN,
+				0x1 << I2S | 0x1 << ADC_DIGITAL,
+				0x0 << I2S | 0x0 << ADC_DIGITAL);
+	ac108_multi_chips_update_bits(MOD_RST_CTRL,
+				0x1 << I2S | 0x1 << ADC_DIGITAL,
+				0x0 << I2S | 0x0 << ADC_DIGITAL);
+#endif
+
+	return 0;
+}
+
+
+/*** define  ac108  dai_ops  struct ***/
+static const struct snd_soc_dai_ops ac108_dai_ops = {
+	/*DAI clocking configuration*/
+	.set_sysclk = ac108_set_sysclk,
+	.set_pll = ac108_set_pll,
+	.set_clkdiv = ac108_set_clkdiv,
+
+	/*ALSA PCM audio operations*/
+	.hw_params = ac108_hw_params,
+	.hw_free = ac108_hw_free,
+
+	/*DAI format configuration*/
+	.set_fmt = ac108_set_fmt,
+};
+
+/*** define  ac108  dai_driver struct ***/
+static struct snd_soc_dai_driver ac108_dai0 = {
+	.name = "ac108-pcm0",
+#ifdef AC108_PLAYBACK_DEBUG
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 1,
+		.channels_max = (AC108_NUM_MAX * 4),
+		.rates = AC108_RATES,
+		.formats = AC108_FORMATS,
+	},
+#endif
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = (AC108_NUM_MAX * 4),
+		.rates = AC108_RATES,
+		.formats = AC108_FORMATS,
+	},
+	.ops = &ac108_dai_ops,
+};
+
+static struct snd_soc_dai_driver ac108_dai1 = {
+	.name = "ac108-pcm1",
+#ifdef AC108_PLAYBACK_DEBUG
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 1,
+		.channels_max = (AC108_NUM_MAX * 4),
+		.rates = AC108_RATES,
+		.formats = AC108_FORMATS,
+	},
+#endif
+
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = (AC108_NUM_MAX * 4),
+		.rates = AC108_RATES,
+		.formats = AC108_FORMATS,
+	},
+	.ops = &ac108_dai_ops,
+};
+
+static struct snd_soc_dai_driver ac108_dai2 = {
+	.name = "ac108-pcm2",
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = (AC108_NUM_MAX * 4),
+		.rates = AC108_RATES,
+		.formats = AC108_FORMATS,
+	},
+	.ops = &ac108_dai_ops,
+};
+
+static struct snd_soc_dai_driver ac108_dai3 = {
+	.name = "ac108-pcm3",
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = (AC108_NUM_MAX * 4),
+		.rates = AC108_RATES,
+		.formats = AC108_FORMATS,
+	},
+	.ops = &ac108_dai_ops,
+};
+
+static struct snd_soc_dai_driver *ac108_dai[] = {
+	&ac108_dai0,
+	&ac108_dai1,
+	&ac108_dai2,
+	&ac108_dai3,
+};
+
+static int ac108_probe(struct snd_soc_component *codec)
+{
+	struct ac108_priv *ac108 = dev_get_drvdata(codec->dev);
+
+	ac108->codec = codec;
+
+#ifdef AC108_DAPM_TEST_EN
+	struct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);
+	int ret = 0;
+
+	/* Add virtual switch */
+	ret = snd_soc_add_codec_controls(codec, ac108_controls,
+					ARRAY_SIZE(ac108_controls));
+	if (ret < 0) {
+		dev_err(codec->dev, "Failed to register ac108 control, will continue without it.\n");
+	}
+	snd_soc_dapm_new_controls(dapm, ac108_dapm_widgets, ARRAY_SIZE(ac108_dapm_widgets));
+	snd_soc_dapm_add_routes(dapm, ac108_dapm_routes, ARRAY_SIZE(ac108_dapm_routes));
+#endif
+
+	return 0;
+}
+
+static void ac108_remove(struct snd_soc_component *component)
+{
+	return;
+}
+
+#ifdef CONFIG_PM
+static int ac108_suspend(struct snd_soc_component *codec)
+{
+#ifdef AC108_MATCH_DTS_EN
+	struct ac108_priv *ac108 = dev_get_drvdata(codec->dev);
+
+	/* FIXME: only support one power control */
+	if (ac108->reset_gpio.used)
+		gpio_set_value(ac108->reset_gpio.gpio, 0);
+	if (ac108->power_gpio.used)
+		gpio_set_value(ac108->power_gpio.gpio, 0);
+	if (ac108->vol_supply.used)
+		regulator_disable(ac108->vol_supply.regulator);
+#endif
+
+	return 0;
+}
+
+static int ac108_resume(struct snd_soc_component *codec)
+{
+#ifndef AC108_IDLE_RESET_EN
+	u8 i;
+#endif
+
+#ifdef AC108_MATCH_DTS_EN
+	struct ac108_priv *ac108 = dev_get_drvdata(codec->dev);
+	struct i2c_client *i2c = ac108->i2c;
+	int ret;
+
+	/* FIXME: only support one power control */
+	if (ac108->vol_supply.used) {
+		ret = regulator_enable(ac108->vol_supply.regulator);
+		if (ret < 0) {
+			dev_err(&i2c->dev, "fail to enable regulator %s!\n",
+				ac108->vol_supply.name);
+		}
+	}
+
+	if (ac108->power_gpio.used) {
+		gpio_set_value(ac108->power_gpio.gpio, 1);
+		msleep(20);
+	}
+
+	if (ac108->reset_gpio.used) {
+		gpio_set_value(ac108->reset_gpio.gpio, 1);
+		msleep(20);
+	}
+#endif
+
+#ifndef AC108_IDLE_RESET_EN
+	for (i = 0; i < ac108_pub_cfg.ac108_nums; i++)
+		ac108_hw_init(i2c_clt[i]);
+#endif
+
+	return 0;
+}
+
+#else
+
+#define ac108_suspend NULL
+#define ac108_resume  NULL
+
+#endif
+
+#ifdef AC108_CODEC_RW_TEST_EN
+static unsigned int ac108_codec_read(struct snd_soc_component *codec,
+				unsigned int reg)
+{
+	unsigned int reg_val;
+	struct ac108_priv *ac108 = dev_get_drvdata(codec->dev);
+
+	regmap_read(ac108->regmap, reg, &reg_val);
+	return reg_val;
+}
+
+static int ac108_codec_write(struct snd_soc_component *codec, unsigned int reg,
+			unsigned int value)
+{
+	struct ac108_priv *ac108 = dev_get_drvdata(codec->dev);
+
+	regmap_write(ac108->regmap, reg & 0xFF, value & 0xFF);
+	return 0;
+}
+#endif
+
+/*** define  ac108  codec_driver struct ***/
+static const struct snd_soc_component_driver ac108_soc_codec_driver = {
+	.probe = ac108_probe,
+	.remove = ac108_remove,
+	.suspend = ac108_suspend,
+	.resume = ac108_resume,
+#ifdef AC108_CODEC_RW_TEST_EN
+	.read = ac108_codec_read,
+	.write = ac108_codec_write,
+#endif
+};
+
+
+static ssize_t ac108_reg_store(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	struct ac108_priv *ac108 = dev_get_drvdata(dev);
+	int ret = 0;
+	unsigned int input_reg_offset = 0;
+	unsigned int input_val = 0;
+	unsigned int reg_val_read = 0;
+	unsigned int rw_flag = 0;
+
+	ret = sscanf(buf, "%d,0x%x,0x%x", &rw_flag, &input_reg_offset, &input_val);
+
+	if (ret == 3) {
+		if (!(rw_flag == 1 || rw_flag == 0)) {
+			dev_err(dev, "rw_flag should be 0(read) or 1(write).\n");
+			return count;
+		}
+		input_reg_offset &= 0xFF;
+		input_val &= 0xFF;
+		if ((input_reg_offset > AC108_REG_MAX) ||
+			((input_reg_offset + input_val) > AC108_REG_MAX)) {
+				dev_err(dev, "reg_dump addr[0x%02x] + count[0x%02x] > AC108_REG_MAX.\n",
+					ac108->reg_dump_offset,
+					ac108->reg_dump_count);
+				return count;
+			}
+		if (input_reg_offset > AC108_REG_MAX) {
+			pr_err("the reg offset is invalid! [0x0 - 0x%x]\n",
+				AC108_REG_MAX);
+			return count;
+		}
+		if (rw_flag) {
+			regmap_write(ac108->regmap, input_reg_offset, input_val);
+			regmap_read(ac108->regmap, input_reg_offset, &reg_val_read);
+			pr_err("\n Reg[0x%x] : 0x%x\n", input_reg_offset, reg_val_read);
+			return count;
+		} else {
+			ac108->reg_dump_offset = input_reg_offset;
+			ac108->reg_dump_count = input_val;
+		}
+	} else {
+		pr_err("ret:%d, The num of params invalid!\n", ret);
+		pr_err("\nExample(reg range: 0x0 - 0x%x):\n", AC108_REG_MAX);
+		pr_err("\nRead reg start[0x04]; reg count:0x10:\n");
+		pr_err("      echo 0,0x04,0x10 > ac108_reg\n");
+		pr_err("Write reg[0x04]=0x10\n");
+		pr_err("      echo 1,0x04,0x10 > ac108_reg\n");
+	}
+
+	return count;
+}
+
+static ssize_t ac108_reg_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	ssize_t count = 0;
+	unsigned int i = 0;
+	unsigned int reg_val_read = 0;
+	struct ac108_priv *ac108 = dev_get_drvdata(dev);
+
+	count += snprintf(buf, PAGE_SIZE, "\n/*** AC108 driver version: V3.0 ***/\n\n");
+
+	if (!ac108->reg_dump_count) {
+		count += snprintf(buf + count, PAGE_SIZE - count,
+			"echo flag(Hex),reg(Hex),val(Hex) > ac108\n");
+		count += snprintf(buf + count, PAGE_SIZE - count,
+			"eg: read start addres=0x06, count=0x10;\n");
+		count += snprintf(buf + count, PAGE_SIZE - count,
+			"[command] echo 0,0x6,0x10 > ac108\n");
+		count += snprintf(buf + count, PAGE_SIZE - count,
+			"eg: write start addres=0x90, value=0x3c;\n");
+		count += snprintf(buf + count, PAGE_SIZE - count,
+			"[command] echo 1,0x90,0x3c > ac108\n");
+	} else {
+		do {
+			reg_val_read = 0;
+			if (count >= PAGE_SIZE) {
+				dev_err(dev, "char count:%ld >= PAGE_SIZE.\n", (long)count);
+				return count;
+			}
+			regmap_read(ac108->regmap, ac108->reg_dump_offset + i,
+					&reg_val_read);
+			count += snprintf(buf + count, PAGE_SIZE - count,
+					"[0x%02x]: 0x%02x;  ",
+					ac108->reg_dump_offset + i,
+					reg_val_read);
+			i++;
+			if ((i == ac108->reg_dump_count) || (i % 4 == 0)) {
+				if (count >= PAGE_SIZE) {
+					dev_err(dev, "char count:%ld >= PAGE_SIZE.\n", (long)count);
+					return count;
+				}
+				count += snprintf(buf + count, PAGE_SIZE - count, "\n");
+			}
+		} while (i < ac108->reg_dump_count);
+	}
+	return count;
+}
+
+static DEVICE_ATTR(ac108_reg, 0644, ac108_reg_show, ac108_reg_store);
+
+static struct attribute *ac108_debug_attrs[] = {
+	&dev_attr_ac108_reg.attr,
+	NULL,
+};
+
+static struct attribute_group ac108_debug_attr_group = {
+	.name	= "ac108_debug",
+	.attrs	= ac108_debug_attrs,
+};
+
+static int ac108_i2c_probe(struct i2c_client *i2c,
+			const struct i2c_device_id *i2c_id)
+{
+	struct ac108_priv *ac108 = NULL;
+	int ret = 0;
+#ifdef AC108_MATCH_DTS_EN
+	enum of_gpio_flags gpio_flags;
+	unsigned int temp_val = 0;
+	struct device_node *np = i2c->dev.of_node;
+#endif
+
+	ac108 = devm_kzalloc(&i2c->dev, sizeof(struct ac108_priv), GFP_KERNEL);
+	if (IS_ERR_OR_NULL(ac108)) {
+		dev_err(&i2c->dev, "Unable to allocate ac108 private data\n");
+		return -ENOMEM;
+	}
+
+	ac108->i2c = i2c;
+	dev_set_drvdata(&i2c->dev, ac108);
+
+	ac108->regmap = devm_regmap_init_i2c(ac108->i2c, &ac108_regmap_config);
+	if (IS_ERR_OR_NULL(ac108->regmap)) {
+		dev_err(&i2c->dev, "Failed to set cache I/O.\n");
+		goto err_devm_regmap_i2c;
+	}
+
+#ifdef AC108_MATCH_DTS_EN
+	ret = of_property_read_u32(np, "regulator_used", &temp_val);
+	if (ret < 0) {
+		dev_err(&i2c->dev, "get regulator_used failed.\n");
+		ac108->vol_supply.used = 0x0;
+	} else
+		ac108->vol_supply.used = temp_val;
+
+	/* FIXME: only support one power */
+	if (ac108->vol_supply.used) {
+		ret = of_property_read_u32(np, "power_voltage",
+						&ac108->vol_supply.voltage);
+		if (ret < 0) {
+			dev_err(&i2c->dev, "get ac108 regulator vol failed!\n");
+			goto err_property_get_power_vol;
+		}
+		/* should fix the vol for the chip */
+		if (ac108->vol_supply.voltage > 5000000)
+			ac108->vol_supply.voltage = 5000000;
+		if (ac108->vol_supply.voltage < 1800000)
+			ac108->vol_supply.voltage = 1800000;
+		dev_warn(&i2c->dev, "ac108 regulator vol is:%d\n",
+			ac108->vol_supply.voltage);
+
+		ret = of_property_read_string(np, AC108_REGULATOR_NAME,
+				&ac108->vol_supply.name);
+		if (ret < 0) {
+			dev_err(&i2c->dev, "get ac108 regulator name failed\n");
+			goto err_regulator_get_name;
+		} else {
+			ac108->vol_supply.regulator = regulator_get(NULL, ac108->vol_supply.name);
+			if (IS_ERR_OR_NULL(ac108->vol_supply.regulator)) {
+				dev_err(&i2c->dev, "get ac108 regulator failed!\n");
+				goto err_regulator_get;
+			}
+			ret = regulator_set_voltage(ac108->vol_supply.regulator,
+						ac108->vol_supply.voltage,
+						ac108->vol_supply.voltage);
+			if (ret < 0) {
+				dev_err(&i2c->dev, "set ac108 voltage failed!\n");
+				goto err_regulator_set_voltage;
+			}
+			ret = regulator_enable(ac108->vol_supply.regulator);
+			if (ret < 0) {
+				dev_err(&i2c->dev, "fail to enable regulator %s.\n",
+					ac108->vol_supply.name);
+				goto err_regulator_enable;
+			}
+		}
+	}
+
+	ret = of_property_read_u32(np, "power_gpio_used", &temp_val);
+	if (ret < 0) {
+		dev_err(&i2c->dev, "get power_gpio_used failed.\n");
+		ac108->power_gpio.used = 0x0;
+	} else
+		ac108->power_gpio.used = temp_val;
+
+	if (ac108->power_gpio.used) {
+		ac108->power_gpio.gpio = of_get_named_gpio_flags(np,
+					     "power-gpio", 0, &gpio_flags);
+		if (!gpio_is_valid(ac108->power_gpio.gpio)) {
+			dev_err(&i2c->dev, "power_gpio is invalid.\n");
+			goto err_power_gpio_invalid;
+		}
+		ret = gpio_request(ac108->power_gpio.gpio, "ac108 power gpio");
+		if (ret < 0) {
+			dev_err(&i2c->dev, "power_gpio request failed.\n");
+			goto err_power_gpio_request;
+		}
+		gpio_direction_output(ac108->power_gpio.gpio, 1);
+		gpio_set_value(ac108->power_gpio.gpio, 1);
+		msleep(20);
+	}
+
+	ret = of_property_read_u32(np, "reset_gpio_used", &temp_val);
+	if (ret < 0) {
+		dev_err(&i2c->dev, "get reset_gpio_used failed.\n");
+		ac108->reset_gpio.used = 0x0;
+	} else
+		ac108->reset_gpio.used = temp_val;
+
+	if (ac108->reset_gpio.used) {
+		ac108->reset_gpio.gpio = of_get_named_gpio_flags(np,
+					     "reset-gpio", 0, &gpio_flags);
+		if (!gpio_is_valid(ac108->reset_gpio.gpio)) {
+			dev_err(&i2c->dev, "reset_gpio is invalid.\n");
+			goto err_reset_gpio_invalid;
+		}
+		ret = gpio_request(ac108->reset_gpio.gpio, "ac108 reset gpio");
+		if (ret < 0) {
+			dev_err(&i2c->dev, "reset_gpio request failed.\n");
+			goto err_reset_gpio_request;
+		}
+		gpio_direction_output(ac108->reset_gpio.gpio, 1);
+		gpio_set_value(ac108->reset_gpio.gpio, 1);
+		msleep(20);
+	}
+
+	ret = of_property_read_u32(np, "twi_bus", &temp_val);
+	if (ret < 0) {
+		dev_err(&i2c->dev, "get twi_bus failed.\n");
+		goto err_get_twi_bus;
+	} else
+		ac108->twi_bus = temp_val;
+
+	ret = of_property_read_u32(np, "pga_gain", &temp_val);
+	if (ret < 0) {
+		dev_err(&i2c->dev, "get pga_gain failed.\n");
+		ac108->pga_gain = AC108_PGA_GAIN;
+	} else
+		ac108->pga_gain = temp_val;
+
+	ret = of_property_read_u32(np, "ref_pga_used", &temp_val);
+	if (ret < 0) {
+		dev_err(&i2c->dev, "get ref_pga_used failed.\n");
+		ac108->ref_cfg.ref_pga.used = 0x0;
+	} else
+		ac108->ref_cfg.ref_pga.used = temp_val;
+
+	if (ac108->ref_cfg.ref_pga.used) {
+		ret = of_property_read_u32(np, "ref_pga_gain", &temp_val);
+		if (ret < 0) {
+			dev_err(&i2c->dev, "get ref_pga_gain failed.\n");
+			ac108->ref_cfg.ref_pga.val = 0x08;
+		} else
+			ac108->ref_cfg.ref_pga.val = temp_val;
+
+		ret = of_property_read_u32(np, "ref_channel", &temp_val);
+		if (ret < 0) {
+			dev_err(&i2c->dev, "get reference channel failed.\n");
+			ac108->ref_cfg.ref_channel = 0x0;
+		} else
+			ac108->ref_cfg.ref_channel = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "lrck_period", &temp_val);
+	if (ret < 0) {
+		dev_err(&i2c->dev, "get lrck_period failed.\n");
+		ac108->lrck_period = AC108_LRCK_PERIOD;
+	} else
+		ac108->lrck_period = temp_val;
+
+	ret = of_property_read_u32(np, "slot_width", &temp_val);
+	if (ret < 0) {
+		dev_err(&i2c->dev, "get slot_width failed.\n");
+		ac108->slot_width = AC108_SLOT_WIDTH;
+	} else
+		ac108->slot_width = temp_val;
+
+	ret = of_property_read_u32(np, "debug_mode", &temp_val);
+	if (ret < 0) {
+		dev_err(&i2c->dev, "get debug_mode failed.\n");
+		ac108->debug_mode = AC108_ADC_PATTERN_SEL;
+	} else
+		ac108->debug_mode = temp_val;
+#else
+	ac108->lrck_period = AC108_LRCK_PERIOD;
+	ac108->slot_width = AC108_SLOT_WIDTH;
+	ac108->debug_mode = AC108_ADC_PATTERN_SEL;
+#endif
+
+	ac108_pub_cfg.ac108_nums++;
+
+	if (i2c_id->driver_data < AC108_NUM_MAX) {
+		i2c_clt[i2c_id->driver_data] = i2c;
+		ret = devm_snd_soc_register_component(&i2c->dev, &ac108_soc_codec_driver,
+				ac108_dai[i2c_id->driver_data], 1);
+		if (ret < 0) {
+			dev_err(&i2c->dev, "Failed to register ac108 codec: %d\n", ret);
+			goto err_register_codec;
+		}
+#ifdef AC108_POWERON_RESET_EN
+		ac108_write(CHIP_AUDIO_RST, 0x12, i2c);
+#endif
+#ifndef AC108_IDLE_RESET_EN
+		ac108_hw_init(i2c);
+#endif
+	} else {
+		pr_err("The wrong i2c_id number :%d\n",
+			(int)(i2c_id->driver_data));
+		goto err_i2c_driver_data;
+	}
+	ret = sysfs_create_group(&i2c->dev.kobj, &ac108_debug_attr_group);
+	if (ret < 0) {
+		pr_err("failed to create attr group\n");
+		goto err_sysfs_create_group;
+	}
+
+	dev_warn(&i2c->dev, "i2c probe succeed.\n");
+
+	return 0;
+
+err_sysfs_create_group:
+err_register_codec:
+err_i2c_driver_data:
+#ifdef AC108_MATCH_DTS_EN
+err_get_twi_bus:
+	if (ac108->reset_gpio.used)
+		gpio_free(ac108->reset_gpio.gpio);
+err_reset_gpio_request:
+err_reset_gpio_invalid:
+	if (ac108->power_gpio.used)
+		gpio_free(ac108->power_gpio.gpio);
+err_power_gpio_request:
+err_power_gpio_invalid:
+	if (ac108->vol_supply.used)
+		regulator_disable(ac108->vol_supply.regulator);
+err_regulator_enable:
+err_regulator_set_voltage:
+	if (ac108->vol_supply.used)
+		regulator_put(ac108->vol_supply.regulator);
+err_regulator_get:
+err_regulator_get_name:
+err_property_get_power_vol:
+#endif
+err_devm_regmap_i2c:
+	devm_kfree(&i2c->dev, ac108);
+	return ret;
+}
+
+static int ac108_i2c_remove(struct i2c_client *i2c)
+{
+	struct ac108_priv *ac108 = dev_get_drvdata(&i2c->dev);
+	unsigned int i = 0;
+
+	sysfs_remove_group(&i2c->dev.kobj, &ac108_debug_attr_group);
+
+	for (i = 0; i < AC108_NUM_MAX; i++) {
+		if (i2c_clt[i] == i2c)
+			i2c_clt[i] = NULL;
+	}
+	ac108_pub_cfg.ac108_nums--;
+#ifdef AC108_MATCH_DTS_EN
+	if (ac108->reset_gpio.used)
+		gpio_free(ac108->reset_gpio.gpio);
+	if (ac108->power_gpio.used)
+		gpio_free(ac108->power_gpio.gpio);
+	if (ac108->vol_supply.used)
+		regulator_disable(ac108->vol_supply.regulator);
+	if (ac108->vol_supply.used)
+		regulator_put(ac108->vol_supply.regulator);
+#endif
+	devm_kfree(&i2c->dev, ac108);
+	return 0;
+}
+
+#ifndef AC108_MATCH_DTS_EN
+//I2C devices register method_3: i2c_detect
+static int ac108_i2c_detect(struct i2c_client *client,
+			struct i2c_board_info *info)
+{
+	u8 ac108_chip_id;
+	struct i2c_adapter *adapter = client->adapter;
+
+	ac108_read(CHIP_AUDIO_RST, &ac108_chip_id, client);
+	pr_alert("\nAC108_Chip_ID on I2C-%d:0x%02X\n",
+			adapter->nr, ac108_chip_id);
+
+	if (ac108_chip_id == 0x4A) {
+		if (client->addr == 0x3b) {
+			strlcpy(info->type, "MicArray_0", I2C_NAME_SIZE);
+			return 0;
+		} else if (client->addr == 0x35) {
+			strlcpy(info->type, "MicArray_1", I2C_NAME_SIZE);
+			return 0;
+		} else if (client->addr == 0x3c) {
+			strlcpy(info->type, "MicArray_2", I2C_NAME_SIZE);
+			return 0;
+		} else if (client->addr == 0x36) {
+			strlcpy(info->type, "MicArray_3", I2C_NAME_SIZE);
+			return 0;
+		}
+	}
+
+	return -ENODEV;
+}
+
+//I2C devices address used in register method_3
+static const unsigned short ac108_i2c_addr[] = {
+	0x3b,
+	0x35,
+	0x3c,
+	0x36,
+	I2C_CLIENT_END,
+};
+#endif
+
+//I2C devices register method_1: i2c_board_info (i2c_register_board_info)
+//I2C devices register method_2: device tree source (in .dts file)
+static const struct i2c_board_info ac108_i2c_board_info[] = {
+	{I2C_BOARD_INFO("MicArray_0", 0x3b),},//ac108_0
+	{I2C_BOARD_INFO("MicArray_1", 0x35),},//ac108_1
+	{I2C_BOARD_INFO("MicArray_2", 0x3c),},//ac108_2
+	{I2C_BOARD_INFO("MicArray_3", 0x36),},//ac108_3
+};
+
+//I2C driver and devices match method_1: i2c_device_id
+static const struct i2c_device_id ac108_i2c_id[] = {
+	{ "MicArray_0", 0 },//ac108_0
+	{ "MicArray_1", 1 },//ac108_1
+	{ "MicArray_2", 2 },//ac108_2
+	{ "MicArray_3", 3 },//ac108_3
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, ac108_i2c_id);
+
+#ifdef AC108_MATCH_DTS_EN
+//I2C driver and devices match method_2: of_device_id (devices tree)
+static const struct of_device_id ac108_dt_ids[] = {
+	//ac108_0
+	{ .compatible = "Allwinner,MicArray_0", },
+	//ac108_1
+	{ .compatible = "Allwinner,MicArray_1", },
+	//ac108_2
+	{ .compatible = "Allwinner,MicArray_2", },
+	//ac108_3
+	{ .compatible = "Allwinner,MicArray_3", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, ac108_dt_ids);
+#endif
+
+static struct i2c_driver ac108_i2c_driver = {
+	.class = I2C_CLASS_HWMON,
+	.driver = {
+		.name = "ac108",
+		.owner = THIS_MODULE,
+#ifdef AC108_MATCH_DTS_EN
+		.of_match_table = of_match_ptr(ac108_dt_ids),
+#endif
+	},
+	.probe = ac108_i2c_probe,
+	.remove = ac108_i2c_remove,
+	.id_table = ac108_i2c_id,
+#ifndef AC108_MATCH_DTS_EN
+	.address_list = ac108_i2c_addr,
+	.detect = ac108_i2c_detect,
+#endif
+};
+module_i2c_driver(ac108_i2c_driver);
+
+MODULE_DESCRIPTION("ASoC ac108 codec driver");
+MODULE_AUTHOR("panjunwen");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/codecs/ac108.h b/sound/soc/codecs/ac108.h
new file mode 100644
index 000000000..e599883e0
--- /dev/null
+++ b/sound/soc/codecs/ac108.h
@@ -0,0 +1,857 @@
+/*
+ * ac108.h --  ac108 ALSA Soc Audio driver
+ *
+ * Version: 3.0
+ *
+ * Author: panjunwen
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef _AC108_H
+#define _AC108_H
+
+
+/*** AC108 Codec Register Define***/
+
+//Chip Reset
+#define CHIP_AUDIO_RST		0x00
+
+//Power Control
+#define PWR_CTRL1			0x01
+#define PWR_CTRL2			0x02
+#define PWR_CTRL3			0x03
+#define PWR_CTRL4			0x04
+#define PWR_CTRL5			0x05
+#define PWR_CTRL6			0x06
+#define PWR_CTRL7			0x07
+#define PWR_CTRL8			0x08
+#define PWR_CTRL9			0x09
+
+//PLL Configure Control
+#define PLL_CTRL1			0x10
+#define PLL_CTRL2			0x11
+#define PLL_CTRL3			0x12
+#define PLL_CTRL4			0x13
+#define PLL_CTRL5			0x14
+#define PLL_CTRL6			0x16
+#define PLL_CTRL7			0x17
+#define PLL_LOCK_CTRL		0x18
+
+//System Clock Control
+#define SYSCLK_CTRL			0x20
+#define MOD_CLK_EN			0x21
+#define MOD_RST_CTRL		0x22
+#define DSM_CLK_CTRL		0x25
+
+//I2S Common Control
+#define I2S_CTRL			0x30
+#define I2S_BCLK_CTRL		0x31
+#define I2S_LRCK_CTRL1		0x32
+#define I2S_LRCK_CTRL2		0x33
+#define I2S_FMT_CTRL1		0x34
+#define I2S_FMT_CTRL2		0x35
+#define I2S_FMT_CTRL3		0x36
+
+//I2S TX1 Control
+#define I2S_TX1_CTRL1		0x38
+#define I2S_TX1_CTRL2		0x39
+#define I2S_TX1_CTRL3		0x3A
+#define I2S_TX1_CHMP_CTRL1	0x3C
+#define I2S_TX1_CHMP_CTRL2	0x3D
+#define I2S_TX1_CHMP_CTRL3	0x3E
+#define I2S_TX1_CHMP_CTRL4	0x3F
+
+//I2S TX2 Control
+#define I2S_TX2_CTRL1		0x40
+#define I2S_TX2_CTRL2		0x41
+#define I2S_TX2_CTRL3		0x42
+#define I2S_TX2_CHMP_CTRL1	0x44
+#define I2S_TX2_CHMP_CTRL2	0x45
+#define I2S_TX2_CHMP_CTRL3	0x46
+#define I2S_TX2_CHMP_CTRL4	0x47
+
+//I2S RX1 Control
+#define I2S_RX1_CTRL1		0x50
+#define I2S_RX1_CHMP_CTRL1	0x54
+#define I2S_RX1_CHMP_CTRL2	0x55
+#define I2S_RX1_CHMP_CTRL3	0x56
+#define I2S_RX1_CHMP_CTRL4	0x57
+
+//I2S Loopback Debug
+#define I2S_LPB_DEBUG		0x58
+
+//ADC Common Control
+#define ADC_SPRC			0x60
+#define ADC_DIG_EN			0x61
+#define DMIC_EN				0x62
+#define ADC_DSR				0x63
+#define ADC_FIR				0x64
+#define ADC_DDT_CTRL		0x65
+
+//HPF Control
+#define HPF_EN				0x66
+#define HPF_COEF_REGH1		0x67
+#define HPF_COEF_REGH2		0x68
+#define HPF_COEF_REGL1		0x69
+#define HPF_COEF_REGL2		0x6A
+#define HPF_GAIN_REGH1		0x6B
+#define HPF_GAIN_REGH2		0x6C
+#define HPF_GAIN_REGL1		0x6D
+#define HPF_GAIN_REGL2		0x6E
+
+//ADC Digital Channel Volume Control
+#define ADC1_DVOL_CTRL		0x70
+#define ADC2_DVOL_CTRL		0x71
+#define ADC3_DVOL_CTRL		0x72
+#define ADC4_DVOL_CTRL		0x73
+
+//ADC Digital Mixer Source and Gain Control
+#define ADC1_DMIX_SRC		0x76
+#define ADC2_DMIX_SRC		0x77
+#define ADC3_DMIX_SRC		0x78
+#define ADC4_DMIX_SRC		0x79
+
+//ADC Digital Debug Control
+#define ADC_DIG_DEBUG		0x7F
+
+//I2S Pad Drive Control
+#define I2S_DAT_PADDRV_CTRL	0x80
+#define I2S_CLK_PADDRV_CTRL	0x81
+
+//Analog PGA Control
+#define ANA_PGA1_CTRL		0x90
+#define ANA_PGA2_CTRL		0x91
+#define ANA_PGA3_CTRL		0x92
+#define ANA_PGA4_CTRL		0x93
+
+//MIC Offset Control
+#define MIC_OFFSET_CTRL1	0x96
+#define MIC_OFFSET_CTRL2	0x97
+#define MIC1_OFFSET_STATU1	0x98
+#define MIC1_OFFSET_STATU2	0x99
+#define MIC2_OFFSET_STATU1	0x9A
+#define MIC2_OFFSET_STATU2	0x9B
+#define MIC3_OFFSET_STATU1	0x9C
+#define MIC3_OFFSET_STATU2	0x9D
+#define MIC4_OFFSET_STATU1	0x9E
+#define MIC4_OFFSET_STATU2	0x9F
+
+//ADC1 Analog Control
+#define ANA_ADC1_CTRL1		0xA0
+#define ANA_ADC1_CTRL2		0xA1
+#define ANA_ADC1_CTRL3		0xA2
+#define ANA_ADC1_CTRL4		0xA3
+#define ANA_ADC1_CTRL5		0xA4
+#define ANA_ADC1_CTRL6		0xA5
+#define ANA_ADC1_CTRL7		0xA6
+
+//ADC2 Analog Control
+#define ANA_ADC2_CTRL1		0xA7
+#define ANA_ADC2_CTRL2		0xA8
+#define ANA_ADC2_CTRL3		0xA9
+#define ANA_ADC2_CTRL4		0xAA
+#define ANA_ADC2_CTRL5		0xAB
+#define ANA_ADC2_CTRL6		0xAC
+#define ANA_ADC2_CTRL7		0xAD
+
+//ADC3 Analog Control
+#define ANA_ADC3_CTRL1		0xAE
+#define ANA_ADC3_CTRL2		0xAF
+#define ANA_ADC3_CTRL3		0xB0
+#define ANA_ADC3_CTRL4		0xB1
+#define ANA_ADC3_CTRL5		0xB2
+#define ANA_ADC3_CTRL6		0xB3
+#define ANA_ADC3_CTRL7		0xB4
+
+//ADC4 Analog Control
+#define ANA_ADC4_CTRL1		0xB5
+#define ANA_ADC4_CTRL2		0xB6
+#define ANA_ADC4_CTRL3		0xB7
+#define ANA_ADC4_CTRL4		0xB8
+#define ANA_ADC4_CTRL5		0xB9
+#define ANA_ADC4_CTRL6		0xBA
+#define ANA_ADC4_CTRL7		0xBB
+
+//GPIO Configure
+#define GPIO_CFG1			0xC0
+#define GPIO_CFG2			0xC1
+#define GPIO_DAT			0xC2
+#define GPIO_DRV			0xC3
+#define GPIO_PULL			0xC4
+#define GPIO_INT_CFG		0xC5
+#define GPIO_INT_EN			0xC6
+#define GPIO_INT_STATUS		0xC7
+
+//Misc
+#define BGTC_DAT			0xD1
+#define BGVC_DAT			0xD2
+#define PRNG_CLK_CTRL		0xDF
+
+#define AC108_REG_MAX		PRNG_CLK_CTRL
+
+
+
+/*** AC108 Codec Register Bit Define***/
+
+/*PWR_CTRL1*/
+#define CP12_CTRL				4
+#define CP12_SENSE_SELECT		3
+
+/*PWR_CTRL2*/
+#define CP12_SENSE_FILT			6
+#define CP12_COMP_FF_EN			3
+#define CP12_FORCE_ENABLE		2
+#define CP12_FORCE_RSTB			1
+
+/*PWR_CTRL3*/
+#define LDO33DIG_CTRL			0
+
+/*PWR_CTRL6*/
+#define LDO33ANA_2XHDRM			2
+#define LDO33ANA_ENABLE			0
+
+/*PWR_CTRL7*/
+#define VREF_SEL				3
+#define VREF_FASTSTART_ENABLE	1
+#define VREF_ENABLE				0
+
+/*PWR_CTRL9*/
+#define VREFP_FASTSTART_ENABLE	7
+#define VREFP_RESCTRL			5
+#define VREFP_LPMODE			4
+#define IGEN_TRIM				1
+#define VREFP_ENABLE			0
+
+
+/*PLL_CTRL1*/
+#define PLL_IBIAS				4
+#define PLL_NDET				3
+#define PLL_LOCKED_STATUS		2
+#define PLL_COM_EN				1
+#define PLL_EN					0
+
+/*PLL_CTRL2*/
+#define PLL_PREDIV2				5
+#define PLL_PREDIV1				0
+
+/*PLL_CTRL3*/
+#define PLL_LOOPDIV_MSB			0
+
+/*PLL_CTRL4*/
+#define PLL_LOOPDIV_LSB			0
+
+/*PLL_CTRL5*/
+#define PLL_POSTDIV2			5
+#define PLL_POSTDIV1			0
+
+/*PLL_CTRL6*/
+#define PLL_LDO					6
+#define PLL_CP					0
+
+/*PLL_CTRL7*/
+#define PLL_CAP					6
+#define PLL_RES					4
+#define PLL_TEST_EN				0
+
+/*PLL_LOCK_CTRL*/
+#define LOCK_LEVEL1				2
+#define LOCK_LEVEL2				1
+#define PLL_LOCK_EN				0
+
+
+/*SYSCLK_CTRL*/
+#define PLLCLK_EN				7
+#define PLLCLK_SRC				4
+#define SYSCLK_SRC				3
+#define SYSCLK_EN				0
+
+/*MOD_CLK_EN & MOD_RST_CTRL*/
+#define I2S						7
+#define ADC_DIGITAL				4
+#define MIC_OFFSET_CALIBRATION	1
+#define ADC_ANALOG				0
+
+/*DSM_CLK_CTRL*/
+#define MIC_OFFSET_DIV			4
+#define DSM_CLK_SEL				0
+
+
+/*I2S_CTRL*/
+#define BCLK_IOEN				7
+#define LRCK_IOEN				6
+#define SDO2_EN					5
+#define SDO1_EN					4
+#define TXEN					2
+#define RXEN					1
+#define GEN						0
+
+/*I2S_BCLK_CTRL*/
+#define EDGE_TRANSFER			5
+#define BCLK_POLARITY			4
+#define BCLKDIV					0
+
+/*I2S_LRCK_CTRL1*/
+#define LRCK_POLARITY			4
+#define LRCK_PERIODH			0
+
+/*I2S_LRCK_CTRL2*/
+#define LRCK_PERIODL			0
+
+/*I2S_FMT_CTRL1*/
+#define ENCD_SEL				6
+#define MODE_SEL				4
+#define TX2_OFFSET				3
+#define TX1_OFFSET				2
+#define TX_SLOT_HIZ				1
+#define TX_STATE				0
+
+/*I2S_FMT_CTRL2*/
+#define SLOT_WIDTH_SEL			4
+#define SAMPLE_RESOLUTION		0
+
+/*I2S_FMT_CTRL3*/
+#define TX_MLS					7
+#define SEXT					5
+#define OUT2_MUTE				4
+#define OUT1_MUTE				3
+#define LRCK_WIDTH				2
+#define TX_PDM					0
+
+
+/*I2S_TX1_CTRL1*/
+#define TX1_CHSEL				0
+
+/*I2S_TX1_CTRL2*/
+#define TX1_CH8_EN				7
+#define TX1_CH7_EN				6
+#define TX1_CH6_EN				5
+#define TX1_CH5_EN				4
+#define TX1_CH4_EN				3
+#define TX1_CH3_EN				2
+#define TX1_CH2_EN				1
+#define TX1_CH1_EN				0
+
+/*I2S_TX1_CTRL3*/
+#define TX1_CH16_EN				7
+#define TX1_CH15_EN				6
+#define TX1_CH14_EN				5
+#define TX1_CH13_EN				4
+#define TX1_CH12_EN				3
+#define TX1_CH11_EN				2
+#define TX1_CH10_EN				1
+#define TX1_CH9_EN				0
+
+/*I2S_TX1_CHMP_CTRL1*/
+#define TX1_CH4_MAP				6
+#define TX1_CH3_MAP				4
+#define TX1_CH2_MAP				2
+#define TX1_CH1_MAP				0
+
+/*I2S_TX1_CHMP_CTRL2*/
+#define TX1_CH8_MAP				6
+#define TX1_CH7_MAP				4
+#define TX1_CH6_MAP				2
+#define TX1_CH5_MAP				0
+
+/*I2S_TX1_CHMP_CTRL3*/
+#define TX1_CH12_MAP			6
+#define TX1_CH11_MAP			4
+#define TX1_CH10_MAP			2
+#define TX1_CH9_MAP				0
+
+/*I2S_TX1_CHMP_CTRL4*/
+#define TX1_CH16_MAP			6
+#define TX1_CH15_MAP			4
+#define TX1_CH14_MAP			2
+#define TX1_CH13_MAP			0
+
+
+/*I2S_TX2_CTRL1*/
+#define TX2_CHSEL				0
+
+/*I2S_TX2_CHMP_CTRL1*/
+#define TX2_CH4_MAP				6
+#define TX2_CH3_MAP				4
+#define TX2_CH2_MAP				2
+#define TX2_CH1_MAP				0
+
+/*I2S_TX2_CHMP_CTRL2*/
+#define TX2_CH8_MAP				6
+#define TX2_CH7_MAP				4
+#define TX2_CH6_MAP				2
+#define TX2_CH5_MAP				0
+
+/*I2S_TX2_CHMP_CTRL3*/
+#define TX2_CH12_MAP			6
+#define TX2_CH11_MAP			4
+#define TX2_CH10_MAP			2
+#define TX2_CH9_MAP				0
+
+/*I2S_TX2_CHMP_CTRL4*/
+#define TX2_CH16_MAP			6
+#define TX2_CH15_MAP			4
+#define TX2_CH14_MAP			2
+#define TX2_CH13_MAP			0
+
+
+/*I2S_RX1_CTRL1*/
+#define RX1_CHSEL				0
+
+/*I2S_RX1_CHMP_CTRL1*/
+#define RX1_CH4_MAP				6
+#define RX1_CH3_MAP				4
+#define RX1_CH2_MAP				2
+#define RX1_CH1_MAP				0
+
+/*I2S_RX1_CHMP_CTRL2*/
+#define RX1_CH8_MAP				6
+#define RX1_CH7_MAP				4
+#define RX1_CH6_MAP				2
+#define RX1_CH5_MAP				0
+
+/*I2S_RX1_CHMP_CTRL3*/
+#define RX1_CH12_MAP			6
+#define RX1_CH11_MAP			4
+#define RX1_CH10_MAP			2
+#define RX1_CH9_MAP				0
+
+/*I2S_RX1_CHMP_CTRL4*/
+#define RX1_CH16_MAP			6
+#define RX1_CH15_MAP			4
+#define RX1_CH14_MAP			2
+#define RX1_CH13_MAP			0
+
+
+/*I2S_LPB_DEBUG*/
+#define I2S_LPB_DEBUG_EN		0
+
+
+/*ADC_SPRC*/
+#define ADC_FS_I2S1				0
+
+/*ADC_DIG_EN*/
+#define DG_EN					4
+#define ENAD4					3
+#define ENAD3					2
+#define ENAD2					1
+#define ENAD1					0
+
+/*DMIC_EN*/
+#define DMIC2_EN				1
+#define DMIC1_EN				0
+
+/*ADC_DSR*/
+#define DIG_ADC4_SRS			6
+#define DIG_ADC3_SRS			4
+#define DIG_ADC2_SRS			2
+#define DIG_ADC1_SRS			0
+
+/*ADC_DDT_CTRL*/
+#define ADOUT_DLY_EN			2
+#define ADOUT_DTS				0
+
+
+/*HPF_EN*/
+#define DIG_ADC4_HPF_EN			3
+#define DIG_ADC3_HPF_EN			2
+#define DIG_ADC2_HPF_EN			1
+#define DIG_ADC1_HPF_EN			0
+
+
+/*ADC1_DMIX_SRC*/
+#define ADC1_ADC4_DMXL_GC		7
+#define ADC1_ADC3_DMXL_GC		6
+#define ADC1_ADC2_DMXL_GC		5
+#define ADC1_ADC1_DMXL_GC		4
+#define ADC1_ADC4_DMXL_SRC		3
+#define ADC1_ADC3_DMXL_SRC		2
+#define ADC1_ADC2_DMXL_SRC		1
+#define ADC1_ADC1_DMXL_SRC		0
+
+/*ADC2_DMIX_SRC*/
+#define ADC2_ADC4_DMXL_GC		7
+#define ADC2_ADC3_DMXL_GC		6
+#define ADC2_ADC2_DMXL_GC		5
+#define ADC2_ADC1_DMXL_GC		4
+#define ADC2_ADC4_DMXL_SRC		3
+#define ADC2_ADC3_DMXL_SRC		2
+#define ADC2_ADC2_DMXL_SRC		1
+#define ADC2_ADC1_DMXL_SRC		0
+
+/*ADC3_DMIX_SRC*/
+#define ADC3_ADC4_DMXL_GC		7
+#define ADC3_ADC3_DMXL_GC		6
+#define ADC3_ADC2_DMXL_GC		5
+#define ADC3_ADC1_DMXL_GC		4
+#define ADC3_ADC4_DMXL_SRC		3
+#define ADC3_ADC3_DMXL_SRC		2
+#define ADC3_ADC2_DMXL_SRC		1
+#define ADC3_ADC1_DMXL_SRC		0
+
+/*ADC4_DMIX_SRC*/
+#define ADC4_ADC4_DMXL_GC		7
+#define ADC4_ADC3_DMXL_GC		6
+#define ADC4_ADC2_DMXL_GC		5
+#define ADC4_ADC1_DMXL_GC		4
+#define ADC4_ADC4_DMXL_SRC		3
+#define ADC4_ADC3_DMXL_SRC		2
+#define ADC4_ADC2_DMXL_SRC		1
+#define ADC4_ADC1_DMXL_SRC		0
+
+
+/*ADC_DIG_DEBUG*/
+#define ADC_PTN_SEL				0
+
+
+/*I2S_DAT_PADDRV_CTRL*/
+#define TX2_DAT_DRV				4
+#define TX1_DAT_DRV				0
+
+/*I2S_CLK_PADDRV_CTRL*/
+#define LRCK_DRV				4
+#define BCLK_DRV				0
+
+
+/*ANA_PGA1_CTRL*/
+#define ADC1_ANALOG_PGA			1
+#define ADC1_ANALOG_PGA_STEP	0
+
+/*ANA_PGA2_CTRL*/
+#define ADC2_ANALOG_PGA			1
+#define ADC2_ANALOG_PGA_STEP	0
+
+/*ANA_PGA3_CTRL*/
+#define ADC3_ANALOG_PGA			1
+#define ADC3_ANALOG_PGA_STEP	0
+
+/*ANA_PGA4_CTRL*/
+#define ADC4_ANALOG_PGA			1
+#define ADC4_ANALOG_PGA_STEP	0
+
+
+/*MIC_OFFSET_CTRL1*/
+#define MIC_OFFSET_CAL_EN4		3
+#define MIC_OFFSET_CAL_EN3		2
+#define MIC_OFFSET_CAL_EN2		1
+#define MIC_OFFSET_CAL_EN1		0
+
+/*MIC_OFFSET_CTRL2*/
+#define MIC_OFFSET_CAL_GAIN		3
+#define MIC_OFFSET_CAL_CHANNEL	1
+#define MIC_OFFSET_CAL_EN_ONCE	0
+
+/*MIC1_OFFSET_STATU1*/
+#define MIC1_OFFSET_CAL_DONE	7
+#define MIC1_OFFSET_CAL_RUN_STA	6
+#define MIC1_OFFSET_MSB			0
+
+/*MIC1_OFFSET_STATU2*/
+#define MIC1_OFFSET_LSB			0
+
+/*MIC2_OFFSET_STATU1*/
+#define MIC2_OFFSET_CAL_DONE	7
+#define MIC2_OFFSET_CAL_RUN_STA	6
+#define MIC2_OFFSET_MSB			0
+
+/*MIC2_OFFSET_STATU2*/
+#define MIC2_OFFSET_LSB			0
+
+/*MIC3_OFFSET_STATU1*/
+#define MIC3_OFFSET_CAL_DONE	7
+#define MIC3_OFFSET_CAL_RUN_STA	6
+#define MIC3_OFFSET_MSB			0
+
+/*MIC3_OFFSET_STATU2*/
+#define MIC3_OFFSET_LSB			0
+
+/*MIC4_OFFSET_STATU1*/
+#define MIC4_OFFSET_CAL_DONE	7
+#define MIC4_OFFSET_CAL_RUN_STA	6
+#define MIC4_OFFSET_MSB			0
+
+/*MIC4_OFFSET_STATU2*/
+#define MIC4_OFFSET_LSB			0
+
+
+/*ANA_ADC1_CTRL1*/
+#define ADC1_PGA_BYPASS			7
+#define ADC1_PGA_BYP_RCM		6
+#define ADC1_PGA_CTRL_RCM		4
+#define ADC1_PGA_MUTE			3
+#define ADC1_DSM_ENABLE			2
+#define ADC1_PGA_ENABLE			1
+#define ADC1_MICBIAS_EN			0
+
+/*ANA_ADC1_CTRL3*/
+#define ADC1_ANA_CAL_EN			5
+#define ADC1_SEL_OUT_EDGE		3
+#define ADC1_DSM_DISABLE		2
+#define ADC1_VREFP_DISABLE		1
+#define ADC1_AAF_DISABLE		0
+
+/*ANA_ADC1_CTRL6*/
+#define PGA_CTRL_TC				6
+#define PGA_CTRL_RC				4
+#define PGA_CTRL_I_LIN			2
+#define PGA_CTRL_I_IN			0
+
+/*ANA_ADC1_CTRL7*/
+#define PGA_CTRL_HI_Z			7
+#define PGA_CTRL_SHORT_RF		6
+#define PGA_CTRL_VCM_VG			4
+#define PGA_CTRL_VCM_IN			0
+
+
+/*ANA_ADC2_CTRL1*/
+#define ADC2_PGA_BYPASS			7
+#define ADC2_PGA_BYP_RCM		6
+#define ADC2_PGA_CTRL_RCM		4
+#define ADC2_PGA_MUTE			3
+#define ADC2_DSM_ENABLE			2
+#define ADC2_PGA_ENABLE			1
+#define ADC2_MICBIAS_EN			0
+
+/*ANA_ADC2_CTRL3*/
+#define ADC2_ANA_CAL_EN			5
+#define ADC2_SEL_OUT_EDGE		3
+#define ADC2_DSM_DISABLE		2
+#define ADC2_VREFP_DISABLE		1
+#define ADC2_AAF_DISABLE		0
+
+/*ANA_ADC2_CTRL6*/
+#define PGA_CTRL_IBOOST			7
+#define PGA_CTRL_IQCTRL			6
+#define PGA_CTRL_OABIAS			4
+#define PGA_CTRL_CMLP_DIS		3
+#define PGA_CTRL_PDB_RIN		2
+#define PGA_CTRL_PEAKDET		0
+
+/*ANA_ADC2_CTRL7*/
+#define AAF_LPMODE_EN			7
+#define AAF_STG2_IB_SEL			4
+#define AAFDSM_IB_DIV2			3
+#define AAF_STG1_IB_SEL			0
+
+
+/*ANA_ADC3_CTRL1*/
+#define ADC3_PGA_BYPASS			7
+#define ADC3_PGA_BYP_RCM		6
+#define ADC3_PGA_CTRL_RCM		4
+#define ADC3_PGA_MUTE			3
+#define ADC3_DSM_ENABLE			2
+#define ADC3_PGA_ENABLE			1
+#define ADC3_MICBIAS_EN			0
+
+/*ANA_ADC3_CTRL3*/
+#define ADC3_ANA_CAL_EN			5
+#define ADC3_INVERT_CLK			4
+#define ADC3_SEL_OUT_EDGE		3
+#define ADC3_DSM_DISABLE		2
+#define ADC3_VREFP_DISABLE		1
+#define ADC3_AAF_DISABLE		0
+
+/*ANA_ADC3_CTRL7*/
+#define DSM_COMP_IB_SEL			6
+#define DSM_OTA_CTRL			4
+#define DSM_LPMODE				3
+#define DSM_OTA_IB_SEL			0
+
+
+/*ANA_ADC4_CTRL1*/
+#define ADC4_PGA_BYPASS			7
+#define ADC4_PGA_BYP_RCM		6
+#define ADC4_PGA_CTRL_RCM		4
+#define ADC4_PGA_MUTE			3
+#define ADC4_DSM_ENABLE			2
+#define ADC4_PGA_ENABLE			1
+#define ADC4_MICBIAS_EN			0
+
+/*ANA_ADC4_CTRL3*/
+#define ADC4_ANA_CAL_EN			5
+#define ADC4_SEL_OUT_EDGE		3
+#define ADC4_DSM_DISABLE		2
+#define ADC4_VREFP_DISABLE		1
+#define ADC4_AAF_DISABLE		0
+
+/*ANA_ADC4_CTRL6*/
+#define DSM_DEMOFF				5
+#define DSM_EN_DITHER			4
+#define DSM_VREFP_LPMODE		2
+#define DSM_VREFP_OUTCTRL		0
+
+/*ANA_ADC4_CTRL7*/
+#define CK8M_EN					5
+#define OSC_EN					4
+#define ADC4_CLK_GATING			3
+#define ADC3_CLK_GATING			2
+#define ADC2_CLK_GATING			1
+#define ADC1_CLK_GATING			0
+
+
+/*GPIO_CFG1*/
+#define GPIO2_SELECT			4
+#define GPIO1_SELECT			0
+
+/*GPIO_CFG2*/
+#define GPIO4_SELECT			4
+#define GPIO3_SELECT			0
+
+/*GPIO_DAT*/
+#define GPIO4_DAT				3
+#define GPIO3_DAT				2
+#define GPIO2_DAT				1
+#define GPIO1_DAT				0
+
+/*GPIO_DRV*/
+#define GPIO4_DRV				6
+#define GPIO3_DRV				4
+#define GPIO2_DRV				2
+#define GPIO1_DRV				0
+
+/*GPIO_PULL*/
+#define GPIO4_PULL				6
+#define GPIO3_PULL				4
+#define GPIO2_PULL				2
+#define GPIO1_PULL				0
+
+/*GPIO_INT_CFG*/
+#define GPIO4_EINT_CFG			6
+#define GPIO3_EINT_CFG			4
+#define GPIO2_EINT_CFG			2
+#define GPIO1_EINT_CFG			0
+
+/*GPIO_INT_EN*/
+#define GPIO4_EINT_EN			3
+#define GPIO3_EINT_EN			2
+#define GPIO2_EINT_EN			1
+#define GPIO1_EINT_EN			0
+
+/*GPIO_INT_STATUS*/
+#define GPIO4_EINT_STA			3
+#define GPIO3_EINT_STA			2
+#define GPIO2_EINT_STA			1
+#define GPIO1_EINT_STA			0
+
+
+/*PRNG_CLK_CTRL*/
+#define PRNG_CLK_EN				1
+#define PRNG_CLK_POS			0
+
+
+
+/*** Some Config Value ***/
+
+//[SYSCLK_CTRL]: PLLCLK_SRC
+#define PLLCLK_SRC_MCLK			0
+#define PLLCLK_SRC_BCLK			1
+#define PLLCLK_SRC_GPIO2		2
+#define PLLCLK_SRC_GPIO3		3
+
+//[SYSCLK_CTRL]: SYSCLK_SRC
+#define SYSCLK_SRC_MCLK			0
+#define SYSCLK_SRC_PLL			1
+
+//I2S BCLK POLARITY Control
+#define BCLK_NORMAL_DRIVE_N_SAMPLE_P	0
+#define BCLK_INVERT_DRIVE_P_SAMPLE_N	1
+
+//I2S LRCK POLARITY Control
+#define	LRCK_LEFT_LOW_RIGHT_HIGH		0
+#define LRCK_LEFT_HIGH_RIGHT_LOW		1
+
+//I2S Format Selection
+#define PCM_FORMAT						0
+#define LEFT_JUSTIFIED_FORMAT			1
+#define RIGHT_JUSTIFIED_FORMAT			2
+
+//ADC Digital Debug Control
+#define ADC_PTN_NORMAL					0
+#define ADC_PTN_0x5A5A5A				1
+#define ADC_PTN_0x123456				2
+#define ADC_PTN_ZERO					3
+#define ADC_PTN_I2S_RX_DATA				4
+
+//ADC PGA GAIN Control
+#define ADC_PGA_GAIN_0dB				0
+#define ADC_PGA_GAIN_MINUS_6dB			1
+#define ADC_PGA_GAIN_3dB				3
+#define ADC_PGA_GAIN_4dB				4
+#define ADC_PGA_GAIN_5dB				5
+#define ADC_PGA_GAIN_6dB				6
+#define ADC_PGA_GAIN_7dB				7
+#define ADC_PGA_GAIN_8dB				8
+#define ADC_PGA_GAIN_9dB				9
+#define ADC_PGA_GAIN_10dB				10
+#define ADC_PGA_GAIN_11dB				11
+#define ADC_PGA_GAIN_12dB				12
+#define ADC_PGA_GAIN_13dB				13
+#define ADC_PGA_GAIN_14dB				14
+#define ADC_PGA_GAIN_15dB				15
+#define ADC_PGA_GAIN_16dB				16
+#define ADC_PGA_GAIN_17dB				17
+#define ADC_PGA_GAIN_18dB				18
+#define ADC_PGA_GAIN_19dB				19
+#define ADC_PGA_GAIN_20dB				20
+#define ADC_PGA_GAIN_21dB				21
+#define ADC_PGA_GAIN_22dB				22
+#define ADC_PGA_GAIN_23dB				23
+#define ADC_PGA_GAIN_24dB				24
+#define ADC_PGA_GAIN_25dB				25
+#define ADC_PGA_GAIN_26dB				26
+#define ADC_PGA_GAIN_27dB				27
+#define ADC_PGA_GAIN_28dB				28
+#define ADC_PGA_GAIN_29dB				29
+#define ADC_PGA_GAIN_30dB				30
+
+struct voltage_supply {
+	const char *name;
+	struct regulator *regulator;
+	unsigned int voltage;
+	unsigned int used;
+};
+
+struct gain_config {
+	unsigned int val;
+	unsigned int used;
+};
+
+struct gpio_setting {
+	unsigned int gpio;
+	unsigned int used;
+};
+
+struct ref_chip_config {
+	struct gain_config ref_pga;
+	unsigned int ref_channel;
+};
+
+struct ac108_priv {
+	struct i2c_client *i2c;
+	struct snd_soc_component *codec;
+	struct regmap *regmap;
+	unsigned int reg_dump_offset;
+	unsigned int reg_dump_count;
+
+	struct voltage_supply vol_supply;
+	struct gpio_setting power_gpio;
+	struct gpio_setting reset_gpio;
+
+	unsigned int twi_bus;
+	unsigned int pga_gain;
+	unsigned int lrck_period;
+	unsigned int slot_width;
+	struct ref_chip_config ref_cfg;
+
+	unsigned int debug_mode;
+};
+
+struct ac108_public_config {
+	unsigned int ac108_nums;
+};
+
+#endif
+
diff --git a/sound/soc/hisilicon/Kconfig b/sound/soc/hisilicon/Kconfig
index df8fbd8bb..93f0f2890 100644
--- a/sound/soc/hisilicon/Kconfig
+++ b/sound/soc/hisilicon/Kconfig
@@ -1,6 +1,12 @@
 # SPDX-License-Identifier: GPL-2.0-only
 config SND_I2S_HI6210_I2S
-	tristate "Hisilicon I2S controller"
+	tristate "Hisilicon Hi6210 I2S controller"
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	help
+	  Hisilicon I2S
+
+config SND_I2S_HI3660_I2S
+	tristate "Hisilicon 960 I2S controller"
 	select SND_SOC_GENERIC_DMAENGINE_PCM
 	help
 	  Hisilicon I2S
diff --git a/sound/soc/hisilicon/Makefile b/sound/soc/hisilicon/Makefile
index 02e766378..7ca808c53 100644
--- a/sound/soc/hisilicon/Makefile
+++ b/sound/soc/hisilicon/Makefile
@@ -1,2 +1,3 @@
 # SPDX-License-Identifier: GPL-2.0-only
 obj-$(CONFIG_SND_I2S_HI6210_I2S) += hi6210-i2s.o
+obj-$(CONFIG_SND_I2S_HI3660_I2S) += hi3660-i2s.o
diff --git a/sound/soc/hisilicon/hi3660-i2s.c b/sound/soc/hisilicon/hi3660-i2s.c
new file mode 100644
index 000000000..b894007d0
--- /dev/null
+++ b/sound/soc/hisilicon/hi3660-i2s.c
@@ -0,0 +1,448 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * linux/sound/soc/hisilicon/hi3660-i2s.c
+ *
+ * I2S IP driver for hi3660.
+ *
+ * Copyright (c) 2001-2021, Huawei Tech. Co., Ltd.
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/jiffies.h>
+#include <linux/io.h>
+#include <linux/gpio.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+#include <linux/interrupt.h>
+#include <linux/reset.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/reset-controller.h>
+#include <linux/clk.h>
+#include <linux/regulator/consumer.h>
+
+#include "hi3660-i2s.h"
+
+struct hi3660_i2s {
+	struct device *dev;
+	struct reset_control *rc;
+	int clocks;
+	struct regulator *regu_asp;
+	struct pinctrl *pctrl;
+	struct pinctrl_state *pin_default;
+	struct pinctrl_state *pin_idle;
+	struct clk *asp_subsys_clk;
+	struct snd_soc_dai_driver dai;
+	void __iomem *base;
+	void __iomem *base_syscon;
+	phys_addr_t base_phys;
+	struct snd_dmaengine_dai_dma_data dma_data[2];
+	spinlock_t lock;
+	int rate;
+	int format;
+	int bits;
+	int channels;
+	u32 master;
+	u32 status;
+};
+
+static void update_bits(struct hi3660_i2s *i2s, u32 ofs, u32 reset, u32 set)
+{
+	u32 val = readl(i2s->base + ofs) & ~reset;
+
+	writel(val | set, i2s->base + ofs);
+}
+
+static void update_bits_syscon(struct hi3660_i2s *i2s,
+			u32 ofs, u32 reset, u32 set)
+{
+	u32 val = readl(i2s->base_syscon + ofs) & ~reset;
+
+	writel(val | set, i2s->base_syscon + ofs);
+}
+
+static int enable_format(struct hi3660_i2s *i2s,
+			       struct snd_pcm_substream *substream)
+{
+	switch (i2s->format & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		i2s->master = false;
+		update_bits_syscon(i2s, HI_ASP_CFG_R_CLK_SEL_REG,
+				0, HI_ASP_CFG_R_CLK_SEL_EN);
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		i2s->master = true;
+		update_bits_syscon(i2s, HI_ASP_CFG_R_CLK_SEL_REG,
+				HI_ASP_CFG_R_CLK_SEL_EN, 0);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int startup(struct snd_pcm_substream *substream,
+		     struct snd_soc_dai *cpu_dai)
+{
+	struct hi3660_i2s *i2s = dev_get_drvdata(cpu_dai->dev);
+
+	/* deassert reset on sio_bt*/
+	update_bits_syscon(i2s, HI_ASP_CFG_R_RST_CTRLDIS_REG,
+			0, BIT(2)|BIT(6)|BIT(8)|BIT(16));
+
+	/* enable clk before frequency division */
+	update_bits_syscon(i2s, HI_ASP_CFG_R_GATE_EN_REG,
+			0, BIT(5)|BIT(6));
+
+	/* enable frequency division */
+	update_bits_syscon(i2s, HI_ASP_CFG_R_GATE_CLKDIV_EN_REG,
+			0, BIT(2)|BIT(5));
+
+	/* select clk */
+	update_bits_syscon(i2s, HI_ASP_CFG_R_CLK_SEL_REG,
+			HI_ASP_MASK, HI_ASP_CFG_R_CLK_SEL);
+
+	/* select clk_div */
+	update_bits_syscon(i2s, HI_ASP_CFG_R_CLK1_DIV_REG,
+			HI_ASP_MASK, HI_ASP_CFG_R_CLK1_DIV_SEL);
+	update_bits_syscon(i2s, HI_ASP_CFG_R_CLK4_DIV_REG,
+			HI_ASP_MASK, HI_ASP_CFG_R_CLK4_DIV_SEL);
+	update_bits_syscon(i2s, HI_ASP_CFG_R_CLK6_DIV_REG,
+			HI_ASP_MASK, HI_ASP_CFG_R_CLK6_DIV_SEL);
+
+	/* sio config */
+	update_bits(i2s, HI_ASP_SIO_MODE_REG, HI_ASP_MASK, 0x0);
+	update_bits(i2s, HI_ASP_SIO_DATA_WIDTH_SET_REG, HI_ASP_MASK, 0x9);
+	update_bits(i2s, HI_ASP_SIO_I2S_POS_MERGE_EN_REG, HI_ASP_MASK, 0x1);
+	update_bits(i2s, HI_ASP_SIO_I2S_START_POS_REG, HI_ASP_MASK, 0x0);
+
+	return 0;
+}
+
+static void shutdown(struct snd_pcm_substream *substream,
+		       struct snd_soc_dai *cpu_dai)
+{
+	struct hi3660_i2s *i2s = dev_get_drvdata(cpu_dai->dev);
+
+	if (!IS_ERR_OR_NULL(i2s->asp_subsys_clk))
+		clk_disable_unprepare(i2s->asp_subsys_clk);
+}
+
+static void txctrl(struct snd_soc_dai *cpu_dai, int on)
+{
+	struct hi3660_i2s *i2s = dev_get_drvdata(cpu_dai->dev);
+
+	spin_lock(&i2s->lock);
+
+	if (on) {
+		/* enable SIO TX */
+		update_bits(i2s, HI_ASP_SIO_CT_SET_REG, 0,
+			HI_ASP_SIO_TX_ENABLE |
+			HI_ASP_SIO_TX_DATA_MERGE |
+			HI_ASP_SIO_TX_FIFO_THRESHOLD |
+			HI_ASP_SIO_RX_ENABLE |
+			HI_ASP_SIO_RX_DATA_MERGE |
+			HI_ASP_SIO_RX_FIFO_THRESHOLD);
+	} else {
+		/* disable SIO TX */
+		update_bits(i2s, HI_ASP_SIO_CT_CLR_REG, 0,
+			HI_ASP_SIO_TX_ENABLE | HI_ASP_SIO_RX_ENABLE);
+	}
+	spin_unlock(&i2s->lock);
+}
+
+static void rxctrl(struct snd_soc_dai *cpu_dai, int on)
+{
+	struct hi3660_i2s *i2s = dev_get_drvdata(cpu_dai->dev);
+
+	spin_lock(&i2s->lock);
+	if (on)
+		/* enable SIO RX */
+		update_bits(i2s, HI_ASP_SIO_CT_SET_REG, 0,
+			HI_ASP_SIO_TX_ENABLE |
+			HI_ASP_SIO_TX_DATA_MERGE |
+			HI_ASP_SIO_TX_FIFO_THRESHOLD |
+			HI_ASP_SIO_RX_ENABLE |
+			HI_ASP_SIO_RX_DATA_MERGE |
+			HI_ASP_SIO_RX_FIFO_THRESHOLD);
+	else
+		/* disable SIO RX */
+		update_bits(i2s, HI_ASP_SIO_CT_CLR_REG, 0,
+			HI_ASP_SIO_TX_ENABLE | HI_ASP_SIO_RX_ENABLE);
+	spin_unlock(&i2s->lock);
+}
+
+static int set_sysclk(struct snd_soc_dai *cpu_dai,
+			     int clk_id, unsigned int freq, int dir)
+{
+	return 0;
+}
+
+static int set_format(struct snd_soc_dai *cpu_dai, unsigned int fmt)
+{
+	struct hi3660_i2s *i2s = dev_get_drvdata(cpu_dai->dev);
+
+	i2s->format = fmt;
+	i2s->master = (i2s->format & SND_SOC_DAIFMT_MASTER_MASK) ==
+		      SND_SOC_DAIFMT_CBS_CFS;
+
+	return 0;
+}
+
+static int hw_params(struct snd_pcm_substream *substream,
+			    struct snd_pcm_hw_params *params,
+			    struct snd_soc_dai *cpu_dai)
+{
+	struct hi3660_i2s *i2s = dev_get_drvdata(cpu_dai->dev);
+	struct snd_dmaengine_dai_dma_data *dma_data;
+
+	dma_data = snd_soc_dai_get_dma_data(cpu_dai, substream);
+
+	enable_format(i2s, substream);
+
+	dma_data->maxburst = 4;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		dma_data->addr = i2s->base_phys +
+			HI_ASP_SIO_I2S_DUAL_TX_CHN_REG;
+	else
+		dma_data->addr = i2s->base_phys +
+			HI_ASP_SIO_I2S_DUAL_RX_CHN_REG;
+
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_U16_LE:
+	case SNDRV_PCM_FORMAT_S16_LE:
+		i2s->bits = 16;
+		dma_data->addr_width = 4;
+		break;
+
+	case SNDRV_PCM_FORMAT_U24_LE:
+	case SNDRV_PCM_FORMAT_S24_LE:
+		i2s->bits = 32;
+		dma_data->addr_width = 4;
+		break;
+	default:
+		dev_err(cpu_dai->dev, "Bad format\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int trigger(struct snd_pcm_substream *substream, int cmd,
+			  struct snd_soc_dai *cpu_dai)
+{
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+			rxctrl(cpu_dai, 1);
+		else
+			txctrl(cpu_dai, 1);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+			rxctrl(cpu_dai, 0);
+		else
+			txctrl(cpu_dai, 0);
+		break;
+	default:
+		dev_err(cpu_dai->dev, "unknown cmd\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int dai_probe(struct snd_soc_dai *dai)
+{
+	struct hi3660_i2s *i2s = snd_soc_dai_get_drvdata(dai);
+
+	snd_soc_dai_init_dma_data(dai,
+		&i2s->dma_data[SNDRV_PCM_STREAM_PLAYBACK],
+		&i2s->dma_data[SNDRV_PCM_STREAM_CAPTURE]);
+
+	return 0;
+}
+
+
+static struct snd_soc_dai_ops dai_ops = {
+	.trigger	= trigger,
+	.hw_params	= hw_params,
+	.set_fmt	= set_format,
+	.set_sysclk	= set_sysclk,
+	.startup	= startup,
+	.shutdown	= shutdown,
+};
+
+static struct snd_soc_dai_driver dai_init = {
+	.name = "hi3660_i2s",
+	.probe = dai_probe,
+	.playback = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE |
+			   SNDRV_PCM_FMTBIT_U16_LE,
+		.rates = SNDRV_PCM_RATE_48000,
+	},
+	.capture = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE |
+			   SNDRV_PCM_FMTBIT_U16_LE,
+		.rates = SNDRV_PCM_RATE_48000,
+	},
+	.ops = &dai_ops,
+};
+
+static const struct snd_soc_component_driver component_driver = {
+	.name = "hi3660_i2s",
+};
+
+#include <sound/dmaengine_pcm.h>
+
+static const struct snd_pcm_hardware sound_hardware = {
+	.info = SNDRV_PCM_INFO_MMAP |
+		SNDRV_PCM_INFO_MMAP_VALID |
+		SNDRV_PCM_INFO_PAUSE |
+		SNDRV_PCM_INFO_RESUME |
+		SNDRV_PCM_INFO_INTERLEAVED |
+		SNDRV_PCM_INFO_HALF_DUPLEX,
+	.period_bytes_min = 4096,
+	.period_bytes_max = 4096,
+	.periods_min = 4,
+	.periods_max = UINT_MAX,
+	.buffer_bytes_max = SIZE_MAX,
+};
+
+static const struct snd_dmaengine_pcm_config dmaengine_pcm_config = {
+	.pcm_hardware = &sound_hardware,
+	.prepare_slave_config = snd_dmaengine_pcm_prepare_slave_config,
+	.prealloc_buffer_size = 64 * 1024,
+};
+
+static int hi3660_i2s_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct hi3660_i2s *i2s;
+	struct resource *res;
+	int ret;
+
+	i2s = devm_kzalloc(dev, sizeof(*i2s), GFP_KERNEL);
+	if (!i2s)
+		return -ENOMEM;
+
+	i2s->dev = dev;
+	spin_lock_init(&i2s->lock);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		ret = -ENODEV;
+		return ret;
+	}
+	i2s->base_phys = (phys_addr_t)res->start;
+
+	i2s->dai = dai_init;
+	dev_set_drvdata(&pdev->dev, i2s);
+
+	i2s->base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(i2s->base)) {
+		dev_err(&pdev->dev, "ioremap failed\n");
+		ret = PTR_ERR(i2s->base);
+		return ret;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (!res) {
+		ret = -ENODEV;
+		return ret;
+	}
+	i2s->base_syscon = devm_ioremap(dev, res->start, resource_size(res));
+	if (IS_ERR(i2s->base_syscon)) {
+		dev_err(&pdev->dev, "ioremap failed\n");
+		ret = PTR_ERR(i2s->base_syscon);
+		return ret;
+	}
+
+	/* i2s iomux config */
+	i2s->pctrl = devm_pinctrl_get(dev);
+	if (IS_ERR(i2s->pctrl)) {
+		dev_err(dev, "could not get pinctrl\n");
+		ret = -EIO;
+		return ret;
+	}
+
+	i2s->pin_default = pinctrl_lookup_state(i2s->pctrl,
+					PINCTRL_STATE_DEFAULT);
+	if (IS_ERR(i2s->pin_default)) {
+		dev_err(dev,
+			"could not get default state (%li)\n",
+			PTR_ERR(i2s->pin_default));
+		ret = -EIO;
+		return ret;
+	}
+
+	if (pinctrl_select_state(i2s->pctrl, i2s->pin_default)) {
+		dev_err(dev, "could not set pins to default state\n");
+		ret = -EIO;
+		return ret;
+	}
+
+	ret = devm_snd_dmaengine_pcm_register(&pdev->dev,
+				&dmaengine_pcm_config, 0);
+	if (ret)
+		return ret;
+
+	ret = snd_soc_register_component(&pdev->dev, &component_driver,
+				&i2s->dai, 1);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to register dai\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int hi3660_i2s_remove(struct platform_device *pdev)
+{
+	struct hi3660_i2s *i2s = dev_get_drvdata(&pdev->dev);
+
+	snd_soc_unregister_component(&pdev->dev);
+	dev_set_drvdata(&pdev->dev, NULL);
+
+	pinctrl_put(i2s->pctrl);
+
+	return 0;
+}
+
+static const struct of_device_id dt_ids[] = {
+	{ .compatible = "hisilicon,hi3660-i2s-1.0" },
+	{ /* sentinel */ }
+};
+
+MODULE_DEVICE_TABLE(of, dt_ids);
+
+static struct platform_driver local_platform_driver = {
+	.probe = hi3660_i2s_probe,
+	.remove = hi3660_i2s_remove,
+	.driver = {
+		.name = "hi3660_i2s",
+		.owner = THIS_MODULE,
+		.of_match_table = dt_ids,
+	},
+};
+
+module_platform_driver(local_platform_driver);
+
+MODULE_DESCRIPTION("Hisilicon I2S driver");
+MODULE_AUTHOR("Guangke Ji <j00209069@notesmail.huawei.com>");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/hisilicon/hi3660-i2s.h b/sound/soc/hisilicon/hi3660-i2s.h
new file mode 100644
index 000000000..187485514
--- /dev/null
+++ b/sound/soc/hisilicon/hi3660-i2s.h
@@ -0,0 +1,99 @@
+/* SPDX-License-Identifier: GPL-2.0+
+ *
+ * linux/sound/soc/hisilicon/hi3660-i2s.c
+ *
+ * I2S IP driver for hi3660.
+ *
+ * Copyright (c) 2001-2021, Huawei Tech. Co., Ltd.
+ *
+ */
+
+#ifndef _HI3660_I2S_H
+#define _HI3660_I2S_H
+
+enum hisi_bits {
+	HII2S_BITS_16,
+	HII2S_BITS_18,
+	HII2S_BITS_20,
+	HII2S_BITS_24,
+};
+
+enum hisi_i2s_rates {
+	HII2S_FS_RATE_8KHZ = 0,
+	HII2S_FS_RATE_16KHZ = 1,
+	HII2S_FS_RATE_32KHZ = 2,
+	HII2S_FS_RATE_48KHZ = 4,
+	HII2S_FS_RATE_96KHZ = 5,
+	HII2S_FS_RATE_192KHZ = 6,
+};
+
+#define HI_ASP_CFG_R_RST_CTRLEN_REG		0x0
+#define HI_ASP_CFG_R_RST_CTRLDIS_REG		0x4
+#define HI_ASP_CFG_R_GATE_EN_REG		0xC
+#define HI_ASP_CFG_R_GATE_DIS_REG		0x10
+#define HI_ASP_CFG_R_GATE_CLKEN_REG		0x14
+#define HI_ASP_CFG_R_GATE_CLKSTAT_REG		0x18
+#define HI_ASP_CFG_R_GATE_CLKDIV_EN_REG		0x1C
+#define HI_ASP_CFG_R_CLK1_DIV_REG		0x20
+#define HI_ASP_CFG_R_CLK2_DIV_REG		0x24
+#define HI_ASP_CFG_R_CLK3_DIV_REG		0x28
+#define HI_ASP_CFG_R_CLK4_DIV_REG		0x2C
+#define HI_ASP_CFG_R_CLK5_DIV_REG		0x30
+#define HI_ASP_CFG_R_CLK6_DIV_REG		0x34
+#define HI_ASP_CFG_R_CLK_SEL_REG		0x38
+#define HI_ASP_CFG_R_SEC_REG			0x100
+
+
+#define HI_ASP_SIO_VERSION_REG			(0x3C)
+#define HI_ASP_SIO_MODE_REG			(0x40)
+#define HI_ASP_SIO_INTSTATUS_REG		(0x44)
+#define HI_ASP_SIO_INTCLR_REG			(0x48)
+#define HI_ASP_SIO_I2S_LEFT_XD_REG		(0x4C)
+#define HI_ASP_SIO_I2S_RIGHT_XD_REG		(0x50)
+#define HI_ASP_SIO_I2S_LEFT_RD_REG		(0x54)
+#define HI_ASP_SIO_I2S_RIGHT_RD_REG		(0x58)
+#define HI_ASP_SIO_CT_SET_REG			(0x5C)
+#define HI_ASP_SIO_CT_CLR_REG			(0x60)
+#define HI_ASP_SIO_RX_STA_REG			(0x68)
+#define HI_ASP_SIO_TX_STA_REG			(0x6C)
+#define HI_ASP_SIO_DATA_WIDTH_SET_REG		(0x78)
+#define HI_ASP_SIO_I2S_START_POS_REG		(0x7C)
+#define HI_ASP_SIO_I2S_POS_FLAG_REG		(0x80)
+#define HI_ASP_SIO_SIGNED_EXT_REG		(0x84)
+#define HI_ASP_SIO_I2S_POS_MERGE_EN_REG		(0x88)
+#define HI_ASP_SIO_INTMASK_REG			(0x8C)
+#define HI_ASP_SIO_I2S_DUAL_RX_CHN_REG		(0xA0)
+#define HI_ASP_SIO_I2S_DUAL_TX_CHN_REG		(0xC0)
+
+
+#define HI_ASP_CFG_R_CLK_SEL_EN			BIT(2)
+#define HI_ASP_CFG_R_CLK_SEL			0x140010
+#define HI_ASP_CFG_R_CLK1_DIV_SEL		0xbcdc9a
+#define HI_ASP_CFG_R_CLK4_DIV_SEL		0x00ff000f
+#define HI_ASP_CFG_R_CLK6_DIV_SEL		0x00ff003f
+#define HI_ASP_CFG_SIO_MODE			0
+#define HI_ASP_SIO_MODE_SEL_EN			BIT(0)
+#define HI_ASP_MASK				0xffffffff
+
+#define HI_ASP_SIO_RX_ENABLE			BIT(13)
+#define HI_ASP_SIO_TX_ENABLE			BIT(12)
+#define HI_ASP_SIO_RX_FIFO_DISABLE		BIT(11)
+#define HI_ASP_SIO_TX_FIFO_DISABLE		BIT(10)
+#define HI_ASP_SIO_RX_DATA_MERGE		BIT(9)
+#define HI_ASP_SIO_TX_DATA_MERGE		BIT(8)
+#define HI_ASP_SIO_RX_FIFO_THRESHOLD		(0x5 << 4)
+#define HI_ASP_SIO_TX_FIFO_THRESHOLD		(0xB << 0)
+#define HI_ASP_SIO_RX_FIFO_THRESHOLD_CLR	(0xF << 4)
+#define HI_ASP_SIO_TX_FIFO_THRESHOLD_CLR	(0xF << 0)
+#define HI_ASP_SIO_BURST			(0x4)
+
+
+enum hisi_i2s_formats {
+	HII2S_FORMAT_I2S,
+	HII2S_FORMAT_PCM_STD,
+	HII2S_FORMAT_PCM_USER,
+	HII2S_FORMAT_LEFT_JUST,
+	HII2S_FORMAT_RIGHT_JUST,
+};
+
+#endif/* _HI3660_I2S_H */
diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 9df20768a..41b631271 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -3351,6 +3351,39 @@ int snd_soc_get_dai_id(struct device_node *ep)
 }
 EXPORT_SYMBOL_GPL(snd_soc_get_dai_id);
 
+/**
+ * snd_soc_info_multi_ext - external single mixer info callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to provide information about a single external mixer control.
+ * that accepts multiple input.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_info_multi_ext(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	struct soc_multi_mixer_control *mc =
+		(struct soc_multi_mixer_control *)kcontrol->private_value;
+	int platform_max;
+
+	if (!mc->platform_max)
+		mc->platform_max = mc->max;
+	platform_max = mc->platform_max;
+
+	if (platform_max == 1 && !strnstr(kcontrol->id.name, " Volume", 30))
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	else
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+
+	uinfo->count = mc->count;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = platform_max;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_info_multi_ext);
+
 int snd_soc_get_dai_name(struct of_phandle_args *args,
 				const char **dai_name)
 {
diff --git a/sound/soc/soc-pcm.c b/sound/soc/soc-pcm.c
index cc4e9aa80..8892bf96a 100644
--- a/sound/soc/soc-pcm.c
+++ b/sound/soc/soc-pcm.c
@@ -19,6 +19,7 @@
 #include <linux/workqueue.h>
 #include <linux/export.h>
 #include <linux/debugfs.h>
+#include <linux/dma-mapping.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
@@ -28,6 +29,27 @@
 
 #define DPCM_MAX_BE_USERS	8
 
+/* ASoC no host IO hardware */
+static const struct snd_pcm_hardware no_host_hardware = {
+	.info			= SNDRV_PCM_INFO_MMAP |
+				  SNDRV_PCM_INFO_MMAP_VALID |
+				  SNDRV_PCM_INFO_INTERLEAVED |
+				  SNDRV_PCM_INFO_PAUSE |
+				  SNDRV_PCM_INFO_RESUME,
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE |
+				  SNDRV_PCM_FMTBIT_S32_LE,
+	.period_bytes_min	= PAGE_SIZE >> 2,
+	.period_bytes_max	= PAGE_SIZE >> 1,
+	.periods_min		= 2,
+	.periods_max		= 4,
+	/*
+	 * Increase the max buffer bytes as PAGE_SIZE bytes is
+	 * not enough to encompass all the scenarios sent by
+	 * userspapce.
+	 */
+	.buffer_bytes_max	= PAGE_SIZE * 4,
+};
+
 /**
  * snd_soc_runtime_activate() - Increment active count for PCM runtime components
  * @rtd: ASoC PCM runtime that is activated
@@ -138,6 +160,8 @@ int snd_soc_set_runtime_hwparams(struct snd_pcm_substream *substream,
 	const struct snd_pcm_hardware *hw)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
+	if (!runtime)
+		return 0;
 	runtime->hw.info = hw->info;
 	runtime->hw.formats = hw->formats;
 	runtime->hw.period_bytes_min = hw->period_bytes_min;
@@ -508,6 +532,9 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
 
 	mutex_lock_nested(&rtd->card->pcm_mutex, rtd->card->pcm_subclass);
 
+	if (rtd->dai_link->no_host_mode == SND_SOC_DAI_LINK_NO_HOST)
+		snd_soc_set_runtime_hwparams(substream, &no_host_hardware);
+
 	/* startup the audio subsystem */
 	ret = snd_soc_dai_startup(cpu_dai, substream);
 	if (ret < 0) {
@@ -882,6 +909,16 @@ static int soc_pcm_hw_params(struct snd_pcm_substream *substream,
 	if (ret)
 		goto out;
 
+	/* perform any hw_params fixups */
+	if ((rtd->dai_link->no_host_mode == SND_SOC_DAI_LINK_NO_HOST) &&
+				rtd->dai_link->be_hw_params_fixup) {
+		ret = rtd->dai_link->be_hw_params_fixup(rtd,
+				params);
+		if (ret < 0)
+			dev_err(rtd->card->dev, "ASoC: fixup failed for %s\n",
+				rtd->dai_link->name);
+	}
+
 	if (rtd->dai_link->ops->hw_params) {
 		ret = rtd->dai_link->ops->hw_params(substream, params);
 		if (ret < 0) {
@@ -963,6 +1000,20 @@ static int soc_pcm_hw_params(struct snd_pcm_substream *substream,
 	}
 	component = NULL;
 
+	/* malloc a page for hostless IO */
+	if (rtd->dai_link->no_host_mode == SND_SOC_DAI_LINK_NO_HOST) {
+		substream->dma_buffer.dev.type = SNDRV_DMA_TYPE_DEV;
+		substream->dma_buffer.dev.dev = rtd->dev;
+		substream->dma_buffer.dev.dev->coherent_dma_mask =
+					DMA_BIT_MASK(sizeof(dma_addr_t) * 8);
+		substream->dma_buffer.private_data = NULL;
+
+		arch_setup_dma_ops(substream->dma_buffer.dev.dev,
+				   0, 0, NULL, 0);
+		ret = snd_pcm_lib_malloc_pages(substream, PAGE_SIZE);
+		if (ret < 0)
+			goto component_err;
+	}
 out:
 	mutex_unlock(&rtd->card->pcm_mutex);
 	return ret;
@@ -1045,6 +1096,8 @@ static int soc_pcm_hw_free(struct snd_pcm_substream *substream)
 
 	snd_soc_dai_hw_free(cpu_dai, substream);
 
+	if (rtd->dai_link->no_host_mode == SND_SOC_DAI_LINK_NO_HOST)
+		snd_pcm_lib_free_pages(substream);
 	mutex_unlock(&rtd->card->pcm_mutex);
 	return 0;
 }
@@ -2876,6 +2929,7 @@ int soc_new_pcm(struct snd_soc_pcm_runtime *rtd, int num)
 	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
 	struct snd_soc_rtdcom_list *rtdcom;
 	struct snd_pcm *pcm;
+	struct snd_pcm_str *stream;
 	char new_name[64];
 	int ret = 0, playback = 0, capture = 0;
 	int i;
@@ -2965,6 +3019,22 @@ int soc_new_pcm(struct snd_soc_pcm_runtime *rtd, int num)
 		goto out;
 	}
 
+	/* setup any hostless PCMs - i.e. no host IO is performed */
+	if (rtd->dai_link->no_host_mode) {
+		if (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream) {
+			stream = &pcm->streams[SNDRV_PCM_STREAM_PLAYBACK];
+			stream->substream->hw_no_buffer = 1;
+			snd_soc_set_runtime_hwparams(stream->substream,
+						     &no_host_hardware);
+		}
+		if (pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream) {
+			stream = &pcm->streams[SNDRV_PCM_STREAM_CAPTURE];
+			stream->substream->hw_no_buffer = 1;
+			snd_soc_set_runtime_hwparams(stream->substream,
+						     &no_host_hardware);
+		}
+	}
+
 	/* ASoC PCM operations */
 	if (rtd->dai_link->dynamic) {
 		rtd->ops.open		= dpcm_fe_dai_open;
diff --git a/sound/soc/sprd/Kconfig b/sound/soc/sprd/Kconfig
index 5474fd3de..5e0ac8278 100644
--- a/sound/soc/sprd/Kconfig
+++ b/sound/soc/sprd/Kconfig
@@ -8,7 +8,7 @@ config SND_SOC_SPRD
 	  the Spreadtrum SoCs' Audio interfaces.
 
 config SND_SOC_SPRD_MCDT
-	bool "Spreadtrum multi-channel data transfer support"
+	tristate "Spreadtrum multi-channel data transfer support"
 	depends on SND_SOC_SPRD
 	help
 	  Say y here to enable multi-channel data transfer support. It
diff --git a/sound/soc/sprd/sprd-mcdt.h b/sound/soc/sprd/sprd-mcdt.h
index 9cc7e207a..679e3af3b 100644
--- a/sound/soc/sprd/sprd-mcdt.h
+++ b/sound/soc/sprd/sprd-mcdt.h
@@ -48,7 +48,7 @@ struct sprd_mcdt_chan {
 	struct list_head list;
 };
 
-#ifdef CONFIG_SND_SOC_SPRD_MCDT
+#if IS_ENABLED(CONFIG_SND_SOC_SPRD_MCDT)
 struct sprd_mcdt_chan *sprd_mcdt_request_chan(u8 channel,
 					      enum sprd_mcdt_channel_type type);
 void sprd_mcdt_free_chan(struct sprd_mcdt_chan *chan);
diff --git a/sound/soc/sunxi/Kconfig b/sound/soc/sunxi/Kconfig
index 9cd7009cb..7fcdf7441 100644
--- a/sound/soc/sunxi/Kconfig
+++ b/sound/soc/sunxi/Kconfig
@@ -1,9 +1,35 @@
 # SPDX-License-Identifier: GPL-2.0-only
+# Embedded Codec and Affiliated
+
+# SUNXI Platform DMA
+config SND_SUNXI_SOC
+	depends on ARCH_SUNXI
+	tristate
+
+# Dummy CPU DAI module
+config SND_SUNXI_SOC_CPUDAI
+	depends on ARCH_SUNXI
+	tristate
+
+# SUNXI Codec Embedded
+config SND_SUN50IW10_CODEC
+	tristate
+
+config SND_SUN50IW12_CODEC
+	tristate
+
+config SND_SUN8IW20_CODEC
+	tristate
+
+config SND_SUN20IW1_CODEC
+	tristate
+
 menu "Allwinner SoC Audio support"
 	depends on ARCH_SUNXI || COMPILE_TEST
 
 config SND_SUN4I_CODEC
 	tristate "Allwinner A10 Codec Support"
+	depends on ARCH_SUN4IW1
 	select SND_SOC_GENERIC_DMAENGINE_PCM
 	select REGMAP_MMIO
 	help
@@ -13,6 +39,7 @@ config SND_SUN4I_CODEC
 config SND_SUN8I_CODEC
 	tristate "Allwinner SUN8I audio codec"
 	depends on OF
+	depends on ARCH_SUN8IW1
 	depends on MACH_SUN8I || (ARM64 && ARCH_SUNXI) || COMPILE_TEST
 	select REGMAP_MMIO
 	help
@@ -24,6 +51,7 @@ config SND_SUN8I_CODEC
 config SND_SUN8I_CODEC_ANALOG
 	tristate "Allwinner sun8i Codec Analog Controls Support"
 	depends on MACH_SUN8I || (ARM64 && ARCH_SUNXI) || COMPILE_TEST
+	depends on ARCH_SUN8IW1
 	select SND_SUN8I_ADDA_PR_REGMAP
 	help
 	  Say Y or M if you want to add support for the analog controls for
@@ -32,6 +60,7 @@ config SND_SUN8I_CODEC_ANALOG
 config SND_SUN50I_CODEC_ANALOG
 	tristate "Allwinner sun50i Codec Analog Controls Support"
 	depends on (ARM64 && ARCH_SUNXI) || COMPILE_TEST
+	depends on ARCH_SUN50IW1
 	select SND_SUN8I_ADDA_PR_REGMAP
 	help
 	  Say Y or M if you want to add support for the analog controls for
@@ -39,6 +68,7 @@ config SND_SUN50I_CODEC_ANALOG
 
 config SND_SUN4I_I2S
 	tristate "Allwinner A10 I2S Support"
+	depends on ARCH_SUN4IW1
 	select SND_SOC_GENERIC_DMAENGINE_PCM
 	select REGMAP_MMIO
 	help
@@ -49,6 +79,7 @@ config SND_SUN4I_I2S
 config SND_SUN4I_SPDIF
 	tristate "Allwinner A10 SPDIF Support"
 	depends on OF
+	depends on ARCH_SUN4IW1
 	select SND_SOC_GENERIC_DMAENGINE_PCM
 	select REGMAP_MMIO
 	help
@@ -57,6 +88,154 @@ config SND_SUN4I_SPDIF
 
 config SND_SUN8I_ADDA_PR_REGMAP
 	tristate
+	depends on ARCH_SUN8IW1
 	select REGMAP
 
+# SUNXI CODEC Machine Select
+config SND_SUNXI_SOC_SUN50IW10_CODEC
+	tristate "Allwinner Sun50iw10 Codec Support"
+	select SND_SUNXI_SOC
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	select REGMAP_MMIO
+	select SND_SUN50IW10_CODEC
+	select SND_SUNXI_SOC_CPUDAI
+	depends on ARCH_SUN50IW10
+   help
+	Select Y or M to add support for the Codec embedded in the Allwinner
+	SUN50IW10 and affiliated SoCs.
+
+config SND_SUNXI_SOC_SUN50IW12_CODEC
+	tristate "Allwinner Sun50iw12 Codec Support"
+	select SND_SUNXI_SOC
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	select REGMAP_MMIO
+	select SND_SUN50IW12_CODEC
+	select SND_SUNXI_SOC_CPUDAI
+	depends on ARCH_SUN50IW12
+   help
+	Select Y or M to add support for the Codec embedded in the Allwinner
+	SUN50IW12 and affiliated SoCs.
+
+config SND_SUNXI_SOC_SUN8IW20_CODEC
+	tristate "Allwinner Sun8iw20 Codec Support"
+	select SND_SUNXI_SOC
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	select REGMAP_MMIO
+	select SND_SUN8IW20_CODEC
+	select SND_SUNXI_SOC_CPUDAI
+	depends on ARCH_SUN8IW20
+   help
+	Select Y or M to add support for the Codec embedded in the Allwinner
+	SUN8IW20 and affiliated SoCs.
+
+config SND_SUNXI_SOC_SUN20IW1_CODEC
+	tristate "Allwinner Sun20iw1 Codec Support"
+	select SND_SUNXI_SOC
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	select REGMAP_MMIO
+	select SND_SUN20IW1_CODEC
+	select SND_SUNXI_SOC_CPUDAI
+	depends on ARCH_SUN20IW1
+   help
+	Select Y or M to add support for the Codec embedded in the Allwinner
+	SUN20IW1 and affiliated SoCs.
+
+#SUNXI MACHINE Select
+config SND_SUNXI_SOC_SIMPLE_CARD
+	tristate "Allwinner Audio Simple Card"
+	depends on OF
+	select SND_SIMPLE_CARD_UTILS
+	help
+	  Select Y to enable debug information of allwinner audio driver
+	  If you not sure, Just not select it.
+
+# SUNXI DAUDIO Select
+config SND_SUNXI_SOC_DAUDIO
+	tristate "Allwinner Digital Audio Support"
+	select SND_SUNXI_SOC
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	select REGMAP_MMIO
+	depends on OF
+	depends on SND_SUNXI_SOC_SIMPLE_CARD
+   help
+	Select Y or M to add support for I2S/PCM/TDM Module in the
+	Allwinner SoCs.
+
+# SUNXI DAUDIO ASRC Select
+config SND_SUNXI_SOC_DAUDIO_ASRC
+	tristate "Allwinner Digital Audio ASRC Support"
+	depends on SND_SUNXI_SOC_DAUDIO
+   help
+	Select Y or M to add support for the ASRC Func of the
+	I2S/PCM/TDM Module in the Allwinner SoCs.
+
+# SUNXI HDMIAUDIO Select
+config SND_SUNXI_SOC_SUNXI_HDMIAUDIO
+	tristate "Allwinner HDMI Audio Support"
+	depends on SND_SUNXI_SOC_DAUDIO
+    help
+	Select Y or M to add support for the HDMI Audio Module in the Allwinner
+	SoCs.
+
+# SUNXI SPDIF Select
+config SND_SUNXI_SOC_SPDIF
+	tristate "Allwinner SPDIF Support"
+	select SND_SUNXI_SOC
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	select REGMAP_MMIO
+	depends on OF
+	depends on SND_SUNXI_SOC_SIMPLE_CARD
+    help
+	Select Y or M to add support SPDIF Module in Allwinner
+	SoCs.
+
+# SUNXI SPDIF RX Select
+config SND_SUNXI_SOC_SPDIF_RX_IEC61937
+	tristate "Allwinner SPDIF RX IEC61937 Support"
+	depends on SND_SUNXI_SOC_SPDIF
+    help
+	Select Y or M to add support SPDIF RX IEC-61937 in Allwinner
+	SoCs.
+
+# SUNXI DMIC Select
+config SND_SUNXI_SOC_DMIC
+	tristate "Allwinner DMIC Support"
+	select SND_SUNXI_SOC
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	select REGMAP_MMIO
+	select SND_SOC_DMIC
+	depends on OF
+	depends on SND_SUNXI_SOC_SIMPLE_CARD
+    help
+	Select Y or M to add support DMIC Module in Allwinner
+	SoCs.
+
+config SUNXI_AUDIO_DEBUG
+	bool "Allwinner Audio Debug Support"
+	depends on SND_SUNXI_SOC
+	help
+	  Select Y to enable debug information of allwinner audio driver
+	  If you not sure, Just not select it.
+
+config SUNXI_RX_SYNC
+	bool "Allwinner RX SYNC Support"
+	help
+	  Select Y to enable rx_sync function of allwinner audio driver
+	  If you not sure, Just not select it.
+
 endmenu
+
+menuconfig SND_SUNXI_RPAF
+	tristate "Allwinner SUNXI HiFi DSP Audio Framework"
+	select RPMSG
+	select RPMSG_SUNXI_AMP
+	default n
+    help
+	Select Y or M to enable the sunxi remote process audio framework.
+
+if SND_SUNXI_RPAF
+
+source "sound/soc/sunxi/sunxi-rpaf/component/Kconfig"
+source "sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/Kconfig"
+
+endif
diff --git a/sound/soc/sunxi/Makefile b/sound/soc/sunxi/Makefile
index a86be340a..d7fbcc948 100644
--- a/sound/soc/sunxi/Makefile
+++ b/sound/soc/sunxi/Makefile
@@ -6,3 +6,54 @@ obj-$(CONFIG_SND_SUN8I_CODEC_ANALOG) += sun8i-codec-analog.o
 obj-$(CONFIG_SND_SUN50I_CODEC_ANALOG) += sun50i-codec-analog.o
 obj-$(CONFIG_SND_SUN8I_CODEC) += sun8i-codec.o
 obj-$(CONFIG_SND_SUN8I_ADDA_PR_REGMAP) += sun8i-adda-pr-regmap.o
+
+snd-soc-sunxi-objs := sunxi-pcm.o
+snd-soc-sunxi-simple-card-objs := sunxi-simple-card.o
+snd-soc-sunxi-dummy-cpudai-objs := sunxi-dummy-cpudai.o
+snd-soc-sunxi-spdif-objs := sunxi-spdif.o
+snd-soc-sunxi-dmic-objs := sunxi-dmic.o
+snd-soc-sunxi-daudio-objs := sunxi-daudio.o
+snd-soc-sunxi-hdmi-objs := sunxi-hdmi.o
+
+obj-$(CONFIG_SND_SUNXI_SOC) += snd-soc-sunxi.o
+
+# SUNXI Audio Simple Card Support
+obj-$(CONFIG_SND_SUNXI_SOC_SIMPLE_CARD) += snd-soc-sunxi-simple-card.o
+
+# SUNXI Dummy CPUDAI Support
+obj-$(CONFIG_SND_SUNXI_SOC_CPUDAI) += snd-soc-sunxi-dummy-cpudai.o
+
+# SUNXI SPDIF Support
+obj-$(CONFIG_SND_SUNXI_SOC_SPDIF) += snd-soc-sunxi-spdif.o
+
+# SUNXI DMIC Support
+obj-$(CONFIG_SND_SUNXI_SOC_DMIC) += snd-soc-sunxi-dmic.o
+
+# SUNXI I2S Support
+obj-$(CONFIG_SND_SUNXI_SOC_DAUDIO) += snd-soc-sunxi-daudio.o
+
+# SUNXI HDMIAUDIO Support
+obj-$(CONFIG_SND_SUNXI_SOC_SUNXI_HDMIAUDIO) += snd-soc-sunxi-hdmi.o
+
+# SUNXI Sun50iw10 Codec Support
+obj-$(CONFIG_SND_SUN50IW10_CODEC) += sun50iw10-codec.o
+obj-$(CONFIG_SND_SUNXI_SOC_SUN50IW10_CODEC) += sun50iw10-sndcodec.o
+
+# SUNXI Sun50iw12 Codec Support
+obj-$(CONFIG_SND_SUN50IW12_CODEC) += sun50iw12-codec.o
+obj-$(CONFIG_SND_SUNXI_SOC_SUN50IW12_CODEC) += sun50iw12-sndcodec.o
+
+# SUNXI Sun8iw20 Codec Support
+obj-$(CONFIG_SND_SUN8IW20_CODEC) += sun8iw20-codec.o
+obj-$(CONFIG_SND_SUNXI_SOC_SUN8IW20_CODEC) += sun8iw20-sndcodec.o
+
+# SUNXI Sun20iw1 Codec Support
+obj-$(CONFIG_SND_SUN20IW1_CODEC) += sun20iw1-codec.o
+obj-$(CONFIG_SND_SUNXI_SOC_SUN20IW1_CODEC) += sun20iw1-sndcodec.o
+
+# SUNXI RPAF For DSP
+obj-$(CONFIG_SND_SUNXI_RPAF) += sunxi-rpaf/component/ \
+				sunxi-rpaf/sunxi-hifi/
+
+# SUNXI RX SYNC
+obj-$(CONFIG_SUNXI_RX_SYNC) += sunxi-rx-sync.o
diff --git a/sound/soc/sunxi/sun20iw1-codec.c b/sound/soc/sunxi/sun20iw1-codec.c
new file mode 100644
index 000000000..fa6b96e8a
--- /dev/null
+++ b/sound/soc/sunxi/sun20iw1-codec.c
@@ -0,0 +1,2692 @@
+/*
+ * sound\soc\sunxi\sun20iw1-codec.c
+ * (C) Copyright 2021-2026
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * yumingfeng <yumingfeng@allwinnertech.com>
+ * luguofang <luguofang@allwinnertech.com>
+ * Dby <Dby@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/pm.h>
+#include <linux/regulator/consumer.h>
+#include <linux/pinctrl/pinctrl-sunxi.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
+#include <linux/reset.h>
+#include <asm/dma.h>
+#include <sound/pcm.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/core.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <sound/tlv.h>
+#include <linux/sunxi-gpio.h>
+#include <linux/sunxi-sid.h>
+
+#include "sun20iw1-codec.h"
+
+#define LOG_ERR(fmt, arg...)	pr_err("[AUDIOCODEC][%s][%d]:" fmt "\n", __func__, __LINE__, ##arg)
+#define LOG_WARN(fmt, arg...)	pr_warn("[AUDIOCODEC][%s][%d]:" fmt "\n", __func__, __LINE__, ##arg)
+#define LOG_INFO(fmt, arg...)	pr_info("[AUDIOCODEC][%s][%d]:" fmt "\n", __func__, __LINE__, ##arg)
+#define LOG_DEBUG(fmt, arg...)	pr_debug("[AUDIOCODEC][%s][%d]:" fmt "\n", __func__, __LINE__, ##arg)
+
+/* digital audio process function */
+enum sunxi_hw_dap {
+	DAP_HP_EN = 0x1,
+	DAP_SPK_EN = 0x2,
+	/* DAP_HP_EN | DAP_SPK_EN */
+	DAP_HPSPK_EN = 0x3,
+};
+
+static const struct sample_rate sample_rate_conv[] = {
+	{8000,   5},
+	{11025,  4},
+	{12000,  4},
+	{16000,  3},
+	{22050,  2},
+	{24000,  2},
+	{32000,  1},
+	{44100,  0},
+	{48000,  0},
+	{96000,  7},
+	{192000, 6},
+};
+
+static const DECLARE_TLV_DB_SCALE(digital_tlv, -7424, 116, 0);
+static const DECLARE_TLV_DB_SCALE(dac_vol_tlv, -11925, 75, 0);
+static const DECLARE_TLV_DB_SCALE(adc_vol_tlv, -11925, 75, 0);
+static const DECLARE_TLV_DB_SCALE(mic_gain_tlv, 0, 100, 0);
+static const DECLARE_TLV_DB_SCALE(fmin_gain_tlv, 0, 600, 0);
+static const DECLARE_TLV_DB_SCALE(linein_gain_tlv, 0, 600, 0);
+static const DECLARE_TLV_DB_SCALE(headphone_gain_tlv, -4200, 600, 0);
+static const unsigned int lineout_tlv[] = {
+	TLV_DB_RANGE_HEAD(2),
+	0, 1, TLV_DB_SCALE_ITEM(0, 0, 1),
+	2, 31, TLV_DB_SCALE_ITEM(-4350, 150, 1),
+};
+
+static struct reg_label reg_labels[] = {
+	REG_LABEL(SUNXI_DAC_DPC),
+	REG_LABEL(SUNXI_DAC_VOL_CTRL),
+	REG_LABEL(SUNXI_DAC_FIFOC),
+	REG_LABEL(SUNXI_DAC_FIFOS),
+	REG_LABEL(SUNXI_DAC_TXDATA),
+	REG_LABEL(SUNXI_DAC_CNT),
+	REG_LABEL(SUNXI_DAC_DG),
+	REG_LABEL(SUNXI_ADC_FIFOC),
+	REG_LABEL(SUNXI_ADC_VOL_CTRL),
+	REG_LABEL(SUNXI_ADC_FIFOS),
+	REG_LABEL(SUNXI_ADC_RXDATA),
+	REG_LABEL(SUNXI_ADC_CNT),
+	REG_LABEL(SUNXI_ADC_DG),
+	REG_LABEL(SUNXI_ADC_DIG_CTRL),
+	REG_LABEL(SUNXI_VRA1SPEEDUP_DOWN_CTRL),
+#ifdef SUNXI_CODEC_DAP_ENABLE
+	REG_LABEL(SUNXI_DAC_DAP_CTL),
+	REG_LABEL(SUNXI_ADC_DAP_CTL),
+#endif
+	REG_LABEL(SUNXI_ADC1_REG),
+	REG_LABEL(SUNXI_ADC2_REG),
+	REG_LABEL(SUNXI_ADC3_REG),
+	REG_LABEL(SUNXI_DAC_REG),
+	REG_LABEL(SUNXI_MICBIAS_REG),
+	REG_LABEL(SUNXI_RAMP_REG),
+	REG_LABEL(SUNXI_BIAS_REG),
+	REG_LABEL(SUNXI_HMIC_CTRL),
+	REG_LABEL(SUNXI_HMIC_STS),
+	REG_LABEL(SUNXI_HP2_REG),
+	REG_LABEL(SUNXI_POWER_REG),
+	REG_LABEL(SUNXI_ADC_CUR_REG),
+	REG_LABEL_END,
+};
+
+#ifdef SUNXI_CODEC_DAP_ENABLE
+static void adcdrc_config(struct snd_soc_component *component)
+{
+	/* Enable DRC gain Min and Max limit, detect noise, Using Peak Filter */
+	snd_soc_component_update_bits(component, SUNXI_ADC_DRC_CTRL,
+		((0x1 << ADC_DRC_DELAY_BUF_EN) |
+		(0x1 << ADC_DRC_GAIN_MAX_EN) | (0x1 << ADC_DRC_GAIN_MIN_EN) |
+		(0x1 << ADC_DRC_NOISE_DET_EN) |
+		(0x1 << ADC_DRC_SIGNAL_SEL) |
+		(0x1 << ADC_DRC_LT_EN) | (0x1 << ADC_DRC_ET_EN)),
+		((0x1 << ADC_DRC_DELAY_BUF_EN) |
+		(0x1 << ADC_DRC_GAIN_MAX_EN) | (0x1 << ADC_DRC_GAIN_MIN_EN) |
+		(0x1 << ADC_DRC_NOISE_DET_EN) |
+		(0x1 << ADC_DRC_SIGNAL_SEL) |
+		(0x1 << ADC_DRC_LT_EN) | (0x1 << ADC_DRC_ET_EN)));
+
+	/* Left peak filter attack time */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LPFHAT, (0x000B77F0 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LPFLAT, 0x000B77F0 & 0xFFFF);
+	/* Right peak filter attack time */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_RPFHAT, (0x000B77F0 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_RPFLAT, 0x000B77F0 & 0xFFFF);
+	/* Left peak filter release time */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LPFHRT, (0x00FFE1F8 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LPFLRT, 0x00FFE1F8 & 0xFFFF);
+	/* Right peak filter release time */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_RPFHRT, (0x00FFE1F8 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_RPFLRT, 0x00FFE1F8 & 0xFFFF);
+
+	/* Left RMS filter attack time */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LPFHAT, (0x00012BB0 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LPFLAT, 0x00012BB0 & 0xFFFF);
+	/* Right RMS filter attack time */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_RPFHAT, (0x00012BB0 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_RPFLAT, 0x00012BB0 & 0xFFFF);
+
+	/* OPL */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_HOPL, (0xFF641741 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LOPL, 0xFF641741 & 0xFFFF);
+	/* OPC */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_HOPC, (0xFC0380F3 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LOPC, 0xFC0380F3 & 0xFFFF);
+	/* OPE */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_HOPE, (0xF608C25F >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LOPE, 0xF608C25F & 0xFFFF);
+	/* LT */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_HLT, (0x035269E0 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LLT, 0x035269E0 & 0xFFFF);
+	/* CT */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_HCT, (0x06B3002C >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LCT, 0x06B3002C & 0xFFFF);
+	/* ET */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_HET, (0x0A139682 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LET, 0x0A139682 & 0xFFFF);
+	/* Ki */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_HKI, (0x00222222 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LKI, 0x00222222 & 0xFFFF);
+	/* Kc */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_HKC, (0x01000000 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LKC, 0x01000000 & 0xFFFF);
+	/* Kn */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_HKN, (0x01C53EF0 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LKN, 0x01C53EF0 & 0xFFFF);
+	/* Ke */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_HKE, (0x04234F68 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LKE, 0x04234F68 & 0xFFFF);
+
+	/* smooth filter attack time */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_SFHAT, (0x00017665 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_SFLAT, 0x00017665 & 0xFFFF);
+	/* gain smooth filter release time */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_SFHRT, (0x00000F04 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_SFLRT, 0x00000F04 & 0xFFFF);
+
+	/* gain max setting */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_MXGHS, (0x69E0F95B >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_MXGLS, 0x69E0F95B & 0xFFFF);
+
+	/* gain min setting */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_MNGHS, (0xF95B2C3F >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_MNGLS, 0xF95B2C3F & 0xFFFF);
+
+	/* smooth filter release and attack time */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_EPSHC, (0x00025600 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_EPSHC, 0x00025600 & 0xFFFF);
+}
+
+static void adcdrc_enable(struct snd_soc_component *component, bool on)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct codec_dap *adc_dap = &sunxi_codec->adc_dap;
+
+	if (on) {
+		if (adc_dap->drc_enable++ == 0) {
+			snd_soc_component_update_bits(component, SUNXI_ADC_DAP_CTL,
+				(0x1 << ADC_DRC0_EN), (0x1 << ADC_DRC0_EN));
+			snd_soc_component_update_bits(component, SUNXI_ADC_DAP_CTL,
+				(0x1 << ADC_DRC1_EN), (0x1 << ADC_DRC1_EN));
+			if (sunxi_codec->adc_dap_enable++ == 0) {
+				snd_soc_component_update_bits(component, SUNXI_ADC_DAP_CTL,
+					(0x1 << ADC_DAP0_EN), (0x1 << ADC_DAP0_EN));
+				snd_soc_component_update_bits(component, SUNXI_ADC_DAP_CTL,
+					(0x1 << ADC_DAP1_EN), (0x1 << ADC_DAP1_EN));
+			}
+		}
+	} else {
+		if (--adc_dap->drc_enable <= 0) {
+			adc_dap->drc_enable = 0;
+			if (--sunxi_codec->adc_dap_enable <= 0) {
+				sunxi_codec->adc_dap_enable = 0;
+				snd_soc_component_update_bits(component, SUNXI_ADC_DAP_CTL,
+					(0x1 << ADC_DAP0_EN), (0x0 << ADC_DAP0_EN));
+				snd_soc_component_update_bits(component, SUNXI_ADC_DAP_CTL,
+					(0x1 << ADC_DAP1_EN), (0x0 << ADC_DAP1_EN));
+			}
+			snd_soc_component_update_bits(component, SUNXI_ADC_DAP_CTL,
+				(0x1 << ADC_DRC0_EN), (0x0 << ADC_DRC0_EN));
+			snd_soc_component_update_bits(component, SUNXI_ADC_DAP_CTL,
+				(0x1 << ADC_DRC1_EN), (0x0 << ADC_DRC1_EN));
+		}
+	}
+}
+
+static void adchpf_config(struct snd_soc_component *component)
+{
+	/* HPF */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_HHPFC, (0xFFFAC1 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LHPFC, 0xFFFAC1 & 0xFFFF);
+}
+
+static void adchpf_enable(struct snd_soc_component *component, bool on)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct codec_dap *adc_dap = &sunxi_codec->adc_dap;
+
+	if (on) {
+		if (adc_dap->hpf_enable++ == 0) {
+			snd_soc_component_update_bits(component, SUNXI_ADC_DAP_CTL,
+				(0x1 << ADC_HPF0_EN), (0x1 << ADC_HPF0_EN));
+			snd_soc_component_update_bits(component, SUNXI_ADC_DAP_CTL,
+				(0x1 << ADC_HPF1_EN), (0x1 << ADC_HPF1_EN));
+			if (sunxi_codec->adc_dap_enable++ == 0) {
+				snd_soc_component_update_bits(component, SUNXI_ADC_DAP_CTL,
+					(0x1 << ADC_DAP0_EN), (0x1 << ADC_DAP0_EN));
+				snd_soc_component_update_bits(component, SUNXI_ADC_DAP_CTL,
+					(0x1 << ADC_DAP1_EN), (0x1 << ADC_DAP1_EN));
+			}
+		}
+	} else {
+		if (--adc_dap->hpf_enable <= 0) {
+			adc_dap->hpf_enable = 0;
+			if (--sunxi_codec->adc_dap_enable <= 0) {
+				sunxi_codec->adc_dap_enable = 0;
+				snd_soc_component_update_bits(component, SUNXI_ADC_DAP_CTL,
+					(0x1 << ADC_DAP0_EN), (0x0 << ADC_DAP0_EN));
+				snd_soc_component_update_bits(component, SUNXI_ADC_DAP_CTL,
+					(0x1 << ADC_DAP1_EN), (0x0 << ADC_DAP1_EN));
+			}
+			snd_soc_component_update_bits(component, SUNXI_ADC_DAP_CTL,
+				(0x1 << ADC_HPF0_EN), (0x0 << ADC_HPF0_EN));
+			snd_soc_component_update_bits(component, SUNXI_ADC_DAP_CTL,
+				(0x1 << ADC_HPF1_EN), (0x0 << ADC_HPF1_EN));
+		}
+	}
+}
+
+static void dacdrc_config(struct snd_soc_component *component)
+{
+	/* Left peak filter attack time */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LPFHAT, (0x000B77BF >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LPFLAT, 0x000B77BF & 0xFFFF);
+	/* Right peak filter attack time */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_RPFHAT, (0x000B77F0 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_RPFLAT, 0x000B77F0 & 0xFFFF);
+
+	/* Left peak filter release time */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LPFHRT, (0x00FFE1F8 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LPFLRT, 0x00FFE1F8 & 0xFFFF);
+	/* Right peak filter release time */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_RPFHRT, (0x00FFE1F8 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_RPFLRT, 0x00FFE1F8 & 0xFFFF);
+
+	/* Left RMS filter attack time */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LRMSHAT, (0x00012BB0 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LRMSLAT, 0x00012BB0 & 0xFFFF);
+	/* Right RMS filter attack time */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_RRMSHAT, (0x00012BB0 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_RRMSLAT, 0x00012BB0 & 0xFFFF);
+
+	/* smooth filter attack time */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_SFHAT, (0x00017665 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_SFLAT, 0x00017665 & 0xFFFF);
+	/* gain smooth filter release time */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_SFHRT, (0x00000F04 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_SFLRT, 0x00000F04 & 0xFFFF);
+
+	/* OPL */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_HOPL, (0xFE56CB10 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LOPL, 0xFE56CB10 & 0xFFFF);
+	/* OPC */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_HOPC, (0xFB04612F >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LOPC, 0xFB04612F & 0xFFFF);
+	/* OPE */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_HOPE, (0xF608C25F >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LOPE, 0xF608C25F & 0xFFFF);
+	/* LT */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_HLT, (0x035269E0 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LLT, 0x035269E0 & 0xFFFF);
+	/* CT */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_HCT, (0x06B3002C >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LCT, 0x06B3002C & 0xFFFF);
+	/* ET */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_HET, (0x0A139682 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LET, 0x0A139682 & 0xFFFF);
+	/* Ki */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_HKI, (0x00400000 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LKI, 0x00400000 & 0xFFFF);
+	/* Kc */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_HKC, (0x00FBCDA5 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LKC, 0x00FBCDA5 & 0xFFFF);
+	/* Kn */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_HKN, (0x0179B472 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LKN, 0x0179B472 & 0xFFFF);
+	/* Ke */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_HKE, (0x04234F68 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LKE, 0x04234F68 & 0xFFFF);
+	/* MXG */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_MXGHS, (0x035269E0 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_MXGLS, 0x035269E0 & 0xFFFF);
+	/* MNG */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_MNGHS, (0xF95B2C3F >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_MNGLS, 0xF95B2C3F & 0xFFFF);
+	/* EPS */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_EPSHC, (0x00025600 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_EPSLC, 0x00025600 & 0xFFFF);
+}
+
+static void dacdrc_enable(struct snd_soc_component *component, bool on)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct codec_dap *dac_dap = &sunxi_codec->dac_dap;
+
+	if (on) {
+		if (dac_dap->drc_enable++ == 0) {
+			/* detect noise when ET enable */
+			snd_soc_component_update_bits(component, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_NOISE_DET_EN),
+				(0x1 << DAC_DRC_NOISE_DET_EN));
+
+			/* 0x0:RMS filter; 0x1:Peak filter */
+			snd_soc_component_update_bits(component, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_SIGNAL_SEL),
+				(0x1 << DAC_DRC_SIGNAL_SEL));
+
+			snd_soc_component_update_bits(component, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_GAIN_MAX_EN),
+				(0x1 << DAC_DRC_GAIN_MAX_EN));
+
+			snd_soc_component_update_bits(component, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_GAIN_MIN_EN),
+				(0x1 << DAC_DRC_GAIN_MIN_EN));
+
+			/* delay function enable */
+			snd_soc_component_update_bits(component, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_DELAY_BUF_EN),
+				(0x1 << DAC_DRC_DELAY_BUF_EN));
+
+			snd_soc_component_update_bits(component, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_LT_EN),
+				(0x1 << DAC_DRC_LT_EN));
+			snd_soc_component_update_bits(component, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_ET_EN),
+				(0x1 << DAC_DRC_ET_EN));
+
+			snd_soc_component_update_bits(component, SUNXI_DAC_DAP_CTL,
+				(0x1 << DDAP_DRC_EN),
+				(0x1 << DDAP_DRC_EN));
+
+			if (sunxi_codec->dac_dap_enable++ == 0)
+				snd_soc_component_update_bits(component, SUNXI_DAC_DAP_CTL,
+					(0x1 << DDAP_EN), (0x1 << DDAP_EN));
+		}
+	} else {
+		if (--dac_dap->drc_enable <= 0) {
+			dac_dap->drc_enable = 0;
+			if (--sunxi_codec->dac_dap_enable <= 0) {
+				sunxi_codec->dac_dap_enable = 0;
+				snd_soc_component_update_bits(component, SUNXI_DAC_DAP_CTL,
+					(0x1 << DDAP_EN), (0x0 << DDAP_EN));
+			}
+
+			snd_soc_component_update_bits(component, SUNXI_DAC_DAP_CTL,
+				(0x1 << DDAP_DRC_EN),
+				(0x0 << DDAP_DRC_EN));
+
+			/* detect noise when ET enable */
+			snd_soc_component_update_bits(component, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_NOISE_DET_EN),
+				(0x0 << DAC_DRC_NOISE_DET_EN));
+
+			/* 0x0:RMS filter; 0x1:Peak filter */
+			snd_soc_component_update_bits(component, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_SIGNAL_SEL),
+				(0x0 << DAC_DRC_SIGNAL_SEL));
+
+			/* delay function enable */
+			snd_soc_component_update_bits(component, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_DELAY_BUF_EN),
+				(0x0 << DAC_DRC_DELAY_BUF_EN));
+
+			snd_soc_component_update_bits(component, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_GAIN_MAX_EN),
+				(0x0 << DAC_DRC_GAIN_MAX_EN));
+			snd_soc_component_update_bits(component, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_GAIN_MIN_EN),
+				(0x0 << DAC_DRC_GAIN_MIN_EN));
+
+			snd_soc_component_update_bits(component, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_LT_EN),
+				(0x0 << DAC_DRC_LT_EN));
+			snd_soc_component_update_bits(component, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_ET_EN),
+				(0x0 << DAC_DRC_ET_EN));
+		}
+	}
+}
+
+static void dachpf_config(struct snd_soc_component *component)
+{
+	/* HPF */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_HHPFC, (0xFFFAC1 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LHPFC, 0xFFFAC1 & 0xFFFF);
+}
+
+static void dachpf_enable(struct snd_soc_component *component, bool on)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct codec_dap *dac_dap = &sunxi_codec->dac_dap;
+
+	if (on) {
+		if (dac_dap->hpf_enable++ == 0) {
+			snd_soc_component_update_bits(component, SUNXI_DAC_DAP_CTL,
+				(0x1 << DDAP_HPF_EN), (0x1 << DDAP_HPF_EN));
+
+			if (sunxi_codec->dac_dap_enable++ == 0)
+				snd_soc_component_update_bits(component, SUNXI_DAC_DAP_CTL,
+					(0x1 << DDAP_EN), (0x1 << DDAP_EN));
+		}
+	} else {
+		if (--dac_dap->hpf_enable <= 0) {
+			dac_dap->hpf_enable = 0;
+			if (--sunxi_codec->dac_dap_enable <= 0) {
+				sunxi_codec->dac_dap_enable = 0;
+				snd_soc_component_update_bits(component, SUNXI_DAC_DAP_CTL,
+					(0x1 << DDAP_EN), (0x0 << DDAP_EN));
+			}
+
+			snd_soc_component_update_bits(component, SUNXI_DAC_DAP_CTL,
+				(0x1 << DDAP_HPF_EN),
+				(0x0 << DDAP_HPF_EN));
+		}
+	}
+}
+#endif
+
+int sunxi_get_gain_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	unsigned int invert = mc->invert;
+	unsigned int shift = mc->shift;
+	int max = mc->max;
+	int min = mc->min;
+	u32 val_tmp;
+
+	switch (shift) {
+	case MIC1_GAIN_SHIFT:
+		val_tmp = sunxi_codec->mic1gain;
+	break;
+	case MIC2_GAIN_SHIFT:
+		val_tmp = sunxi_codec->mic2gain;
+	break;
+	case MIC3_GAIN_SHIFT:
+		val_tmp = sunxi_codec->mic3gain;
+	break;
+	case HP_GAIN_SHIFT:
+		val_tmp = sunxi_codec->headphonegain;
+	break;
+	default:
+		LOG_ERR("the gain is null");
+	break;
+	}
+
+	if (val_tmp > max || val_tmp < min)
+		return -1;
+
+	ucontrol->value.integer.value[0] = val_tmp - min;
+	if (invert)
+		ucontrol->value.integer.value[0] =
+			max - ucontrol->value.integer.value[0];
+
+	return 0;
+}
+
+int sunxi_put_gain_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	unsigned int invert = mc->invert;
+	unsigned int shift = mc->shift;
+	int max = mc->max;
+	int min = mc->min;
+	u32 val_tmp;
+
+	val_tmp = ucontrol->value.integer.value[0] + min;
+	if (invert)
+		val_tmp = max - val_tmp;
+
+	switch (shift) {
+	case MIC1_GAIN_SHIFT:
+		sunxi_codec->mic1gain = val_tmp;
+		if (sunxi_codec->mic1gain_now)
+			snd_soc_component_update_bits(component,
+				SUNXI_ADC1_REG,
+				(0x1F<<ADC1_PGA_GAIN_CTRL),
+				(sunxi_codec->mic1gain<<ADC1_PGA_GAIN_CTRL));
+	break;
+	case MIC2_GAIN_SHIFT:
+		sunxi_codec->mic2gain = val_tmp;
+		if (sunxi_codec->mic2gain_now)
+			snd_soc_component_update_bits(component,
+				SUNXI_ADC2_REG,
+				(0x1F<<ADC2_PGA_GAIN_CTRL),
+				(sunxi_codec->mic2gain<<ADC2_PGA_GAIN_CTRL));
+	break;
+	case MIC3_GAIN_SHIFT:
+		sunxi_codec->mic3gain = val_tmp;
+		if (sunxi_codec->mic3gain_now)
+			snd_soc_component_update_bits(component,
+				SUNXI_ADC3_REG,
+				(0x1F<<ADC3_PGA_GAIN_CTRL),
+				(sunxi_codec->mic3gain<<ADC3_PGA_GAIN_CTRL));
+	break;
+	case HP_GAIN_SHIFT:
+		sunxi_codec->headphonegain = val_tmp;
+		if (sunxi_codec->hpgain_now)
+			snd_soc_component_update_bits(component,
+				SUNXI_HP2_REG,
+				0x7 << HEADPHONE_GAIN,
+				sunxi_codec->headphonegain << HEADPHONE_GAIN);
+	break;
+	default:
+		LOG_ERR("the gain is null");
+	break;
+	}
+
+	return 0;
+}
+
+static int sunxi_codec_playback_event(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *k, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+
+	switch (event) {
+	case	SND_SOC_DAPM_PRE_PMU:
+		/* DACL to left channel LINEOUT Mute control 0:mute 1: not mute */
+		msleep(30);
+		snd_soc_component_update_bits(component, SUNXI_DAC_REG,
+				(0x1 << DACLMUTE) | (0x1 << DACRMUTE),
+				(0x1 << DACLMUTE) | (0x1 << DACRMUTE));
+		snd_soc_component_update_bits(component, SUNXI_DAC_DPC,
+				(0x1<<EN_DAC), (0x1<<EN_DAC));
+		break;
+	case	SND_SOC_DAPM_POST_PMD:
+		snd_soc_component_update_bits(component, SUNXI_DAC_DPC,
+				(0x1<<EN_DAC), (0x0<<EN_DAC));
+		/* DACL to left channel LINEOUT Mute control 0:mute 1: not mute */
+		snd_soc_component_update_bits(component, SUNXI_DAC_REG,
+				(0x1 << DACLMUTE) | (0x1 << DACRMUTE),
+				(0x0 << DACLMUTE) | (0x0 << DACRMUTE));
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+#ifdef SUNXI_CODEC_HUB_ENABLE
+static int sunxi_codec_get_hub_mode(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	unsigned int reg_val;
+
+	reg_val = snd_soc_component_read32(component, SUNXI_DAC_DPC);
+
+	ucontrol->value.integer.value[0] =
+				((reg_val & (0x1 << DAC_HUB_EN)) ? 1 : 0);
+
+	return 0;
+}
+
+static int sunxi_codec_set_hub_mode(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+
+	switch (ucontrol->value.integer.value[0]) {
+	case	0:
+		snd_soc_component_update_bits(component, SUNXI_DAC_DPC,
+				(0x1 << DAC_HUB_EN), (0x0 << DAC_HUB_EN));
+		break;
+	case	1:
+		snd_soc_component_update_bits(component, SUNXI_DAC_DPC,
+				(0x1 << DAC_HUB_EN), (0x1 << DAC_HUB_EN));
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/* sunxi codec hub mdoe select */
+static const char * const sunxi_codec_hub_function[] = {
+				"hub_disable", "hub_enable"};
+
+static const struct soc_enum sunxi_codec_hub_mode_enum[] = {
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(sunxi_codec_hub_function),
+			sunxi_codec_hub_function),
+};
+#endif
+
+#ifdef SUNXI_CODEC_ADCSWAP_ENABLE
+static int sunxi_codec_get_adcswap1_mode(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	unsigned int reg_val;
+
+	reg_val = snd_soc_component_read32(component, SUNXI_ADC_DG);
+
+	ucontrol->value.integer.value[0] =
+				((reg_val & (0x1 << AD_SWP1)) ? 1 : 0);
+
+	return 0;
+}
+
+static int sunxi_codec_set_adcswap1_mode(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+
+	switch (ucontrol->value.integer.value[0]) {
+	case	0:
+		snd_soc_component_update_bits(component, SUNXI_ADC_DG,
+				(0x1 << AD_SWP1), (0x0 << AD_SWP1));
+		break;
+	case	1:
+		snd_soc_component_update_bits(component, SUNXI_ADC_DG,
+				(0x1 << AD_SWP1), (0x1 << AD_SWP1));
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sunxi_codec_get_adcswap2_mode(struct snd_kcontrol *kcontrol,
+					 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	unsigned int reg_val;
+
+	reg_val = snd_soc_component_read32(component, SUNXI_ADC_DG);
+
+	ucontrol->value.integer.value[0] =
+				((reg_val & (0x1 << AD_SWP2)) ? 1 : 0);
+
+	return 0;
+}
+
+static int sunxi_codec_set_adcswap2_mode(struct snd_kcontrol *kcontrol,
+					 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+
+	switch (ucontrol->value.integer.value[0]) {
+	case	0:
+		snd_soc_component_update_bits(component, SUNXI_ADC_DG,
+				(0x1 << AD_SWP2), (0x0 << AD_SWP2));
+		break;
+	case	1:
+		snd_soc_component_update_bits(component, SUNXI_ADC_DG,
+				(0x1 << AD_SWP2), (0x1 << AD_SWP2));
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/* sunxi codec adc swap func */
+static const char * const sunxi_codec_adcswap_function[] = {
+				"Off", "On"};
+
+static const struct soc_enum sunxi_codec_adcswap_func_enum[] = {
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(sunxi_codec_adcswap_function),
+			sunxi_codec_adcswap_function),
+};
+#endif
+
+static int sunxi_codec_hpspeaker_event(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *k, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct codec_spk_config *spk_cfg = &(sunxi_codec->spk_config);
+	struct codec_hw_config *hw_cfg = &(sunxi_codec->hw_config);
+
+	switch (event) {
+	case	SND_SOC_DAPM_POST_PMU:
+#ifdef SUNXI_CODEC_DAP_ENABLE
+		if (hw_cfg->dacdrc_cfg & DAP_SPK_EN)
+			dacdrc_enable(component, 1);
+		else if (hw_cfg->dacdrc_cfg & DAP_HP_EN)
+			dacdrc_enable(component, 0);
+
+		if (hw_cfg->dachpf_cfg & DAP_SPK_EN)
+			dachpf_enable(component, 1);
+		else if (hw_cfg->dachpf_cfg & DAP_HP_EN)
+			dachpf_enable(component, 0);
+#endif
+		if (spk_cfg->used) {
+			gpio_direction_output(spk_cfg->spk_gpio, 1);
+			gpio_set_value(spk_cfg->spk_gpio, spk_cfg->pa_level);
+			/* time delay to wait spk pa work fine */
+			msleep(spk_cfg->pa_msleep);
+		}
+		break;
+	case	SND_SOC_DAPM_PRE_PMD:
+		if (spk_cfg->used)
+			gpio_set_value(spk_cfg->spk_gpio, !(spk_cfg->pa_level));
+#ifdef SUNXI_CODEC_DAP_ENABLE
+		if (hw_cfg->dacdrc_cfg & DAP_SPK_EN)
+			dacdrc_enable(component, 0);
+		if (hw_cfg->dacdrc_cfg & DAP_SPK_EN)
+			dachpf_enable(component, 0);
+#endif
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int sunxi_codec_headphone_event(struct snd_soc_dapm_widget *w,
+			struct snd_kcontrol *k,	int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct codec_hw_config *hw_cfg = &(sunxi_codec->hw_config);
+	unsigned int reg_val;
+
+	switch (event) {
+	case SND_SOC_DAPM_POST_PMU:
+	sunxi_codec->hpgain_now = 1;
+#ifdef SUNXI_CODEC_DAP_ENABLE
+	if (hw_cfg->dacdrc_cfg & DAP_HP_EN)
+		dacdrc_enable(component, 1);
+	if (hw_cfg->dachpf_cfg & DAP_HP_EN)
+		dachpf_enable(component, 1);
+#endif
+	/* In order to ensure that the hpout pop for B chip SOC,
+	 * the B chip SOC needs to disable RMC_EN and enable RD_EN
+	 * when up HPOUT (whether LINEOUT use).
+	 */
+	if (sunxi_get_soc_ver() & 0x7) {
+		snd_soc_component_update_bits(component, SUNXI_RAMP_REG,
+				(0x1 << RMC_EN), (0x0 << RMC_EN));
+		snd_soc_component_update_bits(component, SUNXI_RAMP_REG,
+				(0x1 << RD_EN), (0x1 << RD_EN));
+		msleep(100);
+	} else {
+		snd_soc_component_update_bits(component, SUNXI_HP2_REG,
+				(0x1 << HPFB_BUF_EN), (0x1 << HPFB_BUF_EN));
+		snd_soc_component_update_bits(component, SUNXI_HP2_REG,
+				(0x1 << HP_DRVEN), (0x1 << HP_DRVEN));
+		snd_soc_component_update_bits(component, SUNXI_HP2_REG,
+				(0x1 << HP_DRVOUTEN), (0x1 << HP_DRVOUTEN));
+		snd_soc_component_update_bits(component, SUNXI_HP2_REG,
+				(0x1 << RSWITCH), (0x1 << RSWITCH));
+		snd_soc_component_update_bits(component, SUNXI_HP2_REG,
+				(0x1 << HPFB_IN_EN), (0x1 << HPFB_IN_EN));
+		snd_soc_component_update_bits(component, SUNXI_HP2_REG,
+				(0x1 << RAMP_OUT_EN), (0x1 << RAMP_OUT_EN));
+		snd_soc_component_update_bits(component, SUNXI_POWER_REG,
+				(0x1 << HPLDO_EN), (0x1 << HPLDO_EN));
+	}
+		break;
+	case SND_SOC_DAPM_PRE_PMD:
+	sunxi_codec->hpgain_now = 0;
+
+	/* In order to ensure that the hpout pop for B chip SOC,
+	 * the B chip SOC needs to enable RMC_EN and disable RD_EN
+	 * when down HPOUT and LINEOUT useing.
+	 */
+	if (sunxi_get_soc_ver() & 0x7) {
+		/* if lineout playing, enable RMC_EN */
+		reg_val = snd_soc_component_read32(component, SUNXI_DAC_REG);
+		if ((reg_val & (0x1 << LINEOUTLEN)) || (reg_val & (0x1 << LINEOUTREN)))
+			snd_soc_component_update_bits(component, SUNXI_RAMP_REG,
+					(0x1 << RMC_EN), (0x1 << RMC_EN));
+
+		snd_soc_component_update_bits(component, SUNXI_RAMP_REG,
+				(0x1 << RD_EN), (0x0 << RD_EN));
+		msleep(100);
+	} else {
+		snd_soc_component_update_bits(component, SUNXI_POWER_REG,
+				(0x1 << HPLDO_EN), (0x0 << HPLDO_EN));
+		snd_soc_component_update_bits(component, SUNXI_HP2_REG,
+				(0x1 << HPFB_BUF_EN), (0x0 << HPFB_BUF_EN));
+		snd_soc_component_update_bits(component, SUNXI_HP2_REG,
+				(0x1 << HP_DRVEN), (0x0 << HP_DRVEN));
+		snd_soc_component_update_bits(component, SUNXI_HP2_REG,
+				(0x1 << HP_DRVOUTEN), (0x0 << HP_DRVOUTEN));
+		snd_soc_component_update_bits(component, SUNXI_HP2_REG,
+				(0x1 << RSWITCH), (0x0 << RSWITCH));
+		snd_soc_component_update_bits(component, SUNXI_HP2_REG,
+				(0x1 << HPFB_IN_EN), (0x0 << HPFB_IN_EN));
+		snd_soc_component_update_bits(component, SUNXI_HP2_REG,
+				(0x1 << RAMP_OUT_EN), (0x0 << RAMP_OUT_EN));
+	}
+#ifdef SUNXI_CODEC_DAP_ENABLE
+	if (hw_cfg->dacdrc_cfg & DAP_HP_EN)
+		dacdrc_enable(component, 0);
+	if (hw_cfg->dachpf_cfg & DAP_HP_EN)
+		dachpf_enable(component, 0);
+#endif
+		break;
+	}
+
+	return 0;
+}
+
+static int sunxi_codec_lineout_event(struct snd_soc_dapm_widget *w,
+				  struct snd_kcontrol *k, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct codec_spk_config *spk_cfg = &(sunxi_codec->spk_config);
+	struct codec_hw_config *hw_cfg = &(sunxi_codec->hw_config);
+	unsigned int reg_val;
+
+	switch (event) {
+	case	SND_SOC_DAPM_POST_PMU:
+#ifdef SUNXI_CODEC_DAP_ENABLE
+	if (hw_cfg->dacdrc_cfg & DAP_SPK_EN)
+		dacdrc_enable(component, 1);
+	if (hw_cfg->dachpf_cfg & DAP_SPK_EN)
+		dachpf_enable(component, 1);
+#endif
+
+	/* In order to ensure that the hpout pop for B chip SOC,
+	 * the B chip SOC needs to enable RMC_EN when RD_EN disable (HPOUT no useing).
+	 */
+	if (sunxi_get_soc_ver() & 0x7) {
+		reg_val = snd_soc_component_read32(component, SUNXI_RAMP_REG);
+		if (!(reg_val & (0x1 << RD_EN)))
+			snd_soc_component_update_bits(component, SUNXI_RAMP_REG,
+					(0x1 << RMC_EN), (0x1 << RMC_EN));
+	}
+
+	snd_soc_component_update_bits(component, SUNXI_DAC_REG,
+			(0x1 << LINEOUTLEN), (0x1 << LINEOUTLEN));
+	snd_soc_component_update_bits(component, SUNXI_DAC_REG,
+			(0x1 << LINEOUTREN), (0x1 << LINEOUTREN));
+
+	if (spk_cfg->used) {
+		gpio_direction_output(spk_cfg->spk_gpio, 1);
+		gpio_set_value(spk_cfg->spk_gpio, spk_cfg->pa_level);
+		/* time delay to wait spk pa work fine */
+		msleep(spk_cfg->pa_msleep);
+	}
+		break;
+	case	SND_SOC_DAPM_PRE_PMD:
+	if (spk_cfg->used)
+		gpio_set_value(spk_cfg->spk_gpio, !(spk_cfg->pa_level));
+
+	snd_soc_component_update_bits(component, SUNXI_DAC_REG,
+			(0x1 << LINEOUTLEN), (0x0 << LINEOUTLEN));
+	snd_soc_component_update_bits(component, SUNXI_DAC_REG,
+			(0x1 << LINEOUTREN), (0x0 << LINEOUTREN));
+
+	/* In order to ensure that the hpout pop for B chip SOC,
+	 * the B chip SOC needs to disable RMC_EN when RD_EN disable and disable lineout.
+	 */
+	if (sunxi_get_soc_ver() & 0x7) {
+		reg_val = snd_soc_component_read32(component, SUNXI_RAMP_REG);
+		if (!(reg_val & (0x1 << RD_EN)))
+			snd_soc_component_update_bits(component, SUNXI_RAMP_REG,
+					(0x1 << RMC_EN), (0x0 << RMC_EN));
+	}
+
+#ifdef SUNXI_CODEC_DAP_ENABLE
+	if (hw_cfg->dacdrc_cfg & DAP_SPK_EN)
+		dacdrc_enable(component, 0);
+	if (hw_cfg->dachpf_cfg & DAP_SPK_EN)
+		dachpf_enable(component, 0);
+#endif
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int sunxi_hp_gain_event(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *k, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	switch (event) {
+	case	SND_SOC_DAPM_PRE_PMU:
+		snd_soc_component_update_bits(component, SUNXI_HP2_REG,
+				0x7 << HEADPHONE_GAIN,
+				sunxi_codec->headphonegain << HEADPHONE_GAIN);
+		break;
+	case	SND_SOC_DAPM_POST_PMD:
+		snd_soc_component_update_bits(component, SUNXI_HP2_REG,
+				0x7 << HEADPHONE_GAIN,
+				0x0 << HEADPHONE_GAIN);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int sunxi_mic1_gain_event(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *k, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	switch (event) {
+	case	SND_SOC_DAPM_PRE_PMU:
+		snd_soc_component_update_bits(component, SUNXI_ADC1_REG,
+				(0x1F<<ADC1_PGA_GAIN_CTRL),
+				(sunxi_codec->mic1gain<<ADC1_PGA_GAIN_CTRL));
+		break;
+	case	SND_SOC_DAPM_POST_PMD:
+		snd_soc_component_update_bits(component, SUNXI_ADC1_REG,
+				(0x1F<<ADC1_PGA_GAIN_CTRL),
+				(0x0<<ADC1_PGA_GAIN_CTRL));
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int sunxi_mic2_gain_event(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *k, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	switch (event) {
+	case	SND_SOC_DAPM_PRE_PMU:
+		snd_soc_component_update_bits(component, SUNXI_ADC2_REG,
+				(0x1F<<ADC2_PGA_GAIN_CTRL),
+				(sunxi_codec->mic2gain<<ADC2_PGA_GAIN_CTRL));
+		break;
+	case	SND_SOC_DAPM_POST_PMD:
+		snd_soc_component_update_bits(component, SUNXI_ADC2_REG,
+				(0x1F<<ADC2_PGA_GAIN_CTRL),
+				(0x0<<ADC2_PGA_GAIN_CTRL));
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int sunxi_mic3_gain_event(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *k, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	switch (event) {
+	case	SND_SOC_DAPM_PRE_PMU:
+		snd_soc_component_update_bits(component, SUNXI_ADC3_REG,
+				(0x1F<<ADC3_PGA_GAIN_CTRL),
+				(sunxi_codec->mic3gain<<ADC3_PGA_GAIN_CTRL));
+		break;
+	case	SND_SOC_DAPM_POST_PMD:
+		snd_soc_component_update_bits(component, SUNXI_ADC3_REG,
+				(0x1F<<ADC3_PGA_GAIN_CTRL),
+				(0x0<<ADC3_PGA_GAIN_CTRL));
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int sunxi_codec_adc1_event(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *k, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	switch (event) {
+	case	SND_SOC_DAPM_POST_PMU:
+		//mdelay(80);
+		sunxi_codec->mic1gain_now = 1;
+		snd_soc_component_update_bits(component, SUNXI_ADC_DIG_CTRL,
+					      0x1 << ADC1_CHANNEL_EN,
+					      0x1 << ADC1_CHANNEL_EN);
+		snd_soc_component_update_bits(component, SUNXI_ADC1_REG,
+					      0x1 << ADC1_EN,
+					      0x1 << ADC1_EN);
+		snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+					      0x1 << EN_AD,
+					      0x1 << EN_AD);
+		break;
+	case	SND_SOC_DAPM_POST_PMD:
+		sunxi_codec->mic1gain_now = 0;
+		snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+					      0x1 << EN_AD,
+					      0x0 << EN_AD);
+		snd_soc_component_update_bits(component, SUNXI_ADC1_REG,
+					      0x1 << ADC1_EN,
+					      0x0 << ADC1_EN);
+		snd_soc_component_update_bits(component, SUNXI_ADC_DIG_CTRL,
+					      0x1 << ADC1_CHANNEL_EN,
+					      0x0 << ADC1_CHANNEL_EN);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int sunxi_codec_adc2_event(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *k, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	switch (event) {
+	case	SND_SOC_DAPM_POST_PMU:
+		//mdelay(80);
+		sunxi_codec->mic2gain_now = 1;
+		snd_soc_component_update_bits(component, SUNXI_ADC_DIG_CTRL,
+					      0x1 << ADC2_CHANNEL_EN,
+					      0x1 << ADC2_CHANNEL_EN);
+		snd_soc_component_update_bits(component, SUNXI_ADC2_REG,
+					      0x1 << ADC2_EN,
+					      0x1 << ADC2_EN);
+		snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+					      0x1 << EN_AD,
+					      0x1 << EN_AD);
+		break;
+	case	SND_SOC_DAPM_POST_PMD:
+		sunxi_codec->mic2gain_now = 0;
+		snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+					      0x1 << EN_AD,
+					      0x0 << EN_AD);
+		snd_soc_component_update_bits(component, SUNXI_ADC2_REG,
+					      0x1 << ADC2_EN,
+					      0x0 << ADC2_EN);
+		snd_soc_component_update_bits(component, SUNXI_ADC_DIG_CTRL,
+					      0x1 << ADC2_CHANNEL_EN,
+					      0x0 << ADC2_CHANNEL_EN);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int sunxi_codec_adc3_event(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *k, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	switch (event) {
+	case	SND_SOC_DAPM_POST_PMU:
+		//mdelay(80);
+		sunxi_codec->mic3gain_now = 1;
+		snd_soc_component_update_bits(component, SUNXI_ADC_DIG_CTRL,
+					      0x1 << ADC3_CHANNEL_EN,
+					      0x1 << ADC3_CHANNEL_EN);
+		snd_soc_component_update_bits(component, SUNXI_ADC3_REG,
+					      0x1 << ADC3_EN,
+					      0x1 << ADC3_EN);
+		snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+					      0x1 << EN_AD,
+					      0x1 << EN_AD);
+		break;
+	case	SND_SOC_DAPM_POST_PMD:
+		sunxi_codec->mic3gain_now = 0;
+		snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+					      0x1 << EN_AD,
+					      0x0 << EN_AD);
+		snd_soc_component_update_bits(component, SUNXI_ADC3_REG,
+					      0x1 << ADC3_EN,
+					      0x0 << ADC3_EN);
+		snd_soc_component_update_bits(component, SUNXI_ADC_DIG_CTRL,
+					      0x1 << ADC3_CHANNEL_EN,
+					      0x0 << ADC3_CHANNEL_EN);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int sunxi_codec_adc_mixer_event(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *k, int event)
+{
+#ifdef SUNXI_CODEC_DAP_ENABLE
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct codec_hw_config *hw_cfg = &(sunxi_codec->hw_config);
+	unsigned int adcctrl_val = 0;
+
+	switch (event) {
+	case SND_SOC_DAPM_POST_PMU:
+		if (hw_cfg->adcdrc_cfg & DAP_HP_EN) {
+			adcctrl_val = snd_soc_component_read32(component, SUNXI_ADC1_REG);
+			if ((adcctrl_val >> MIC1_PGA_EN) & 0x1)
+				adcdrc_enable(component, 1);
+		} else if (hw_cfg->adcdrc_cfg & DAP_SPK_EN) {
+			adcctrl_val = snd_soc_component_read32(component, SUNXI_ADC2_REG);
+			if ((adcctrl_val >> MIC2_PGA_EN) & 0x1)
+				adcdrc_enable(component, 1);
+		}
+		break;
+	case SND_SOC_DAPM_POST_PMD:
+		if ((hw_cfg->adcdrc_cfg & DAP_SPK_EN) ||
+			(hw_cfg->adcdrc_cfg & DAP_HP_EN))
+			adcdrc_enable(component, 0);
+		break;
+	default:
+		break;
+	}
+#endif
+
+	return 0;
+}
+
+static const struct snd_kcontrol_new sunxi_codec_controls[] = {
+#ifdef SUNXI_CODEC_HUB_ENABLE
+	SOC_ENUM_EXT("codec hub mode", sunxi_codec_hub_mode_enum[0],
+				sunxi_codec_get_hub_mode,
+				sunxi_codec_set_hub_mode),
+#endif
+#ifdef SUNXI_CODEC_ADCSWAP_ENABLE
+	SOC_ENUM_EXT("ADC1 ADC2 swap", sunxi_codec_adcswap_func_enum[0],
+		     sunxi_codec_get_adcswap1_mode,
+		     sunxi_codec_set_adcswap1_mode),
+	SOC_ENUM_EXT("ADC3 ADC4 swap", sunxi_codec_adcswap_func_enum[0],
+		     sunxi_codec_get_adcswap2_mode,
+		     sunxi_codec_set_adcswap2_mode),
+#endif
+	/* Digital Volume */
+	SOC_SINGLE_TLV("digital volume", SUNXI_DAC_DPC,
+		       DVOL, 0x3F, 1, digital_tlv),
+	/* DAC Volume */
+	SOC_DOUBLE_TLV("DAC volume", SUNXI_DAC_VOL_CTRL,
+		       DAC_VOL_L, DAC_VOL_R, 0xFF, 0, dac_vol_tlv),
+	/* ADC1 Volume */
+	SOC_SINGLE_TLV("ADC1 volume", SUNXI_ADC_VOL_CTRL,
+		       ADC1_VOL, 0xFF, 0, adc_vol_tlv),
+	/* ADC2 Volume */
+	SOC_SINGLE_TLV("ADC2 volume", SUNXI_ADC_VOL_CTRL,
+		       ADC2_VOL, 0xFF, 0, adc_vol_tlv),
+	/* ADC3 Volume */
+	SOC_SINGLE_TLV("ADC3 volume", SUNXI_ADC_VOL_CTRL,
+		       ADC3_VOL, 0xFF, 0, adc_vol_tlv),
+	/* MIC1 Gain */
+	SOC_SINGLE_EXT_TLV("MIC1 gain volume", SND_SOC_NOPM,
+			MIC1_GAIN_SHIFT, 0x1F, 0,
+			sunxi_get_gain_volsw,
+			sunxi_put_gain_volsw,
+			mic_gain_tlv),
+	/* MIC2 Gain */
+	SOC_SINGLE_EXT_TLV("MIC2 gain volume", SND_SOC_NOPM,
+			MIC2_GAIN_SHIFT, 0x1F, 0,
+			sunxi_get_gain_volsw,
+			sunxi_put_gain_volsw,
+			mic_gain_tlv),
+	/* MIC3 Gain */
+	SOC_SINGLE_EXT_TLV("MIC3 gain volume", SND_SOC_NOPM,
+			MIC3_GAIN_SHIFT, 0x1F, 0,
+			sunxi_get_gain_volsw,
+			sunxi_put_gain_volsw,
+			mic_gain_tlv),
+	/* FMIN_L Gain */
+	SOC_SINGLE_TLV("FMINL gain volume", SUNXI_ADC1_REG,
+		       FMINLG, 0x1, 0, fmin_gain_tlv),
+	/* FMIN_R Gain */
+	SOC_SINGLE_TLV("FMINR gain volume", SUNXI_ADC2_REG,
+		       FMINRG, 0x1, 0, fmin_gain_tlv),
+	/* LINEIN_L Gain */
+	SOC_SINGLE_TLV("LINEINL gain volume", SUNXI_ADC1_REG,
+		       LINEINLG, 0x1, 0, linein_gain_tlv),
+	/* LINEIN_R Gain */
+	SOC_SINGLE_TLV("LINEINR gain volume", SUNXI_ADC2_REG,
+		       LINEINRG, 0x1, 0, linein_gain_tlv),
+	/* LINEOUT Volume */
+	SOC_SINGLE_TLV("LINEOUT volume", SUNXI_DAC_REG,
+		       LINEOUT_VOL, 0x1F, 0, lineout_tlv),
+	/* Headphone Gain */
+	SOC_SINGLE_EXT_TLV("Headphone volume", SND_SOC_NOPM,
+			HP_GAIN_SHIFT, 0x07, 1,
+			sunxi_get_gain_volsw,
+			sunxi_put_gain_volsw,
+			headphone_gain_tlv),
+};
+
+/* lineout controls */
+static const char * const lineout_select_text[] = {
+	"DAC_SINGLE", "DAC_DIFFER",
+};
+/* micin controls */
+static const char * const micin_select_text[] = {
+	"MIC_DIFFER", "MIC_SINGLE",
+};
+
+static const struct soc_enum left_lineout_enum =
+	SOC_ENUM_SINGLE(SUNXI_DAC_REG, LINEOUTLDIFFEN,
+			ARRAY_SIZE(lineout_select_text), lineout_select_text);
+static const struct soc_enum right_lineout_enum =
+	SOC_ENUM_SINGLE(SUNXI_DAC_REG, LINEOUTRDIFFEN,
+			ARRAY_SIZE(lineout_select_text), lineout_select_text);
+
+static const struct soc_enum mic1_input_enum =
+	SOC_ENUM_SINGLE(SUNXI_ADC1_REG, MIC1_SIN_EN,
+			ARRAY_SIZE(micin_select_text), micin_select_text);
+static const struct soc_enum mic2_input_enum =
+	SOC_ENUM_SINGLE(SUNXI_ADC2_REG, MIC2_SIN_EN,
+			ARRAY_SIZE(micin_select_text), micin_select_text);
+static const struct soc_enum mic3_input_enum =
+	SOC_ENUM_SINGLE(SUNXI_ADC3_REG, MIC3_SIN_EN,
+			ARRAY_SIZE(micin_select_text), micin_select_text);
+
+static const struct snd_kcontrol_new left_lineout_mux =
+	SOC_DAPM_ENUM("LINEOUT Output Select", left_lineout_enum);
+static const struct snd_kcontrol_new right_lineout_mux =
+	SOC_DAPM_ENUM("LINEOUTR Output Select", right_lineout_enum);
+
+static const struct snd_kcontrol_new mic1_input_mux =
+	SOC_DAPM_ENUM("MIC1 Input Select", mic1_input_enum);
+static const struct snd_kcontrol_new mic2_input_mux =
+	SOC_DAPM_ENUM("MIC2 Input Select", mic2_input_enum);
+static const struct snd_kcontrol_new mic3_input_mux =
+	SOC_DAPM_ENUM("MIC3 Input Select", mic3_input_enum);
+
+static const struct snd_kcontrol_new adc1_input_mixer[] = {
+	SOC_DAPM_SINGLE("MIC1 Boost Switch", SUNXI_ADC1_REG, MIC1_PGA_EN, 1, 0),
+	SOC_DAPM_SINGLE("FMINL Switch", SUNXI_ADC1_REG, FMINLEN, 1, 0),
+	SOC_DAPM_SINGLE("LINEINL Switch", SUNXI_ADC1_REG, LINEINLEN, 1, 0),
+};
+
+static const struct snd_kcontrol_new adc2_input_mixer[] = {
+	SOC_DAPM_SINGLE("MIC2 Boost Switch", SUNXI_ADC2_REG, MIC2_PGA_EN, 1, 0),
+	SOC_DAPM_SINGLE("FMINR Switch", SUNXI_ADC2_REG, FMINREN, 1, 0),
+	SOC_DAPM_SINGLE("LINEINR Switch", SUNXI_ADC2_REG, LINEINREN, 1, 0),
+};
+
+static const struct snd_kcontrol_new adc3_input_mixer[] = {
+	SOC_DAPM_SINGLE("MIC3 Boost Switch", SUNXI_ADC3_REG, MIC3_PGA_EN, 1, 0),
+};
+
+/*audio dapm widget */
+static const struct snd_soc_dapm_widget sunxi_codec_dapm_widgets[] = {
+	SND_SOC_DAPM_AIF_IN_E("DACL", "Playback", 0, SUNXI_DAC_REG,
+				DACLEN, 0,
+				sunxi_codec_playback_event,
+				SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+
+	SND_SOC_DAPM_AIF_IN_E("DACR", "Playback", 0, SUNXI_DAC_REG,
+				DACREN, 0,
+				sunxi_codec_playback_event,
+				SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+
+	SND_SOC_DAPM_AIF_OUT_E("ADC1", "Capture", 0, SND_SOC_NOPM, 0, 0,
+			       sunxi_codec_adc1_event,
+			       SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_AIF_OUT_E("ADC2", "Capture", 0, SND_SOC_NOPM, 0, 0,
+			       sunxi_codec_adc2_event,
+			       SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_AIF_OUT_E("ADC3", "Capture", 0, SND_SOC_NOPM, 0, 0,
+			       sunxi_codec_adc3_event,
+			       SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
+
+	SND_SOC_DAPM_PGA_E("HP PGA", SND_SOC_NOPM, 0, 0, NULL, 0,
+			     sunxi_hp_gain_event,
+			     SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+
+	SND_SOC_DAPM_MUX("LINEOUTL Output Select", SND_SOC_NOPM, 0, 0,
+			 &left_lineout_mux),
+	SND_SOC_DAPM_MUX("LINEOUTR Output Select", SND_SOC_NOPM, 0, 0,
+			 &right_lineout_mux),
+
+	SND_SOC_DAPM_MUX("MIC1 Input Select", SND_SOC_NOPM, 0, 0,
+			 &mic1_input_mux),
+	SND_SOC_DAPM_MUX("MIC2 Input Select", SND_SOC_NOPM, 0, 0,
+			 &mic2_input_mux),
+	SND_SOC_DAPM_MUX("MIC3 Input Select", SND_SOC_NOPM, 0, 0,
+			 &mic3_input_mux),
+
+	SND_SOC_DAPM_PGA_E("MIC1 PGA", SND_SOC_NOPM, 0, 0, NULL, 0,
+			     sunxi_mic1_gain_event,
+			     SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_PGA_E("MIC2 PGA", SND_SOC_NOPM, 0, 0, NULL, 0,
+			     sunxi_mic2_gain_event,
+			     SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_PGA_E("MIC3 PGA", SND_SOC_NOPM, 0, 0, NULL, 0,
+			     sunxi_mic3_gain_event,
+			     SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+
+	SND_SOC_DAPM_MIXER_E("ADC1 Input", SND_SOC_NOPM, 0, 0,
+			     adc1_input_mixer, ARRAY_SIZE(adc1_input_mixer),
+			     sunxi_codec_adc_mixer_event,
+			     SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_MIXER_E("ADC2 Input", SND_SOC_NOPM, 0, 0,
+			     adc2_input_mixer, ARRAY_SIZE(adc2_input_mixer),
+			     sunxi_codec_adc_mixer_event,
+			     SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_MIXER_E("ADC3 Input", SND_SOC_NOPM, 0, 0,
+			     adc3_input_mixer, ARRAY_SIZE(adc3_input_mixer),
+			     sunxi_codec_adc_mixer_event,
+			     SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
+
+	SND_SOC_DAPM_MICBIAS("MainMic Bias", SUNXI_MICBIAS_REG, MMICBIASEN, 0),
+
+	SND_SOC_DAPM_INPUT("MIC1"),
+	SND_SOC_DAPM_INPUT("MIC2"),
+	SND_SOC_DAPM_INPUT("MIC3"),
+	SND_SOC_DAPM_INPUT("FMINL"),
+	SND_SOC_DAPM_INPUT("FMINR"),
+	SND_SOC_DAPM_INPUT("LINEINL"),
+	SND_SOC_DAPM_INPUT("LINEINR"),
+
+	SND_SOC_DAPM_OUTPUT("HPOUTL"),
+	SND_SOC_DAPM_OUTPUT("HPOUTR"),
+	SND_SOC_DAPM_OUTPUT("LINEOUTL"),
+	SND_SOC_DAPM_OUTPUT("LINEOUTR"),
+
+	SND_SOC_DAPM_HP("Headphone", sunxi_codec_headphone_event),
+	SND_SOC_DAPM_LINE("LINEOUT", sunxi_codec_lineout_event),
+	SND_SOC_DAPM_SPK("HpSpeaker", sunxi_codec_hpspeaker_event),
+};
+
+static const struct snd_soc_dapm_route sunxi_codec_dapm_routes[] = {
+	/* input route */
+	{"MIC1 Input Select", "MIC_SINGLE", "MIC1"},
+	{"MIC1 Input Select", "MIC_DIFFER", "MIC1"},
+	{"MIC2 Input Select", "MIC_SINGLE", "MIC2"},
+	{"MIC2 Input Select", "MIC_DIFFER", "MIC2"},
+	{"MIC3 Input Select", "MIC_SINGLE", "MIC3"},
+	{"MIC3 Input Select", "MIC_DIFFER", "MIC3"},
+
+	{"MIC1 PGA", NULL, "MIC1 Input Select"},
+	{"MIC2 PGA", NULL, "MIC2 Input Select"},
+	{"MIC3 PGA", NULL, "MIC3 Input Select"},
+
+	{"ADC1 Input", "MIC1 Boost Switch", "MIC1 PGA"},
+	{"ADC1 Input", "FMINL Switch", "FMINL"},
+	{"ADC1 Input", "LINEINL Switch", "LINEINL"},
+
+	{"ADC2 Input", "MIC2 Boost Switch", "MIC2 PGA"},
+	{"ADC2 Input", "FMINR Switch", "FMINR"},
+	{"ADC2 Input", "LINEINR Switch", "LINEINR"},
+
+	{"ADC3 Input", "MIC3 Boost Switch", "MIC3 PGA"},
+
+	{"ADC1", NULL, "ADC1 Input"},
+	{"ADC2", NULL, "ADC2 Input"},
+	{"ADC3", NULL, "ADC3 Input"},
+
+	/* Output route */
+	{"LINEOUTL Output Select", "DAC_SINGLE", "DACL"},
+	{"LINEOUTL Output Select", "DAC_DIFFER", "DACL"},
+
+	{"LINEOUTR Output Select", "DAC_SINGLE", "DACR"},
+	{"LINEOUTR Output Select", "DAC_DIFFER", "DACR"},
+
+	{"HPOUTL", NULL, "DACL"},
+	{"HPOUTR", NULL, "DACR"},
+
+	{"LINEOUTL", NULL, "LINEOUTL Output Select"},
+	{"LINEOUTR", NULL, "LINEOUTR Output Select"},
+
+	{"LINEOUT", NULL, "LINEOUTL"},
+	{"LINEOUT", NULL, "LINEOUTR"},
+
+	{"HP PGA", NULL, "HPOUTL"},
+	{"HP PGA", NULL, "HPOUTR"},
+
+	{"Headphone", NULL, "HP PGA"},
+	{"HpSpeaker", NULL, "HP PGA"},
+};
+
+static void sunxi_codec_init(struct snd_soc_component *component)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	/* In order to ensure that the ADC sampling is normal,
+	 * the A chip SOC needs to always open HPLDO and RMC_EN
+	 */
+	if (sunxi_get_soc_ver() & 0x7) {
+		snd_soc_component_update_bits(component, SUNXI_RAMP_REG,
+				(0x1 << RMC_EN), (0x0 << RMC_EN));
+	} else {
+		snd_soc_component_update_bits(component, SUNXI_POWER_REG,
+				(0x1 << HPLDO_EN), (0x1 << HPLDO_EN));
+		snd_soc_component_update_bits(component, SUNXI_RAMP_REG,
+				(0x1 << RMC_EN), (0x1 << RMC_EN));
+	}
+
+	/* DAC_VOL_SEL default disabled */
+	snd_soc_component_update_bits(component, SUNXI_DAC_VOL_CTRL,
+			(0x1 << DAC_VOL_SEL), (0x1 << DAC_VOL_SEL));
+
+	if (sunxi_codec->rx_sync_en) {
+		/* disabled ADCFDT */
+		snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+				(0x1 << ADCDFEN), (0x0 << ADCDFEN));
+		snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+				(0x3 << ADCFDT), (0x2 << ADCFDT));
+		/* Enable RX_SYNC_EN */
+		snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+				(0x1 << RX_SYNC_EN), (0x1 << RX_SYNC_EN));
+	} else {
+		/* Enable ADCFDT to overcome niose at the beginning */
+		snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+				(0x1 << ADCDFEN), (0x1 << ADCDFEN));
+		snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+				(0x3 << ADCFDT), (0x2 << ADCFDT));
+	}
+
+	/* Digital VOL defeult setting */
+	snd_soc_component_update_bits(component, SUNXI_DAC_DPC,
+			0x3F << DVOL,
+			sunxi_codec->digital_vol << DVOL);
+
+	/* LINEOUT VOL defeult setting */
+	snd_soc_component_update_bits(component, SUNXI_DAC_REG,
+			0x1F << LINEOUT_VOL,
+			sunxi_codec->lineout_vol << LINEOUT_VOL);
+
+	/* Headphone Gain defeult setting */
+	snd_soc_component_update_bits(component, SUNXI_HP2_REG,
+			0x7 << HEADPHONE_GAIN,
+			0x0 << HEADPHONE_GAIN);
+
+	/* ADCL MIC1 gain defeult setting */
+	snd_soc_component_update_bits(component, SUNXI_ADC1_REG,
+			0x1F << ADC1_PGA_GAIN_CTRL,
+			0x0 << ADC1_PGA_GAIN_CTRL);
+	/* ADCR MIC2 gain defeult setting */
+	snd_soc_component_update_bits(component, SUNXI_ADC2_REG,
+			0x1F << ADC2_PGA_GAIN_CTRL,
+			0x0 << ADC2_PGA_GAIN_CTRL);
+	/* ADCR MIC3 gain defeult setting */
+	snd_soc_component_update_bits(component, SUNXI_ADC3_REG,
+			0x1F << ADC3_PGA_GAIN_CTRL,
+			0x0 << ADC3_PGA_GAIN_CTRL);
+
+	/* ADC IOP params default setting */
+	snd_soc_component_update_bits(component, SUNXI_ADC1_REG,
+			0xFF << ADC1_IOPMIC, 0x55 << ADC1_IOPMIC);
+	snd_soc_component_update_bits(component, SUNXI_ADC2_REG,
+			0xFF << ADC2_IOPMIC, 0x55 << ADC2_IOPMIC);
+	snd_soc_component_update_bits(component, SUNXI_ADC3_REG,
+			0xFF << ADC3_IOPMIC, 0x55 << ADC3_IOPMIC);
+
+	snd_soc_component_update_bits(component, SUNXI_DAC_REG,
+			0x01 << LINEOUTLDIFFEN, 0x01 << LINEOUTLDIFFEN);
+	snd_soc_component_update_bits(component, SUNXI_DAC_REG,
+			0x01 << LINEOUTRDIFFEN, 0x01 << LINEOUTRDIFFEN);
+	snd_soc_component_update_bits(component, SUNXI_ADC1_REG,
+			0x01 << MIC1_SIN_EN, 0x00 << MIC1_SIN_EN);
+	snd_soc_component_update_bits(component, SUNXI_ADC2_REG,
+			0x01 << MIC2_SIN_EN, 0x00 << MIC2_SIN_EN);
+	snd_soc_component_update_bits(component, SUNXI_ADC3_REG,
+			0x01 << MIC3_SIN_EN, 0x00 << MIC3_SIN_EN);
+#ifdef SUNXI_CODEC_DAP_ENABLE
+	if (sunxi_codec->hw_config.adcdrc_cfg)
+		adcdrc_config(component);
+	if (sunxi_codec->hw_config.adchpf_cfg)
+		adchpf_config(component);
+
+	if (sunxi_codec->hw_config.dacdrc_cfg)
+		dacdrc_config(component);
+	if (sunxi_codec->hw_config.dachpf_cfg)
+		dachpf_config(component);
+#endif
+}
+
+static void sunxi_codec_rx_enable(void *data, bool enable)
+{
+	struct snd_soc_component *component = data;
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	if (enable)
+		regmap_update_bits(sunxi_codec->regmap, SUNXI_ADC_FIFOC,
+			(1 << RX_SYNC_EN_STA), (1 << RX_SYNC_EN_STA));
+	else
+		regmap_update_bits(sunxi_codec->regmap, SUNXI_ADC_FIFOC,
+			(1 << RX_SYNC_EN_STA), (0 << RX_SYNC_EN_STA));
+
+}
+
+static int sunxi_codec_startup(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+#ifdef SUNXI_CODEC_DAP_ENABLE
+	struct snd_soc_component *component = dai->component;
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		if (sunxi_codec->hw_config.adchpf_cfg)
+			adchpf_enable(component, 1);
+	}
+#endif
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE &&
+		sunxi_codec->rx_sync_en) {
+		sunxi_rx_sync_startup((void *)dai->component,
+			sunxi_codec->rx_sync_domain, sunxi_codec->rx_sync_id,
+			sunxi_codec_rx_enable);
+	}
+
+	return 0;
+}
+
+static int sunxi_codec_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct snd_soc_component *component = dai->component;
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	int i = 0;
+
+	switch (params_format(params)) {
+	case	SNDRV_PCM_FORMAT_S16_LE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			snd_soc_component_update_bits(component, SUNXI_DAC_FIFOC,
+				(3 << FIFO_MODE), (3 << FIFO_MODE));
+			snd_soc_component_update_bits(component, SUNXI_DAC_FIFOC,
+				(1 << TX_SAMPLE_BITS), (0 << TX_SAMPLE_BITS));
+		} else {
+			snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+				(1 << RX_FIFO_MODE), (1 << RX_FIFO_MODE));
+			snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+				(1 << RX_SAMPLE_BITS), (0 << RX_SAMPLE_BITS));
+		}
+		break;
+	case	SNDRV_PCM_FORMAT_S24_LE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			snd_soc_component_update_bits(component, SUNXI_DAC_FIFOC,
+				(3 << FIFO_MODE), (0 << FIFO_MODE));
+			snd_soc_component_update_bits(component, SUNXI_DAC_FIFOC,
+				(1 << TX_SAMPLE_BITS), (1 << TX_SAMPLE_BITS));
+		} else {
+			snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+				(1 << RX_FIFO_MODE), (0 << RX_FIFO_MODE));
+			snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+				(1 << RX_SAMPLE_BITS), (1 << RX_SAMPLE_BITS));
+		}
+		break;
+	default:
+		break;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(sample_rate_conv); i++) {
+		if (sample_rate_conv[i].samplerate == params_rate(params)) {
+			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+				snd_soc_component_update_bits(component, SUNXI_DAC_FIFOC,
+					(0x7 << DAC_FS),
+					(sample_rate_conv[i].rate_bit << DAC_FS));
+			} else {
+				if (sample_rate_conv[i].samplerate > 48000)
+					return -EINVAL;
+				snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+					(0x7 << ADC_FS),
+					(sample_rate_conv[i].rate_bit<<ADC_FS));
+			}
+		}
+	}
+
+	/* reset the adchpf func setting for different sampling */
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		if (sunxi_codec->hw_config.adchpf_cfg) {
+			if (params_rate(params) == 16000) {
+				snd_soc_component_write(component, SUNXI_ADC_DRC_HHPFC,
+						(0x00F623A5 >> 16) & 0xFFFF);
+
+				snd_soc_component_write(component, SUNXI_ADC_DRC_LHPFC,
+							0x00F623A5 & 0xFFFF);
+
+			} else if (params_rate(params) == 44100) {
+				snd_soc_component_write(component, SUNXI_ADC_DRC_HHPFC,
+						(0x00FC60DB >> 16) & 0xFFFF);
+
+				snd_soc_component_write(component, SUNXI_ADC_DRC_LHPFC,
+							0x00FC60DB & 0xFFFF);
+			} else {
+				snd_soc_component_write(component, SUNXI_ADC_DRC_HHPFC,
+						(0x00FCABB3 >> 16) & 0xFFFF);
+
+				snd_soc_component_write(component, SUNXI_ADC_DRC_LHPFC,
+							0x00FCABB3 & 0xFFFF);
+			}
+		}
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		switch (params_channels(params)) {
+		case 1:
+			/* DACL & DACR send same data */
+			snd_soc_component_update_bits(component, SUNXI_DAC_FIFOC,
+				(0x1 << DAC_MONO_EN), 0x1 << DAC_MONO_EN);
+			break;
+		case 2:
+			snd_soc_component_update_bits(component, SUNXI_DAC_FIFOC,
+				(0x1 << DAC_MONO_EN), 0x0 << DAC_MONO_EN);
+			break;
+		default:
+			LOG_WARN("not support channels:%u", params_channels(params));
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+static int sunxi_codec_set_sysclk(struct snd_soc_dai *dai,
+			int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_component *component = dai->component;
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	switch (clk_id) {
+	case	0:
+		/* set clk source [22.5792MHz * n] to surpport playback */
+		if (clk_set_parent(sunxi_codec->dacclk, sunxi_codec->pllaudio0)) {
+			LOG_ERR("set parent of dacclk to pllaudio0 failed");
+			return -EINVAL;
+		}
+
+		if (clk_set_rate(sunxi_codec->dacclk, freq)) {
+			LOG_ERR("codec set dac clk rate failed");
+			return -EINVAL;
+		}
+		break;
+	case	1:
+		/* set clk source [22.5792MHz * n] to surpport capture */
+		if (clk_set_parent(sunxi_codec->adcclk, sunxi_codec->pllaudio0)) {
+			LOG_ERR("set parent of adcclk to pllaudio0 failed");
+			return -EINVAL;
+		}
+
+		if (clk_set_rate(sunxi_codec->adcclk, freq)) {
+			LOG_ERR("codec set adc clk rate failed");
+			return -EINVAL;
+		}
+		break;
+	case	2:
+		/* set clk source [24.576MHz * n] to surpport playback */
+		if (clk_set_parent(sunxi_codec->dacclk, sunxi_codec->pllaudio1_div5)) {
+			LOG_ERR("set parent of dacclk to pllaudio1_div5 failed");
+			return -EINVAL;
+		}
+
+		if (clk_set_rate(sunxi_codec->dacclk, freq)) {
+			LOG_ERR("codec set dac clk rate failed");
+			return -EINVAL;
+		}
+		break;
+	case	3:
+		/* set clk source [24.576MHz * n] to surpport capture */
+		if (clk_set_parent(sunxi_codec->adcclk, sunxi_codec->pllaudio1_div5)) {
+			LOG_ERR("set parent of adcclk to pllaudio1_div5 failed");
+			return -EINVAL;
+		}
+
+		if (clk_set_rate(sunxi_codec->adcclk, freq)) {
+			LOG_ERR("codec set adc clk rate failed");
+			return -EINVAL;
+		}
+		break;
+	default:
+		LOG_ERR("Bad clk params input!");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void sunxi_codec_shutdown(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+#ifdef SUNXI_CODEC_DAP_ENABLE
+	struct snd_soc_component *component = dai->component;
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		if (sunxi_codec->hw_config.adchpf_cfg)
+			adchpf_enable(component, 0);
+	}
+#endif
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE &&
+		sunxi_codec->rx_sync_en) {
+		sunxi_rx_sync_shutdown(sunxi_codec->rx_sync_domain,
+				sunxi_codec->rx_sync_id);
+	}
+}
+
+static int sunxi_codec_prepare(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	struct snd_soc_component *component = dai->component;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		snd_soc_component_update_bits(component, SUNXI_DAC_FIFOC,
+			(1 << FIFO_FLUSH), (1 << FIFO_FLUSH));
+		snd_soc_component_write(component, SUNXI_DAC_FIFOS,
+			(1 << DAC_TXE_INT | 1 << DAC_TXU_INT | 1 << DAC_TXO_INT));
+		snd_soc_component_write(component, SUNXI_DAC_CNT, 0);
+	} else {
+		snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+				(1 << ADC_FIFO_FLUSH), (1 << ADC_FIFO_FLUSH));
+		snd_soc_component_write(component, SUNXI_ADC_FIFOS,
+				(1 << ADC_RXA_INT | 1 << ADC_RXO_INT));
+		snd_soc_component_write(component, SUNXI_ADC_CNT, 0);
+	}
+
+	return 0;
+}
+
+static int sunxi_codec_trigger(struct snd_pcm_substream *substream,
+				int cmd, struct snd_soc_dai *dai)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(dai->component);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			regmap_update_bits(sunxi_codec->regmap, SUNXI_DAC_FIFOC,
+				(1 << DAC_DRQ_EN), (1 << DAC_DRQ_EN));
+		} else {
+			regmap_update_bits(sunxi_codec->regmap, SUNXI_ADC_FIFOC,
+				(1 << ADC_DRQ_EN), (1 << ADC_DRQ_EN));
+			if (sunxi_codec->rx_sync_en)
+				sunxi_rx_sync_control(sunxi_codec->rx_sync_domain,
+						sunxi_codec->rx_sync_id, 1);
+		}
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			regmap_update_bits(sunxi_codec->regmap, SUNXI_DAC_FIFOC,
+				(1 << DAC_DRQ_EN), (0 << DAC_DRQ_EN));
+		} else {
+			regmap_update_bits(sunxi_codec->regmap, SUNXI_ADC_FIFOC,
+				(1 << ADC_DRQ_EN), (0 << ADC_DRQ_EN));
+			if (sunxi_codec->rx_sync_en)
+				sunxi_rx_sync_control(sunxi_codec->rx_sync_domain,
+						sunxi_codec->rx_sync_id, 0);
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops sunxi_codec_dai_ops = {
+	.startup	= sunxi_codec_startup,
+	.hw_params	= sunxi_codec_hw_params,
+	.shutdown	= sunxi_codec_shutdown,
+	.set_sysclk	= sunxi_codec_set_sysclk,
+	.trigger	= sunxi_codec_trigger,
+	.prepare	= sunxi_codec_prepare,
+};
+
+static struct snd_soc_dai_driver sunxi_codec_dai[] = {
+	{
+		.name	= "sun20iw1codec",
+		.playback = {
+			.stream_name = "Playback",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates	= SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE,
+		},
+		.capture = {
+			.stream_name = "Capture",
+			.channels_min = 1,
+			.channels_max = 3,
+			.rates = SNDRV_PCM_RATE_8000_48000
+				| SNDRV_PCM_RATE_KNOT,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE,
+		},
+		.ops = &sunxi_codec_dai_ops,
+	},
+};
+
+static int sunxi_codec_probe(struct snd_soc_component *component)
+{
+	int ret;
+	struct snd_soc_dapm_context *dapm = &component->dapm;
+
+	ret = snd_soc_add_component_controls(component, sunxi_codec_controls,
+					ARRAY_SIZE(sunxi_codec_controls));
+	if (ret)
+		LOG_ERR("failed to register codec controls");
+
+	snd_soc_dapm_new_controls(dapm, sunxi_codec_dapm_widgets,
+				ARRAY_SIZE(sunxi_codec_dapm_widgets));
+	snd_soc_dapm_add_routes(dapm, sunxi_codec_dapm_routes,
+				ARRAY_SIZE(sunxi_codec_dapm_routes));
+
+	sunxi_codec_init(component);
+
+	return 0;
+}
+
+static void sunxi_codec_remove(struct snd_soc_component *component)
+{
+
+}
+
+static int save_audio_reg(struct sunxi_codec_info *sunxi_codec)
+{
+	int i = 0;
+
+	while (reg_labels[i].name != NULL) {
+		regmap_read(sunxi_codec->regmap, reg_labels[i].address,
+			&reg_labels[i].value);
+		i++;
+	}
+
+	return i;
+}
+
+static int echo_audio_reg(struct sunxi_codec_info *sunxi_codec)
+{
+	int i = 0;
+
+	while (reg_labels[i].name != NULL) {
+		regmap_write(sunxi_codec->regmap, reg_labels[i].address,
+					reg_labels[i].value);
+		i++;
+	}
+
+	return i;
+}
+
+static int sunxi_codec_suspend(struct snd_soc_component *component)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct codec_spk_config *spk_cfg = &(sunxi_codec->spk_config);
+
+	pr_debug("Enter %s\n", __func__);
+	save_audio_reg(sunxi_codec);
+
+	if (spk_cfg->used)
+		gpio_set_value(spk_cfg->spk_gpio, !(spk_cfg->pa_level));
+
+	if (sunxi_codec->vol_supply.avcc)
+		regulator_disable(sunxi_codec->vol_supply.avcc);
+
+	if (sunxi_codec->vol_supply.hpvcc)
+		regulator_disable(sunxi_codec->vol_supply.hpvcc);
+
+	clk_disable_unprepare(sunxi_codec->dacclk);
+	clk_disable_unprepare(sunxi_codec->adcclk);
+	clk_disable_unprepare(sunxi_codec->pllaudio0);
+	clk_disable_unprepare(sunxi_codec->pllaudio1_div5);
+	clk_disable_unprepare(sunxi_codec->codec_clk_bus);
+	reset_control_assert(sunxi_codec->codec_clk_rst);
+
+	pr_debug("End %s\n", __func__);
+
+	return 0;
+}
+
+static int sunxi_codec_resume(struct snd_soc_component *component)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct codec_spk_config *spk_cfg = &(sunxi_codec->spk_config);
+	unsigned int ret;
+
+	pr_debug("Enter %s\n", __func__);
+
+	if (sunxi_codec->vol_supply.avcc) {
+		ret = regulator_enable(sunxi_codec->vol_supply.avcc);
+		if (ret)
+			LOG_ERR("resume avcc enable failed");
+	}
+
+	if (sunxi_codec->vol_supply.hpvcc) {
+		ret = regulator_enable(sunxi_codec->vol_supply.hpvcc);
+		if (ret)
+			LOG_ERR("resume hpvcc enable failed");
+	}
+
+	/* 22579200 * n */
+	if (clk_set_rate(sunxi_codec->pllaudio0, 22579200)) {
+		LOG_ERR("resume codec source set pllaudio0 rate failed");
+		return -EBUSY;
+	}
+
+	/* 24576000 * 25 */
+	if (clk_set_rate(sunxi_codec->pllaudio1_div5, 614400000)) {
+		LOG_ERR("resume codec source set pllaudio1_div5 rate failed");
+		return -EBUSY;
+	}
+
+	if (reset_control_deassert(sunxi_codec->codec_clk_rst)) {
+		LOG_ERR("resume deassert the codec reset failed");
+		return -EBUSY;
+	}
+
+	if (clk_prepare_enable(sunxi_codec->codec_clk_bus)) {
+		LOG_ERR("enable codec bus clk failed, resume exit");
+		return -EBUSY;
+	}
+
+	if (clk_prepare_enable(sunxi_codec->pllaudio0)) {
+		LOG_ERR("enable pllaudio0 failed, resume exit");
+		return -EBUSY;
+	}
+
+	if (clk_prepare_enable(sunxi_codec->pllaudio1_div5)) {
+		LOG_ERR("enable pllaudio1_div5 failed, resume exit");
+		return -EBUSY;
+	}
+
+	if (clk_prepare_enable(sunxi_codec->dacclk)) {
+		LOG_ERR("enable dacclk failed, resume exit");
+		return -EBUSY;
+	}
+
+	if (clk_prepare_enable(sunxi_codec->adcclk)) {
+		LOG_ERR("enable  adcclk failed, resume exit");
+		clk_disable_unprepare(sunxi_codec->adcclk);
+		return -EBUSY;
+	}
+
+	if (spk_cfg->used) {
+		gpio_direction_output(spk_cfg->spk_gpio, 1);
+		gpio_set_value(spk_cfg->spk_gpio, !(spk_cfg->pa_level));
+	}
+
+	sunxi_codec_init(component);
+	echo_audio_reg(sunxi_codec);
+
+	pr_debug("End %s\n", __func__);
+
+	return 0;
+}
+
+static unsigned int sunxi_codec_read(struct snd_soc_component *component,
+					unsigned int reg)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	unsigned int reg_val;
+
+	regmap_read(sunxi_codec->regmap, reg, &reg_val);
+
+	return reg_val;
+}
+
+static int sunxi_codec_write(struct snd_soc_component *component,
+				unsigned int reg, unsigned int val)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	regmap_write(sunxi_codec->regmap, reg, val);
+
+	return 0;
+};
+
+static struct snd_soc_component_driver soc_codec_dev_sunxi = {
+	.probe = sunxi_codec_probe,
+	.remove = sunxi_codec_remove,
+	.suspend = sunxi_codec_suspend,
+	.resume = sunxi_codec_resume,
+	.read = sunxi_codec_read,
+	.write = sunxi_codec_write,
+};
+
+/* audiocodec reg dump about */
+static ssize_t show_audio_reg(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct sunxi_codec_info *sunxi_codec = dev_get_drvdata(dev);
+	int cnt = 0, i = 0, j = 0;
+	unsigned int reg_val, reg_val_tmp;
+	unsigned int size = ARRAY_SIZE(reg_labels);
+	char *reg_name_play = "REG NAME";
+	char *reg_offset_play = "OFFSET";
+	char *reg_val_play = "VALUE";
+
+	cnt += sprintf(buf + cnt,
+		       "%-30s|%-6s|%-10s"
+		       "|31-28|27-24|23-20|19-16|15-12|11-08|07-04|03-00|"
+		       "save_value\n",
+		       reg_name_play, reg_offset_play, reg_val_play);
+
+	while ((i < size) && (reg_labels[i].name != NULL)) {
+		regmap_read(sunxi_codec->regmap,
+			    reg_labels[i].address, &reg_val);
+
+		cnt += sprintf(buf + cnt,
+			       "%-30s|0x%4x|0x%8x",
+			       reg_labels[i].name,
+			       reg_labels[i].address,
+			       reg_val);
+		for (j = 7; j >= 0; j--) {
+			reg_val_tmp = reg_val >> (j * 4);
+			cnt += sprintf(buf + cnt,
+				       "|%c%c%c%c ",
+				       (((reg_val_tmp) & 0x08ull) ? '1' : '0'),
+				       (((reg_val_tmp) & 0x04ull) ? '1' : '0'),
+				       (((reg_val_tmp) & 0x02ull) ? '1' : '0'),
+				       (((reg_val_tmp) & 0x01ull) ? '1' : '0')
+				       );
+		}
+		cnt += sprintf(buf + cnt, "|0x%8x\n", reg_labels[i].value);
+
+		i++;
+	}
+
+	return cnt;
+}
+
+/* ex:
+ * param 1: 0 read;1 write
+ * param 2: reg value;
+ * param 3: write value;
+	read:
+		echo 0,0x00> audio_reg
+	write:
+		echo 1,0x00,0xa > audio_reg
+*/
+static ssize_t store_audio_reg(struct device *dev, struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	int ret;
+	int rw_flag;
+	int input_reg_val = 0;
+	int input_reg_offset = 0;
+	struct sunxi_codec_info *sunxi_codec = dev_get_drvdata(dev);
+
+	ret = sscanf(buf, "%d,0x%x,0x%x", &rw_flag,
+			&input_reg_offset, &input_reg_val);
+	LOG_INFO("ret:%d, reg_offset:%d, reg_val:0x%x",
+		 ret, input_reg_offset, input_reg_val);
+
+	if (!(rw_flag == 1 || rw_flag == 0)) {
+		LOG_ERR("not rw_flag");
+		ret = count;
+		goto out;
+	}
+
+	if (input_reg_offset > SUNXI_BIAS_REG) {
+		LOG_ERR("the reg offset[0x%03x] > SUNXI_BIAS_REG[0x%03x]",
+			input_reg_offset, SUNXI_BIAS_REG);
+		ret = count;
+		goto out;
+	}
+
+	if (rw_flag) {
+		regmap_write(sunxi_codec->regmap,
+				input_reg_offset, input_reg_val);
+	} else {
+		regmap_read(sunxi_codec->regmap,
+				input_reg_offset, &input_reg_val);
+		LOG_INFO("\n\n Reg[0x%x] : 0x%08x\n\n",
+				input_reg_offset, input_reg_val);
+	}
+	ret = count;
+out:
+	return ret;
+}
+
+static DEVICE_ATTR(audio_reg, 0644, show_audio_reg, store_audio_reg);
+
+static struct attribute *audio_debug_attrs[] = {
+	&dev_attr_audio_reg.attr,
+	NULL,
+};
+
+static struct attribute_group audio_debug_attr_group = {
+	.name   = "audio_reg_debug",
+	.attrs  = audio_debug_attrs,
+};
+
+/* regmap configuration */
+static const struct regmap_config sunxi_codec_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = SUNXI_ADC_CUR_REG,
+	.cache_type = REGCACHE_NONE,
+};
+static const struct snd_pcm_hardware snd_rockchip_hardware = {
+	.info			= SNDRV_PCM_INFO_MMAP |
+				  SNDRV_PCM_INFO_MMAP_VALID |
+				  SNDRV_PCM_INFO_PAUSE |
+				  SNDRV_PCM_INFO_RESUME |
+				  SNDRV_PCM_INFO_INTERLEAVED,
+	.period_bytes_min	= 32,
+	.period_bytes_max	= 8192,
+	.periods_min		= 1,
+	.periods_max		= 52,
+	.buffer_bytes_max	= 64 * 1024,
+	.fifo_size		= 32,
+};
+
+/*
+static int sunxi_codec_regulator_init(struct platform_device *pdev,
+				struct sunxi_codec_info *sunxi_codec)
+{
+	int ret = -EFAULT;
+
+	sunxi_codec->vol_supply.avcc = regulator_get(&pdev->dev, "avcc");
+	if (IS_ERR(sunxi_codec->vol_supply.avcc)) {
+		LOG_ERR("get audio avcc failed");
+		goto err_regulator;
+	} else {
+		ret = regulator_set_voltage(sunxi_codec->vol_supply.avcc,
+							1800000, 1800000);
+		if (ret) {
+			LOG_ERR("avcc set vol failed");
+			goto err_regulator_avcc;
+		}
+
+		ret = regulator_enable(sunxi_codec->vol_supply.avcc);
+		if (ret) {
+			LOG_ERR("avcc enable failed");
+			goto err_regulator_avcc;
+		}
+	}
+
+	sunxi_codec->vol_supply.hpvcc = regulator_get(&pdev->dev, "hpvcc");
+	if (IS_ERR(sunxi_codec->vol_supply.hpvcc)) {
+		LOG_ERR("get audio hpvcc failed");
+		goto err_regulator_avcc;
+	} else {
+		ret = regulator_set_voltage(sunxi_codec->vol_supply.hpvcc,
+							1800000, 1800000);
+		if (ret) {
+			LOG_ERR("hpvcc set vol failed");
+			goto err_regulator_hpvcc;
+		}
+
+		ret = regulator_enable(sunxi_codec->vol_supply.hpvcc);
+		if (ret) {
+			LOG_ERR("hpvcc enable failed");
+			goto err_regulator_hpvcc;
+		}
+	}
+	return 0;
+
+err_regulator_hpvcc:
+	regulator_put(sunxi_codec->vol_supply.hpvcc);
+err_regulator_avcc:
+	regulator_put(sunxi_codec->vol_supply.avcc);
+err_regulator:
+	return ret;
+}
+*/
+
+static int sunxi_codec_clk_init(struct device_node *np,
+				struct platform_device *pdev,
+				struct sunxi_codec_info *sunxi_codec)
+{
+	int ret = -EBUSY;
+	/* get the parent clk and the module clk */
+	sunxi_codec->dacclk = of_clk_get_by_name(np, "audio_clk_dac");
+	if (IS_ERR(sunxi_codec->dacclk))
+		LOG_ERR("audio_clk_dac clk get failed");
+	sunxi_codec->adcclk = of_clk_get_by_name(np, "audio_clk_adc");
+	if (IS_ERR(sunxi_codec->adcclk))
+		LOG_ERR("audio_clk_adc clk get failed");
+	sunxi_codec->pllaudio0 = of_clk_get_by_name(np, "pll_audio0");
+	if (IS_ERR(sunxi_codec->pllaudio0))
+		LOG_ERR("pll_audio0 clk get failed");
+	sunxi_codec->pllaudio1_div5 = of_clk_get_by_name(np, "pll_audio1_div5");
+	if (IS_ERR(sunxi_codec->pllaudio1_div5))
+		LOG_ERR("pll_audio1_div5 clk get failed");
+	sunxi_codec->codec_clk_bus = of_clk_get_by_name(np, "audio_clk_bus");
+	if (IS_ERR(sunxi_codec->codec_clk_bus))
+		LOG_ERR("audio_clk_bus clk get failed");
+	sunxi_codec->codec_clk_rst = devm_reset_control_get(&pdev->dev, NULL);
+
+	if (reset_control_deassert(sunxi_codec->codec_clk_rst)) {
+		LOG_ERR("reset clk deassert failed");
+		goto err_devm_kfree;
+	}
+
+	if (clk_set_parent(sunxi_codec->dacclk, sunxi_codec->pllaudio0)) {
+		LOG_ERR("set parent of dacclk to pllaudio0 failed");
+		goto err_devm_kfree;
+	}
+
+	if (clk_set_parent(sunxi_codec->adcclk, sunxi_codec->pllaudio0)) {
+		LOG_ERR("set parent of adcclk to pllaudio0 failed");
+		goto err_devm_kfree;
+	}
+
+	/* 22579200 * n */
+	if (clk_set_rate(sunxi_codec->pllaudio0, 22579200)) {
+		LOG_ERR("pllaudio0 set rate failed");
+		goto err_devm_kfree;
+	}
+
+	/* 24576000 * n */
+	if (clk_set_rate(sunxi_codec->pllaudio1_div5, 614400000)) {
+		LOG_ERR("pllaudio1_div5 set rate failed");
+		goto err_devm_kfree;
+	}
+
+	if (clk_prepare_enable(sunxi_codec->codec_clk_bus)) {
+		LOG_ERR("codec clk bus enable failed");
+	}
+
+	if (clk_prepare_enable(sunxi_codec->pllaudio0)) {
+		LOG_ERR("pllaudio0 enable failed");
+		goto err_bus_kfree;
+	}
+
+	if (clk_prepare_enable(sunxi_codec->pllaudio1_div5)) {
+		LOG_ERR("pllaudio1_div5 enable failed");
+		goto err_pllaudio0_kfree;
+	}
+
+	if (clk_prepare_enable(sunxi_codec->dacclk)) {
+		LOG_ERR("dacclk enable failed");
+		goto err_pllaudio1_div5_kfree;
+	}
+
+	if (clk_prepare_enable(sunxi_codec->adcclk)) {
+		LOG_ERR("adcclk enable failed");
+		goto err_dacclk_kfree;
+	}
+	return 0;
+
+err_dacclk_kfree:
+	clk_disable_unprepare(sunxi_codec->dacclk);
+err_pllaudio1_div5_kfree:
+	clk_disable_unprepare(sunxi_codec->pllaudio1_div5);
+err_pllaudio0_kfree:
+	clk_disable_unprepare(sunxi_codec->pllaudio0);
+err_bus_kfree:
+	clk_disable_unprepare(sunxi_codec->codec_clk_bus);
+err_devm_kfree:
+	return ret;
+}
+
+static int sunxi_codec_parse_params(struct device_node *np,
+				struct platform_device *pdev,
+				struct sunxi_codec_info *sunxi_codec)
+{
+	int ret = 0;
+	unsigned int temp_val;
+
+	/* get the special property form the board.dts */
+	ret = of_property_read_u32(np, "digital_vol", &temp_val);
+	if (ret < 0) {
+		LOG_WARN("digital volume get failed, use default vol");
+		sunxi_codec->digital_vol = 0;
+	} else {
+		sunxi_codec->digital_vol = temp_val;
+	}
+
+	/* lineout volume */
+	ret = of_property_read_u32(np, "lineout_vol", &temp_val);
+	if (ret < 0) {
+		LOG_WARN("lineout volume get failed, use default vol");
+		sunxi_codec->lineout_vol = 0;
+	} else {
+		sunxi_codec->lineout_vol = temp_val;
+	}
+
+	/* headphone volume */
+	ret = of_property_read_u32(np, "headphonegain", &temp_val);
+	if (ret < 0) {
+		LOG_WARN("headphonegain volume get failed, use default vol");
+		sunxi_codec->headphonegain = 0;
+	} else {
+		sunxi_codec->headphonegain = temp_val;
+	}
+
+	/* mic gain for capturing */
+	ret = of_property_read_u32(np, "mic1gain", &temp_val);
+	if (ret < 0) {
+		LOG_WARN("mic1gain get failed, use default vol");
+		sunxi_codec->mic1gain = 31;
+	} else {
+		sunxi_codec->mic1gain = temp_val;
+	}
+	ret = of_property_read_u32(np, "mic2gain", &temp_val);
+	if (ret < 0) {
+		LOG_WARN("mic2gain get failed, use default vol");
+		sunxi_codec->mic2gain = 31;
+	} else {
+		sunxi_codec->mic2gain = temp_val;
+	}
+	ret = of_property_read_u32(np, "mic3gain", &temp_val);
+	if (ret < 0) {
+		sunxi_codec->mic3gain = 31;
+		LOG_WARN("mic3gain get failed, use default vol");
+	} else {
+		sunxi_codec->mic3gain = temp_val;
+	}
+
+	/* Pa's delay time(ms) to work fine */
+	ret = of_property_read_u32(np, "pa_msleep_time", &temp_val);
+	if (ret < 0) {
+		LOG_WARN("pa_msleep get failed, use default vol");
+		sunxi_codec->spk_config.pa_msleep = 160;
+	} else {
+		sunxi_codec->spk_config.pa_msleep = temp_val;
+	}
+
+	/* PA/SPK enable property */
+	ret = of_property_read_u32(np, "pa_level", &temp_val);
+	if (ret < 0) {
+		LOG_WARN("pa_level get failed, use default vol");
+		sunxi_codec->spk_config.pa_level = 1;
+	} else {
+		sunxi_codec->spk_config.pa_level = temp_val;
+	}
+	ret = of_property_read_u32(np, "pa_pwr_level", &temp_val);
+	if (ret < 0) {
+		LOG_WARN("pa_pwr_level get failed, use default vol");
+		sunxi_codec->spk_pwr_config.pa_level = 1;
+	} else {
+		sunxi_codec->spk_pwr_config.pa_level = temp_val;
+	}
+
+	LOG_INFO("digital_vol:%d, lineout_vol:%d, mic1gain:%d, mic2gain:%d"
+		 " pa_msleep:%d, pa_level:%d, pa_pwr_level:%d\n",
+		 sunxi_codec->digital_vol,
+		 sunxi_codec->lineout_vol,
+		 sunxi_codec->mic1gain,
+		 sunxi_codec->mic2gain,
+		 sunxi_codec->spk_config.pa_msleep,
+		 sunxi_codec->spk_config.pa_level,
+		 sunxi_codec->spk_pwr_config.pa_level);
+
+#ifdef SUNXI_CODEC_DAP_ENABLE
+	/* ADC/DAC DRC/HPF func enable property */
+	ret = of_property_read_u32(np, "adcdrc_cfg", &temp_val);
+	if (ret < 0) {
+		LOG_ERR("adcdrc_cfg configs missing or invalid");
+	} else {
+		sunxi_codec->hw_config.adcdrc_cfg = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "adchpf_cfg", &temp_val);
+	if (ret < 0) {
+		LOG_ERR("adchpf_cfg configs missing or invalid");
+	} else {
+		sunxi_codec->hw_config.adchpf_cfg = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "dacdrc_cfg", &temp_val);
+	if (ret < 0) {
+		LOG_ERR("dacdrc_cfg configs missing or invalid");
+	} else {
+		sunxi_codec->hw_config.dacdrc_cfg = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "dachpf_cfg", &temp_val);
+	if (ret < 0) {
+		LOG_ERR("dachpf_cfg configs missing or invalid");
+	} else {
+		sunxi_codec->hw_config.dachpf_cfg = temp_val;
+	}
+
+	LOG_INFO("adcdrc_cfg:%d, adchpf_cfg:%d, dacdrc_cfg:%d, dachpf:%d",
+		 sunxi_codec->hw_config.adcdrc_cfg,
+		 sunxi_codec->hw_config.adchpf_cfg,
+		 sunxi_codec->hw_config.dacdrc_cfg,
+		 sunxi_codec->hw_config.dachpf_cfg);
+#endif
+	/* get the gpio number to control external speaker */
+	ret = of_get_named_gpio(np, "gpio-spk", 0);
+	if (ret >= 0) {
+		sunxi_codec->spk_config.used = 1;
+		sunxi_codec->spk_config.spk_gpio = ret;
+		if (!gpio_is_valid(sunxi_codec->spk_config.spk_gpio)) {
+			sunxi_codec->spk_config.used = 0;
+			LOG_ERR("gpio-spk set failed, SPK not work!");
+		} else {
+			ret = devm_gpio_request(&pdev->dev,
+				sunxi_codec->spk_config.spk_gpio, "SPK");
+			if (ret) {
+				sunxi_codec->spk_config.used = 0;
+				LOG_ERR("gpio-spk set failed, SPK not work!");
+			}
+		}
+	} else {
+		sunxi_codec->spk_config.used = 0;
+	}
+
+	ret = of_get_named_gpio(np, "gpio-spk-pwr", 0);
+	if (ret >= 0) {
+		sunxi_codec->spk_pwr_config.used = 1;
+		sunxi_codec->spk_pwr_config.spk_gpio = ret;
+		if (!gpio_is_valid(sunxi_codec->spk_pwr_config.spk_gpio)) {
+			sunxi_codec->spk_pwr_config.used = 0;
+			LOG_ERR("gpio-spk-pwr set failed, SPK not work!");
+		} else {
+			ret = devm_gpio_request(&pdev->dev,
+				sunxi_codec->spk_pwr_config.spk_gpio, "SPK POWER");
+			if (ret) {
+				sunxi_codec->spk_pwr_config.used = 0;
+				LOG_ERR("gpio-spk-pwr set failed, SPK not work!");
+			} else {
+				gpio_direction_output(sunxi_codec->spk_pwr_config.spk_gpio, 1);
+				gpio_set_value(sunxi_codec->spk_pwr_config.spk_gpio,
+						sunxi_codec->spk_pwr_config.pa_level);
+			}
+		}
+	} else {
+		sunxi_codec->spk_pwr_config.used = 0;
+	}
+
+	ret = of_property_read_u32(np, "rx_sync_en", &temp_val);
+	if (ret < 0) {
+		LOG_ERR("rx_sync_en configs missing or invalid");
+		sunxi_codec->rx_sync_en = 0;
+	} else {
+		sunxi_codec->rx_sync_en = temp_val;
+	}
+
+	if (sunxi_codec->rx_sync_en) {
+		sunxi_codec->rx_sync_domain = RX_SYNC_SYS_DOMAIN;
+		sunxi_codec->rx_sync_id =
+			sunxi_rx_sync_probe(sunxi_codec->rx_sync_domain);
+		if (sunxi_codec->rx_sync_id < 0) {
+			LOG_ERR("sunxi_rx_sync_probe failed");
+			return -EINVAL;
+		}
+		LOG_INFO("sunxi_rx_sync_probe successful. domain=%d, id=%d",
+			sunxi_codec->rx_sync_domain,
+			sunxi_codec->rx_sync_id);
+	}
+
+	return 0;
+}
+
+static int sunxi_internal_codec_probe(struct platform_device *pdev)
+{
+	struct sunxi_codec_info *sunxi_codec;
+	struct resource res;
+	struct resource *memregion = NULL;
+	struct device_node *np = pdev->dev.of_node;
+	int ret;
+
+	if (IS_ERR_OR_NULL(np)) {
+		LOG_ERR("pdev->dev.of_node is err");
+		ret = -EFAULT;
+		goto err_node_put;
+	}
+
+	sunxi_codec = devm_kzalloc(&pdev->dev,
+				sizeof(struct sunxi_codec_info), GFP_KERNEL);
+	if (!sunxi_codec) {
+		LOG_ERR("Can't allocate sunxi codec memory");
+		ret = -ENOMEM;
+		goto err_node_put;
+	}
+	dev_set_drvdata(&pdev->dev, sunxi_codec);
+	sunxi_codec->dev = &pdev->dev;
+
+	/*
+	if (sunxi_codec_regulator_init(pdev, sunxi_codec) != 0) {
+		LOG_ERR("Failed to init sunxi audio regulator");
+		ret = -EFAULT;
+		goto err_devm_kfree;
+	}
+	*/
+
+	if (sunxi_codec_parse_params(np, pdev, sunxi_codec) != 0) {
+		LOG_ERR("Failed to parse sunxi audio params");
+		ret = -EFAULT;
+		goto err_devm_kfree;
+	}
+
+	if (sunxi_codec_clk_init(np, pdev, sunxi_codec) != 0) {
+		LOG_ERR("Failed to init sunxi audio clk");
+		ret = -EFAULT;
+		goto err_devm_kfree;
+	}
+
+	/* codec reg_base */
+	/* get the true codec addr form np0 to avoid the build warning */
+	ret = of_address_to_resource(np, 0, &res);
+	if (ret) {
+		LOG_ERR("Failed to get sunxi resource");
+		return -EINVAL;
+		goto err_moduleclk_disable;
+	}
+
+	memregion = devm_request_mem_region(&pdev->dev, res.start,
+				resource_size(&res), "sunxi-internal-codec");
+	if (!memregion) {
+		LOG_ERR("sunxi memory region already claimed");
+		ret = -EBUSY;
+		goto err_moduleclk_disable;
+	}
+
+	sunxi_codec->digital_base = devm_ioremap(&pdev->dev,
+					res.start, resource_size(&res));
+	if (!sunxi_codec->digital_base) {
+		LOG_ERR("sunxi digital_base ioremap failed");
+		ret = -EBUSY;
+		goto err_moduleclk_disable;
+	}
+
+	sunxi_codec->regmap = devm_regmap_init_mmio(&pdev->dev,
+				sunxi_codec->digital_base,
+				&sunxi_codec_regmap_config);
+	if (IS_ERR_OR_NULL(sunxi_codec->regmap)) {
+		LOG_ERR("regmap init failed");
+		ret = PTR_ERR(sunxi_codec->regmap);
+		goto err_moduleclk_disable;
+	}
+
+	/* CODEC DAI cfg and register */
+	ret = devm_snd_soc_register_component(&pdev->dev, &soc_codec_dev_sunxi,
+				sunxi_codec_dai, ARRAY_SIZE(sunxi_codec_dai));
+	if (ret < 0) {
+		LOG_ERR("register codec failed");
+		goto err_moduleclk_disable;
+	}
+
+	ret  = sysfs_create_group(&pdev->dev.kobj, &audio_debug_attr_group);
+	if (ret) {
+		LOG_WARN("failed to create attr group");
+		goto err_moduleclk_disable;
+	}
+
+	LOG_INFO("codec probe finished");
+
+	return 0;
+
+
+err_moduleclk_disable:
+	clk_disable_unprepare(sunxi_codec->dacclk);
+	clk_disable_unprepare(sunxi_codec->adcclk);
+	clk_disable_unprepare(sunxi_codec->pllaudio0);
+	clk_disable_unprepare(sunxi_codec->pllaudio1_div5);
+err_devm_kfree:
+	devm_kfree(&pdev->dev, sunxi_codec);
+err_node_put:
+	of_node_put(np);
+	return ret;
+}
+
+static int  __exit sunxi_internal_codec_remove(struct platform_device *pdev)
+{
+	struct sunxi_codec_info *sunxi_codec = dev_get_drvdata(&pdev->dev);
+	struct codec_spk_config *spk_cfg = &(sunxi_codec->spk_config);
+
+	if (sunxi_codec->rx_sync_en)
+		sunxi_rx_sync_remove(sunxi_codec->rx_sync_domain);
+
+	if (spk_cfg->used) {
+		devm_gpio_free(&pdev->dev,
+					sunxi_codec->spk_config.spk_gpio);
+	}
+
+	if (sunxi_codec->vol_supply.avcc) {
+		regulator_disable(sunxi_codec->vol_supply.avcc);
+		regulator_put(sunxi_codec->vol_supply.avcc);
+	}
+
+	if (sunxi_codec->vol_supply.hpvcc) {
+		regulator_disable(sunxi_codec->vol_supply.hpvcc);
+		regulator_put(sunxi_codec->vol_supply.hpvcc);
+	}
+
+	sysfs_remove_group(&pdev->dev.kobj, &audio_debug_attr_group);
+	snd_soc_unregister_component(&pdev->dev);
+
+	clk_disable_unprepare(sunxi_codec->dacclk);
+	clk_put(sunxi_codec->dacclk);
+	clk_disable_unprepare(sunxi_codec->adcclk);
+	clk_put(sunxi_codec->adcclk);
+	clk_disable_unprepare(sunxi_codec->pllaudio0);
+	clk_put(sunxi_codec->pllaudio0);
+	clk_disable_unprepare(sunxi_codec->pllaudio1_div5);
+	clk_put(sunxi_codec->pllaudio1_div5);
+	clk_disable_unprepare(sunxi_codec->codec_clk_bus);
+	clk_put(sunxi_codec->codec_clk_bus);
+	reset_control_assert(sunxi_codec->codec_clk_rst);
+
+	devm_iounmap(&pdev->dev, sunxi_codec->digital_base);
+	devm_kfree(&pdev->dev, sunxi_codec);
+	platform_set_drvdata(pdev, NULL);
+
+	LOG_INFO("codec remove finished");
+
+	return 0;
+}
+
+static const struct of_device_id sunxi_internal_codec_of_match[] = {
+	{ .compatible = "allwinner,sunxi-internal-codec", },
+	{},
+};
+
+static struct platform_driver sunxi_internal_codec_driver = {
+	.driver = {
+		.name = "sunxi-internal-codec",
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_internal_codec_of_match,
+	},
+	.probe = sunxi_internal_codec_probe,
+	.remove = __exit_p(sunxi_internal_codec_remove),
+};
+module_platform_driver(sunxi_internal_codec_driver);
+
+MODULE_DESCRIPTION("SUNXI Codec ASoC driver");
+MODULE_AUTHOR("Dby <Dby@allwinnertech.com>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:sunxi-internal-codec");
diff --git a/sound/soc/sunxi/sun20iw1-codec.h b/sound/soc/sunxi/sun20iw1-codec.h
new file mode 100644
index 000000000..0eab82a3d
--- /dev/null
+++ b/sound/soc/sunxi/sun20iw1-codec.h
@@ -0,0 +1,557 @@
+/*
+ * sound\soc\sunxi\sun20iw1-codec.h
+ * (C) Copyright 2021-2026
+ * allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * yumingfeng <yumingfeng@allwinnertech.com>
+ * luguofang <luguofang@allwinnertech.com>
+ * Dby <Dby@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+#ifndef _SUN20IW1_CODEC_H
+#define _SUN20IW1_CODEC_H
+
+#include "sunxi-pcm.h"
+
+#define SUNXI_DAC_DPC		0x00
+#define SUNXI_DAC_VOL_CTRL	0x04
+#define SUNXI_DAC_FIFOC		0x10
+#define SUNXI_DAC_FIFOS		0x14
+
+#define SUNXI_DAC_TXDATA	0X20
+#define SUNXI_DAC_CNT		0x24
+#define SUNXI_DAC_DG		0x28
+
+#define	SUNXI_ADC_FIFOC		0x30
+#define	SUNXI_ADC_VOL_CTRL	0x34
+#define SUNXI_ADC_FIFOS		0x38
+#define SUNXI_ADC_RXDATA	0x40
+#define SUNXI_ADC_CNT		0x44
+#define SUNXI_ADC_DG		0x4C
+#define SUNXI_ADC_DIG_CTRL	0x50
+#define SUNXI_VRA1SPEEDUP_DOWN_CTRL	0x54
+
+#define SUNXI_DAC_DAP_CTL	0xF0
+#define SUNXI_ADC_DAP_CTL	0xF8
+
+#define SUNXI_DAC_DRC_HHPFC	0x100
+#define SUNXI_DAC_DRC_LHPFC	0x104
+#define SUNXI_DAC_DRC_CTRL	0x108
+#define SUNXI_DAC_DRC_LPFHAT	0x10C
+#define SUNXI_DAC_DRC_LPFLAT	0x110
+#define SUNXI_DAC_DRC_RPFHAT	0x114
+#define SUNXI_DAC_DRC_RPFLAT	0x118
+#define SUNXI_DAC_DRC_LPFHRT	0x11C
+#define SUNXI_DAC_DRC_LPFLRT	0x120
+#define SUNXI_DAC_DRC_RPFHRT	0x124
+#define SUNXI_DAC_DRC_RPFLRT	0x128
+#define SUNXI_DAC_DRC_LRMSHAT	0x12C
+#define SUNXI_DAC_DRC_LRMSLAT	0x130
+#define SUNXI_DAC_DRC_RRMSHAT	0x134
+#define SUNXI_DAC_DRC_RRMSLAT	0x138
+#define SUNXI_DAC_DRC_HCT	0x13C
+#define SUNXI_DAC_DRC_LCT	0x140
+#define SUNXI_DAC_DRC_HKC	0x144
+#define SUNXI_DAC_DRC_LKC	0x148
+#define SUNXI_DAC_DRC_HOPC	0x14C
+#define SUNXI_DAC_DRC_LOPC	0x150
+#define SUNXI_DAC_DRC_HLT	0x154
+#define SUNXI_DAC_DRC_LLT	0x158
+#define SUNXI_DAC_DRC_HKI	0x15C
+#define SUNXI_DAC_DRC_LKI	0x160
+#define SUNXI_DAC_DRC_HOPL	0x164
+#define SUNXI_DAC_DRC_LOPL	0x168
+#define SUNXI_DAC_DRC_HET	0x16C
+#define SUNXI_DAC_DRC_LET	0x170
+#define SUNXI_DAC_DRC_HKE	0x174
+#define SUNXI_DAC_DRC_LKE	0x178
+#define SUNXI_DAC_DRC_HOPE	0x17C
+#define SUNXI_DAC_DRC_LOPE	0x180
+#define SUNXI_DAC_DRC_HKN	0x184
+#define SUNXI_DAC_DRC_LKN	0x188
+#define SUNXI_DAC_DRC_SFHAT	0x18C
+#define SUNXI_DAC_DRC_SFLAT	0x190
+#define SUNXI_DAC_DRC_SFHRT	0x194
+#define SUNXI_DAC_DRC_SFLRT	0x198
+#define SUNXI_DAC_DRC_MXGHS	0x19C
+#define SUNXI_DAC_DRC_MXGLS	0x1A0
+#define SUNXI_DAC_DRC_MNGHS	0x1A4
+#define SUNXI_DAC_DRC_MNGLS	0x1A8
+#define SUNXI_DAC_DRC_EPSHC	0x1AC
+#define SUNXI_DAC_DRC_EPSLC	0x1B0
+#define SUNXI_DAC_DRC_OPT	0x1B4
+#define SUNXI_DAC_DRC_HPFHGAIN	0x1B8
+#define SUNXI_DAC_DRC_HPFLGAIN	0x1BC
+
+#define SUNXI_ADC_DRC_HHPFC	0x200
+#define SUNXI_ADC_DRC_LHPFC	0x204
+#define SUNXI_ADC_DRC_CTRL	0x208
+#define SUNXI_ADC_DRC_LPFHAT	0x20C
+#define SUNXI_ADC_DRC_LPFLAT	0x210
+#define SUNXI_ADC_DRC_RPFHAT	0x214
+#define SUNXI_ADC_DRC_RPFLAT	0x218
+#define SUNXI_ADC_DRC_LPFHRT	0x21C
+#define SUNXI_ADC_DRC_LPFLRT	0x220
+#define SUNXI_ADC_DRC_RPFHRT	0x224
+#define SUNXI_ADC_DRC_RPFLRT	0x228
+#define SUNXI_ADC_DRC_LRMSHAT	0x22C
+#define SUNXI_ADC_DRC_LRMSLAT	0x230
+#define SUNXI_ADC_DRC_RRMSHAT	0x234
+#define SUNXI_ADC_DRC_RRMSLAT	0x238
+#define SUNXI_ADC_DRC_HCT	0x23C
+#define SUNXI_ADC_DRC_LCT	0x240
+#define SUNXI_ADC_DRC_HKC	0x244
+#define SUNXI_ADC_DRC_LKC	0x248
+#define SUNXI_ADC_DRC_HOPC	0x24C
+#define SUNXI_ADC_DRC_LOPC	0x250
+#define SUNXI_ADC_DRC_HLT	0x254
+#define SUNXI_ADC_DRC_LLT	0x258
+#define SUNXI_ADC_DRC_HKI	0x25C
+#define SUNXI_ADC_DRC_LKI	0x260
+#define SUNXI_ADC_DRC_HOPL	0x264
+#define SUNXI_ADC_DRC_LOPL	0x268
+#define SUNXI_ADC_DRC_HET	0x26C
+#define SUNXI_ADC_DRC_LET	0x270
+#define SUNXI_ADC_DRC_HKE	0x274
+#define SUNXI_ADC_DRC_LKE	0x278
+#define SUNXI_ADC_DRC_HOPE	0x27C
+#define SUNXI_ADC_DRC_LOPE	0x280
+#define SUNXI_ADC_DRC_HKN	0x284
+#define SUNXI_ADC_DRC_LKN	0x288
+#define SUNXI_ADC_DRC_SFHAT	0x28C
+#define SUNXI_ADC_DRC_SFLAT	0x290
+#define SUNXI_ADC_DRC_SFHRT	0x294
+#define SUNXI_ADC_DRC_SFLRT	0x298
+#define SUNXI_ADC_DRC_MXGHS	0x29C
+#define SUNXI_ADC_DRC_MXGLS	0x2A0
+#define SUNXI_ADC_DRC_MNGHS	0x2A4
+#define SUNXI_ADC_DRC_MNGLS	0x2A8
+#define SUNXI_ADC_DRC_EPSHC	0x2AC
+#define SUNXI_ADC_DRC_EPSLC	0x2B0
+#define SUNXI_ADC_DRC_OPT	0x2B4
+#define SUNXI_ADC_DRC_HPFHGAIN	0x2B8
+#define SUNXI_ADC_DRC_HPFLGAIN	0x2BC
+
+#define SUNXI_AC_VERSION	0x2C0
+
+/* Analog register */
+#define SUNXI_ADC1_REG		0x300
+#define SUNXI_ADC2_REG		0x304
+#define SUNXI_ADC3_REG		0x308
+#define SUNXI_DAC_REG		0x310
+#define SUNXI_MICBIAS_REG	0x318
+#define SUNXI_RAMP_REG		0x31C
+#define SUNXI_BIAS_REG		0x320
+#define SUNXI_HMIC_CTRL		0x328
+#define SUNXI_HMIC_STS		0x32C
+#define SUNXI_HP2_REG		0x340
+#define SUNXI_POWER_REG		0x348
+#define SUNXI_ADC_CUR_REG	0x34C
+
+/* SUNXI_DAC_DPC:0x00 */
+#define EN_DAC			31
+#define MODQU			25
+#define DWA_EN			24
+#define HPF_EN			18
+#define DVOL			12
+#define DAC_HUB_EN		0
+
+/* SUNXI_DAC_VOL_CTRL:0x04 */
+#define DAC_VOL_SEL		16
+#define DAC_VOL_L		8
+#define DAC_VOL_R		0
+
+/* SUNXI_DAC_FIFOC:0x10 */
+#define DAC_FS			29
+#define FIR_VER			28
+#define SEND_LASAT		26
+#define FIFO_MODE		24
+#define DAC_DRQ_CLR_CNT		21
+#define TX_TRIG_LEVEL		8
+#define DAC_MONO_EN		6
+#define TX_SAMPLE_BITS		5
+#define DAC_DRQ_EN		4
+#define DAC_IRQ_EN		3
+#define FIFO_UNDERRUN_IRQ_EN	2
+#define FIFO_OVERRUN_IRQ_EN	1
+#define FIFO_FLUSH		0
+
+/* SUNXI_DAC_FIFOS:0x14 */
+#define	TX_EMPTY		23
+#define	DAC_TXE_CNT		8
+#define	DAC_TXE_INT		3
+#define	DAC_TXU_INT		2
+#define	DAC_TXO_INT		1
+
+/* SUNXI_DAC_DG:0x28 */
+#define	DAC_MODU_SEL		11
+#define	DAC_PATTERN_SEL		9
+#define	DAC_CODEC_CLK_SEL	8
+#define	DAC_SWP			6
+#define	ADDA_LOOP_MODE		0
+
+/* SUNXI_ADC_FIFOC:0x30 */
+#define ADC_FS			29
+#define EN_AD			28
+#define ADCFDT			26
+#define ADCDFEN			25
+#define RX_FIFO_MODE		24
+#define RX_SYNC_EN_STA		21
+#define RX_SYNC_EN		20
+#define RX_SAMPLE_BITS		16
+#define RX_FIFO_TRG_LEVEL	4
+#define ADC_DRQ_EN		3
+#define ADC_IRQ_EN		2
+#define ADC_OVERRUN_IRQ_EN	1
+#define ADC_FIFO_FLUSH		0
+
+/* SUNXI_ADC_VOL_CTRL:0x34 */
+#define ADC3_VOL		16
+#define ADC2_VOL		8
+#define ADC1_VOL		0
+
+/* SUNXI_ADC_FIFOS:0x38 */
+#define	RXA			23
+#define	ADC_RXA_CNT		8
+#define	ADC_RXA_INT		3
+#define	ADC_RXO_INT		1
+
+/* SUNXI_ADC_DG:0x4C */
+#define	AD_SWP2			25
+#define	AD_SWP1			24
+
+/* SUNXI_ADC_DIG_CTRL:0x50 */
+#define	ADC3_VOL_EN		17
+#define	ADC1_2_VOL_EN		16
+#define	ADC3_CHANNEL_EN		2
+#define	ADC2_CHANNEL_EN		1
+#define	ADC1_CHANNEL_EN		0
+#define	ADC_CHANNEL_EN		0
+
+/* SUNXI_VRA1SPEEDUP_DOWN_CTRL:0x54 */
+#define	VRA1SPEEDUP_DOWN_STATE		4
+#define	VRA1SPEEDUP_DOWN_CTRL		1
+#define	VRA1SPEEDUP_DOWN_RST_CTRL	0
+
+/* SUNXI_DAC_DAP_CTL:0xf0 */
+#define	DDAP_EN			31
+#define	DDAP_DRC_EN		29
+#define	DDAP_HPF_EN		28
+
+/* SUNXI_ADC_DAP_CTL:0xf8 */
+#define	ADC_DAP0_EN		31
+#define	ADC_DRC0_EN		29
+#define	ADC_HPF0_EN		28
+#define	ADC_DAP1_EN		27
+#define	ADC_DRC1_EN		25
+#define	ADC_HPF1_EN		24
+
+/* SUNXI_DAC_DRC_HHPFC : 0x100*/
+#define DAC_HHPF_CONF		0
+
+/* SUNXI_DAC_DRC_LHPFC : 0x104*/
+#define DAC_LHPF_CONF		0
+
+/* SUNXI_DAC_DRC_CTRL : 0x108*/
+#define DAC_DRC_DELAY_OUT_STATE		15
+#define DAC_DRC_SIGNAL_DELAY		8
+#define DAC_DRC_DELAY_BUF_EN		7
+#define DAC_DRC_GAIN_MAX_EN		6
+#define DAC_DRC_GAIN_MIN_EN		5
+#define DAC_DRC_NOISE_DET_EN		4
+#define DAC_DRC_SIGNAL_SEL		3
+#define DAC_DRC_DELAY_EN		2
+#define DAC_DRC_LT_EN			1
+#define DAC_DRC_ET_EN			0
+
+/* SUNXI_ADC_DRC_HHPFC : 0x200*/
+#define ADC_HHPF_CONF		0
+
+/* SUNXI_ADC_DRC_LHPFC : 0x204*/
+#define ADC_LHPF_CONF		0
+
+/* SUNXI_ADC_DRC_CTRL : 0x208*/
+#define ADC_DRC_DELAY_OUT_STATE		15
+#define ADC_DRC_SIGNAL_DELAY		8
+#define ADC_DRC_DELAY_BUF_EN		7
+#define ADC_DRC_GAIN_MAX_EN		6
+#define ADC_DRC_GAIN_MIN_EN		5
+#define ADC_DRC_NOISE_DET_EN		4
+#define ADC_DRC_SIGNAL_SEL		3
+#define ADC_DRC_DELAY_EN		2
+#define ADC_DRC_LT_EN			1
+#define ADC_DRC_ET_EN			0
+
+/* SUNXI_ADC1_REG : 0x300 */
+#define ADC1_EN			31
+#define MIC1_PGA_EN		30
+#define ADC1_DITHER_CTRL	29
+#define MIC1_SIN_EN		28
+#define FMINLEN			27
+#define FMINLG			26
+#define ADC1_DSM_DITHER_LVL	24
+#define LINEINLEN		23
+#define LINEINLG		22
+#define ADC1_IOPBUFFER		20
+#define ADC1_PGA_CTRL_RCM	18
+#define ADC1_PGA_IN_VCM_CTRL	16
+#define IOPADC			14
+#define ADC1_PGA_GAIN_CTRL	8
+#define ADC1_IOPAAF		6
+#define ADC1_IOPSDM1		4
+#define ADC1_IOPSDM2		2
+#define ADC1_IOPMIC		0
+
+/* SUNXI_ADC2_REG : 0x304 */
+#define ADC2_EN			31
+#define MIC2_PGA_EN		30
+#define ADC2_DITHER_CTRL	29
+#define MIC2_SIN_EN		28
+#define FMINREN			27
+#define FMINRG			26
+#define ADC2_DSM_DITHER_LVL	24
+#define LINEINREN		23
+#define LINEINRG		22
+#define ADC2_IOPBUFFER		20
+#define ADC2_PGA_CTRL_RCM	18
+#define ADC2_PGA_IN_VCM_CTRL	16
+#define ADC2_PGA_GAIN_CTRL	8
+#define ADC2_IOPAAF		6
+#define ADC2_IOPSDM1		4
+#define ADC2_IOPSDM2		2
+#define ADC2_IOPMIC		0
+
+/* SUNXI_ADC3_REG : 0x308 */
+#define ADC3_EN			31
+#define MIC3_PGA_EN		30
+#define ADC3_DITHER_CTRL	29
+#define MIC3_SIN_EN		28
+#define ADC3_DSM_DITHER_LVL	24
+#define ADC3_IOPBUFFER		20
+#define ADC3_PGA_CTRL_RCM	18
+#define ADC3_PGA_IN_VCM_CTRL	16
+#define ADC3_PGA_GAIN_CTRL	8
+#define ADC3_IOPAAF		6
+#define ADC3_IOPSDM1		4
+#define ADC3_IOPSDM2		2
+#define ADC3_IOPMIC		0
+
+/* SUNXI_DAC_REG : 0x310 */
+#define CURRENT_TEST_SELECT	23
+#define	VRA2_IOPVRS		20
+#define	ILINEOUTAMPS		18
+#define IOPDACS			16
+#define DACLEN			15
+#define DACREN			14
+#define LINEOUTLEN		13
+#define DACLMUTE		12
+#define LINEOUTREN		11
+#define DACRMUTE		10
+#define LINEOUTLDIFFEN		6
+#define LINEOUTRDIFFEN		5
+#define LINEOUT_VOL		0
+
+/* SUNXI_MICBIAS_REG : 0x318 */
+#define SELDETADCFS		28
+#define SELDETADCDB		26
+#define SELDETADCBF		24
+#define JACKDETEN		23
+#define SELDETADCDY		21
+#define MICADCEN		20
+#define POPFREE			19
+#define DETMODE			18
+#define AUTOPLEN		17
+#define MICDETPL		16
+#define HMICBIASEN		15
+#define HBIASSEL		13
+#define	HMICBIAS_CHOP_EN	12
+#define HMICBIAS_CHOP_CLK_SEL	10
+#define MMICBIASEN		7
+#define	MBIASSEL		5
+#define	MMICBIAS_CHOP_EN	4
+#define MMICBIAS_CHOP_CLK_SEL	2
+
+/* SUNXI_RAMP_REG : 0x31C */
+#define RAMP_RISE_INT_EN	31
+#define RAMP_RISE_INT		30
+#define RAMP_FALL_INT_EN	29
+#define RAMP_FALL_INT		28
+#define RAMP_SRST		24
+#define RAMP_CLK_DIV_M		16
+#define HP_PULL_OUT_EN		15
+#define RAMP_HOLD_STEP		12
+#define GAP_STEP		8
+#define RAMP_STEP		4
+#define RMD_EN			3
+#define RMU_EN			2
+#define RMC_EN			1
+#define RD_EN			0
+
+/* SUNXI_BIAS_REG : 0x320 */
+#define AC_BIASDATA		0
+
+/* SUNXI_HMIC_CTRL : 0x328 */
+#define HMIC_SAMPLE_SEL		21
+#define MDATA_THRESHOLD		16
+#define HMIC_SF			14
+#define HMIC_M			10
+#define HMIC_N			6
+#define MDATA_THRESHOLD_DB	3
+#define JACK_OUT_IRQ_EN		2
+#define JACK_IN_IRQ_EN		1
+#define MIC_DET_IRQ_EN		0
+
+/* SUNXI_HMIC_STS : 0x32C */
+#define MDATA_DISCARD		13
+#define	HMIC_DATA		8
+#define JACK_DET_OUT_ST		4
+#define JACK_DET_OIRQ		4
+#define JACK_DET_IIN_ST 	3
+#define JACK_DET_IIRQ		3
+#define MIC_DET_ST		0
+
+/* SUNXI_HP2_REG	:0x340 */
+#define HPFB_BUF_EN		31
+#define HEADPHONE_GAIN		28
+#define HPFB_RES		26
+#define OPDRV_CUR		24
+#define IOPHP			22
+#define HP_DRVEN		21
+#define HP_DRVOUTEN		20
+#define RSWITCH			19
+#define RAMPEN			18
+#define HPFB_IN_EN		17
+#define RAMP_FINAL_CTRL		16
+#define RAMP_OUT_EN		15
+#define RAMP_FINAL_STATE_RES	13
+#define FB_BUF_OUTPUT_CURRENT	8
+
+/* SUNXI_POWER_REG      :0x348 */
+#define ALDO_EN			31
+#define HPLDO_EN		30
+#define VAR1SPEEDUP_DOWN_FURTHER_CTRL	29
+#define AVCCPOR			16
+#define ALDO_OUTPUT_VOLTAGE	12
+#define HPLDO_OUTPUT_VOLTAGE	8
+#define BG_TRIM			0
+
+/* SUNXI_ADC_CUR_REG    :0x34C */
+#define ADC3_IOPMIC2		20
+#define ADC3_OP_MIC1_CUR	18
+#define ADC3_OP_MIC2_CUR	16
+#define ADC2_IOPMIC2		12
+#define ADC2_OP_MIC1_CUR	10
+#define ADC2_OP_MIC2_CUR	8
+#define ADC1_IOPMIC2		4
+#define ADC1_OP_MIC1_CUR	2
+#define ADC1_OP_MIC2_CUR	0
+
+#define CODEC_TX_FIFO_SIZE	128
+#define CODEC_RX_FIFO_SIZE	256
+
+/* gain select */
+#define MIC1_GAIN_SHIFT		1
+#define MIC2_GAIN_SHIFT		2
+#define MIC3_GAIN_SHIFT		3
+
+#define HP_GAIN_SHIFT		4
+
+/*125ms * (HP_DEBOUCE_TIME+1)*/
+#define HP_DEBOUCE_TIME	0x3
+
+#define REG_LABEL(constant)	{#constant, constant, 0}
+#define REG_LABEL_END           {NULL, 0, 0}
+
+/* SUNXI_CODEC_DAP_ENABLE: Whether to use the adc/dac drc/hpf function */
+#define SUNXI_CODEC_DAP_ENABLE
+
+/* SUNXI_CODEC_HUB_ENABLE: Whether to use the hub mode */
+#define SUNXI_CODEC_HUB_ENABLE
+
+/* SUNXI_CODEC_ADCSWAP_ENABLE: Whether to open the adc swap func controls */
+#define SUNXI_CODEC_ADCSWAP_ENABLE
+
+struct reg_label {
+	const char *name;
+	const unsigned int address;
+	unsigned int value;
+};
+
+struct codec_hw_config {
+	u32 adcdrc_cfg:8;
+	u32 dacdrc_cfg:8;
+	u32 adchpf_cfg:8;
+	u32 dachpf_cfg:8;
+};
+
+struct codec_spk_config {
+	u32 spk_gpio;
+	u32 pa_msleep;
+	bool used;
+	bool pa_level;
+};
+
+struct sample_rate {
+	unsigned int samplerate;
+	unsigned int rate_bit;
+};
+
+struct voltage_supply {
+	struct regulator *avcc;
+	struct regulator *hpvcc;
+};
+
+struct codec_dap {
+	int drc_enable;
+	int hpf_enable;
+};
+
+struct sunxi_codec_info {
+	struct device *dev;
+	struct regmap *regmap;
+	void __iomem *digital_base;
+	struct clk *pllaudio0;
+	struct clk *pllaudio1_div5;
+	struct clk *dacclk;
+	struct clk *adcclk;
+	struct clk *codec_clk_bus;
+	struct reset_control *codec_clk_rst;
+
+	/* regulator about */
+	struct voltage_supply vol_supply;
+
+	/* for dap function */
+	struct codec_dap dac_dap;
+	struct codec_dap adc_dap;
+	int dac_dap_enable;
+	int adc_dap_enable;
+
+	/* self user config params */
+	u32 digital_vol;
+	u32 lineout_vol;
+	u32 dac_digital_vol;
+
+	bool mic1gain_now;
+	bool mic2gain_now;
+	bool mic3gain_now;
+	bool hpgain_now;
+	u32 mic1gain;
+	u32 mic2gain;
+	u32 mic3gain;
+	u32 headphonegain;
+
+	u32 rx_sync_en;
+	int rx_sync_id;
+	rx_sync_domain_t rx_sync_domain;
+
+	struct codec_spk_config spk_config;
+	struct codec_spk_config spk_pwr_config;
+	struct codec_hw_config hw_config;
+};
+
+#endif
diff --git a/sound/soc/sunxi/sun20iw1-sndcodec.c b/sound/soc/sunxi/sun20iw1-sndcodec.c
new file mode 100644
index 000000000..db8075f08
--- /dev/null
+++ b/sound/soc/sunxi/sun20iw1-sndcodec.c
@@ -0,0 +1,900 @@
+/*
+ * sound\soc\sunxi\sun20iw1-sndcodec.c
+ * (C) Copyright 2021-2026
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * huangxin <huangxin@Reuuimllatech.com>
+ * liushaohua <liushaohua@allwinnertech.com>
+ * yumingfengng <yumingfeng@allwinnertech.com>
+ * luguofang <luguofang@allwinnertech.com>
+ * Dby <Dby@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+#include <linux/gpio.h>
+#include <linux/io.h>
+#include <linux/input.h>
+#include <linux/of.h>
+#include <linux/delay.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/jack.h>
+#include <sound/pcm_params.h>
+#include <sound/soc-dapm.h>
+
+#include "sun20iw1-codec.h"
+
+#define LOG_ERR(fmt, arg...)	pr_err("[SNDCODEC][%s][%d]:" fmt "\n", __func__, __LINE__, ##arg)
+#define LOG_WARN(fmt, arg...)	pr_warn("[SNDCODEC][%s][%d]:" fmt "\n", __func__, __LINE__, ##arg)
+#define LOG_INFO(fmt, arg...)	pr_info("[SNDCODEC][%s][%d]:" fmt "\n", __func__, __LINE__, ##arg)
+
+static int mdata_threshold = 0x10;
+module_param(mdata_threshold, int, 0644);
+MODULE_PARM_DESC(mdata_threshold,
+		"SUNXI hmic data threshold");
+
+typedef enum {
+	RESUME_IRQ  = 0x0,
+	SYSINIT_IRQ = 0x1,
+	OTHER_IRQ   = 0x2,
+} _jack_irq_times;
+
+enum HPDETECTWAY {
+	HP_DETECT_LOW = 0x0,
+	HP_DETECT_HIGH = 0x1,
+};
+
+enum dectect_jack {
+	PLUG_OUT = 0x0,
+	PLUG_IN  = 0x1,
+};
+
+enum JACK_FUNCTION {
+	JACK_ENABLE = 0x1,
+	JACK_DISABLE = 0x0,
+};
+
+static bool is_irq;
+static int switch_state;
+
+struct sunxi_card_priv {
+	struct snd_soc_card *card;
+	struct snd_soc_component *component;
+	struct delayed_work hs_init_work;
+	struct delayed_work hs_detect_work;
+	struct delayed_work hs_button_work;
+	struct delayed_work hs_checkplug_work;
+	struct mutex jack_mlock;
+	struct snd_soc_jack jack;
+	struct timespec64 tv_headset_plugin;	/*4*/
+	_jack_irq_times jack_irq_times;
+	u32 detect_state;
+	u32 jackirq;				/*switch irq*/
+	u32 HEADSET_DATA;			/*threshod for switch insert*/
+	u32 headset_basedata;
+	u32 switch_status;
+	u32 key_volup;
+	u32 key_voldown;
+	u32 key_hook;
+	u32 key_voiceassist;
+	u32 hp_detect_case;
+	u32 jack_func;
+};
+
+/*
+ * Identify the jack type as Headset/Headphone/None
+ */
+static int sunxi_check_jack_type(struct snd_soc_jack *jack)
+{
+	u32 reg_val = 0;
+	u32 jack_type = 0, tempdata = 0;
+	struct sunxi_card_priv *priv = container_of(jack,
+						    struct sunxi_card_priv,
+						    jack);
+
+	reg_val = snd_soc_component_read32(priv->component, SUNXI_HMIC_STS);
+	tempdata = (reg_val >> HMIC_DATA) & 0x1f;
+	priv->headset_basedata = tempdata;
+
+	if (tempdata >= priv->HEADSET_DATA) {
+		/* headset:4 */
+		jack_type = SND_JACK_HEADSET;
+	} else {
+		/* headphone:3, disable hbias and adc */
+		snd_soc_component_update_bits(priv->component,
+				SUNXI_MICBIAS_REG,
+				(0x1 << HMICBIASEN),
+				(0x0 << HMICBIASEN));
+		snd_soc_component_update_bits(priv->component,
+				SUNXI_MICBIAS_REG,
+				(0x1 << MICADCEN),
+				(0x0 << MICADCEN));
+		jack_type = SND_JACK_HEADPHONE;
+	}
+
+	return jack_type;
+}
+
+/* Checks hs insertion by mdet */
+static void sunxi_check_hs_plug(struct work_struct *work)
+{
+	struct sunxi_card_priv *priv = container_of(work,
+						    struct sunxi_card_priv,
+						    hs_checkplug_work.work);
+
+	mutex_lock(&priv->jack_mlock);
+	if (priv->detect_state != PLUG_IN) {
+		/* Enable MDET */
+		snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+				(0x1 << MIC_DET_IRQ_EN),
+				(0x1 << MIC_DET_IRQ_EN));
+		snd_soc_component_update_bits(priv->component, SUNXI_MICBIAS_REG,
+				(0x1 << MICADCEN),
+				(0x1 << MICADCEN));
+		/* Enable PA */
+		/*
+		snd_soc_component_update_bits(priv->component, SUNXI_HEADPHONE_REG,
+				(0x1 << HPPA_EN),
+				(0x1 << HPPA_EN));
+		*/
+	} else {
+		/*
+		 * Enable HPPA_EN
+		 * FIXME:When the Audio HAL is not at the do_output_standby,
+		 * apk not play the music at the same time, we can insert
+		 * headset now and click to play music immediately in the apk,
+		 * the Audio HAL will write data to the card and not update
+		 * the stream routing. Because we also set mute when
+		 * the mdet come into force, so that the dapm will not update
+		 * and it makes the mute.
+		 */
+		/*
+		snd_soc_component_update_bits(priv->component, SUNXI_HEADPHONE_REG,
+				(0x1 << HPPA_EN),
+				(0x1 << HPPA_EN));
+		*/
+	}
+	mutex_unlock(&priv->jack_mlock);
+}
+
+/* Checks jack insertion and identifies the jack type.*/
+static void sunxi_check_hs_detect_status(struct work_struct *work)
+{
+	int jack_type = 0, reg_val = 0;
+	struct sunxi_card_priv *priv = container_of(work,
+						    struct sunxi_card_priv,
+						    hs_detect_work.work);
+
+	mutex_lock(&priv->jack_mlock);
+	if (priv->detect_state == PLUG_IN) {
+		/* enable hbias and adc */
+		snd_soc_component_update_bits(priv->component,
+				SUNXI_MICBIAS_REG,
+				(0x1 << HMICBIASEN),
+				(0x1 << HMICBIASEN));
+		snd_soc_component_update_bits(priv->component,
+				SUNXI_MICBIAS_REG,
+				(0x1 << MICADCEN),
+				(0x1 << MICADCEN));
+		msleep(100);
+		jack_type = sunxi_check_jack_type(&priv->jack);
+		if (jack_type != priv->switch_status) {
+			priv->switch_status = jack_type;
+			snd_jack_report(priv->jack.jack, jack_type);
+			LOG_INFO("plugin --> switch:%d", jack_type);
+			switch_state = jack_type;
+		}
+
+		/* if SND_JACK_HEADSET,enable mic detect irq */
+		if (jack_type == SND_JACK_HEADSET) {
+			reg_val = snd_soc_component_read32(priv->component, SUNXI_HMIC_STS);
+			priv->headset_basedata = (reg_val >> HMIC_DATA) & 0x1f;
+			if (priv->headset_basedata > 3)
+				priv->headset_basedata -= 3;
+
+			usleep_range(1000, 2000);
+			snd_soc_component_update_bits(priv->component,
+				SUNXI_HMIC_CTRL,
+				(0x1f << MDATA_THRESHOLD),
+				(priv->headset_basedata << MDATA_THRESHOLD));
+			snd_soc_component_update_bits(priv->component,
+				SUNXI_HMIC_CTRL,
+				(0x1 << MIC_DET_IRQ_EN),
+				(0x1 << MIC_DET_IRQ_EN));
+		} else if (jack_type == SND_JACK_HEADPHONE) {
+			/* if is HEADPHONE 3, close mic detect irq */
+			snd_soc_component_update_bits(priv->component,
+				SUNXI_HMIC_CTRL,
+				(0x1 << MIC_DET_IRQ_EN),
+				(0x0 << MIC_DET_IRQ_EN));
+		}
+	} else {
+		priv->switch_status = 0;
+		snd_jack_report(priv->jack.jack, priv->switch_status);
+		switch_state = priv->switch_status;
+		LOG_INFO("plugout --> switch:%d", priv->switch_status);
+		snd_soc_component_update_bits(priv->component,
+				SUNXI_MICBIAS_REG,
+				(0x1 << HMICBIASEN),
+				(0x0 << HMICBIASEN));
+		snd_soc_component_update_bits(priv->component,
+				SUNXI_MICBIAS_REG,
+				(0x1 << MICADCEN),
+				(0x0 << MICADCEN));
+		snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+				(0x1f << MDATA_THRESHOLD),
+				(mdata_threshold << MDATA_THRESHOLD));
+		snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+				(0x1 << MIC_DET_IRQ_EN),
+				(0x0 << MIC_DET_IRQ_EN));
+	}
+	mutex_unlock(&priv->jack_mlock);
+}
+
+static void sunxi_hs_init_work(struct work_struct *work)
+{
+	struct sunxi_card_priv *priv = container_of(work,
+						    struct sunxi_card_priv,
+						    hs_init_work.work);
+
+	mutex_lock(&priv->jack_mlock);
+	if (is_irq == true) {
+		is_irq = false;
+	} else {
+		if ((priv->hp_detect_case == HP_DETECT_LOW) ||
+		    (priv->jack_irq_times == RESUME_IRQ)) {
+			/*
+			 * It should be report after resume.
+			 * If the headset plugout after suspend, the system
+			 * can not know the state, so we should reset here
+			 * when resume.
+			 */
+			LOG_INFO("resume-->report switch");
+			priv->switch_status = 0;
+			snd_jack_report(priv->jack.jack, priv->switch_status);
+			switch_state = 0;
+		}
+	}
+	priv->jack_irq_times = OTHER_IRQ;
+	mutex_unlock(&priv->jack_mlock);
+}
+
+/* Check for hook release */
+static void sunxi_check_hs_button_status(struct work_struct *work)
+{
+	u32 i = 0;
+	struct sunxi_card_priv *priv = container_of(work,
+						    struct sunxi_card_priv,
+						    hs_button_work.work);
+
+	mutex_lock(&priv->jack_mlock);
+	for (i = 0; i < 1; i++) {
+		if (priv->key_hook == 0) {
+			LOG_INFO("Hook (2)!!");
+			priv->switch_status &= ~SND_JACK_BTN_0;
+			snd_jack_report(priv->jack.jack, priv->switch_status);
+			break;
+		}
+		/* may msleep 8 */
+		msleep(20);
+	}
+	mutex_unlock(&priv->jack_mlock);
+}
+
+static irqreturn_t jack_interrupt(int irq, void *dev_id)
+{
+	struct sunxi_card_priv *priv = dev_id;
+	struct timespec64 tv;
+	u32 tempdata = 0, regval = 0;
+	int jack_state = 0;
+
+	if (priv->jack_irq_times == RESUME_IRQ ||
+	    priv->jack_irq_times == SYSINIT_IRQ) {
+		LOG_INFO("is_irq is ture");
+		is_irq = true;
+		priv->jack_irq_times = OTHER_IRQ;
+	}
+
+	jack_state = snd_soc_component_read32(priv->component, SUNXI_HMIC_STS);
+
+	/*
+	if (priv->detect_state != PLUG_IN) {
+		//when headphone half-insertion, MIC_DET IRQ will be trigger.
+		if (jack_state & (1 << MIC_DET_ST)) {
+			regval = snd_soc_component_read32(priv->component, SUNXI_HMIC_CTRL);
+			regval &= ~(0x1 << MIC_DET_IRQ_EN);
+			snd_soc_component_write(priv->component, SUNXI_HMIC_CTRL, regval);
+
+			regval = snd_soc_component_read32(priv->component, SUNXI_MICBIAS_REG);
+			regval &= ~(0x1 << MICADCEN);
+			snd_soc_component_write(priv->component, SUNXI_MICBIAS_REG, regval);
+
+			//clear mic detect status
+			regval = snd_soc_component_read32(priv->component, SUNXI_HMIC_STS);
+			regval &= ~(0x1 << JACK_DET_IIN_ST);
+			regval &= ~(0x1 << JACK_DET_OUT_ST);
+			regval |= 0x1 << MIC_DET_ST;
+			snd_soc_component_write(priv->component, SUNXI_HMIC_STS, regval);
+
+			//prevent mic detect false trigger
+			schedule_delayed_work(&priv->hs_checkplug_work,
+				msecs_to_jiffies(700));
+		}
+	}
+	*/
+
+	/* headphone plugin */
+	if (jack_state & (1 << JACK_DET_IIN_ST)) {
+		regval = jack_state;
+		regval &= ~(0x1 << JACK_DET_OUT_ST);
+		snd_soc_component_write(priv->component, SUNXI_HMIC_STS, regval);
+		priv->detect_state = PLUG_IN;
+		/* get jack insert time to set mic det dead time */
+		ktime_get_real_ts64(&priv->tv_headset_plugin);
+		schedule_delayed_work(&priv->hs_detect_work,
+				      msecs_to_jiffies(10));
+	}
+
+	/* headphone plugout */
+	if (jack_state & (1 << JACK_DET_OUT_ST)) {
+		regval = jack_state;
+		regval &= ~(0x1 << JACK_DET_IIN_ST);
+		snd_soc_component_write(priv->component, SUNXI_HMIC_STS, regval);
+		priv->detect_state = PLUG_OUT;
+		schedule_delayed_work(&priv->hs_detect_work,
+				      msecs_to_jiffies(10));
+	}
+
+	/* headphone btn event */
+	if ((priv->detect_state == PLUG_IN) &&
+	    (jack_state & (1 << MIC_DET_ST))) {
+		regval = jack_state;
+		regval &= ~(0x1 << JACK_DET_IIN_ST);
+		regval &= ~(0x1 << JACK_DET_OUT_ST);
+		snd_soc_component_write(priv->component, SUNXI_HMIC_STS, regval);
+
+		/* plugin less 1s, not operate */
+		ktime_get_real_ts64(&tv);
+		if (abs(tv.tv_sec - priv->tv_headset_plugin.tv_sec) < 1)
+			return IRQ_HANDLED;
+
+		tempdata = snd_soc_component_read32(priv->component, SUNXI_HMIC_STS);
+		tempdata = (tempdata & 0x1f00) >> 8;
+		LOG_ERR("KEY tempdata: %d", tempdata);
+
+		if (tempdata == 2) {
+			priv->key_hook = 0;
+			priv->key_voldown = 0;
+			priv->key_voiceassist = 0;
+			priv->key_volup++;
+			if (priv->key_volup == 1) {
+				LOG_INFO("Volume ++");
+				priv->key_volup = 0;
+				priv->switch_status |= SND_JACK_BTN_1;
+				snd_jack_report(priv->jack.jack,
+						priv->switch_status);
+				priv->switch_status &= ~SND_JACK_BTN_1;
+				snd_jack_report(priv->jack.jack,
+						priv->switch_status);
+			}
+		} else if ((tempdata == 5) || tempdata == 4) {
+			priv->key_volup = 0;
+			priv->key_hook = 0;
+			priv->key_voiceassist = 0;
+			priv->key_voldown++;
+			if (priv->key_voldown == 1) {
+				LOG_INFO("Volume --");
+				priv->key_voldown = 0;
+				priv->switch_status |= SND_JACK_BTN_2;
+				snd_jack_report(priv->jack.jack,
+						priv->switch_status);
+				priv->switch_status &= ~SND_JACK_BTN_2;
+				snd_jack_report(priv->jack.jack,
+						priv->switch_status);
+			}
+		} else if (tempdata == 1) {
+			priv->key_volup = 0;
+			priv->key_hook = 0;
+			priv->key_voldown = 0;
+			priv->key_voiceassist++;
+			if (priv->key_voiceassist == 1) {
+				LOG_INFO("Voice Assistant Open");
+				priv->key_voiceassist = 0;
+				priv->switch_status |= SND_JACK_BTN_3;
+				snd_jack_report(priv->jack.jack,
+						priv->switch_status);
+				priv->switch_status &= ~SND_JACK_BTN_3;
+				snd_jack_report(priv->jack.jack,
+						priv->switch_status);
+			}
+		} else if (tempdata == 0x0) {
+			priv->key_volup = 0;
+			priv->key_voldown = 0;
+			priv->key_voiceassist = 0;
+			priv->key_hook++;
+			if (priv->key_hook >= 1) {
+				priv->key_hook = 0;
+				if ((priv->switch_status & SND_JACK_BTN_0)
+				    == 0) {
+					priv->switch_status |= SND_JACK_BTN_0;
+					snd_jack_report(priv->jack.jack,
+							priv->switch_status);
+					LOG_INFO("Hook (1)");
+				}
+				schedule_delayed_work(&priv->hs_button_work,
+						      msecs_to_jiffies(180));
+			}
+		} else {
+			LOG_ERR("tempdata:0x%x,Key data err:",
+				 tempdata);
+			priv->key_volup = 0;
+			priv->key_voldown = 0;
+			priv->key_hook = 0;
+			priv->key_voiceassist = 0;
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+static const struct snd_kcontrol_new sunxi_card_controls[] = {
+	SOC_DAPM_PIN_SWITCH("Headphone"),
+	SOC_DAPM_PIN_SWITCH("HpSpeaker"),
+	SOC_DAPM_PIN_SWITCH("LINEOUT"),
+};
+
+static const struct snd_soc_dapm_widget sunxi_card_dapm_widgets[] = {
+	SND_SOC_DAPM_MIC("HeadphoneMic", NULL),
+	SND_SOC_DAPM_MIC("Main Mic", NULL),
+};
+
+static const struct snd_soc_dapm_route sunxi_card_routes[] = {
+	{"MainMic Bias", NULL, "Main Mic"},
+	{"MIC1", NULL, "MainMic Bias"},
+	/*{"MIC2", NULL, "HeadphoneMic"},*/
+	{"MIC2", NULL, "MainMic Bias"},
+	{"MIC3", NULL, "MainMic Bias"},
+};
+
+static void sunxi_hs_reg_init(struct sunxi_card_priv *priv)
+{
+	/*
+	snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+			(0xffff << 0),
+			(0x0 << 0));
+	*/
+	snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+			(0x1f << MDATA_THRESHOLD),
+			(0x17 << MDATA_THRESHOLD));
+	/*
+	snd_soc_component_update_bits(priv->component, SUNXI_HMIC_STS,
+			(0xffff << 0),
+			(0x6000 << 0));
+	*/
+	/*
+	snd_soc_component_update_bits(priv->component, SUNXI_MICBIAS_REG,
+			(0x7f << SELDETADCBF),
+			(0x40 << SELDETADCBF));
+	*/
+	if (priv->hp_detect_case == HP_DETECT_LOW) {
+		snd_soc_component_update_bits(priv->component,
+				SUNXI_MICBIAS_REG,
+				(0x1 << AUTOPLEN),
+				(0x1 << AUTOPLEN));
+		snd_soc_component_update_bits(priv->component,
+				SUNXI_MICBIAS_REG,
+				(0x1 << DETMODE),
+				(0x0 << DETMODE));
+	} else {
+		snd_soc_component_update_bits(priv->component,
+				SUNXI_MICBIAS_REG,
+				(0x1 << AUTOPLEN),
+				(0x0 << AUTOPLEN));
+		snd_soc_component_update_bits(priv->component,
+				SUNXI_MICBIAS_REG,
+				(0x1 << DETMODE),
+				(0x1 << DETMODE));
+	}
+	snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+			(0xf << HMIC_N),
+			(HP_DEBOUCE_TIME << HMIC_N));
+	snd_soc_component_update_bits(priv->component, SUNXI_MICBIAS_REG,
+			(0x1 << JACKDETEN),
+			(0x1 << JACKDETEN));
+	snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+			(0x1 << JACK_IN_IRQ_EN),
+			(0x1 << JACK_IN_IRQ_EN));
+	snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+			(0x1 << JACK_OUT_IRQ_EN),
+			(0x1 << JACK_OUT_IRQ_EN));
+
+	/*
+	snd_soc_component_update_bits(priv->component, SUNXI_MICBIAS_REG,
+			    (0x1 << HMICBIASEN), (0x1 << HMICBIASEN));
+	snd_soc_component_update_bits(priv->component, SUNXI_MICBIAS_REG,
+			    (0x1 << MICADCEN), (0x1 << MICADCEN));
+	*/
+
+	/*
+	snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+			(0x1 << MIC_DET_IRQ_EN),
+			(0x1 << MIC_DET_IRQ_EN));
+	*/
+
+	schedule_delayed_work(&priv->hs_init_work, msecs_to_jiffies(10));
+}
+
+static void snd_sunxi_unregister_jack(struct sunxi_card_priv *priv)
+{
+	/*
+	 * Set process button events to false so that the button
+	 * delayed work will not be scheduled.
+	 */
+	cancel_delayed_work_sync(&priv->hs_detect_work);
+	cancel_delayed_work_sync(&priv->hs_button_work);
+	cancel_delayed_work_sync(&priv->hs_init_work);
+	free_irq(priv->jackirq, priv);
+}
+
+/*
+ * Card initialization
+ */
+static int sunxi_card_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_component *component = rtd->codec_dai->component;
+	struct snd_soc_dapm_context *dapm = &component->dapm;
+
+	struct sunxi_card_priv *priv = snd_soc_card_get_drvdata(rtd->card);
+	int ret;
+
+	priv->component = rtd->codec_dai->component;
+
+	ret = snd_soc_card_jack_new(rtd->card, "sunxi Audio Jack",
+			       SND_JACK_HEADSET | SND_JACK_HEADPHONE |
+				   SND_JACK_BTN_0 | SND_JACK_BTN_1 |
+				   SND_JACK_BTN_2 | SND_JACK_BTN_3,
+			       &priv->jack, NULL, 0);
+	if (ret) {
+		LOG_ERR("jack creation failed");
+		return ret;
+	}
+
+	snd_jack_set_key(priv->jack.jack, SND_JACK_BTN_0, KEY_MEDIA);
+	snd_jack_set_key(priv->jack.jack, SND_JACK_BTN_1, KEY_VOLUMEUP);
+	snd_jack_set_key(priv->jack.jack, SND_JACK_BTN_2, KEY_VOLUMEDOWN);
+	snd_jack_set_key(priv->jack.jack, SND_JACK_BTN_3, KEY_VOICECOMMAND);
+
+	snd_soc_dapm_disable_pin(dapm, "HPOUTR");
+	snd_soc_dapm_disable_pin(dapm, "HPOUTL");
+
+	snd_soc_dapm_disable_pin(dapm, "LINEOUT");
+	snd_soc_dapm_disable_pin(dapm, "HpSpeaker");
+	snd_soc_dapm_disable_pin(dapm, "Headphone");
+
+	snd_soc_dapm_sync(dapm);
+
+	LOG_WARN("card init finished");
+	return 0;
+}
+
+static int sunxi_card_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	/* struct snd_soc_card *card = rtd->card; */
+	unsigned int freq;
+	int ret;
+	int stream_flag;
+
+	switch (params_rate(params)) {
+	case	8000:
+	case	12000:
+	case	16000:
+	case	24000:
+	case	32000:
+	case	48000:
+	case	96000:
+	case	192000:
+		freq = 24576000;
+		break;
+	case	11025:
+	case	22050:
+	case	44100:
+		freq = 22579200;
+		break;
+	default:
+		LOG_ERR("invalid rate setting");
+		return -EINVAL;
+	}
+
+	/* the substream type: 0->playback, 1->capture */
+	stream_flag = substream->stream;
+	LOG_INFO("stream_flag: %d", stream_flag);
+
+	/* To surpport playback and capture func in different freq point */
+	if (freq == 22579200) {
+		if (stream_flag == 0) {
+			ret = snd_soc_dai_set_sysclk(codec_dai, 0, freq, 0);
+			if (ret < 0) {
+				LOG_ERR("set codec dai sysclk faided, freq:%d", freq);
+				return ret;
+			}
+		}
+	}
+
+	if (freq == 22579200) {
+		if (stream_flag == 1) {
+			ret = snd_soc_dai_set_sysclk(codec_dai, 1, freq, 0);
+			if (ret < 0) {
+				LOG_ERR("set codec dai sysclk faided, freq:%d", freq);
+				return ret;
+			}
+		}
+	}
+
+	if (freq == 24576000) {
+		if (stream_flag == 0) {
+			ret = snd_soc_dai_set_sysclk(codec_dai, 2, freq, 0);
+			if (ret < 0) {
+				LOG_ERR("set codec dai sysclk faided, freq:%d", freq);
+				return ret;
+			}
+		}
+	}
+
+	if (freq == 24576000) {
+			if (stream_flag == 1) {
+			ret = snd_soc_dai_set_sysclk(codec_dai, 3, freq, 0);
+			if (ret < 0) {
+				LOG_ERR("set codec dai sysclk faided, freq:%d", freq);
+				return ret;
+			}
+		}
+	}
+
+	return 0;
+}
+
+static struct snd_soc_ops sunxi_card_ops = {
+	.hw_params = sunxi_card_hw_params,
+};
+
+SND_SOC_DAILINK_DEFS(sun20iw1p1_dai_link,
+	DAILINK_COMP_ARRAY(COMP_CPU("sunxi-dummy-cpudai")),
+	DAILINK_COMP_ARRAY(COMP_CODEC("sunxi-internal-codec", "sun20iw1codec")),
+	DAILINK_COMP_ARRAY(COMP_PLATFORM("sunxi-dummy-cpudai")));
+
+static struct snd_soc_dai_link sunxi_card_dai_link[] = {
+	{
+		.name		= "audiocodec",
+		.stream_name	= "SUNXI-CODEC",
+		.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF
+				| SND_SOC_DAIFMT_CBM_CFM,
+		.init		= sunxi_card_init,
+		.ops		= &sunxi_card_ops,
+		SND_SOC_DAILINK_REG(sun20iw1p1_dai_link),
+	},
+};
+
+static int sunxi_card_suspend(struct snd_soc_card *card)
+{
+	struct sunxi_card_priv *priv = snd_soc_card_get_drvdata(card);
+
+	if (priv->jack_func == JACK_DISABLE)
+		return 0;
+	disable_irq(priv->jackirq);
+
+	snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+			    (0x1 << MIC_DET_IRQ_EN), (0x0 << MIC_DET_IRQ_EN));
+	snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+			    (0x1 << JACK_IN_IRQ_EN), (0x0 << JACK_IN_IRQ_EN));
+	snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+			    (0x1 << JACK_OUT_IRQ_EN), (0x0 << JACK_OUT_IRQ_EN));
+	snd_soc_component_update_bits(priv->component, SUNXI_MICBIAS_REG, (0x1 << JACKDETEN),
+			    (0x0 << JACKDETEN));
+	LOG_INFO("suspend");
+
+	return 0;
+}
+
+static int sunxi_card_resume(struct snd_soc_card *card)
+{
+	struct sunxi_card_priv *priv = snd_soc_card_get_drvdata(card);
+
+	if (priv->jack_func == JACK_DISABLE)
+		return 0;
+	enable_irq(priv->jackirq);
+	priv->jack_irq_times = RESUME_IRQ;
+	priv->detect_state = PLUG_OUT;/*todo..?*/
+	sunxi_hs_reg_init(priv);
+	LOG_INFO("resume");
+
+	return 0;
+}
+
+static struct snd_soc_card snd_soc_sunxi_card = {
+	.name			= "audiocodec",
+	.owner			= THIS_MODULE,
+	.dai_link		= sunxi_card_dai_link,
+	.num_links		= ARRAY_SIZE(sunxi_card_dai_link),
+	.suspend_post		= sunxi_card_suspend,
+	.resume_post		= sunxi_card_resume,
+
+};
+
+static int sunxi_card_dev_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	u32 temp_val;
+	struct sunxi_card_priv *priv = NULL;
+	struct device_node *np = pdev->dev.of_node;
+	struct snd_soc_card *card = &snd_soc_sunxi_card;
+	struct snd_soc_dapm_context *dapm = &card->dapm;
+
+	if (!np) {
+		LOG_ERR("can not get dt node for this device");
+		return -EINVAL;
+	}
+
+	/* dai link */
+	sunxi_card_dai_link[0].cpus->dai_name = NULL;
+	sunxi_card_dai_link[0].cpus->of_node = of_parse_phandle(np,
+					"sunxi,cpudai-controller", 0);
+	if (!sunxi_card_dai_link[0].cpus->of_node) {
+		LOG_ERR("Property 'sunxi,cpudai-controller' missing or invalid");
+		ret = -EINVAL;
+		goto err_devm_kfree;
+	} else {
+		sunxi_card_dai_link[0].platforms->name = NULL;
+		sunxi_card_dai_link[0].platforms->of_node =
+				sunxi_card_dai_link[0].cpus->of_node;
+	}
+	sunxi_card_dai_link[0].codecs->name = NULL;
+	sunxi_card_dai_link[0].codecs->of_node = of_parse_phandle(np,
+						"sunxi,audio-codec", 0);
+	if (!sunxi_card_dai_link[0].codecs->of_node) {
+		LOG_ERR("Property 'sunxi,audio-codec' missing or invalid");
+		ret = -EINVAL;
+		goto err_devm_kfree;
+	}
+
+	/* register the soc card */
+	card->dev = &pdev->dev;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(struct sunxi_card_priv),
+			    GFP_KERNEL);
+	if (!priv) {
+		LOG_ERR("devm_kzalloc failed %d", ret);
+		return -ENOMEM;
+	}
+	priv->card = card;
+
+	snd_soc_card_set_drvdata(card, priv);
+
+	ret = snd_soc_register_card(card);
+	if (ret) {
+		LOG_ERR("snd_soc_register_card failed %d", ret);
+		goto err_devm_kfree;
+	}
+
+	ret = snd_soc_add_card_controls(card, sunxi_card_controls,
+					ARRAY_SIZE(sunxi_card_controls));
+	if (ret)
+		LOG_ERR("failed to register codec controls");
+
+	snd_soc_dapm_new_controls(dapm, sunxi_card_dapm_widgets,
+				  ARRAY_SIZE(sunxi_card_dapm_widgets));
+	snd_soc_dapm_add_routes(dapm, sunxi_card_routes,
+				ARRAY_SIZE(sunxi_card_routes));
+
+	ret = of_property_read_u32(np, "jack_enable", &temp_val);
+	if (ret < 0) {
+		LOG_ERR("jack_enable missing, use default enable jack");
+		priv->jack_func = JACK_ENABLE;
+	} else {
+		priv->jack_func = temp_val;
+	}
+	if (priv->jack_func == JACK_DISABLE)
+		return 0;
+
+	ret = of_property_read_u32(np, "hp_detect_case", &temp_val);
+	if (ret < 0) {
+		LOG_ERR("hp_detect_case missing, use default hp_detect_low");
+		priv->hp_detect_case = HP_DETECT_LOW;
+	} else {
+		priv->hp_detect_case = temp_val;
+	}
+
+	/* initial the parameters for judge switch state */
+	priv->jack_irq_times = SYSINIT_IRQ;
+	priv->HEADSET_DATA = 0xA;
+	priv->detect_state = PLUG_OUT;
+	mutex_init(&priv->jack_mlock);
+	INIT_DELAYED_WORK(&priv->hs_detect_work, sunxi_check_hs_detect_status);
+	INIT_DELAYED_WORK(&priv->hs_button_work, sunxi_check_hs_button_status);
+	INIT_DELAYED_WORK(&priv->hs_init_work, sunxi_hs_init_work);
+	INIT_DELAYED_WORK(&priv->hs_checkplug_work, sunxi_check_hs_plug);
+
+	priv->jackirq = platform_get_irq(pdev, 0);
+	if (priv->jackirq < 0) {
+		LOG_ERR("irq get failed");
+		ret = -ENODEV;
+	}
+	ret = request_irq(priv->jackirq, jack_interrupt, 0, "audio jack irq",
+			  priv);
+
+	sunxi_hs_reg_init(priv);
+
+	LOG_INFO("register card finished");
+	return 0;
+
+err_devm_kfree:
+	devm_kfree(&pdev->dev, priv);
+	return ret;
+}
+
+static int __exit sunxi_card_dev_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+	struct sunxi_card_priv *priv = snd_soc_card_get_drvdata(card);
+
+	snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+			    (0x1 << JACK_IN_IRQ_EN), (0x0 << JACK_IN_IRQ_EN));
+	snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+			    (0x1 << JACK_OUT_IRQ_EN), (0x0 << JACK_OUT_IRQ_EN));
+	snd_soc_component_update_bits(priv->component, SUNXI_MICBIAS_REG, (0x1 << JACKDETEN),
+			    (0x0 << JACKDETEN));
+	snd_soc_component_update_bits(priv->component, SUNXI_MICBIAS_REG,
+				(0x1 << HMICBIASEN), (0x0 << HMICBIASEN));
+	snd_sunxi_unregister_jack(priv);
+
+	snd_soc_unregister_card(card);
+	devm_kfree(&pdev->dev, priv);
+
+	LOG_WARN("unregister card finished");
+
+	return 0;
+}
+
+static const struct of_device_id sunxi_card_of_match[] = {
+	{ .compatible = "allwinner,sunxi-codec-machine", },
+	{},
+};
+
+static struct platform_driver sunxi_machine_driver = {
+	.driver = {
+		.name = "sunxi-codec-machine",
+		.owner = THIS_MODULE,
+		.pm = &snd_soc_pm_ops,
+		.of_match_table = sunxi_card_of_match,
+	},
+	.probe = sunxi_card_dev_probe,
+	.remove = __exit_p(sunxi_card_dev_remove),
+};
+
+static int __init sunxi_machine_driver_init(void)
+{
+	return platform_driver_register(&sunxi_machine_driver);
+}
+module_init(sunxi_machine_driver_init);
+
+static void __exit sunxi_machine_driver_exit(void)
+{
+	platform_driver_unregister(&sunxi_machine_driver);
+}
+module_exit(sunxi_machine_driver_exit);
+
+module_param_named(switch_state, switch_state, int, S_IRUGO | S_IWUSR);
+
+MODULE_DESCRIPTION("SUNXI Codec Machine ASoC driver");
+MODULE_AUTHOR("Dby <Dby@allwinnertech.com>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:sunxi-codec-machine");
diff --git a/sound/soc/sunxi/sun50iw10-codec.c b/sound/soc/sunxi/sun50iw10-codec.c
new file mode 100644
index 000000000..46a649daf
--- /dev/null
+++ b/sound/soc/sunxi/sun50iw10-codec.c
@@ -0,0 +1,2013 @@
+/*
+ * sound\soc\sunxi\sun50iw10-codec.c
+ * (C) Copyright 2014-2019
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * yumingfeng <yumingfeng@allwinnertech.com>
+ * luguofang <luguofang@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/pm.h>
+#include <linux/regulator/consumer.h>
+#include <linux/pinctrl/pinctrl-sunxi.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
+#include <linux/reset.h>
+#include <asm/dma.h>
+#include <sound/pcm.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/core.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <sound/tlv.h>
+#include <linux/sunxi-gpio.h>
+
+#include "sunxi_sound_log.h"
+#include "sun50iw10-codec.h"
+
+/* digital audio process function */
+enum sunxi_hw_dap {
+	DAP_HP_EN = 0x1,
+	DAP_SPK_EN = 0x2,
+	/* DAP_HP_EN | DAP_SPK_EN */
+	DAP_HPSPK_EN = 0x3,
+};
+
+static const struct sample_rate sample_rate_conv[] = {
+	{8000,   5},
+	{11025,  4},
+	{12000,  4},
+	{16000,  3},
+	{22050,  2},
+	{24000,  2},
+	{32000,  1},
+	{44100,  0},
+	{48000,  0},
+	{96000,  7},
+	{192000, 6},
+};
+
+static const DECLARE_TLV_DB_SCALE(digital_tlv, -7424, 116, 0);
+static const DECLARE_TLV_DB_SCALE(headphone_gain_tlv, -4200, 600, 0);
+static const DECLARE_TLV_DB_SCALE(mic1gain_tlv, 0, 100, 0);
+static const DECLARE_TLV_DB_SCALE(mic2gain_tlv, 0, 100, 0);
+static const DECLARE_TLV_DB_SCALE(dac_vol_tlv, -11925, 75, 0);
+static const DECLARE_TLV_DB_SCALE(adc_vol_tlv, -11925, 75, 0);
+static const unsigned int lineout_tlv[] = {
+	TLV_DB_RANGE_HEAD(2),
+	0, 1, TLV_DB_SCALE_ITEM(0, 0, 1),
+	2, 31, TLV_DB_SCALE_ITEM(-4350, 150, 1),
+};
+
+static struct reg_label reg_labels[] = {
+	REG_LABEL(SUNXI_DAC_DPC),
+	REG_LABEL(SUNXI_DAC_VOL_CTRL),
+	REG_LABEL(SUNXI_DAC_FIFOC),
+	REG_LABEL(SUNXI_DAC_FIFOS),
+	REG_LABEL(SUNXI_DAC_CNT),
+	REG_LABEL(SUNXI_DAC_DG),
+	REG_LABEL(SUNXI_ADC_FIFOC),
+	REG_LABEL(SUNXI_ADC_VOL_CTRL),
+	REG_LABEL(SUNXI_ADC_FIFOS),
+	REG_LABEL(SUNXI_ADC_CNT),
+	REG_LABEL(SUNXI_ADC_DG),
+#ifdef SUNXI_CODEC_DAP_ENABLE
+	REG_LABEL(SUNXI_DAC_DAP_CTL),
+	REG_LABEL(SUNXI_ADC_DAP_CTL),
+#endif
+	REG_LABEL(SUNXI_ADCL_REG),
+	REG_LABEL(SUNXI_ADCR_REG),
+	REG_LABEL(SUNXI_DAC_REG),
+	REG_LABEL(SUNXI_MICBIAS_REG),
+	REG_LABEL(SUNXI_BIAS_REG),
+	REG_LABEL(SUNXI_HEADPHONE_REG),
+	REG_LABEL(SUNXI_HMIC_CTRL),
+	REG_LABEL(SUNXI_HMIC_STS),
+	REG_LABEL_END,
+};
+
+#ifdef SUNXI_CODEC_DAP_ENABLE
+static void adcdrc_config(struct snd_soc_component *component)
+{
+	/* Enable DRC gain Min and Max limit, detect noise, Using Peak Filter */
+	snd_soc_component_update_bits(component, SUNXI_ADC_DRC_CTRL,
+		((0x1 << ADC_DRC_DELAY_BUF_EN) |
+		(0x1 << ADC_DRC_GAIN_MAX_EN) | (0x1 << ADC_DRC_GAIN_MIN_EN) |
+		(0x1 << ADC_DRC_NOISE_DET_EN) |
+		(0x1 << ADC_DRC_SIGNAL_SEL) |
+		(0x1 << ADC_DRC_LT_EN) | (0x1 << ADC_DRC_ET_EN)),
+		((0x1 << ADC_DRC_DELAY_BUF_EN) |
+		(0x1 << ADC_DRC_GAIN_MAX_EN) | (0x1 << ADC_DRC_GAIN_MIN_EN) |
+		(0x1 << ADC_DRC_NOISE_DET_EN) |
+		(0x1 << ADC_DRC_SIGNAL_SEL) |
+		(0x1 << ADC_DRC_LT_EN) | (0x1 << ADC_DRC_ET_EN)));
+
+	/* Left peak filter attack time */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LPFHAT, (0x000B77F0 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LPFLAT, 0x000B77F0 & 0xFFFF);
+	/* Right peak filter attack time */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_RPFHAT, (0x000B77F0 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_RPFLAT, 0x000B77F0 & 0xFFFF);
+	/* Left peak filter release time */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LPFHRT, (0x00FFE1F8 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LPFLRT, 0x00FFE1F8 & 0xFFFF);
+	/* Right peak filter release time */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_RPFHRT, (0x00FFE1F8 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_RPFLRT, 0x00FFE1F8 & 0xFFFF);
+
+	/* Left RMS filter attack time */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LPFHAT, (0x00012BB0 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LPFLAT, 0x00012BB0 & 0xFFFF);
+	/* Right RMS filter attack time */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_RPFHAT, (0x00012BB0 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_RPFLAT, 0x00012BB0 & 0xFFFF);
+
+	/* OPL */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_HOPL, (0xFF641741 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LOPL, 0xFF641741 & 0xFFFF);
+	/* OPC */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_HOPC, (0xFC0380F3 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LOPC, 0xFC0380F3 & 0xFFFF);
+	/* OPE */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_HOPE, (0xF608C25F >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LOPE, 0xF608C25F & 0xFFFF);
+	/* LT */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_HLT, (0x035269E0 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LLT, 0x035269E0 & 0xFFFF);
+	/* CT */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_HCT, (0x06B3002C >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LCT, 0x06B3002C & 0xFFFF);
+	/* ET */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_HET, (0x0A139682 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LET, 0x0A139682 & 0xFFFF);
+	/* Ki */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_HKI, (0x00222222 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LKI, 0x00222222 & 0xFFFF);
+	/* Kc */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_HKC, (0x01000000 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LKC, 0x01000000 & 0xFFFF);
+	/* Kn */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_HKN, (0x01C53EF0 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LKN, 0x01C53EF0 & 0xFFFF);
+	/* Ke */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_HKE, (0x04234F68 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LKE, 0x04234F68 & 0xFFFF);
+
+	/* smooth filter attack time */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_SFHAT, (0x00017665 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_SFLAT, 0x00017665 & 0xFFFF);
+	/* gain smooth filter release time */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_SFHRT, (0x00000F04 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_SFLRT, 0x00000F04 & 0xFFFF);
+
+	/* gain max setting */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_MXGHS, (0x69E0F95B >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_MXGLS, 0x69E0F95B & 0xFFFF);
+
+	/* gain min setting */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_MNGHS, (0xF95B2C3F >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_MNGLS, 0xF95B2C3F & 0xFFFF);
+
+	/* smooth filter release and attack time */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_EPSHC, (0x00025600 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_EPSHC, 0x00025600 & 0xFFFF);
+}
+
+static void adcdrc_enable(struct snd_soc_component *component, bool on)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct codec_dap *adc_dap = &sunxi_codec->adc_dap;
+
+	if (on) {
+		if (adc_dap->drc_enable++ == 0) {
+			snd_soc_component_update_bits(component, SUNXI_ADC_DAP_CTL,
+				(0x1 << ADC_DRC0_EN), (0x1 << ADC_DRC0_EN));
+			if (sunxi_codec->adc_dap_enable++ == 0) {
+				snd_soc_component_update_bits(component, SUNXI_ADC_DAP_CTL,
+					(0x1 << ADC_DAP0_EN), (0x1 << ADC_DAP0_EN));
+			}
+		}
+	} else {
+		if (--adc_dap->drc_enable <= 0) {
+			adc_dap->drc_enable = 0;
+			if (--sunxi_codec->adc_dap_enable <= 0) {
+				sunxi_codec->adc_dap_enable = 0;
+				snd_soc_component_update_bits(component, SUNXI_ADC_DAP_CTL,
+					(0x1 << ADC_DAP0_EN), (0x0 << ADC_DAP0_EN));
+			}
+			snd_soc_component_update_bits(component, SUNXI_ADC_DAP_CTL,
+				(0x1 << ADC_DRC0_EN), (0x0 << ADC_DRC0_EN));
+		}
+	}
+}
+
+static void adchpf_config(struct snd_soc_component *component)
+{
+	/* HPF */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_HHPFC, (0xFFFAC1 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LHPFC, 0xFFFAC1 & 0xFFFF);
+}
+
+static void adchpf_enable(struct snd_soc_component *component, bool on)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct codec_dap *adc_dap = &sunxi_codec->adc_dap;
+
+	if (on) {
+		if (adc_dap->hpf_enable++ == 0) {
+			snd_soc_component_update_bits(component, SUNXI_ADC_DAP_CTL,
+				(0x1 << ADC_HPF0_EN), (0x1 << ADC_HPF0_EN));
+			if (sunxi_codec->adc_dap_enable++ == 0) {
+				snd_soc_component_update_bits(component, SUNXI_ADC_DAP_CTL,
+					(0x1 << ADC_DAP0_EN), (0x1 << ADC_DAP0_EN));
+			}
+		}
+	} else {
+		if (--adc_dap->hpf_enable <= 0) {
+			adc_dap->hpf_enable = 0;
+			if (--sunxi_codec->adc_dap_enable <= 0) {
+				sunxi_codec->adc_dap_enable = 0;
+				snd_soc_component_update_bits(component, SUNXI_ADC_DAP_CTL,
+					(0x1 << ADC_DAP0_EN), (0x0 << ADC_DAP0_EN));
+			}
+			snd_soc_component_update_bits(component, SUNXI_ADC_DAP_CTL,
+				(0x1 << ADC_HPF0_EN), (0x0 << ADC_HPF0_EN));
+		}
+	}
+}
+
+static void dacdrc_config(struct snd_soc_component *component)
+{
+	/* Left peak filter attack time */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LPFHAT, (0x000B77BF >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LPFLAT, 0x000B77BF & 0xFFFF);
+	/* Right peak filter attack time */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_RPFHAT, (0x000B77F0 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_RPFLAT, 0x000B77F0 & 0xFFFF);
+
+	/* Left peak filter release time */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LPFHRT, (0x00FFE1F8 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LPFLRT, 0x00FFE1F8 & 0xFFFF);
+	/* Right peak filter release time */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_RPFHRT, (0x00FFE1F8 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_RPFLRT, 0x00FFE1F8 & 0xFFFF);
+
+	/* Left RMS filter attack time */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LRMSHAT, (0x00012BB0 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LRMSLAT, 0x00012BB0 & 0xFFFF);
+	/* Right RMS filter attack time */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_RRMSHAT, (0x00012BB0 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_RRMSLAT, 0x00012BB0 & 0xFFFF);
+
+	/* smooth filter attack time */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_SFHAT, (0x00017665 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_SFLAT, 0x00017665 & 0xFFFF);
+	/* gain smooth filter release time */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_SFHRT, (0x00000F04 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_SFLRT, 0x00000F04 & 0xFFFF);
+
+	/* OPL */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_HOPL, (0xFE56CB10 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LOPL, 0xFE56CB10 & 0xFFFF);
+	/* OPC */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_HOPC, (0xFB04612F >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LOPC, 0xFB04612F & 0xFFFF);
+	/* OPE */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_HOPE, (0xF608C25F >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LOPE, 0xF608C25F & 0xFFFF);
+	/* LT */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_HLT, (0x035269E0 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LLT, 0x035269E0 & 0xFFFF);
+	/* CT */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_HCT, (0x06B3002C >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LCT, 0x06B3002C & 0xFFFF);
+	/* ET */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_HET, (0x0A139682 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LET, 0x0A139682 & 0xFFFF);
+	/* Ki */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_HKI, (0x00400000 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LKI, 0x00400000 & 0xFFFF);
+	/* Kc */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_HKC, (0x00FBCDA5 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LKC, 0x00FBCDA5 & 0xFFFF);
+	/* Kn */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_HKN, (0x0179B472 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LKN, 0x0179B472 & 0xFFFF);
+	/* Ke */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_HKE, (0x04234F68 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LKE, 0x04234F68 & 0xFFFF);
+	/* MXG */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_MXGHS, (0x035269E0 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_MXGLS, 0x035269E0 & 0xFFFF);
+	/* MNG */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_MNGHS, (0xF95B2C3F >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_MNGLS, 0xF95B2C3F & 0xFFFF);
+	/* EPS */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_EPSHC, (0x00025600 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_EPSLC, 0x00025600 & 0xFFFF);
+}
+
+static void dacdrc_enable(struct snd_soc_component *component, bool on)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct codec_dap *dac_dap = &sunxi_codec->dac_dap;
+
+	if (on) {
+		if (dac_dap->drc_enable++ == 0) {
+			/* detect noise when ET enable */
+			snd_soc_component_update_bits(component, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_NOISE_DET_EN),
+				(0x1 << DAC_DRC_NOISE_DET_EN));
+
+			/* 0x0:RMS filter; 0x1:Peak filter */
+			snd_soc_component_update_bits(component, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_SIGNAL_SEL),
+				(0x1 << DAC_DRC_SIGNAL_SEL));
+
+			snd_soc_component_update_bits(component, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_GAIN_MAX_EN),
+				(0x1 << DAC_DRC_GAIN_MAX_EN));
+
+			snd_soc_component_update_bits(component, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_GAIN_MIN_EN),
+				(0x1 << DAC_DRC_GAIN_MIN_EN));
+
+			/* delay function enable */
+			snd_soc_component_update_bits(component, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_DELAY_BUF_EN),
+				(0x1 << DAC_DRC_DELAY_BUF_EN));
+
+			snd_soc_component_update_bits(component, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_LT_EN),
+				(0x1 << DAC_DRC_LT_EN));
+			snd_soc_component_update_bits(component, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_ET_EN),
+				(0x1 << DAC_DRC_ET_EN));
+
+			snd_soc_component_update_bits(component, SUNXI_DAC_DAP_CTL,
+				(0x1 << DDAP_DRC_EN),
+				(0x1 << DDAP_DRC_EN));
+
+			if (sunxi_codec->dac_dap_enable++ == 0)
+				snd_soc_component_update_bits(component, SUNXI_DAC_DAP_CTL,
+					(0x1 << DDAP_EN), (0x1 << DDAP_EN));
+		}
+	} else {
+		if (--dac_dap->drc_enable <= 0) {
+			dac_dap->drc_enable = 0;
+			if (--sunxi_codec->dac_dap_enable <= 0) {
+				sunxi_codec->dac_dap_enable = 0;
+				snd_soc_component_update_bits(component, SUNXI_DAC_DAP_CTL,
+					(0x1 << DDAP_EN), (0x0 << DDAP_EN));
+			}
+
+			snd_soc_component_update_bits(component, SUNXI_DAC_DAP_CTL,
+				(0x1 << DDAP_DRC_EN),
+				(0x0 << DDAP_DRC_EN));
+
+			/* detect noise when ET enable */
+			snd_soc_component_update_bits(component, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_NOISE_DET_EN),
+				(0x0 << DAC_DRC_NOISE_DET_EN));
+
+			/* 0x0:RMS filter; 0x1:Peak filter */
+			snd_soc_component_update_bits(component, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_SIGNAL_SEL),
+				(0x0 << DAC_DRC_SIGNAL_SEL));
+
+			/* delay function enable */
+			snd_soc_component_update_bits(component, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_DELAY_BUF_EN),
+				(0x0 << DAC_DRC_DELAY_BUF_EN));
+
+			snd_soc_component_update_bits(component, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_GAIN_MAX_EN),
+				(0x0 << DAC_DRC_GAIN_MAX_EN));
+			snd_soc_component_update_bits(component, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_GAIN_MIN_EN),
+				(0x0 << DAC_DRC_GAIN_MIN_EN));
+
+			snd_soc_component_update_bits(component, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_LT_EN),
+				(0x0 << DAC_DRC_LT_EN));
+			snd_soc_component_update_bits(component, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_ET_EN),
+				(0x0 << DAC_DRC_ET_EN));
+		}
+	}
+}
+
+static void dachpf_config(struct snd_soc_component *component)
+{
+	/* HPF */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_HHPFC, (0xFFFAC1 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LHPFC, 0xFFFAC1 & 0xFFFF);
+}
+
+static void dachpf_enable(struct snd_soc_component *component, bool on)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct codec_dap *dac_dap = &sunxi_codec->dac_dap;
+
+	if (on) {
+		if (dac_dap->hpf_enable++ == 0) {
+			snd_soc_component_update_bits(component, SUNXI_DAC_DAP_CTL,
+				(0x1 << DDAP_HPF_EN), (0x1 << DDAP_HPF_EN));
+
+			if (sunxi_codec->dac_dap_enable++ == 0)
+				snd_soc_component_update_bits(component, SUNXI_DAC_DAP_CTL,
+					(0x1 << DDAP_EN), (0x1 << DDAP_EN));
+		}
+	} else {
+		if (--dac_dap->hpf_enable <= 0) {
+			dac_dap->hpf_enable = 0;
+			if (--sunxi_codec->dac_dap_enable <= 0) {
+				sunxi_codec->dac_dap_enable = 0;
+				snd_soc_component_update_bits(component, SUNXI_DAC_DAP_CTL,
+					(0x1 << DDAP_EN), (0x0 << DDAP_EN));
+			}
+
+			snd_soc_component_update_bits(component, SUNXI_DAC_DAP_CTL,
+				(0x1 << DDAP_HPF_EN),
+				(0x0 << DDAP_HPF_EN));
+		}
+	}
+}
+#endif
+
+#ifdef SUNXI_CODEC_HUB_ENABLE
+static int sunxi_codec_get_hub_mode(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	unsigned int reg_val;
+
+	reg_val = snd_soc_component_read32(component, SUNXI_DAC_DPC);
+
+	ucontrol->value.integer.value[0] =
+				((reg_val & (0x1 << DAC_HUB_EN)) ? 1 : 0);
+
+	return 0;
+}
+
+static int sunxi_codec_set_hub_mode(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+
+	switch (ucontrol->value.integer.value[0]) {
+	case	0:
+		snd_soc_component_update_bits(component, SUNXI_DAC_DPC,
+				(0x1 << DAC_HUB_EN), (0x0 << DAC_HUB_EN));
+		break;
+	case	1:
+		snd_soc_component_update_bits(component, SUNXI_DAC_DPC,
+				(0x1 << DAC_HUB_EN), (0x1 << DAC_HUB_EN));
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/* sunxi codec hub mdoe select */
+static const char * const sunxi_codec_hub_function[] = {
+				"hub_disable", "hub_enable"};
+
+static const struct soc_enum sunxi_codec_hub_mode_enum[] = {
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(sunxi_codec_hub_function),
+			sunxi_codec_hub_function),
+};
+#endif
+
+#ifdef SUNXI_CODEC_ADCSWAP_ENABLE
+static int sunxi_codec_get_adcswap_mode(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	unsigned int reg_val;
+
+	reg_val = snd_soc_component_read32(component, SUNXI_ADC_DG);
+
+	ucontrol->value.integer.value[0] =
+				((reg_val & (0x1 << AD_SWP)) ? 1 : 0);
+
+	return 0;
+}
+
+static int sunxi_codec_set_adcswap_mode(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+
+	switch (ucontrol->value.integer.value[0]) {
+	case	0:
+		snd_soc_component_update_bits(component, SUNXI_ADC_DG,
+				(0x1 << AD_SWP), (0x0 << AD_SWP));
+		break;
+	case	1:
+		snd_soc_component_update_bits(component, SUNXI_ADC_DG,
+				(0x1 << AD_SWP), (0x1 << AD_SWP));
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/* sunxi codec adc swap func */
+static const char * const sunxi_codec_adcswap_function[] = {
+				"Off", "On"};
+
+static const struct soc_enum sunxi_codec_adcswap_func_enum[] = {
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(sunxi_codec_adcswap_function),
+			sunxi_codec_adcswap_function),
+};
+#endif
+
+static int sunxi_codec_hpspeaker_event(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *k, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct codec_spk_config *spk_cfg = &(sunxi_codec->spk_config);
+	struct codec_hw_config *hw_cfg = &(sunxi_codec->hw_config);
+
+	switch (event) {
+	case	SND_SOC_DAPM_POST_PMU:
+#ifdef SUNXI_CODEC_DAP_ENABLE
+		if (hw_cfg->dacdrc_cfg & DAP_SPK_EN)
+			dacdrc_enable(component, 1);
+		else if (hw_cfg->dacdrc_cfg & DAP_HP_EN)
+			dacdrc_enable(component, 0);
+
+		if (hw_cfg->dachpf_cfg & DAP_SPK_EN)
+			dachpf_enable(component, 1);
+		else if (hw_cfg->dachpf_cfg & DAP_HP_EN)
+			dachpf_enable(component, 0);
+#endif
+		if (spk_cfg->used) {
+			gpio_direction_output(spk_cfg->spk_gpio, 1);
+			gpio_set_value(spk_cfg->spk_gpio, spk_cfg->pa_level);
+			/* time delay to wait spk pa work fine */
+			msleep(spk_cfg->pa_msleep);
+		}
+		break;
+	case	SND_SOC_DAPM_PRE_PMD:
+		if (spk_cfg->used)
+			gpio_set_value(spk_cfg->spk_gpio, !(spk_cfg->pa_level));
+#ifdef SUNXI_CODEC_DAP_ENABLE
+		if (hw_cfg->dacdrc_cfg & DAP_SPK_EN)
+			dacdrc_enable(component, 0);
+		if (hw_cfg->dacdrc_cfg & DAP_SPK_EN)
+			dachpf_enable(component, 0);
+#endif
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int sunxi_codec_headphone_event(struct snd_soc_dapm_widget *w,
+			struct snd_kcontrol *k,	int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct codec_hw_config *hw_cfg = &(sunxi_codec->hw_config);
+
+	switch (event) {
+	case SND_SOC_DAPM_POST_PMU:
+#ifdef SUNXI_CODEC_DAP_ENABLE
+		if (hw_cfg->dacdrc_cfg & DAP_HP_EN)
+			dacdrc_enable(component, 1);
+		if (hw_cfg->dachpf_cfg & DAP_HP_EN)
+			dachpf_enable(component, 1);
+#endif
+		/*open*/
+		snd_soc_component_update_bits(component, SUNXI_HEADPHONE_REG,
+				(0x1 << HPINPUTEN), (0x1 << HPINPUTEN));
+		snd_soc_component_update_bits(component, SUNXI_HEADPHONE_REG,
+				(0x1 << HPOUTPUTEN), (0x1 << HPOUTPUTEN));
+		snd_soc_component_update_bits(component, SUNXI_HEADPHONE_REG,
+				(0x1 << HPPA_EN), (0x1 << HPPA_EN));
+		break;
+	case SND_SOC_DAPM_PRE_PMD:
+		/*close*/
+		snd_soc_component_update_bits(component, SUNXI_HEADPHONE_REG,
+				(0x1 << HPPA_EN), (0x0 << HPPA_EN));
+		snd_soc_component_update_bits(component, SUNXI_HEADPHONE_REG,
+				(0x1 << HPOUTPUTEN), (0x0 << HPOUTPUTEN));
+		snd_soc_component_update_bits(component, SUNXI_HEADPHONE_REG,
+				(0x1 << HPINPUTEN), (0x0 << HPINPUTEN));
+
+#ifdef SUNXI_CODEC_DAP_ENABLE
+		if (hw_cfg->dacdrc_cfg & DAP_HP_EN)
+			dacdrc_enable(component, 0);
+		if (hw_cfg->dachpf_cfg & DAP_HP_EN)
+			dachpf_enable(component, 0);
+#endif
+		break;
+	}
+
+	return 0;
+}
+
+static int sunxi_codec_lineout_event(struct snd_soc_dapm_widget *w,
+				  struct snd_kcontrol *k, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct codec_spk_config *spk_cfg = &(sunxi_codec->spk_config);
+	struct codec_hw_config *hw_cfg = &(sunxi_codec->hw_config);
+
+	switch (event) {
+	case	SND_SOC_DAPM_POST_PMU:
+#ifdef SUNXI_CODEC_DAP_ENABLE
+		if (hw_cfg->dacdrc_cfg & DAP_SPK_EN)
+			dacdrc_enable(component, 1);
+		if (hw_cfg->dachpf_cfg & DAP_SPK_EN)
+			dachpf_enable(component, 1);
+#endif
+		snd_soc_component_update_bits(component, SUNXI_DAC_REG,
+				(0x1 << LINEOUTLEN), (0x1 << LINEOUTLEN));
+
+		if (spk_cfg->used) {
+			gpio_direction_output(spk_cfg->spk_gpio, 1);
+			gpio_set_value(spk_cfg->spk_gpio, spk_cfg->pa_level);
+			/* time delay to wait spk pa work fine */
+			msleep(spk_cfg->pa_msleep);
+		}
+		break;
+	case	SND_SOC_DAPM_PRE_PMD:
+		if (spk_cfg->used)
+			gpio_set_value(spk_cfg->spk_gpio, !(spk_cfg->pa_level));
+
+		snd_soc_component_update_bits(component, SUNXI_DAC_REG,
+				(0x1 << LINEOUTLEN), (0x0 << LINEOUTLEN));
+
+#ifdef SUNXI_CODEC_DAP_ENABLE
+		if (hw_cfg->dacdrc_cfg & DAP_SPK_EN)
+			dacdrc_enable(component, 0);
+		if (hw_cfg->dachpf_cfg & DAP_SPK_EN)
+			dachpf_enable(component, 0);
+#endif
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int sunxi_codec_playback_event(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *k, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+
+	switch (event) {
+	case	SND_SOC_DAPM_PRE_PMU:
+		/* DACL to left channel LINEOUT Mute control 0:mute 1: not mute */
+		snd_soc_component_update_bits(component, SUNXI_DAC_REG,
+				(0x1 << DACLMUTE),
+				(0x1 << DACLMUTE));
+		snd_soc_component_update_bits(component, SUNXI_DAC_DPC,
+				(0x1<<EN_DAC), (0x1<<EN_DAC));
+		msleep(30);
+		break;
+	case	SND_SOC_DAPM_POST_PMD:
+		snd_soc_component_update_bits(component, SUNXI_DAC_DPC,
+				(0x1<<EN_DAC), (0x0<<EN_DAC));
+		/* DACL to left channel LINEOUT Mute control 0:mute 1: not mute */
+		snd_soc_component_update_bits(component, SUNXI_DAC_REG,
+				(0x1 << DACLMUTE),
+				(0x0 << DACLMUTE));
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int sunxi_codec_capture_event(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *k, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+
+	switch (event) {
+	case	SND_SOC_DAPM_POST_PMU:
+		/* delay 80ms to avoid the capture pop at the beginning */
+		mdelay(80);
+		snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+				(0x1 << EN_AD), (0x1 << EN_AD));
+		break;
+	case	SND_SOC_DAPM_POST_PMD:
+		snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+				(0x1 << EN_AD), (0x0 << EN_AD));
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int sunxi_codec_adc_mixer_event(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *k, int event)
+{
+#ifdef SUNXI_CODEC_DAP_ENABLE
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct codec_hw_config *hw_cfg = &(sunxi_codec->hw_config);
+	unsigned int adcctrl_val = 0;
+
+	switch (event) {
+	case SND_SOC_DAPM_POST_PMU:
+		if (hw_cfg->adcdrc_cfg & DAP_HP_EN) {
+			adcctrl_val = snd_soc_component_read32(component, SUNXI_ADCL_REG);
+			if ((adcctrl_val >> MIC1AMPEN) & 0x1)
+				adcdrc_enable(component, 1);
+		} else if (hw_cfg->adcdrc_cfg & DAP_SPK_EN) {
+			adcctrl_val = snd_soc_component_read32(component, SUNXI_ADCR_REG);
+			if ((adcctrl_val >> MIC2AMPEN) & 0x1)
+				adcdrc_enable(component, 1);
+		}
+		break;
+	case SND_SOC_DAPM_POST_PMD:
+		if ((hw_cfg->adcdrc_cfg & DAP_SPK_EN) ||
+			(hw_cfg->adcdrc_cfg & DAP_HP_EN))
+			adcdrc_enable(component, 0);
+		break;
+	default:
+		break;
+	}
+#endif
+
+	return 0;
+}
+
+static const struct snd_kcontrol_new sunxi_codec_controls[] = {
+#ifdef SUNXI_CODEC_HUB_ENABLE
+	SOC_ENUM_EXT("codec hub mode", sunxi_codec_hub_mode_enum[0],
+				sunxi_codec_get_hub_mode,
+				sunxi_codec_set_hub_mode),
+#endif
+#ifdef SUNXI_CODEC_ADCSWAP_ENABLE
+	SOC_ENUM_EXT("ADC Swap", sunxi_codec_adcswap_func_enum[0],
+				sunxi_codec_get_adcswap_mode,
+				sunxi_codec_set_adcswap_mode),
+#endif
+	/* Digital Volume */
+	SOC_SINGLE_TLV("digital volume", SUNXI_DAC_DPC,
+					DVOL, 0x3F, 1, digital_tlv),
+	/* MIC1 Gain */
+	SOC_SINGLE_TLV("MIC1 gain volume", SUNXI_ADCL_REG,
+					ADCL_PGA_GAIN_CTRL, 0x1F, 0, mic1gain_tlv),
+	/* MIC2 Gain */
+	SOC_SINGLE_TLV("MIC2 gain volume", SUNXI_ADCR_REG,
+					ADCR_PGA_GAIN_CTRL, 0x1F, 0, mic2gain_tlv),
+	/* DAC Volume */
+	SOC_SINGLE_TLV("LINEOUT volume", SUNXI_DAC_REG, LINEOUT_VOL,
+			0x1F, 0, lineout_tlv),
+	/* DAC Volume / HEADPHONE VOL */
+	SOC_DOUBLE_TLV("DAC volume", SUNXI_DAC_VOL_CTRL, DAC_VOL_L, DAC_VOL_R,
+		       0xFF, 0, dac_vol_tlv),
+	/* ADC Volume */
+	SOC_DOUBLE_TLV("ADC volume", SUNXI_ADC_VOL_CTRL, ADC_VOL_L, ADC_VOL_R,
+		       0xFF, 0, adc_vol_tlv),
+	/* Headphone Gain */
+	SOC_SINGLE_TLV("Headphone Volume", SUNXI_DAC_REG, HEADPHONE_GAIN,
+			0x7, 0, headphone_gain_tlv),
+};
+
+/* lineout controls */
+static const char * const left_lineout_text[] = {
+	"DAC_SINGLE", "DAC_DIFFER",
+};
+
+static const struct soc_enum left_lineout_enum =
+	SOC_ENUM_SINGLE(SUNXI_DAC_REG, LINEOUTLDIFFEN,
+			ARRAY_SIZE(left_lineout_text), left_lineout_text);
+
+static const struct snd_kcontrol_new left_lineout_mux =
+	SOC_DAPM_ENUM("LINEOUT Output Select", left_lineout_enum);
+
+/* mic controls */
+static const struct snd_kcontrol_new mic1_input_mixer[] = {
+	SOC_DAPM_SINGLE("MIC1 Boost Switch", SUNXI_ADCL_REG, MIC1AMPEN, 1, 0),
+};
+
+static const struct snd_kcontrol_new mic2_input_mixer[] = {
+	SOC_DAPM_SINGLE("MIC2 Boost Switch", SUNXI_ADCR_REG, MIC2AMPEN, 1, 0),
+};
+
+/*audio dapm widget */
+static const struct snd_soc_dapm_widget sunxi_codec_dapm_widgets[] = {
+	SND_SOC_DAPM_AIF_IN_E("DACL", "Playback", 0, SUNXI_DAC_REG,
+				DACLEN, 0,
+				sunxi_codec_playback_event,
+				SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+
+	SND_SOC_DAPM_AIF_IN_E("DACR", "Playback", 0, SUNXI_DAC_REG,
+				DACREN, 0,
+				sunxi_codec_playback_event,
+				SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+
+	SND_SOC_DAPM_AIF_OUT_E("ADCL", "Capture", 0, SUNXI_ADCL_REG,
+				ADCL_EN, 0,
+				sunxi_codec_capture_event,
+				SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
+
+	SND_SOC_DAPM_AIF_OUT_E("ADCR", "Capture", 0, SUNXI_ADCR_REG,
+				ADCR_EN, 0,
+				sunxi_codec_capture_event,
+				SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
+
+	SND_SOC_DAPM_MUX("LINEOUT Output Select", SND_SOC_NOPM,
+			0, 0, &left_lineout_mux),
+
+	SND_SOC_DAPM_MIXER_E("ADCL Input", SND_SOC_NOPM, 0, 0,
+			mic1_input_mixer, ARRAY_SIZE(mic1_input_mixer),
+			sunxi_codec_adc_mixer_event,
+			SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
+
+	SND_SOC_DAPM_MIXER_E("ADCR Input", SND_SOC_NOPM, 0, 0,
+			mic2_input_mixer, ARRAY_SIZE(mic2_input_mixer),
+			sunxi_codec_adc_mixer_event,
+			SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
+
+	SND_SOC_DAPM_MICBIAS("MainMic Bias", SUNXI_MICBIAS_REG,
+				MMICBIASEN, 0),
+
+	SND_SOC_DAPM_INPUT("MIC1"),
+	SND_SOC_DAPM_INPUT("MIC2"),
+
+	SND_SOC_DAPM_OUTPUT("HPOUTL"),
+	SND_SOC_DAPM_OUTPUT("HPOUTR"),
+
+	SND_SOC_DAPM_HP("Headphone", sunxi_codec_headphone_event),
+	SND_SOC_DAPM_LINE("LINEOUT", sunxi_codec_lineout_event),
+	SND_SOC_DAPM_SPK("HpSpeaker", sunxi_codec_hpspeaker_event),
+};
+
+static const struct snd_soc_dapm_route sunxi_codec_dapm_routes[] = {
+	/* Mic input route */
+	{"ADCL Input", "MIC1 Boost Switch", "MIC1"},
+	{"ADCR Input", "MIC2 Boost Switch", "MIC2"},
+
+	{"ADCL", NULL, "ADCL Input"},
+	{"ADCR", NULL, "ADCR Input"},
+
+	/* LINEOUT Output route */
+	{"LINEOUT Output Select", "DAC_SINGLE", "DACL"},
+	{"LINEOUT Output Select", "DAC_DIFFER", "DACL"},
+
+	{"LINEOUT", NULL, "LINEOUT Output Select"},
+
+	/* Headphone output route */
+	{"HPOUTL", NULL, "DACL"},
+	{"HPOUTR", NULL, "DACR"},
+
+	{"Headphone", NULL, "HPOUTL"},
+	{"Headphone", NULL, "HPOUTR"},
+
+	{"HpSpeaker", NULL, "HPOUTR"},
+	{"HpSpeaker", NULL, "HPOUTL"},
+};
+
+static void sunxi_codec_init(struct snd_soc_component *component)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	/* DAC_VOL_SEL default disabled */
+	snd_soc_component_update_bits(component, SUNXI_DAC_VOL_CTRL,
+			(0x1 << DAC_VOL_SEL), (0x1 << DAC_VOL_SEL));
+
+	/* ADC_VOL_SEL default disabled */
+	snd_soc_component_update_bits(component, SUNXI_ADC_VOL_CTRL,
+			(0x1 << ADC_VOL_SEL), (0x1 << ADC_VOL_SEL));
+
+	/* Enable ADCFDT to overcome niose at the beginning */
+	snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+			(0x7 << ADCDFEN), (0x7 << ADCDFEN));
+
+	/* Digital VOL defeult setting */
+	snd_soc_component_update_bits(component, SUNXI_DAC_DPC,
+			0x3F << DVOL,
+			sunxi_codec->digital_vol << DVOL);
+
+	/* LINEOUT VOL defeult setting */
+	snd_soc_component_update_bits(component, SUNXI_DAC_REG,
+			0x1F << LINEOUT_VOL,
+			sunxi_codec->lineout_vol << LINEOUT_VOL);
+
+	/* Headphone Gain defeult setting */
+	snd_soc_component_update_bits(component, SUNXI_DAC_REG,
+			0x7 << HEADPHONE_GAIN,
+			sunxi_codec->headphonegain << HEADPHONE_GAIN);
+
+	/* ADCL MIC1 gain defeult setting */
+	snd_soc_component_update_bits(component, SUNXI_ADCL_REG,
+			0x1F << ADCL_PGA_GAIN_CTRL,
+			sunxi_codec->mic1gain << ADCL_PGA_GAIN_CTRL);
+
+	/* ADCR MIC2 gain defeult setting */
+	snd_soc_component_update_bits(component, SUNXI_ADCR_REG,
+			0x1F << ADCR_PGA_GAIN_CTRL,
+			sunxi_codec->mic2gain << ADCR_PGA_GAIN_CTRL);
+
+	/* ADCL/R IOP params default setting */
+	snd_soc_component_update_bits(component, SUNXI_ADCL_REG,
+			0xFF << ADCL_IOPMICL, 0x55 << ADCL_IOPMICL);
+	snd_soc_component_update_bits(component, SUNXI_ADCR_REG,
+			0xFF << ADCR_IOPMICL, 0x55 << ADCR_IOPMICL);
+
+	/* For improve performance of THD+N about HP */
+	snd_soc_component_update_bits(component, SUNXI_HEADPHONE_REG,
+			(0x3 << CP_CLKS), (0x2 << CP_CLKS));
+
+	/* To fix some pop noise */
+	snd_soc_component_update_bits(component, SUNXI_HEADPHONE_REG,
+			(0x1 << HPCALIFIRST), (0x1 << HPCALIFIRST));
+
+	snd_soc_component_update_bits(component, SUNXI_HEADPHONE_REG,
+			(0x3 << HPPA_DEL), (0x3 << HPPA_DEL));
+
+	snd_soc_component_update_bits(component, SUNXI_DAC_REG,
+			(0x3 << CPLDO_VOLTAGE), (0x1 << CPLDO_VOLTAGE));
+
+#ifdef SUNXI_CODEC_DAP_ENABLE
+	if (sunxi_codec->hw_config.adcdrc_cfg)
+		adcdrc_config(component);
+	if (sunxi_codec->hw_config.adchpf_cfg)
+		adchpf_config(component);
+
+	if (sunxi_codec->hw_config.dacdrc_cfg)
+		dacdrc_config(component);
+	if (sunxi_codec->hw_config.dachpf_cfg)
+		dachpf_config(component);
+#endif
+}
+
+static int sunxi_codec_startup(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+#ifdef SUNXI_CODEC_DAP_ENABLE
+	struct snd_soc_component *component = dai->component;
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		if (sunxi_codec->hw_config.adchpf_cfg)
+			adchpf_enable(component, 1);
+	}
+#endif
+
+	return 0;
+}
+
+static int sunxi_codec_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct snd_soc_component *component = dai->component;
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	int i = 0;
+
+	switch (params_format(params)) {
+	case	SNDRV_PCM_FORMAT_S16_LE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			snd_soc_component_update_bits(component, SUNXI_DAC_FIFOC,
+				(3 << FIFO_MODE), (3 << FIFO_MODE));
+			snd_soc_component_update_bits(component, SUNXI_DAC_FIFOC,
+				(1 << TX_SAMPLE_BITS), (0 << TX_SAMPLE_BITS));
+		} else {
+			snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+				(1 << RX_FIFO_MODE), (1 << RX_FIFO_MODE));
+			snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+				(1 << RX_SAMPLE_BITS), (0 << RX_SAMPLE_BITS));
+		}
+		break;
+	case	SNDRV_PCM_FORMAT_S24_LE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			snd_soc_component_update_bits(component, SUNXI_DAC_FIFOC,
+				(3 << FIFO_MODE), (0 << FIFO_MODE));
+			snd_soc_component_update_bits(component, SUNXI_DAC_FIFOC,
+				(1 << TX_SAMPLE_BITS), (1 << TX_SAMPLE_BITS));
+		} else {
+			snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+				(1 << RX_FIFO_MODE), (0 << RX_FIFO_MODE));
+			snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+				(1 << RX_SAMPLE_BITS), (1 << RX_SAMPLE_BITS));
+		}
+		break;
+	default:
+		break;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(sample_rate_conv); i++) {
+		if (sample_rate_conv[i].samplerate == params_rate(params)) {
+			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+				snd_soc_component_update_bits(component, SUNXI_DAC_FIFOC,
+					(0x7 << DAC_FS),
+					(sample_rate_conv[i].rate_bit << DAC_FS));
+			} else {
+				if (sample_rate_conv[i].samplerate > 48000)
+					return -EINVAL;
+				snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+					(0x7 << ADC_FS),
+					(sample_rate_conv[i].rate_bit<<ADC_FS));
+			}
+		}
+	}
+
+	/* reset the adchpf func setting for different sampling */
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		if (sunxi_codec->hw_config.adchpf_cfg) {
+			if (params_rate(params) == 16000) {
+				snd_soc_component_write(component, SUNXI_ADC_DRC_HHPFC,
+						(0x00F623A5 >> 16) & 0xFFFF);
+
+				snd_soc_component_write(component, SUNXI_ADC_DRC_LHPFC,
+							0x00F623A5 & 0xFFFF);
+
+			} else if (params_rate(params) == 44100) {
+				snd_soc_component_write(component, SUNXI_ADC_DRC_HHPFC,
+						(0x00FC60DB >> 16) & 0xFFFF);
+
+				snd_soc_component_write(component, SUNXI_ADC_DRC_LHPFC,
+							0x00FC60DB & 0xFFFF);
+			} else {
+				snd_soc_component_write(component, SUNXI_ADC_DRC_HHPFC,
+						(0x00FCABB3 >> 16) & 0xFFFF);
+
+				snd_soc_component_write(component, SUNXI_ADC_DRC_LHPFC,
+							0x00FCABB3 & 0xFFFF);
+			}
+		}
+	}
+
+	switch (params_channels(params)) {
+	case 1:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			snd_soc_component_update_bits(component, SUNXI_DAC_FIFOC,
+				(0x1 << DAC_MONO_EN), 0x1 << DAC_MONO_EN);
+		} else {
+			snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+				(0x3 << ADC_CHAN_EN), (0x1 << ADC_CHAN_EN));
+		}
+		break;
+	case 2:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			snd_soc_component_update_bits(component, SUNXI_DAC_FIFOC,
+				(0x1 << DAC_MONO_EN), (0x0 << DAC_MONO_EN));
+		} else {
+			snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+				(0x3 << ADC_CHAN_EN), (0x3 << ADC_CHAN_EN));
+		}
+		break;
+	default:
+		SOUND_LOG_ERR("only support mono or stereo mode.\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sunxi_codec_set_sysclk(struct snd_soc_dai *dai,
+			int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_component *component = dai->component;
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	switch (clk_id) {
+	case	0:
+		/* For setting the clk source to 90.3168M to surpport playback */
+		if (clk_set_parent(sunxi_codec->dacclk, sunxi_codec->pllcomdiv5)) {
+			SOUND_LOG_ERR("set parent of dacclk to pllcomdiv5 failed\n");
+			return -EINVAL;
+		}
+
+		if (clk_set_rate(sunxi_codec->dacclk, freq)) {
+			SOUND_LOG_ERR("codec set dac clk rate failed\n");
+			return -EINVAL;
+		}
+		break;
+	case	1:
+		/* For setting the clk source to 90.3168M to surpport capture */
+		if (clk_set_parent(sunxi_codec->adcclk, sunxi_codec->pllcomdiv5)) {
+			SOUND_LOG_ERR("set parent of adcclk to pllcomdiv5 failed\n");
+			return -EINVAL;
+		}
+
+		if (clk_set_rate(sunxi_codec->adcclk, freq)) {
+			SOUND_LOG_ERR("codec set adc clk rate failed\n");
+			return -EINVAL;
+		}
+		break;
+	case	2:
+		/* For setting the clk source to 98.304M to surpport playback */
+		if (clk_set_parent(sunxi_codec->dacclk, sunxi_codec->pllclk)) {
+			SOUND_LOG_ERR("set parent of dacclk to pllclk failed\n");
+			return -EINVAL;
+		}
+
+		if (clk_set_rate(sunxi_codec->dacclk, freq)) {
+			SOUND_LOG_ERR("codec set dac clk rate failed\n");
+			return -EINVAL;
+		}
+		break;
+	case	3:
+		/* For setting the clk source to 98.304M to surpport capture */
+		if (clk_set_parent(sunxi_codec->adcclk, sunxi_codec->pllclk)) {
+			SOUND_LOG_ERR("set parent of adcclk to pllclk failed\n");
+			return -EINVAL;
+		}
+
+		if (clk_set_rate(sunxi_codec->adcclk, freq)) {
+			SOUND_LOG_ERR("codec set adc clk rate failed\n");
+			return -EINVAL;
+		}
+		break;
+	default:
+		SOUND_LOG_ERR("Bad clk params input!\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void sunxi_codec_shutdown(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+#ifdef SUNXI_CODEC_DAP_ENABLE
+	struct snd_soc_component *component = dai->component;
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		if (sunxi_codec->hw_config.adchpf_cfg)
+			adchpf_enable(component, 0);
+	}
+#endif
+}
+
+static int sunxi_codec_prepare(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	struct snd_soc_component *component = dai->component;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		snd_soc_component_update_bits(component, SUNXI_DAC_FIFOC,
+			(1 << FIFO_FLUSH), (1 << FIFO_FLUSH));
+		snd_soc_component_write(component, SUNXI_DAC_FIFOS,
+			(1 << DAC_TXE_INT | 1 << DAC_TXU_INT | 1 << DAC_TXO_INT));
+		snd_soc_component_write(component, SUNXI_DAC_CNT, 0);
+	} else {
+		snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+				(1 << ADC_FIFO_FLUSH), (1 << ADC_FIFO_FLUSH));
+		snd_soc_component_write(component, SUNXI_ADC_FIFOS,
+				(1 << ADC_RXA_INT | 1 << ADC_RXO_INT));
+		snd_soc_component_write(component, SUNXI_ADC_CNT, 0);
+	}
+
+	return 0;
+}
+
+static int sunxi_codec_trigger(struct snd_pcm_substream *substream,
+				int cmd, struct snd_soc_dai *dai)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(dai->component);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			regmap_update_bits(sunxi_codec->regmap, SUNXI_DAC_FIFOC,
+				(1 << DAC_DRQ_EN), (1 << DAC_DRQ_EN));
+		else
+			regmap_update_bits(sunxi_codec->regmap, SUNXI_ADC_FIFOC,
+				(1 << ADC_DRQ_EN), (1 << ADC_DRQ_EN));
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			regmap_update_bits(sunxi_codec->regmap, SUNXI_DAC_FIFOC,
+				(1 << DAC_DRQ_EN), (0 << DAC_DRQ_EN));
+		else
+			regmap_update_bits(sunxi_codec->regmap, SUNXI_ADC_FIFOC,
+				(1 << ADC_DRQ_EN), (0 << ADC_DRQ_EN));
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops sunxi_codec_dai_ops = {
+	.startup	= sunxi_codec_startup,
+	.hw_params	= sunxi_codec_hw_params,
+	.shutdown	= sunxi_codec_shutdown,
+	.set_sysclk	= sunxi_codec_set_sysclk,
+	.trigger	= sunxi_codec_trigger,
+	.prepare	= sunxi_codec_prepare,
+};
+
+static struct snd_soc_dai_driver sunxi_codec_dai[] = {
+	{
+		.name	= "sun50iw10codec",
+		.playback = {
+			.stream_name = "Playback",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates	= SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE,
+		},
+		.capture = {
+			.stream_name = "Capture",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = SNDRV_PCM_RATE_8000_48000
+				| SNDRV_PCM_RATE_KNOT,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE,
+		},
+		.ops = &sunxi_codec_dai_ops,
+	},
+};
+
+static int sunxi_codec_probe(struct snd_soc_component *component)
+{
+	int ret;
+	struct snd_soc_dapm_context *dapm = &component->dapm;
+
+	ret = snd_soc_add_component_controls(component, sunxi_codec_controls,
+					ARRAY_SIZE(sunxi_codec_controls));
+	if (ret)
+		SOUND_LOG_ERR("failed to register codec controls!\n");
+
+	snd_soc_dapm_new_controls(dapm, sunxi_codec_dapm_widgets,
+				ARRAY_SIZE(sunxi_codec_dapm_widgets));
+	snd_soc_dapm_add_routes(dapm, sunxi_codec_dapm_routes,
+				ARRAY_SIZE(sunxi_codec_dapm_routes));
+
+	sunxi_codec_init(component);
+
+	return 0;
+}
+
+static void sunxi_codec_remove(struct snd_soc_component *component)
+{
+
+}
+
+static int save_audio_reg(struct sunxi_codec_info *sunxi_codec)
+{
+	int i = 0;
+
+	while (reg_labels[i].name != NULL) {
+		regmap_read(sunxi_codec->regmap, reg_labels[i].address,
+			&reg_labels[i].value);
+		i++;
+	}
+
+	return i;
+}
+
+static int echo_audio_reg(struct sunxi_codec_info *sunxi_codec)
+{
+	int i = 0;
+
+	while (reg_labels[i].name != NULL) {
+		regmap_write(sunxi_codec->regmap, reg_labels[i].address,
+					reg_labels[i].value);
+		i++;
+	}
+
+	return i;
+}
+
+static int sunxi_codec_suspend(struct snd_soc_component *component)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct codec_spk_config *spk_cfg = &(sunxi_codec->spk_config);
+
+	SOUND_LOG_DEBUG("Enter\n");
+	save_audio_reg(sunxi_codec);
+
+	if (spk_cfg->used)
+		gpio_set_value(spk_cfg->spk_gpio, !(spk_cfg->pa_level));
+
+	if (sunxi_codec->vol_supply.avcc)
+		regulator_disable(sunxi_codec->vol_supply.avcc);
+
+	if (sunxi_codec->vol_supply.cpvin)
+		regulator_disable(sunxi_codec->vol_supply.cpvin);
+
+	clk_disable_unprepare(sunxi_codec->dacclk);
+	clk_disable_unprepare(sunxi_codec->adcclk);
+	clk_disable_unprepare(sunxi_codec->pllcomdiv5);
+	clk_disable_unprepare(sunxi_codec->pllcom);
+	clk_disable_unprepare(sunxi_codec->pllclk);
+	clk_disable_unprepare(sunxi_codec->codec_clk_bus);
+	reset_control_assert(sunxi_codec->codec_clk_rst);
+
+	SOUND_LOG_DEBUG("End\n");
+
+	return 0;
+}
+
+static int sunxi_codec_resume(struct snd_soc_component *component)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct codec_spk_config *spk_cfg = &(sunxi_codec->spk_config);
+	unsigned int ret;
+
+	SOUND_LOG_DEBUG("Enter\n");
+
+	if (sunxi_codec->vol_supply.avcc) {
+		ret = regulator_enable(sunxi_codec->vol_supply.avcc);
+		if (ret)
+			SOUND_LOG_ERR("resume avcc enable failed!\n");
+	}
+
+	if (sunxi_codec->vol_supply.cpvin) {
+		ret = regulator_enable(sunxi_codec->vol_supply.cpvin);
+		if (ret)
+			SOUND_LOG_ERR("resume cpvin enable failed!\n");
+	}
+
+	if (clk_set_rate(sunxi_codec->pllcom, 451584000)) {
+		SOUND_LOG_ERR("resume codec source set pllcom rate failed\n");
+		return -EBUSY;
+
+	}
+
+	if (clk_set_rate(sunxi_codec->pllclk, 98304000)) {
+		SOUND_LOG_ERR("resume codec source set pllclk rate failed\n");
+		return -EBUSY;
+	}
+
+	if (reset_control_deassert(sunxi_codec->codec_clk_rst)) {
+		SOUND_LOG_ERR("resume deassert the codec reset failed\n");
+		return -EBUSY;
+	}
+
+	if (clk_prepare_enable(sunxi_codec->codec_clk_bus)) {
+		SOUND_LOG_ERR("enable codec bus clk failed, resume exit\n");
+		return -EBUSY;
+	}
+
+	if (clk_prepare_enable(sunxi_codec->pllclk)) {
+		SOUND_LOG_ERR("enable pllclk failed, resume exit\n");
+		return -EBUSY;
+	}
+
+	if (clk_prepare_enable(sunxi_codec->pllcom)) {
+		SOUND_LOG_ERR("enable pllcom failed, resume exit\n");
+		return -EBUSY;
+	}
+
+	if (clk_prepare_enable(sunxi_codec->pllcomdiv5)) {
+		SOUND_LOG_ERR("enable pllcomdiv5 failed, resume exit\n");
+		return -EBUSY;
+	}
+
+	if (clk_prepare_enable(sunxi_codec->dacclk)) {
+		SOUND_LOG_ERR("enable dacclk failed, resume exit\n");
+		return -EBUSY;
+	}
+
+	if (clk_prepare_enable(sunxi_codec->adcclk)) {
+		SOUND_LOG_ERR("enable  adcclk failed, resume exit\n");
+		clk_disable_unprepare(sunxi_codec->adcclk);
+		return -EBUSY;
+	}
+
+	if (spk_cfg->used) {
+		gpio_direction_output(spk_cfg->spk_gpio, 1);
+		gpio_set_value(spk_cfg->spk_gpio, !(spk_cfg->pa_level));
+	}
+
+	sunxi_codec_init(component);
+	echo_audio_reg(sunxi_codec);
+
+	SOUND_LOG_DEBUG("End\n");
+
+	return 0;
+}
+
+static unsigned int sunxi_codec_read(struct snd_soc_component *component,
+					unsigned int reg)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	unsigned int reg_val;
+
+	regmap_read(sunxi_codec->regmap, reg, &reg_val);
+
+	return reg_val;
+}
+
+static int sunxi_codec_write(struct snd_soc_component *component,
+				unsigned int reg, unsigned int val)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	regmap_write(sunxi_codec->regmap, reg, val);
+
+	return 0;
+};
+
+static struct snd_soc_component_driver soc_codec_dev_sunxi = {
+	.probe = sunxi_codec_probe,
+	.remove = sunxi_codec_remove,
+	.suspend = sunxi_codec_suspend,
+	.resume = sunxi_codec_resume,
+	.read = sunxi_codec_read,
+	.write = sunxi_codec_write,
+};
+
+/* audiocodec reg dump about */
+static ssize_t show_audio_reg(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct sunxi_codec_info *sunxi_codec = dev_get_drvdata(dev);
+	int count = 0, i = 0;
+	unsigned int reg_val;
+	unsigned int size = ARRAY_SIZE(reg_labels);
+
+	count += sprintf(buf, "dump audiocodec reg:\n");
+
+	while ((i < size) && (reg_labels[i].name != NULL)) {
+		regmap_read(sunxi_codec->regmap,
+				reg_labels[i].address, &reg_val);
+		count += sprintf(buf + count, "%-20s [0x%03x]: 0x%-10x save_val:0x%x\n",
+			reg_labels[i].name, (reg_labels[i].address),
+			reg_val, reg_labels[i].value);
+		i++;
+	}
+
+	return count;
+}
+
+/* ex:
+ * param 1: 0 read;1 write
+ * param 2: reg value;
+ * param 3: write value;
+	read:
+		echo 0,0x00> audio_reg
+	write:
+		echo 1,0x00,0xa > audio_reg
+*/
+static ssize_t store_audio_reg(struct device *dev, struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	int ret;
+	int rw_flag;
+	int input_reg_val = 0;
+	int input_reg_offset = 0;
+	struct sunxi_codec_info *sunxi_codec = dev_get_drvdata(dev);
+
+	ret = sscanf(buf, "%d,0x%x,0x%x", &rw_flag,
+			&input_reg_offset, &input_reg_val);
+	SOUND_LOG_INFO("ret:%d, reg_offset:%d, reg_val:0x%x\n",
+			ret, input_reg_offset, input_reg_val);
+
+	if (!(rw_flag == 1 || rw_flag == 0)) {
+		SOUND_LOG_ERR("not rw_flag\n");
+		ret = count;
+		goto out;
+	}
+
+	if (input_reg_offset > SUNXI_BIAS_REG) {
+		SOUND_LOG_ERR("the reg offset[0x%03x] > SUNXI_BIAS_REG[0x%03x]\n",
+			      input_reg_offset, SUNXI_BIAS_REG);
+		ret = count;
+		goto out;
+	}
+
+	if (rw_flag) {
+		regmap_write(sunxi_codec->regmap,
+				input_reg_offset, input_reg_val);
+	} else {
+		regmap_read(sunxi_codec->regmap,
+				input_reg_offset, &input_reg_val);
+		SOUND_LOG_INFO("\n\n Reg[0x%x] : 0x%08x\n\n",
+				input_reg_offset, input_reg_val);
+	}
+	ret = count;
+out:
+	return ret;
+}
+
+static DEVICE_ATTR(audio_reg, 0644, show_audio_reg, store_audio_reg);
+
+static struct attribute *audio_debug_attrs[] = {
+	&dev_attr_audio_reg.attr,
+	NULL,
+};
+
+static struct attribute_group audio_debug_attr_group = {
+	.name   = "audio_reg_debug",
+	.attrs  = audio_debug_attrs,
+};
+
+/* regmap configuration */
+static const struct regmap_config sunxi_codec_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = SUNXI_HMIC_STS,
+	.cache_type = REGCACHE_NONE,
+};
+static const struct snd_pcm_hardware snd_rockchip_hardware = {
+	.info			= SNDRV_PCM_INFO_MMAP |
+				  SNDRV_PCM_INFO_MMAP_VALID |
+				  SNDRV_PCM_INFO_PAUSE |
+				  SNDRV_PCM_INFO_RESUME |
+				  SNDRV_PCM_INFO_INTERLEAVED,
+	.period_bytes_min	= 32,
+	.period_bytes_max	= 8192,
+	.periods_min		= 1,
+	.periods_max		= 52,
+	.buffer_bytes_max	= 64 * 1024,
+	.fifo_size		= 32,
+};
+
+static int sunxi_codec_regulator_init(struct platform_device *pdev,
+				struct sunxi_codec_info *sunxi_codec)
+{
+	int ret = -EFAULT;
+
+	sunxi_codec->vol_supply.avcc = regulator_get(&pdev->dev, "avcc");
+	if (IS_ERR(sunxi_codec->vol_supply.avcc)) {
+		SOUND_LOG_ERR("get audio avcc failed\n");
+		goto err_regulator;
+	} else {
+		ret = regulator_set_voltage(sunxi_codec->vol_supply.avcc,
+							1800000, 1800000);
+		if (ret) {
+			SOUND_LOG_ERR("audiocodec avcc set vol failed\n");
+			goto err_regulator_avcc;
+		}
+
+		ret = regulator_enable(sunxi_codec->vol_supply.avcc);
+		if (ret) {
+			SOUND_LOG_ERR("avcc enable failed!\n");
+			goto err_regulator_avcc;
+		}
+	}
+
+	sunxi_codec->vol_supply.cpvin = regulator_get(&pdev->dev, "cpvin");
+	if (IS_ERR(sunxi_codec->vol_supply.cpvin)) {
+		SOUND_LOG_ERR("get cpvin failed\n");
+		goto err_regulator_avcc;
+	} else {
+		ret = regulator_set_voltage(sunxi_codec->vol_supply.cpvin,
+							1800000, 1800000);
+		if (ret) {
+			SOUND_LOG_ERR("cpvin set vol failed\n");
+			goto err_regulator_cpvin;
+		}
+
+		ret = regulator_enable(sunxi_codec->vol_supply.cpvin);
+		if (ret) {
+			SOUND_LOG_ERR("cpvin enable failed!\n");
+			goto err_regulator_cpvin;
+		}
+	}
+	return 0;
+
+err_regulator_cpvin:
+	regulator_put(sunxi_codec->vol_supply.cpvin);
+err_regulator_avcc:
+	regulator_put(sunxi_codec->vol_supply.avcc);
+err_regulator:
+	return ret;
+}
+
+static int sunxi_codec_clk_init(struct device_node *np,
+				struct platform_device *pdev,
+				struct sunxi_codec_info *sunxi_codec)
+{
+	int ret = -EBUSY;
+	/* get the parent clk and the module clk */
+	sunxi_codec->pllclk = of_clk_get_by_name(np, "pll_audio");
+	sunxi_codec->dacclk = of_clk_get_by_name(np, "codec_dac");
+	sunxi_codec->adcclk = of_clk_get_by_name(np, "codec_adc");
+	sunxi_codec->pllcom = of_clk_get_by_name(np, "pll_com");
+	sunxi_codec->pllcomdiv5 = of_clk_get_by_name(np, "pll_com_audio");
+	sunxi_codec->codec_clk_bus = of_clk_get_by_name(np, "codec_bus");
+	sunxi_codec->codec_clk_rst = devm_reset_control_get(&pdev->dev, NULL);
+
+	if (reset_control_deassert(sunxi_codec->codec_clk_rst)) {
+		SOUND_LOG_ERR("deassert the codec reset failed\n");
+		goto err_devm_kfree;
+	}
+
+	if (clk_set_parent(sunxi_codec->pllcomdiv5, sunxi_codec->pllcom)) {
+		SOUND_LOG_ERR("set parent of pllcomdiv5 to pllcom failed\n");
+		goto err_devm_kfree;
+	}
+
+	if (clk_set_parent(sunxi_codec->dacclk, sunxi_codec->pllcomdiv5)) {
+		SOUND_LOG_ERR("set parent of dacclk to pllcomdiv5 failed\n");
+		goto err_devm_kfree;
+	}
+
+	if (clk_set_parent(sunxi_codec->adcclk, sunxi_codec->pllcomdiv5)) {
+		SOUND_LOG_ERR("set parent of adcclk to pllcomdiv5 failed\n");
+		goto err_devm_kfree;
+	}
+
+	if (clk_set_rate(sunxi_codec->pllcom, 451584000)) {
+		SOUND_LOG_ERR("codec source set pllcom rate failed\n");
+		goto err_devm_kfree;
+	}
+
+	if (clk_set_rate(sunxi_codec->pllclk, 98304000)) {
+		SOUND_LOG_ERR("codec source set pllclk rate failed\n");
+		goto err_devm_kfree;
+	}
+
+	if (clk_prepare_enable(sunxi_codec->codec_clk_bus)) {
+		SOUND_LOG_ERR("codec clk bus enable failed\n");
+	}
+
+	if (clk_prepare_enable(sunxi_codec->pllclk)) {
+		SOUND_LOG_ERR("pllclk enable failed\n");
+		goto err_bus_kfree;
+	}
+
+	if (clk_prepare_enable(sunxi_codec->pllcom)) {
+		SOUND_LOG_ERR("pllcom enable failed\n");
+		goto err_pllclk_kfree;
+	}
+
+	if (clk_prepare_enable(sunxi_codec->pllcomdiv5)) {
+		SOUND_LOG_ERR("pllcomdiv5 enable failed\n");
+		goto err_pllcom_kfree;
+	}
+
+	if (clk_prepare_enable(sunxi_codec->dacclk)) {
+		SOUND_LOG_ERR("dacclk enable failed\n");
+		goto err_pllcomdiv5_kfree;
+	}
+
+	if (clk_prepare_enable(sunxi_codec->adcclk)) {
+		SOUND_LOG_ERR("moduleclk enable failed\n");
+		goto err_dacclk_kfree;
+	}
+	return 0;
+
+err_dacclk_kfree:
+	clk_disable_unprepare(sunxi_codec->dacclk);
+err_pllcomdiv5_kfree:
+	clk_disable_unprepare(sunxi_codec->pllcomdiv5);
+err_pllcom_kfree:
+	clk_disable_unprepare(sunxi_codec->pllcom);
+err_pllclk_kfree:
+	clk_disable_unprepare(sunxi_codec->pllclk);
+err_bus_kfree:
+	clk_disable_unprepare(sunxi_codec->codec_clk_bus);
+err_devm_kfree:
+	return ret;
+}
+
+static int sunxi_codec_parse_params(struct device_node *np,
+				    struct platform_device *pdev,
+				    struct sunxi_codec_info *sunxi_codec)
+{
+	int ret = 0;
+	unsigned int temp_val;
+	/* get the special property form the board.dts */
+	ret = of_property_read_u32(np, "digital_vol", &temp_val);
+	if (ret < 0) {
+		SOUND_LOG_WARN("digital volume get failed, use default vol\n");
+		sunxi_codec->digital_vol = 0;
+	} else {
+		sunxi_codec->digital_vol = temp_val;
+	}
+
+	/* lineout volume */
+	ret = of_property_read_u32(np, "lineout_vol", &temp_val);
+	if (ret < 0) {
+		SOUND_LOG_WARN("lineout volume get failed, use default vol\n");
+		sunxi_codec->lineout_vol = 0;
+	} else {
+		sunxi_codec->lineout_vol = temp_val;
+	}
+
+	/* headphone volume */
+	ret = of_property_read_u32(np, "headphonegain", &temp_val);
+	if (ret < 0) {
+		SOUND_LOG_WARN("headphonegain volume get failed, use default vol\n");
+		sunxi_codec->headphonegain = 0;
+	} else {
+		sunxi_codec->headphonegain = temp_val;
+	}
+
+	/* mic gain for capturing */
+	ret = of_property_read_u32(np, "mic1gain", &temp_val);
+	if (ret < 0) {
+		SOUND_LOG_WARN("mic1gain get failed, use default vol\n");
+		sunxi_codec->mic1gain = 32;
+	} else {
+		sunxi_codec->mic1gain = temp_val;
+	}
+	ret = of_property_read_u32(np, "mic2gain", &temp_val);
+	if (ret < 0) {
+		SOUND_LOG_WARN("mic2gain get failed, use default vol\n");
+		sunxi_codec->mic2gain = 32;
+	} else {
+		sunxi_codec->mic2gain = temp_val;
+	}
+
+	/* Pa's delay time(ms) to work fine */
+	ret = of_property_read_u32(np, "pa_msleep_time", &temp_val);
+	if (ret < 0) {
+		SOUND_LOG_WARN("pa_msleep get failed, use default vol\n");
+		sunxi_codec->spk_config.pa_msleep = 160;
+	} else {
+		sunxi_codec->spk_config.pa_msleep = temp_val;
+	}
+
+	/* PA/SPK enable property */
+	ret = of_property_read_u32(np, "pa_level", &temp_val);
+	if (ret < 0) {
+		SOUND_LOG_WARN("pa_level get failed, use default vol\n");
+		sunxi_codec->spk_config.pa_level = 1;
+	} else {
+		sunxi_codec->spk_config.pa_level = temp_val;
+	}
+
+	SOUND_LOG_DEBUG("digital_vol:%d, lineout_vol:%d, "
+			"mic1gain:%d, mic2gain:%d, "
+			"pa_msleep:%d, pa_level:%d\n",
+			sunxi_codec->digital_vol,
+			sunxi_codec->lineout_vol,
+			sunxi_codec->mic1gain,
+			sunxi_codec->mic2gain,
+			sunxi_codec->spk_config.pa_msleep,
+			sunxi_codec->spk_config.pa_level);
+
+#ifdef SUNXI_CODEC_DAP_ENABLE
+	/* ADC/DAC DRC/HPF func enable property */
+	ret = of_property_read_u32(np, "adcdrc_cfg", &temp_val);
+	if (ret < 0) {
+		SOUND_LOG_WARN("adcdrc_cfg configs missing or invalid.\n");
+	} else {
+		sunxi_codec->hw_config.adcdrc_cfg = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "adchpf_cfg", &temp_val);
+	if (ret < 0) {
+		SOUND_LOG_WARN("adchpf_cfg configs missing or invalid.\n");
+	} else {
+		sunxi_codec->hw_config.adchpf_cfg = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "dacdrc_cfg", &temp_val);
+	if (ret < 0) {
+		SOUND_LOG_WARN("dacdrc_cfg configs missing or invalid.\n");
+	} else {
+		sunxi_codec->hw_config.dacdrc_cfg = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "dachpf_cfg", &temp_val);
+	if (ret < 0) {
+		SOUND_LOG_WARN("dachpf_cfg configs missing or invalid.\n");
+	} else {
+		sunxi_codec->hw_config.dachpf_cfg = temp_val;
+	}
+
+	SOUND_LOG_DEBUG("adcdrc_cfg:%d, adchpf_cfg:%d, "
+			"dacdrc_cfg:%d, dachpf:%d\n",
+			sunxi_codec->hw_config.adcdrc_cfg,
+			sunxi_codec->hw_config.adchpf_cfg,
+			sunxi_codec->hw_config.dacdrc_cfg,
+			sunxi_codec->hw_config.dachpf_cfg);
+#endif
+	/* get the gpio number to control external speaker */
+	ret = of_get_named_gpio(np, "gpio-spk", 0);
+	if (ret >= 0) {
+		sunxi_codec->spk_config.used = 1;
+		sunxi_codec->spk_config.spk_gpio = ret;
+		if (!gpio_is_valid(sunxi_codec->spk_config.spk_gpio)) {
+			SOUND_LOG_ERR("gpio-spk is invalid\n");
+			return -EINVAL;
+		} else {
+			ret = devm_gpio_request(&pdev->dev,
+				sunxi_codec->spk_config.spk_gpio, "SPK");
+			if (ret) {
+				SOUND_LOG_ERR("failed to request gpio-spk\n");
+				return -EBUSY;
+			}
+		}
+	} else {
+		sunxi_codec->spk_config.used = 0;
+		SOUND_LOG_ERR("gpio-spk no exist\n");
+	}
+
+	return ret;
+}
+
+static int sunxi_internal_codec_probe(struct platform_device *pdev)
+{
+	struct sunxi_codec_info *sunxi_codec;
+	struct resource res;
+	struct resource *memregion = NULL;
+	struct device_node *np = pdev->dev.of_node;
+	int ret;
+
+	if (IS_ERR_OR_NULL(np)) {
+		SOUND_LOG_ERR("pdev->dev.of_node is err.\n");
+		ret = -EFAULT;
+		goto err_node_put;
+	}
+
+	sunxi_codec = devm_kzalloc(&pdev->dev,
+				sizeof(struct sunxi_codec_info), GFP_KERNEL);
+	if (!sunxi_codec) {
+		SOUND_LOG_ERR("Can't allocate sunxi codec memory\n");
+		ret = -ENOMEM;
+		goto err_node_put;
+	}
+	dev_set_drvdata(&pdev->dev, sunxi_codec);
+	sunxi_codec->dev = &pdev->dev;
+
+	if (sunxi_codec_regulator_init(pdev, sunxi_codec) != 0) {
+		SOUND_LOG_ERR("Failed to init sunxi audio regulator\n");
+		ret = -EFAULT;
+		goto err_devm_kfree;
+	}
+
+	if (sunxi_codec_clk_init(np, pdev, sunxi_codec) != 0) {
+		SOUND_LOG_ERR("Failed to init sunxi audio clk\n");
+		ret = -EFAULT;
+		goto err_devm_kfree;
+	}
+
+	if (sunxi_codec_parse_params(np, pdev, sunxi_codec) != 0) {
+		SOUND_LOG_WARN("Failed to parse sunxi audio params\n");
+	}
+
+	/* codec reg_base */
+	/* get the true codec addr form np0 to avoid the build warning */
+	ret = of_address_to_resource(np, 0, &res);
+	if (ret) {
+		SOUND_LOG_ERR("Failed to get sunxi resource\n");
+		return -EINVAL;
+		goto err_moduleclk_disable;
+	}
+
+	memregion = devm_request_mem_region(&pdev->dev, res.start,
+				resource_size(&res), "sunxi-internal-codec");
+	if (!memregion) {
+		SOUND_LOG_ERR("sunxi memory region already claimed\n");
+		ret = -EBUSY;
+		goto err_moduleclk_disable;
+	}
+
+	sunxi_codec->digital_base = devm_ioremap(&pdev->dev, res.start,
+						 resource_size(&res));
+	if (!sunxi_codec->digital_base) {
+		SOUND_LOG_ERR("sunxi digital_base ioremap failed\n");
+		ret = -EBUSY;
+		goto err_moduleclk_disable;
+	}
+
+	sunxi_codec->regmap = devm_regmap_init_mmio(&pdev->dev,
+				sunxi_codec->digital_base,
+				&sunxi_codec_regmap_config);
+	if (IS_ERR_OR_NULL(sunxi_codec->regmap)) {
+		SOUND_LOG_ERR("regmap init failed\n");
+		ret = PTR_ERR(sunxi_codec->regmap);
+		goto err_moduleclk_disable;
+	}
+
+	/* CODEC DAI cfg and register */
+	ret = devm_snd_soc_register_component(&pdev->dev,
+					      &soc_codec_dev_sunxi,
+					      sunxi_codec_dai,
+					      ARRAY_SIZE(sunxi_codec_dai));
+	if (ret < 0) {
+		SOUND_LOG_ERR("register codec failed\n");
+		goto err_moduleclk_disable;
+	}
+
+	ret  = sysfs_create_group(&pdev->dev.kobj, &audio_debug_attr_group);
+	if (ret) {
+		SOUND_LOG_ERR("failed to create attr group\n");
+		goto err_moduleclk_disable;
+	}
+
+	SOUND_LOG_INFO("audiocodec probe finished.\n");
+
+	return 0;
+
+
+err_moduleclk_disable:
+	clk_disable_unprepare(sunxi_codec->dacclk);
+	clk_disable_unprepare(sunxi_codec->adcclk);
+	clk_disable_unprepare(sunxi_codec->pllclk);
+	clk_disable_unprepare(sunxi_codec->pllcomdiv5);
+	clk_disable_unprepare(sunxi_codec->pllcom);
+err_devm_kfree:
+	devm_kfree(&pdev->dev, sunxi_codec);
+err_node_put:
+	of_node_put(np);
+	return ret;
+}
+
+static int  __exit sunxi_internal_codec_remove(struct platform_device *pdev)
+{
+	struct sunxi_codec_info *sunxi_codec = dev_get_drvdata(&pdev->dev);
+	struct codec_spk_config *spk_cfg = &(sunxi_codec->spk_config);
+
+	if (spk_cfg->used) {
+		devm_gpio_free(&pdev->dev,
+					sunxi_codec->spk_config.spk_gpio);
+	}
+
+	if (sunxi_codec->vol_supply.avcc) {
+		regulator_disable(sunxi_codec->vol_supply.avcc);
+		regulator_put(sunxi_codec->vol_supply.avcc);
+	}
+
+	if (sunxi_codec->vol_supply.cpvin) {
+		regulator_disable(sunxi_codec->vol_supply.cpvin);
+		regulator_put(sunxi_codec->vol_supply.cpvin);
+	}
+
+	sysfs_remove_group(&pdev->dev.kobj, &audio_debug_attr_group);
+	snd_soc_unregister_component(&pdev->dev);
+
+	clk_disable_unprepare(sunxi_codec->dacclk);
+	clk_put(sunxi_codec->dacclk);
+	clk_disable_unprepare(sunxi_codec->adcclk);
+	clk_put(sunxi_codec->adcclk);
+	clk_disable_unprepare(sunxi_codec->pllcomdiv5);
+	clk_put(sunxi_codec->pllcomdiv5);
+	clk_disable_unprepare(sunxi_codec->pllcom);
+	clk_put(sunxi_codec->pllcom);
+	clk_disable_unprepare(sunxi_codec->pllclk);
+	clk_put(sunxi_codec->pllclk);
+	clk_disable_unprepare(sunxi_codec->codec_clk_bus);
+	clk_put(sunxi_codec->codec_clk_bus);
+	reset_control_assert(sunxi_codec->codec_clk_rst);
+
+	devm_iounmap(&pdev->dev, sunxi_codec->digital_base);
+	devm_kfree(&pdev->dev, sunxi_codec);
+	platform_set_drvdata(pdev, NULL);
+
+	SOUND_LOG_INFO("audiocodec remove finished.\n");
+
+	return 0;
+}
+
+static const struct of_device_id sunxi_internal_codec_of_match[] = {
+	{ .compatible = "allwinner,sunxi-internal-codec", },
+	{},
+};
+
+static struct platform_driver sunxi_internal_codec_driver = {
+	.driver = {
+		.name = "sunxi-internal-codec",
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_internal_codec_of_match,
+	},
+	.probe = sunxi_internal_codec_probe,
+	.remove = __exit_p(sunxi_internal_codec_remove),
+};
+module_platform_driver(sunxi_internal_codec_driver);
+
+MODULE_DESCRIPTION("SUNXI Codec ASoC driver");
+MODULE_AUTHOR("luguofang <luguofang@allwinnertech.com>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:sunxi-internal-codec");
diff --git a/sound/soc/sunxi/sun50iw10-codec.h b/sound/soc/sunxi/sun50iw10-codec.h
new file mode 100644
index 000000000..5a5f19a09
--- /dev/null
+++ b/sound/soc/sunxi/sun50iw10-codec.h
@@ -0,0 +1,448 @@
+/*
+ * sound\soc\sunxi\sun50iw10-codec.h
+ * (C) Copyright 2014-2019
+ * allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * yumingfeng <yumingfeng@allwinnertech.com>
+ * luguofang <luguofang@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#ifndef _SUN50IW10_CODEC_H
+#define _SUN50IW10_CODEC_H
+
+#include "sunxi-pcm.h"
+
+#define SUNXI_DAC_DPC		0x00
+#define SUNXI_DAC_VOL_CTRL	0x04
+#define SUNXI_DAC_FIFOC		0x10
+#define SUNXI_DAC_FIFOS		0x14
+
+#define SUNXI_DAC_TXDATA	0X20
+#define SUNXI_DAC_CNT		0x24
+#define SUNXI_DAC_DG		0x28
+
+#define	SUNXI_ADC_FIFOC		0x30
+#define	SUNXI_ADC_VOL_CTRL	0x34
+#define SUNXI_ADC_FIFOS		0x38
+#define SUNXI_ADC_RXDATA	0x40
+#define SUNXI_ADC_CNT		0x44
+#define SUNXI_ADC_DG		0x4C
+
+#define SUNXI_DAC_DAP_CTL	0xF0
+#define SUNXI_ADC_DAP_CTL	0xF8
+
+#define SUNXI_DAC_DRC_HHPFC	0x100
+#define SUNXI_DAC_DRC_LHPFC	0x104
+#define SUNXI_DAC_DRC_CTRL	0x108
+#define SUNXI_DAC_DRC_LPFHAT	0x10C
+#define SUNXI_DAC_DRC_LPFLAT	0x110
+#define SUNXI_DAC_DRC_RPFHAT	0x114
+#define SUNXI_DAC_DRC_RPFLAT	0x118
+#define SUNXI_DAC_DRC_LPFHRT	0x11C
+#define SUNXI_DAC_DRC_LPFLRT	0x120
+#define SUNXI_DAC_DRC_RPFHRT	0x124
+#define SUNXI_DAC_DRC_RPFLRT	0x128
+#define SUNXI_DAC_DRC_LRMSHAT	0x12C
+#define SUNXI_DAC_DRC_LRMSLAT	0x130
+#define SUNXI_DAC_DRC_RRMSHAT	0x134
+#define SUNXI_DAC_DRC_RRMSLAT	0x138
+#define SUNXI_DAC_DRC_HCT	0x13C
+#define SUNXI_DAC_DRC_LCT	0x140
+#define SUNXI_DAC_DRC_HKC	0x144
+#define SUNXI_DAC_DRC_LKC	0x148
+#define SUNXI_DAC_DRC_HOPC	0x14C
+#define SUNXI_DAC_DRC_LOPC	0x150
+#define SUNXI_DAC_DRC_HLT	0x154
+#define SUNXI_DAC_DRC_LLT	0x158
+#define SUNXI_DAC_DRC_HKI	0x15C
+#define SUNXI_DAC_DRC_LKI	0x160
+#define SUNXI_DAC_DRC_HOPL	0x164
+#define SUNXI_DAC_DRC_LOPL	0x168
+#define SUNXI_DAC_DRC_HET	0x16C
+#define SUNXI_DAC_DRC_LET	0x170
+#define SUNXI_DAC_DRC_HKE	0x174
+#define SUNXI_DAC_DRC_LKE	0x178
+#define SUNXI_DAC_DRC_HOPE	0x17C
+#define SUNXI_DAC_DRC_LOPE	0x180
+#define SUNXI_DAC_DRC_HKN	0x184
+#define SUNXI_DAC_DRC_LKN	0x188
+#define SUNXI_DAC_DRC_SFHAT	0x18C
+#define SUNXI_DAC_DRC_SFLAT	0x190
+#define SUNXI_DAC_DRC_SFHRT	0x194
+#define SUNXI_DAC_DRC_SFLRT	0x198
+#define SUNXI_DAC_DRC_MXGHS	0x19C
+#define SUNXI_DAC_DRC_MXGLS	0x1A0
+#define SUNXI_DAC_DRC_MNGHS	0x1A4
+#define SUNXI_DAC_DRC_MNGLS	0x1A8
+#define SUNXI_DAC_DRC_EPSHC	0x1AC
+#define SUNXI_DAC_DRC_EPSLC	0x1B0
+#define SUNXI_DAC_DRC_OPT	0x1B4
+#define SUNXI_DAC_DRC_HPFHGAIN	0x1B8
+#define SUNXI_DAC_DRC_HPFLGAIN	0x1BC
+
+#define SUNXI_ADC_DRC_HHPFC	0x200
+#define SUNXI_ADC_DRC_LHPFC	0x204
+#define SUNXI_ADC_DRC_CTRL	0x208
+#define SUNXI_ADC_DRC_LPFHAT	0x20C
+#define SUNXI_ADC_DRC_LPFLAT	0x210
+#define SUNXI_ADC_DRC_RPFHAT	0x214
+#define SUNXI_ADC_DRC_RPFLAT	0x218
+#define SUNXI_ADC_DRC_LPFHRT	0x21C
+#define SUNXI_ADC_DRC_LPFLRT	0x220
+#define SUNXI_ADC_DRC_RPFHRT	0x224
+#define SUNXI_ADC_DRC_RPFLRT	0x228
+#define SUNXI_ADC_DRC_LRMSHAT	0x22C
+#define SUNXI_ADC_DRC_LRMSLAT	0x230
+#define SUNXI_ADC_DRC_HCT	0x23C
+#define SUNXI_ADC_DRC_LCT	0x240
+#define SUNXI_ADC_DRC_HKC	0x244
+#define SUNXI_ADC_DRC_LKC	0x248
+#define SUNXI_ADC_DRC_HOPC	0x24C
+#define SUNXI_ADC_DRC_LOPC	0x250
+#define SUNXI_ADC_DRC_HLT	0x254
+#define SUNXI_ADC_DRC_LLT	0x258
+#define SUNXI_ADC_DRC_HKI	0x25C
+#define SUNXI_ADC_DRC_LKI	0x260
+#define SUNXI_ADC_DRC_HOPL	0x264
+#define SUNXI_ADC_DRC_LOPL	0x268
+#define SUNXI_ADC_DRC_HET	0x26C
+#define SUNXI_ADC_DRC_LET	0x270
+#define SUNXI_ADC_DRC_HKE	0x274
+#define SUNXI_ADC_DRC_LKE	0x278
+#define SUNXI_ADC_DRC_HOPE	0x27C
+#define SUNXI_ADC_DRC_LOPE	0x280
+#define SUNXI_ADC_DRC_HKN	0x284
+#define SUNXI_ADC_DRC_LKN	0x288
+#define SUNXI_ADC_DRC_SFHAT	0x28C
+#define SUNXI_ADC_DRC_SFLAT	0x290
+#define SUNXI_ADC_DRC_SFHRT	0x294
+#define SUNXI_ADC_DRC_SFLRT	0x298
+#define SUNXI_ADC_DRC_MXGHS	0x29C
+#define SUNXI_ADC_DRC_MXGLS	0x2A0
+#define SUNXI_ADC_DRC_MNGHS	0x2A4
+#define SUNXI_ADC_DRC_MNGLS	0x2A8
+#define SUNXI_ADC_DRC_EPSHC	0x2AC
+#define SUNXI_ADC_DRC_EPSLC	0x2B0
+#define SUNXI_ADC_DRC_OPT	0x2B4
+#define SUNXI_ADC_DRC_HPFHGAIN	0x2B8
+#define SUNXI_ADC_DRC_HPFLGAIN	0x2BC
+
+#define SUNXI_AC_VERSION	0x2C0
+
+/* Analog register */
+#define SUNXI_ADCL_REG		0x300
+#define SUNXI_ADCR_REG		0x304
+#define SUNXI_DAC_REG		0x310
+#define SUNXI_MICBIAS_REG	0x318
+#define SUNXI_BIAS_REG		0x320
+#define SUNXI_HEADPHONE_REG	0x324
+#define SUNXI_HMIC_CTRL		0x328
+#define SUNXI_HMIC_STS		0x32c
+
+/* SUNXI_DAC_DPC:0x00 */
+#define EN_DAC			31
+#define MODQU			25
+#define DWA_EN			24
+#define HPF_EN			18
+#define DVOL			12
+#define DAC_HUB_EN		0
+
+/* SUNXI_DAC_VOL_CTRL:0x04 */
+#define DAC_VOL_SEL		16
+#define DAC_VOL_L		8
+#define DAC_VOL_R		0
+
+/* SUNXI_DAC_FIFOC:0x10 */
+#define DAC_FS			29
+#define FIR_VER			28
+#define SEND_LASAT		26
+#define FIFO_MODE		24
+#define DAC_DRQ_CLR_CNT		21
+#define TX_TRIG_LEVEL		8
+#define DAC_MONO_EN		6
+#define TX_SAMPLE_BITS		5
+#define DAC_DRQ_EN		4
+#define DAC_IRQ_EN		3
+#define FIFO_UNDERRUN_IRQ_EN	2
+#define FIFO_OVERRUN_IRQ_EN	1
+#define FIFO_FLUSH		0
+
+/* SUNXI_DAC_FIFOS:0x14 */
+#define	TX_EMPTY		23
+#define	DAC_TXE_CNT		8
+#define	DAC_TXE_INT		3
+#define	DAC_TXU_INT		2
+#define	DAC_TXO_INT		1
+
+/* SUNXI_DAC_DG:0x28 */
+#define	DAC_MODU_SEL		11
+#define	DAC_PATTERN_SEL		9
+#define	DAC_CODEC_CLK_SEL	8
+#define	DAC_SWP			6
+#define	ADDA_LOOP_MODE		0
+
+/* SUNXI_ADC_FIFOC:0x30 */
+#define ADC_FS			29
+#define EN_AD			28
+#define ADCFDT			26
+#define ADCDFEN			25
+#define RX_FIFO_MODE		24
+#define RX_SYNC_EN		21
+#define RX_EN_MUX		20
+#define ADC_VOL_SEL		17
+#define RX_SAMPLE_BITS		16
+#define ADC_CHAN_EN		12
+#define RX_FIFO_TRG_LEVEL	4
+#define ADC_DRQ_EN		3
+#define ADC_IRQ_EN		2
+#define ADC_OVERRUN_IRQ_EN	1
+#define ADC_FIFO_FLUSH		0
+
+/* SUNXI_ADC_FIFOS:0x34 */
+#define ADC_VOL_L		8
+#define ADC_VOL_R		0
+
+/* SUNXI_ADC_FIFOS:0x38 */
+#define	RXA			23
+#define	ADC_RXA_CNT		8
+#define	ADC_RXA_INT		3
+#define	ADC_RXO_INT		1
+
+/* SUNXI_ADC_DG:0x4C */
+#define	AD_SWP			24
+
+/* SUNXI_DAC_DAP_CTL:0xf0 */
+#define	DDAP_EN			31
+#define	DDAP_DRC_EN		29
+#define	DDAP_HPF_EN		28
+
+/* SUNXI_ADC_DAP_CTL:0xf8 */
+#define	ADC_DAP0_EN		31
+#define	ADC_DRC0_EN		29
+#define	ADC_HPF0_EN		28
+
+/* SUNXI_DAC_DRC_HHPFC : 0x100*/
+#define DAC_HHPF_CONF		0
+
+/* SUNXI_DAC_DRC_LHPFC : 0x104*/
+#define DAC_LHPF_CONF		0
+
+/* SUNXI_DAC_DRC_CTRL : 0x108*/
+#define DAC_DRC_DELAY_OUT_STATE		15
+#define DAC_DRC_SIGNAL_DELAY		8
+#define DAC_DRC_DELAY_BUF_EN		7
+#define DAC_DRC_GAIN_MAX_EN		6
+#define DAC_DRC_GAIN_MIN_EN		5
+#define DAC_DRC_NOISE_DET_EN		4
+#define DAC_DRC_SIGNAL_SEL		3
+#define DAC_DRC_DELAY_EN		2
+#define DAC_DRC_LT_EN			1
+#define DAC_DRC_ET_EN			0
+
+/* SUNXI_ADC_DRC_HHPFC : 0x200*/
+#define ADC_HHPF_CONF		0
+
+/* SUNXI_ADC_DRC_LHPFC : 0x204*/
+#define ADC_LHPF_CONF		0
+
+/* SUNXI_ADC_DRC_CTRL : 0x208*/
+#define ADC_DRC_DELAY_OUT_STATE		15
+#define ADC_DRC_SIGNAL_DELAY		8
+#define ADC_DRC_DELAY_BUF_EN		7
+#define ADC_DRC_GAIN_MAX_EN		6
+#define ADC_DRC_GAIN_MIN_EN		5
+#define ADC_DRC_NOISE_DET_EN		4
+#define ADC_DRC_SIGNAL_SEL		3
+#define ADC_DRC_DELAY_EN		2
+#define ADC_DRC_LT_EN			1
+#define ADC_DRC_ET_EN			0
+
+/* SUNXI_ADCL_REG : 0x300 */
+#define ADCL_EN			31
+#define MIC1AMPEN		30
+#define ADCL_DITHER_RESET	29
+#define ADCL_PGA_CTRL_RCM	18
+#define ADCL_PGA_IN_VCM_CTRL	16
+#define ADCL_PGA_GAIN_CTRL	8
+#define ADCL_IOPAAFL		6
+#define ADCL_IOPSDML1		4
+#define ADCL_IOPSDML2		2
+#define ADCL_IOPMICL	0
+
+/* SUNXI_ADCR_REG : 0x304 */
+#define ADCR_EN			31
+#define MIC2AMPEN		30
+#define ADCR_DITHER_RESET	29
+#define ADCR_PGA_CTRL_RCM	18
+#define ADCR_PGA_IN_VCM_CTRL	16
+#define ADCR_PGA_GAIN_CTRL	8
+#define ADCR_IOPAAFL		6
+#define ADCR_IOPSDML1		4
+#define ADCR_IOPSDML2		2
+#define ADCR_IOPMICL	0
+
+/* SUNXI_DAC_REG : 0x310 */
+#define CURRENT_TEST_SELECT	31
+#define HEADPHONE_GAIN		28
+#define CPLDO_EN		27
+#define CPLDO_VOLTAGE		24
+#define OPDRV_CUR		22
+#define	VRA2_IOPVRS		20
+#define	ILINEOUTAMPS		18
+#define IOPDACS			16
+#define DACLEN			15
+#define DACREN			14
+#define LINEOUTLEN		13
+#define DACLMUTE		12
+#define LINEOUTLDIFFEN		6
+#define LINEOUT_VOL		0
+
+/* SUNXI_MICBIAS_REG : 0x318 */
+#define SELDETADCFS		28
+#define SELDETADCDB		26
+#define SELDETADCBF		24
+#define JACKDETEN		23
+#define SELDETADCDY		21
+#define MICADCEN		20
+#define POPFREE			19
+#define DETMODE			18
+#define AUTOPLEN		17
+#define MICDETPL		16
+#define HMICBIASEN		15
+#define HBIASSEL		13
+#define	HMICBIAS_CHOP_EN	12
+#define HMICBIAS_CHOP_CLK_SEL	10
+#define MMICBIASEN		7
+#define	MBIASSEL		5
+#define	MMICBIAS_CHOP_EN	4
+#define MMICBIAS_CHOP_CLK_SEL	2
+
+/* SUNXI_BIAS_REG : 0x320 */
+#define AC_BIASDATA		0
+
+/* SUNXI_HEADPHONE_REG : 0x324 */
+#define HPRCALIVERIFY		24
+#define HPLCALIVERIFY		16
+#define HPPA_EN			15
+#define HPINPUTEN		11
+#define HPOUTPUTEN		10
+#define HPPA_DEL		8
+#define CP_CLKS			6
+#define HPCALIMODE		5
+#define HPCALIVERIFY		4
+#define HPCALIFIRST		3
+#define HPCALICKS		0
+
+/* SUNXI_HMIC_CTRL : 0x328 */
+#define HMIC_SAMPLE_SEL		21
+#define MDATA_THRESHOLD		16
+#define HMIC_SF			14
+#define HMIC_M			10
+#define HMIC_N			6
+#define MDATA_THRESHOLD_DB	3
+#define JACK_OUT_IRQ_EN		2
+#define JACK_IN_IRQ_EN		1
+#define MIC_DET_IRQ_EN		0
+
+/* SUNXI_HMIC_STS : 0x32c */
+#define MDATA_DISCARD		13
+#define	HMIC_DATA		8
+#define JACK_DET_OUT_ST		4
+#define JACK_DET_OIRQ		4
+#define JACK_DET_IIN_ST 	3
+#define JACK_DET_IIRQ		3
+#define MIC_DET_ST		0
+
+#define CODEC_TX_FIFO_SIZE	128
+#define CODEC_RX_FIFO_SIZE	256
+
+/*125ms * (HP_DEBOUCE_TIME+1)*/
+#define HP_DEBOUCE_TIME	0x1
+
+#define REG_LABEL(constant)	{#constant, constant, 0}
+#define REG_LABEL_END           {NULL, 0, 0}
+
+/* SUNXI_CODEC_DAP_ENABLE: Whether to use the adc/dac drc/hpf function */
+#define SUNXI_CODEC_DAP_ENABLE
+
+/* SUNXI_CODEC_HUB_ENABLE: Whether to use the hub mode */
+#define SUNXI_CODEC_HUB_ENABLE
+
+/* SUNXI_CODEC_ADCSWAP_ENABLE: Whether to open the adc swap func controls */
+#define SUNXI_CODEC_ADCSWAP_ENABLE
+
+struct reg_label {
+	const char *name;
+	const unsigned int address;
+	unsigned int value;
+};
+
+struct codec_hw_config {
+	u32 adcdrc_cfg:8;
+	u32 dacdrc_cfg:8;
+	u32 adchpf_cfg:8;
+	u32 dachpf_cfg:8;
+};
+
+struct codec_spk_config {
+	u32 spk_gpio;
+	u32 pa_msleep;
+	bool used;
+	bool pa_level;
+};
+
+struct sample_rate {
+	unsigned int samplerate;
+	unsigned int rate_bit;
+};
+
+struct voltage_supply {
+	struct regulator *avcc;
+	struct regulator *cpvin;
+};
+
+struct codec_dap {
+	int drc_enable;
+	int hpf_enable;
+};
+
+struct sunxi_codec_info {
+	struct device *dev;
+	struct regmap *regmap;
+	void __iomem *digital_base;
+	struct clk *pllclk;
+	struct clk *pllcom;
+	struct clk *pllcomdiv5;
+	struct clk *dacclk;
+	struct clk *adcclk;
+	struct clk *codec_clk_bus;
+	struct reset_control *codec_clk_rst;
+
+	/* regulator about */
+	struct voltage_supply vol_supply;
+
+	/* for dap function */
+	struct codec_dap dac_dap;
+	struct codec_dap adc_dap;
+	int dac_dap_enable;
+	int adc_dap_enable;
+
+	/* self user config params */
+	u32 digital_vol;
+	u32 lineout_vol;
+	u32 dac_digital_vol;
+	u32 mic1gain;
+	u32 mic2gain;
+	u32 headphonegain;
+
+	struct codec_spk_config spk_config;
+	struct codec_hw_config hw_config;
+};
+
+#endif /* __SUN50IW10_CODEC_H */
diff --git a/sound/soc/sunxi/sun50iw10-sndcodec.c b/sound/soc/sunxi/sun50iw10-sndcodec.c
new file mode 100644
index 000000000..6915fbb8b
--- /dev/null
+++ b/sound/soc/sunxi/sun50iw10-sndcodec.c
@@ -0,0 +1,1103 @@
+/*
+ * sound\soc\sunxi\sun50iw10-sndcodec.c
+ * (C) Copyright 2014-2018
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * huangxin <huangxin@Reuuimllatech.com>
+ * liushaohua <liushaohua@allwinnertech.com>
+ * yumingfengng <yumingfeng@allwinnertech.com>
+ * luguofang <luguofang@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+#include <linux/gpio.h>
+#include <linux/io.h>
+#include <linux/input.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/delay.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/jack.h>
+#include <sound/pcm_params.h>
+#include <sound/soc-dapm.h>
+#include <linux/extcon.h>
+
+#include "sunxi_sound_log.h"
+#include "sun50iw10-codec.h"
+
+/* #define CONFIG_EXTCON_TYPEC_JACK */
+
+static int mdata_threshold = 0x10;
+module_param(mdata_threshold, int, 0644);
+MODULE_PARM_DESC(mdata_threshold,
+		"SUNXI hmic data threshold");
+
+typedef enum {
+	RESUME_IRQ  = 0x0,
+	SYSINIT_IRQ = 0x1,
+	OTHER_IRQ   = 0x2,
+} _jack_irq_times;
+
+enum HPDETECTWAY {
+	HP_DETECT_LOW = 0x0,
+	HP_DETECT_HIGH = 0x1,
+};
+
+enum dectect_jack {
+	PLUG_OUT = 0x0,
+	PLUG_IN  = 0x1,
+};
+
+static bool is_irq;
+static int switch_state;
+
+#ifdef CONFIG_EXTCON_TYPEC_JACK
+struct typec_jack_cfg {
+	u32 pin;
+	bool used;
+	bool level;
+};
+#endif
+
+struct sunxi_card_priv {
+	struct snd_soc_card *card;
+	struct snd_soc_component *component;
+	struct delayed_work hs_init_work;
+	struct delayed_work hs_detect_work;
+	struct delayed_work hs_button_work;
+	struct delayed_work hs_checkplug_work;
+	struct mutex jack_mlock;
+	struct snd_soc_jack jack;
+#ifdef CONFIG_EXTCON_TYPEC_JACK
+	u32 typec_analog_jack_enable;
+	struct extcon_dev *extdev;
+	struct notifier_block hp_nb;
+	struct delayed_work typec_jack_detect_work;
+	struct typec_jack_cfg usb_sel;
+	struct typec_jack_cfg usb_noe;
+	struct typec_jack_cfg mic_sel;
+#endif
+	struct timespec64 tv_headset_plugin;	/*4*/
+	_jack_irq_times jack_irq_times;
+	u32 detect_state;
+	u32 jackirq;				/*switch irq*/
+	u32 HEADSET_DATA;			/*threshod for switch insert*/
+	u32 headset_basedata;
+	u32 switch_status;
+	u32 key_volup;
+	u32 key_voldown;
+	u32 key_hook;
+	u32 key_voiceassist;
+	u32 hp_detect_case;
+};
+
+/*
+ * Identify the jack type as Headset/Headphone/None
+ */
+static int sunxi_check_jack_type(struct snd_soc_jack *jack)
+{
+	u32 reg_val = 0;
+	u32 jack_type = 0, tempdata = 0;
+	struct sunxi_card_priv *priv = container_of(jack, struct sunxi_card_priv, jack);
+
+	reg_val = snd_soc_component_read32(priv->component, SUNXI_HMIC_STS);
+	tempdata = (reg_val >> HMIC_DATA) & 0x1f;
+
+	priv->headset_basedata = tempdata;
+	SOUND_LOG_DEBUG("headset_basedata-> 0x%x\n", priv->headset_basedata);
+	if (tempdata >= priv->HEADSET_DATA) {
+		/*
+		 * headset:4
+		 */
+		jack_type = SND_JACK_HEADSET;
+	} else {
+		/*
+		 * headphone:3
+		 * disable hbias and adc
+		 */
+		snd_soc_component_update_bits(priv->component, SUNXI_MICBIAS_REG,
+				(0x1 << HMICBIASEN), (0x0 << HMICBIASEN));
+		snd_soc_component_update_bits(priv->component, SUNXI_MICBIAS_REG,
+				(0x1 << MICADCEN), (0x0 << MICADCEN));
+		jack_type = SND_JACK_HEADPHONE;
+	}
+
+	return jack_type;
+}
+
+/* Checks hs insertion by mdet */
+static void sunxi_check_hs_plug(struct work_struct *work)
+{
+	struct sunxi_card_priv *priv =
+		container_of(work, struct sunxi_card_priv, hs_checkplug_work.work);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(priv->component);
+	struct codec_spk_config *spk_cfg = &(sunxi_codec->spk_config);
+
+	mutex_lock(&priv->jack_mlock);
+	if (priv->detect_state != PLUG_IN) {
+		/* Enable MDET */
+		snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+				(0x1 << MIC_DET_IRQ_EN),
+				(0x1 << MIC_DET_IRQ_EN));
+		snd_soc_component_update_bits(priv->component, SUNXI_MICBIAS_REG,
+				(0x1 << MICADCEN),
+				(0x1 << MICADCEN));
+		/* Enable PA */
+		snd_soc_component_update_bits(priv->component, SUNXI_HEADPHONE_REG,
+				(0x1 << HPPA_EN),
+				(0x1 << HPPA_EN));
+
+		if (spk_cfg->used)
+			gpio_set_value(spk_cfg->spk_gpio, spk_cfg->pa_level);
+	} else {
+		/*
+		 * Enable HPPA_EN
+		 * FIXME:When the Audio HAL is not at the do_output_standby,
+		 * apk not play the music at the same time, we can insert
+		 * headset now and click to play music immediately in the apk,
+		 * the Audio HAL will write data to the card and not update
+		 * the stream routing. Because we also set mute when
+		 * the mdet come into force, so that the dapm will not update
+		 * and it makes the mute.
+		 */
+		snd_soc_component_update_bits(priv->component, SUNXI_HEADPHONE_REG,
+				(0x1 << HPPA_EN),
+				(0x1 << HPPA_EN));
+	}
+	mutex_unlock(&priv->jack_mlock);
+}
+
+/* Checks jack insertion and identifies the jack type.*/
+static void sunxi_check_hs_detect_status(struct work_struct *work)
+{
+	struct sunxi_card_priv *priv =
+		container_of(work, struct sunxi_card_priv, hs_detect_work.work);
+	int jack_type = 0, reg_val = 0;
+
+	mutex_lock(&priv->jack_mlock);
+	if (priv->detect_state == PLUG_IN) {
+		/* Enable hbias and adc*/
+		snd_soc_component_update_bits(priv->component, SUNXI_MICBIAS_REG,
+				(0x1 << MICADCEN), (0x1 << MICADCEN));
+		msleep(100);
+		jack_type = sunxi_check_jack_type(&priv->jack);
+		if (jack_type != priv->switch_status) {
+			priv->switch_status = jack_type;
+			snd_jack_report(priv->jack.jack, jack_type);
+			SOUND_LOG_INFO("plugin --> switch:%d\n", jack_type);
+			switch_state = jack_type;
+		}
+
+		/*
+		 * if SND_JACK_HEADSET,enable mic detect irq
+		 */
+		if (jack_type == SND_JACK_HEADSET) {
+			/*
+			 * headset:clear headset insert pending.
+			 */
+			reg_val = snd_soc_component_read32(priv->component, SUNXI_HMIC_STS);
+			priv->headset_basedata = (reg_val >> HMIC_DATA) & 0x1f;
+			if (priv->headset_basedata > 3)
+				priv->headset_basedata -= 3;
+
+			usleep_range(1000, 2000);
+			snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+				(0x1f << MDATA_THRESHOLD),
+				(priv->headset_basedata << MDATA_THRESHOLD));
+			snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+				(0x1 << MIC_DET_IRQ_EN),
+				(0x1 << MIC_DET_IRQ_EN));
+		} else if (jack_type == SND_JACK_HEADPHONE) {
+			/*
+			 * if is HEADPHONE 3,close mic detect irq
+			 */
+			snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+				(0x1 << MIC_DET_IRQ_EN),
+				(0x0 << MIC_DET_IRQ_EN));
+		}
+	} else {
+		priv->switch_status = 0;
+		/*clear headset pulgout pending.*/
+		snd_jack_report(priv->jack.jack, priv->switch_status);
+		switch_state = priv->switch_status;
+		SOUND_LOG_INFO("plugout --> switch:%d\n", priv->switch_status);
+		/*enable hbias and adc*/
+		snd_soc_component_update_bits(priv->component, SUNXI_MICBIAS_REG,
+				    (0x1 << HMICBIASEN), (0x1 << HMICBIASEN));
+		snd_soc_component_update_bits(priv->component, SUNXI_MICBIAS_REG,
+				    (0x1 << MICADCEN), (0x1 << MICADCEN));
+		snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+				(0x1f << MDATA_THRESHOLD),
+				(mdata_threshold << MDATA_THRESHOLD));
+		snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+				    (0x1 << MIC_DET_IRQ_EN),
+				    (0x1 << MIC_DET_IRQ_EN));
+	}
+	mutex_unlock(&priv->jack_mlock);
+}
+
+static void sunxi_hs_init_work(struct work_struct *work)
+{
+	struct sunxi_card_priv *priv =
+	    container_of(work, struct sunxi_card_priv, hs_init_work.work);
+
+	mutex_lock(&priv->jack_mlock);
+	if (is_irq == true) {
+		is_irq = false;
+	} else {
+		if (priv->hp_detect_case == HP_DETECT_LOW ||
+			(priv->jack_irq_times == RESUME_IRQ)) {
+			/*
+			 * It should be report after resume.
+			 * If the headset plugout after suspend, the system
+			 * can not know the state, so we should reset here
+			 * when resume.
+			 */
+			SOUND_LOG_DEBUG("resume-->report switch\n");
+			priv->switch_status = 0;
+			snd_jack_report(priv->jack.jack, priv->switch_status);
+			switch_state = 0;
+		}
+	}
+	priv->jack_irq_times = OTHER_IRQ;
+	mutex_unlock(&priv->jack_mlock);
+}
+
+/* Check for hook release */
+static void sunxi_check_hs_button_status(struct work_struct *work)
+{
+	struct sunxi_card_priv *priv =
+		container_of(work, struct sunxi_card_priv, hs_button_work.work);
+	u32 i = 0;
+
+	mutex_lock(&priv->jack_mlock);
+	for (i = 0; i < 1; i++) {
+		if (priv->key_hook == 0) {
+			SOUND_LOG_INFO("Hook (2)!!\n");
+			priv->switch_status &= ~SND_JACK_BTN_0;
+			snd_jack_report(priv->jack.jack, priv->switch_status);
+			break;
+		}
+		/* may msleep 8 */
+		msleep(20);
+	}
+
+	mutex_unlock(&priv->jack_mlock);
+}
+
+static irqreturn_t jack_interrupt(int irq, void *dev_id)
+{
+	struct sunxi_card_priv *priv = dev_id;
+	struct timespec64 tv;
+	u32 tempdata = 0, regval = 0;
+	int jack_state = 0;
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(priv->component);
+	struct codec_spk_config *spk_cfg = &(sunxi_codec->spk_config);
+
+	if (priv->jack_irq_times == RESUME_IRQ ||
+	    priv->jack_irq_times == SYSINIT_IRQ) {
+		is_irq = true;
+		priv->jack_irq_times = OTHER_IRQ;
+	}
+
+	SOUND_LOG_DEBUG("SUNXI_HMIC_STS:0x%x\n", snd_soc_component_read32(priv->component, SUNXI_HMIC_STS));
+
+	jack_state = snd_soc_component_read32(priv->component, SUNXI_HMIC_STS);
+
+	if (priv->detect_state != PLUG_IN) {
+		/* when headphone half-insertion, MIC_DET IRQ will be trigger. */
+		if (jack_state & (1 << MIC_DET_ST)) {
+			regval = snd_soc_component_read32(priv->component, SUNXI_HMIC_CTRL);
+			regval &= ~(0x1 << MIC_DET_IRQ_EN);
+			snd_soc_component_write(priv->component, SUNXI_HMIC_CTRL, regval);
+
+			regval = snd_soc_component_read32(priv->component, SUNXI_MICBIAS_REG);
+			regval &= ~(0x1 << MICADCEN);
+			snd_soc_component_write(priv->component, SUNXI_MICBIAS_REG, regval);
+
+			/* clear mic detect status */
+			regval = snd_soc_component_read32(priv->component, SUNXI_HMIC_STS);
+			regval &= ~(0x1 << JACK_DET_IIN_ST);
+			regval &= ~(0x1 << JACK_DET_OUT_ST);
+			regval |= 0x1 << MIC_DET_ST;
+			snd_soc_component_write(priv->component, SUNXI_HMIC_STS, regval);
+
+			/* close PA */
+			regval = snd_soc_component_read32(priv->component, SUNXI_HEADPHONE_REG);
+			regval &= ~(0x1 << HPPA_EN);
+			snd_soc_component_write(priv->component, SUNXI_HEADPHONE_REG, regval);
+
+			if (spk_cfg->used)
+				gpio_set_value(spk_cfg->spk_gpio, !(spk_cfg->pa_level));
+			/* prevent mic detect false trigger */
+			schedule_delayed_work(&priv->hs_checkplug_work,
+				msecs_to_jiffies(700));
+		}
+	}
+
+	/*headphone insert*/
+	if (jack_state & (1 << JACK_DET_IIN_ST)) {
+		regval = snd_soc_component_read32(priv->component, SUNXI_HMIC_STS);
+		regval |= 0x1 << JACK_DET_IIN_ST;
+		regval &= ~(0x1 << JACK_DET_OUT_ST);
+		snd_soc_component_write(priv->component, SUNXI_HMIC_STS, regval);
+		priv->detect_state = PLUG_IN;
+		/* hs_checkplug_work will set spk gpio. some time, it will set
+		 * spk gpio output befor headphone insert, but tinymix
+		 * spk_switch conctrl is OFF now. So, we need to close spk gpio.*/
+		if (spk_cfg->used)
+			gpio_set_value(spk_cfg->spk_gpio, !(spk_cfg->pa_level));
+		ktime_get_real_ts64(&priv->tv_headset_plugin);
+		schedule_delayed_work(&priv->hs_detect_work,
+				msecs_to_jiffies(10));
+	}
+
+	/*headphone plugout*/
+	if (jack_state & (1 << JACK_DET_OUT_ST)) {
+		regval = snd_soc_component_read32(priv->component, SUNXI_HMIC_STS);
+		regval &= ~(0x1 << JACK_DET_IIN_ST);
+		regval |= 0x1 << JACK_DET_OUT_ST;
+		snd_soc_component_write(priv->component, SUNXI_HMIC_STS, regval);
+		priv->detect_state = PLUG_OUT;
+		schedule_delayed_work(&priv->hs_detect_work,
+				msecs_to_jiffies(10));
+	}
+
+	/*key*/
+	if ((priv->detect_state == PLUG_IN) &&
+		(jack_state & (1 << MIC_DET_ST))) {
+		regval = snd_soc_component_read32(priv->component, SUNXI_HMIC_STS);
+		regval &= ~(0x1 << JACK_DET_IIN_ST);
+		regval &= ~(0x1 << JACK_DET_OUT_ST);
+		regval |= 0x1 << MIC_DET_ST;
+		snd_soc_component_write(priv->component, SUNXI_HMIC_STS, regval);
+
+		ktime_get_real_ts64(&tv);
+		if (abs(tv.tv_sec - priv->tv_headset_plugin.tv_sec) > 1) {
+			tempdata = snd_soc_component_read32(priv->component, SUNXI_HMIC_STS);
+			tempdata = (tempdata & 0x1f00) >> 8;
+			SOUND_LOG_DEBUG("KEY tempdata: %d\n", tempdata);
+
+			if (tempdata == 2) {
+				priv->key_hook = 0;
+				priv->key_voldown = 0;
+				priv->key_voiceassist = 0;
+				priv->key_volup++;
+				if (priv->key_volup == 1) {
+					SOUND_LOG_INFO("Volume ++\n");
+					priv->key_volup = 0;
+					priv->switch_status |= SND_JACK_BTN_1;
+					snd_jack_report(priv->jack.jack,
+							priv->switch_status);
+					priv->switch_status &= ~SND_JACK_BTN_1;
+					snd_jack_report(priv->jack.jack,
+							priv->switch_status);
+				}
+			} else if ((tempdata == 5) || tempdata == 4) {
+				priv->key_volup = 0;
+				priv->key_hook = 0;
+				priv->key_voiceassist = 0;
+				priv->key_voldown++;
+				if (priv->key_voldown == 1) {
+					SOUND_LOG_INFO("Volume --\n");
+					priv->key_voldown = 0;
+					priv->switch_status |= SND_JACK_BTN_2;
+					snd_jack_report(priv->jack.jack,
+							priv->switch_status);
+					priv->switch_status &= ~SND_JACK_BTN_2;
+					snd_jack_report(priv->jack.jack,
+							priv->switch_status);
+				}
+			/* add KET_VOICECOMMAND for voice assistant */
+			} else if (tempdata == 1) {
+				priv->key_volup = 0;
+				priv->key_hook = 0;
+				priv->key_voldown = 0;
+				priv->key_voiceassist++;
+				if (priv->key_voiceassist == 1) {
+					SOUND_LOG_INFO("Voice Assistant Open\n");
+					priv->key_voiceassist = 0;
+					priv->switch_status |= SND_JACK_BTN_3;
+					snd_jack_report(priv->jack.jack,
+							priv->switch_status);
+					priv->switch_status &= ~SND_JACK_BTN_3;
+					snd_jack_report(priv->jack.jack,
+							priv->switch_status);
+				}
+			} else if (tempdata == 0x0) {
+				priv->key_volup = 0;
+				priv->key_voldown = 0;
+				priv->key_voiceassist = 0;
+				priv->key_hook++;
+				if (priv->key_hook >= 1) {
+					priv->key_hook = 0;
+					if ((priv->switch_status &
+					     SND_JACK_BTN_0) == 0) {
+						priv->switch_status |=
+						    SND_JACK_BTN_0;
+						snd_jack_report(
+						    priv->jack.jack,
+						    priv->switch_status);
+						SOUND_LOG_INFO("Hook (1)!!\n");
+					}
+					schedule_delayed_work(
+					    &priv->hs_button_work,
+					    msecs_to_jiffies(180));
+				}
+			} else {
+				/*This could be key release,fix me ! */
+				SOUND_LOG_DEBUG("tempdata:0x%x,Key data err:\n", tempdata);
+				priv->key_volup = 0;
+				priv->key_voldown = 0;
+				priv->key_hook = 0;
+				priv->key_voiceassist = 0;
+			}
+		} else {
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+#ifdef CONFIG_EXTCON_TYPEC_JACK
+static void wait_and_detect_mic_gnd_state(struct sunxi_card_priv *priv)
+{
+	int i, reg_val;
+	int interval_ms = 10;
+	int total_ms = 180;
+	int count = 5;
+	int threshold = 0x8;
+
+	if (!priv->mic_sel.used)
+		return;
+
+	snd_soc_component_update_bits(priv->component, SUNXI_MICBIAS_REG,
+		    (0x1 << HMICBIASEN), (0x1 << HMICBIASEN));
+	snd_soc_component_update_bits(priv->component, SUNXI_MICBIAS_REG,
+		    (0x1 << MICADCEN), (0x1 << MICADCEN));
+
+	gpio_set_value(priv->mic_sel.pin, 0);
+	for (i = 0; i < count; i++) {
+		reg_val = snd_soc_component_read32(priv->component, SUNXI_HMIC_STS);
+		reg_val = (reg_val >> HMIC_DATA) & 0x1f;
+		if (reg_val >= threshold) {
+			int ms = total_ms - interval_ms * i;
+			msleep(ms);
+			return;
+		}
+		msleep(interval_ms);
+	}
+
+	gpio_set_value(priv->mic_sel.pin, 1);
+	for (i = 0; i < count; i++) {
+		reg_val = snd_soc_component_read32(priv->component, SUNXI_HMIC_STS);
+		reg_val = (reg_val >> HMIC_DATA) & 0x1f;
+		if (reg_val >= threshold) {
+			int ms = total_ms - interval_ms * i;
+			msleep(ms);
+			return;
+		}
+		msleep(interval_ms);
+	}
+
+	return;
+}
+
+static void sunxi_typec_jack_detect_status(struct work_struct *work)
+{
+	struct sunxi_card_priv *priv =
+		container_of(work, struct sunxi_card_priv, typec_jack_detect_work.work);
+
+	mutex_lock(&priv->jack_mlock);
+	if (priv->detect_state == PLUG_OUT) {
+		/* disable typec jack */
+		if (priv->usb_sel.used)
+			gpio_set_value(priv->usb_sel.pin, !priv->usb_sel.level);
+	} else {
+		wait_and_detect_mic_gnd_state(priv);
+
+		/* enable typec jack */
+		if (priv->usb_sel.used)
+			gpio_set_value(priv->usb_sel.pin, priv->usb_sel.level);
+	}
+
+	schedule_delayed_work(&priv->hs_detect_work, msecs_to_jiffies(10));
+
+	mutex_unlock(&priv->jack_mlock);
+}
+
+static int hp_plugin_notifier(struct notifier_block *nb, unsigned long event, void *ptr)
+{
+	struct sunxi_card_priv *priv = container_of(nb, struct sunxi_card_priv, hp_nb);
+
+	SOUND_LOG_DEBUG("event -> %lu\n", event);
+	if (event)
+		priv->detect_state = PLUG_IN;
+	else
+		priv->detect_state = PLUG_OUT;
+
+	schedule_delayed_work(&priv->typec_jack_detect_work, msecs_to_jiffies(10));
+
+	return NOTIFY_DONE;
+}
+#endif
+
+static const struct snd_kcontrol_new sunxi_card_controls[] = {
+	SOC_DAPM_PIN_SWITCH("Headphone"),
+	SOC_DAPM_PIN_SWITCH("HpSpeaker"),
+	SOC_DAPM_PIN_SWITCH("LINEOUT"),
+};
+
+static const struct snd_soc_dapm_widget sunxi_card_dapm_widgets[] = {
+	SND_SOC_DAPM_MIC("HeadphoneMic", NULL),
+	SND_SOC_DAPM_MIC("Main Mic", NULL),
+};
+
+static const struct snd_soc_dapm_route sunxi_card_routes[] = {
+	{"MainMic Bias", NULL, "Main Mic"},
+	{"MIC1", NULL, "MainMic Bias"},
+	{"MIC2", NULL, "HeadphoneMic"},
+};
+
+static void sunxi_hs_reg_init(struct sunxi_card_priv *priv)
+{
+
+	snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL, (0xffff << 0),
+			    (0x0 << 0));
+
+	snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+			(0x1f << MDATA_THRESHOLD),
+			(0x17 << MDATA_THRESHOLD));
+
+	snd_soc_component_update_bits(priv->component, SUNXI_HMIC_STS, (0xffff << 0),
+			    (0x6000 << 0));
+
+	snd_soc_component_update_bits(priv->component, SUNXI_MICBIAS_REG,
+			(0xff << SELDETADCBF), (0x40 << SELDETADCBF));
+
+	if (priv->hp_detect_case == HP_DETECT_LOW) {
+		snd_soc_component_update_bits(priv->component, SUNXI_MICBIAS_REG,
+				    (0x1 << AUTOPLEN), (0x1 << AUTOPLEN));
+		snd_soc_component_update_bits(priv->component, SUNXI_MICBIAS_REG,
+				    (0x1 << DETMODE), (0x0 << DETMODE));
+	} else {
+		snd_soc_component_update_bits(priv->component, SUNXI_MICBIAS_REG,
+				    (0x1 << AUTOPLEN), (0x0 << AUTOPLEN));
+		snd_soc_component_update_bits(priv->component, SUNXI_MICBIAS_REG,
+				    (0x1 << DETMODE), (0x1 << DETMODE));
+	}
+	snd_soc_component_update_bits(priv->component, SUNXI_MICBIAS_REG, (0x1 << JACKDETEN),
+			    (0x1 << JACKDETEN));
+	/*enable jack in /out irq*/
+	snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+			    (0x1 << JACK_IN_IRQ_EN), (0x1 << JACK_IN_IRQ_EN));
+	snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+			    (0x1 << JACK_OUT_IRQ_EN), (0x1 << JACK_OUT_IRQ_EN));
+
+	snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+			(0xf << HMIC_N), (HP_DEBOUCE_TIME << HMIC_N));
+
+	snd_soc_component_update_bits(priv->component, SUNXI_MICBIAS_REG,
+			    (0x1 << HMICBIASEN), (0x1 << HMICBIASEN));
+	snd_soc_component_update_bits(priv->component, SUNXI_MICBIAS_REG,
+			    (0x1 << MICADCEN), (0x1 << MICADCEN));
+	snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+				(0x1 << MIC_DET_IRQ_EN),
+				(0x1 << MIC_DET_IRQ_EN));
+
+	schedule_delayed_work(&priv->hs_init_work, msecs_to_jiffies(10));
+}
+
+static void snd_sunxi_unregister_jack(struct sunxi_card_priv *priv)
+{
+	/*
+	 * Set process button events to false so that the button
+	 * delayed work will not be scheduled.
+	 */
+	cancel_delayed_work_sync(&priv->hs_detect_work);
+	cancel_delayed_work_sync(&priv->hs_button_work);
+	cancel_delayed_work_sync(&priv->hs_init_work);
+	free_irq(priv->jackirq, priv);
+}
+
+/*
+ * Card initialization
+ */
+static int sunxi_card_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_component *component = rtd->codec_dai->component;
+	struct snd_soc_dapm_context *dapm = &component->dapm;
+
+	struct sunxi_card_priv *priv = snd_soc_card_get_drvdata(rtd->card);
+	int ret;
+
+	priv->component = rtd->codec_dai->component;
+
+	ret = snd_soc_card_jack_new(rtd->card, "sunxi Audio Jack",
+			       SND_JACK_HEADSET | SND_JACK_HEADPHONE |
+				   SND_JACK_BTN_0 | SND_JACK_BTN_1 |
+				   SND_JACK_BTN_2 | SND_JACK_BTN_3,
+			       &priv->jack, NULL, 0);
+	if (ret) {
+		SOUND_LOG_ERR("jack creation failed\n");
+		return ret;
+	}
+
+	snd_jack_set_key(priv->jack.jack, SND_JACK_BTN_0, KEY_MEDIA);
+	snd_jack_set_key(priv->jack.jack, SND_JACK_BTN_1, KEY_VOLUMEUP);
+	snd_jack_set_key(priv->jack.jack, SND_JACK_BTN_2, KEY_VOLUMEDOWN);
+	snd_jack_set_key(priv->jack.jack, SND_JACK_BTN_3, KEY_VOICECOMMAND);
+
+	snd_soc_dapm_disable_pin(dapm, "HPOUTR");
+	snd_soc_dapm_disable_pin(dapm, "HPOUTL");
+
+	snd_soc_dapm_disable_pin(dapm, "LINEOUT");
+	snd_soc_dapm_disable_pin(dapm, "HpSpeaker");
+	snd_soc_dapm_disable_pin(dapm, "Headphone");
+
+	snd_soc_dapm_sync(dapm);
+
+	return 0;
+}
+
+static int sunxi_card_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	unsigned int freq;
+	int ret;
+	int stream_flag;
+
+	switch (params_rate(params)) {
+	case	8000:
+	case	12000:
+	case	16000:
+	case	24000:
+	case	32000:
+	case	48000:
+	case	96000:
+	case	192000:
+		freq = 24576000;
+		break;
+	case	11025:
+	case	22050:
+	case	44100:
+		freq = 22579200;
+		break;
+	default:
+		SOUND_LOG_ERR("invalid rate setting\n");
+		return -EINVAL;
+	}
+
+	/* the substream type: 0->playback, 1->capture */
+	stream_flag = substream->stream;
+	SOUND_LOG_DEBUG("stream_flag: %d\n", stream_flag);
+
+	/* To surpport playback and capture func in different freq point */
+	if (freq == 22579200) {
+		if (stream_flag == 0) {
+			ret = snd_soc_dai_set_sysclk(codec_dai, 0, freq, 0);
+			if (ret < 0) {
+				SOUND_LOG_ERR("set codec dai sysclk faided, freq:%d\n", freq);
+				return ret;
+			}
+		}
+	}
+
+	if (freq == 22579200) {
+		if (stream_flag == 1) {
+			ret = snd_soc_dai_set_sysclk(codec_dai, 1, freq, 0);
+			if (ret < 0) {
+				SOUND_LOG_ERR("set codec dai sysclk faided, freq:%d\n", freq);
+				return ret;
+			}
+		}
+	}
+
+	if (freq == 24576000) {
+		if (stream_flag == 0) {
+			ret = snd_soc_dai_set_sysclk(codec_dai, 2, freq, 0);
+			if (ret < 0) {
+				SOUND_LOG_ERR("set codec dai sysclk faided, freq:%d\n", freq);
+				return ret;
+			}
+		}
+	}
+
+	if (freq == 24576000) {
+			if (stream_flag == 1) {
+			ret = snd_soc_dai_set_sysclk(codec_dai, 3, freq, 0);
+			if (ret < 0) {
+				SOUND_LOG_ERR("set codec dai sysclk faided, freq:%d\n", freq);
+				return ret;
+			}
+		}
+	}
+
+	return 0;
+}
+
+static struct snd_soc_ops sunxi_card_ops = {
+	.hw_params = sunxi_card_hw_params,
+};
+
+SND_SOC_DAILINK_DEFS(sun50iw10p1_dai_link,
+	DAILINK_COMP_ARRAY(COMP_CPU("sunxi-dummy-cpudai")),
+	DAILINK_COMP_ARRAY(COMP_CODEC("sunxi-internal-codec", "sun50iw10codec")),
+	DAILINK_COMP_ARRAY(COMP_PLATFORM("sunxi-dummy-cpudai")));
+
+static struct snd_soc_dai_link sunxi_card_dai_link[] = {
+	{
+		.name		= "audiocodec",
+		.stream_name	= "SUNXI-CODEC",
+		.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF
+				| SND_SOC_DAIFMT_CBM_CFM,
+		.init		= sunxi_card_init,
+		.ops		= &sunxi_card_ops,
+		SND_SOC_DAILINK_REG(sun50iw10p1_dai_link),
+	},
+};
+
+static int sunxi_card_suspend(struct snd_soc_card *card)
+{
+	struct sunxi_card_priv *priv = snd_soc_card_get_drvdata(card);
+
+	disable_irq(priv->jackirq);
+
+	snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+			    (0x1 << MIC_DET_IRQ_EN), (0x0 << MIC_DET_IRQ_EN));
+	snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+			    (0x1 << JACK_IN_IRQ_EN), (0x0 << JACK_IN_IRQ_EN));
+	snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+			    (0x1 << JACK_OUT_IRQ_EN), (0x0 << JACK_OUT_IRQ_EN));
+	snd_soc_component_update_bits(priv->component, SUNXI_MICBIAS_REG, (0x1 << JACKDETEN),
+			    (0x0 << JACKDETEN));
+	SOUND_LOG_DEBUG("suspend\n");
+
+	return 0;
+}
+
+static int sunxi_card_resume(struct snd_soc_card *card)
+{
+	struct sunxi_card_priv *priv = snd_soc_card_get_drvdata(card);
+
+	enable_irq(priv->jackirq);
+	priv->jack_irq_times = RESUME_IRQ;
+	priv->detect_state = PLUG_OUT;/*todo..?*/
+	sunxi_hs_reg_init(priv);
+	SOUND_LOG_DEBUG("resume\n");
+
+	return 0;
+}
+
+static struct snd_soc_card snd_soc_sunxi_card = {
+	.name			= "audiocodec",
+	.owner			= THIS_MODULE,
+	.dai_link		= sunxi_card_dai_link,
+	.num_links		= ARRAY_SIZE(sunxi_card_dai_link),
+	.suspend_post		= sunxi_card_suspend,
+	.resume_post		= sunxi_card_resume,
+};
+
+static int sunxi_card_dev_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	u32 temp_val;
+	struct sunxi_card_priv *priv = NULL;
+	struct device_node *np = pdev->dev.of_node;
+	struct snd_soc_card *card = &snd_soc_sunxi_card;
+	struct snd_soc_dapm_context *dapm = &card->dapm;
+
+	if (!np) {
+		SOUND_LOG_ERR("can not get dt node for this device\n");
+		return -EINVAL;
+	}
+
+	/* dai link */
+	sunxi_card_dai_link[0].cpus->dai_name = NULL;
+	sunxi_card_dai_link[0].cpus->of_node = of_parse_phandle(np,
+					"sunxi,cpudai-controller", 0);
+	if (!sunxi_card_dai_link[0].cpus->of_node) {
+		SOUND_LOG_ERR("Property 'sunxi,cpudai-controller' missing or invalid\n");
+		ret = -EINVAL;
+		goto err_devm_kfree;
+	} else {
+		sunxi_card_dai_link[0].platforms->name = NULL;
+		sunxi_card_dai_link[0].platforms->of_node =
+				sunxi_card_dai_link[0].cpus->of_node;
+	}
+	sunxi_card_dai_link[0].codecs->name = NULL;
+	sunxi_card_dai_link[0].codecs->of_node = of_parse_phandle(np,
+						"sunxi,audio-codec", 0);
+	if (!sunxi_card_dai_link[0].codecs->of_node) {
+		SOUND_LOG_ERR("Property 'sunxi,audio-codec' missing or invalid\n");
+		ret = -EINVAL;
+		goto err_devm_kfree;
+	}
+
+	/* register the soc card */
+	card->dev = &pdev->dev;
+
+	priv = devm_kzalloc(&pdev->dev,
+		sizeof(struct sunxi_card_priv), GFP_KERNEL);
+	if (!priv) {
+		SOUND_LOG_ERR("devm_kzalloc failed %d\n", ret);
+		return -ENOMEM;
+	}
+	priv->card = card;
+
+	snd_soc_card_set_drvdata(card, priv);
+
+	ret = snd_soc_register_card(card);
+	if (ret) {
+		SOUND_LOG_ERR("snd_soc_register_card failed %d\n", ret);
+		goto err_devm_kfree;
+	}
+
+	ret = snd_soc_add_card_controls(card, sunxi_card_controls,
+					ARRAY_SIZE(sunxi_card_controls));
+	if (ret)
+		SOUND_LOG_ERR("failed to register codec controls!\n");
+
+	snd_soc_dapm_new_controls(dapm, sunxi_card_dapm_widgets,
+				ARRAY_SIZE(sunxi_card_dapm_widgets));
+	snd_soc_dapm_add_routes(dapm, sunxi_card_routes,
+				ARRAY_SIZE(sunxi_card_routes));
+
+	ret = of_property_read_u32(np, "hp_detect_case", &temp_val);
+	if (ret < 0) {
+		SOUND_LOG_WARN("hp_detect_case  missing or invalid.\n");
+	} else {
+		priv->hp_detect_case = temp_val;
+		SOUND_LOG_INFO("hp_detect_case: %d\n", priv->hp_detect_case);
+	}
+
+	priv->jackirq = platform_get_irq(pdev, 0);
+	if (priv->jackirq < 0) {
+		SOUND_LOG_ERR("irq failed\n");
+		ret = -ENODEV;
+	}
+
+	priv->jack_irq_times = SYSINIT_IRQ;
+
+	/*
+	 * initial the parameters for judge switch state
+	 */
+	ret = of_property_read_u32(np, "jack_threshold", &temp_val);
+	if (ret < 0) {
+		SOUND_LOG_WARN("headset_threshold get failed, use default vol -> 0x10\n");
+		priv->HEADSET_DATA = 0x10;
+	} else {
+		priv->HEADSET_DATA = temp_val;
+	}
+	priv->detect_state = PLUG_OUT;
+	INIT_DELAYED_WORK(&priv->hs_detect_work, sunxi_check_hs_detect_status);
+	INIT_DELAYED_WORK(&priv->hs_button_work, sunxi_check_hs_button_status);
+	INIT_DELAYED_WORK(&priv->hs_init_work, sunxi_hs_init_work);
+	INIT_DELAYED_WORK(&priv->hs_checkplug_work, sunxi_check_hs_plug);
+	mutex_init(&priv->jack_mlock);
+
+	ret = request_irq(priv->jackirq, jack_interrupt, 0, "audio jack irq", priv);
+
+#ifdef CONFIG_EXTCON_TYPEC_JACK
+	ret = of_property_read_u32(np, "typec_analog_jack_enable", &temp_val);
+	if (ret < 0) {
+		SOUND_LOG_WARN("typec_analog_jack_enable get failed, default disable\n");
+		priv->typec_analog_jack_enable = 0;
+	} else {
+		priv->typec_analog_jack_enable = temp_val;
+	}
+
+	if (priv->typec_analog_jack_enable) {
+
+	ret = of_property_read_u32(np, "usb_sel_level", &temp_val);
+	if (ret < 0) {
+		SOUND_LOG_WARN("usb_sel_level get failed, use default vol -> H\n");
+		priv->usb_sel.level = 0;
+	} else {
+		priv->usb_sel.level = temp_val;
+	}
+	ret = of_property_read_u32(np, "usb_noe_level", &temp_val);
+	if (ret < 0) {
+		SOUND_LOG_WARN("usb_noe_level get failed, use default vol -> L\n");
+		priv->usb_noe.level = 0;
+	} else {
+		priv->usb_noe.level = temp_val;
+	}
+
+	ret = of_get_named_gpio(np, "usb_sel_gpio", 0);
+	priv->usb_sel.used = 0;
+	if (ret >= 0) {
+		priv->usb_sel.pin = ret;
+		if (!gpio_is_valid(priv->usb_sel.pin)) {
+			SOUND_LOG_ERR("usb_sel_gpio is invalid\n");
+		} else {
+			ret = devm_gpio_request(&pdev->dev,
+					priv->usb_sel.pin, "USB_SEL");
+			if (ret) {
+				SOUND_LOG_ERR("failed to request usb_sel_gpio\n");
+			} else {
+				priv->usb_sel.used = 1;
+				gpio_direction_output(priv->usb_sel.pin, 1);
+			}
+		}
+	}
+	ret = of_get_named_gpio(np, "usb_noe_gpio", 0);
+	priv->usb_noe.used = 0;
+	if (ret >= 0) {
+		priv->usb_noe.pin = ret;
+		if (!gpio_is_valid(priv->usb_noe.pin)) {
+			SOUND_LOG_ERR("usb_noe_gpio is invalid\n");
+		} else {
+			ret = devm_gpio_request(&pdev->dev,
+					priv->usb_noe.pin, "USB_NOE");
+			if (ret) {
+				SOUND_LOG_ERR("failed to request usb_noe_gpio\n");
+			} else {
+				priv->usb_noe.used = 1;
+				gpio_direction_output(priv->usb_noe.pin, 1);
+				/* default connect */
+				gpio_set_value(priv->usb_noe.pin, priv->usb_noe.level);
+			}
+		}
+	}
+	ret = of_get_named_gpio(np, "mic_sel_gpio", 0);
+	priv->mic_sel.used = 0;
+	if (ret >= 0) {
+		priv->mic_sel.pin = ret;
+		if (!gpio_is_valid(priv->mic_sel.pin)) {
+			SOUND_LOG_ERR("mic_sel_gpio is invalid\n");
+		} else {
+			ret = devm_gpio_request(&pdev->dev,
+					priv->mic_sel.pin, "MIC_SEL");
+			if (ret) {
+				SOUND_LOG_ERR("failed to request mic_sel_gpio\n");
+			} else {
+				priv->mic_sel.used = 1;
+				gpio_direction_output(priv->mic_sel.pin, 1);
+			}
+		}
+	}
+
+	if (of_property_read_bool(np, "extcon")) {
+		priv->extdev = extcon_get_edev_by_phandle(&pdev->dev, 0);
+		if (IS_ERR(priv->extdev)) {
+			ret = -ENODEV;
+			goto err_devm_kfree;
+		}
+		priv->hp_nb.notifier_call = hp_plugin_notifier;
+		ret = extcon_register_notifier(priv->extdev,
+				EXTCON_JACK_HEADPHONE, &priv->hp_nb);
+		if (ret < 0) {
+			SOUND_LOG_ERR("register hp notifier failed\n");
+			goto err_devm_kfree;
+		}
+		INIT_DELAYED_WORK(&priv->typec_jack_detect_work,
+				  sunxi_typec_jack_detect_status);
+		priv->detect_state = PLUG_OUT;
+		ret = extcon_get_state(priv->extdev, EXTCON_JACK_HEADPHONE);
+		if (ret > 0) {
+			priv->detect_state = PLUG_IN;
+		}
+
+		schedule_delayed_work(&priv->typec_jack_detect_work,
+				      msecs_to_jiffies(10));
+	}
+	}
+#endif
+
+	sunxi_hs_reg_init(priv);
+	SOUND_LOG_DEBUG("0x310:0x%X,0x314:0x%X,0x318:0x%X,0x1C:0x%X,0x1D:0x%X\n",
+			snd_soc_component_read32(priv->component, 0x310),
+			snd_soc_component_read32(priv->component, 0x314),
+			snd_soc_component_read32(priv->component, 0x318),
+			snd_soc_component_read32(priv->component, 0x1C),
+			snd_soc_component_read32(priv->component, 0x1D));
+
+	SOUND_LOG_INFO("register card finished\n");
+
+	return 0;
+
+err_devm_kfree:
+	devm_kfree(&pdev->dev, priv);
+	return ret;
+}
+
+static int __exit sunxi_card_dev_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+	struct sunxi_card_priv *priv = snd_soc_card_get_drvdata(card);
+
+#ifdef CONFIG_EXTCON_TYPEC_JACK
+	if (priv->typec_analog_jack_enable) {
+
+	extcon_unregister_notifier(priv->extdev, EXTCON_JACK_HEADPHONE, &priv->hp_nb);
+	/* disable typec jack */
+	if (priv->usb_sel.used)
+		gpio_set_value(priv->usb_sel.pin, !priv->usb_sel.level);
+
+	}
+#endif
+
+	snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+			    (0x1 << JACK_IN_IRQ_EN), (0x0 << JACK_IN_IRQ_EN));
+	snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+			    (0x1 << JACK_OUT_IRQ_EN), (0x0 << JACK_OUT_IRQ_EN));
+	snd_soc_component_update_bits(priv->component, SUNXI_MICBIAS_REG, (0x1 << JACKDETEN),
+			    (0x0 << JACKDETEN));
+	snd_soc_component_update_bits(priv->component, SUNXI_MICBIAS_REG,
+				(0x1 << HMICBIASEN), (0x0 << HMICBIASEN));
+	snd_sunxi_unregister_jack(priv);
+
+	snd_soc_unregister_card(card);
+	devm_kfree(&pdev->dev, priv);
+
+	SOUND_LOG_INFO("unregister card finished\n");
+
+	return 0;
+}
+
+static const struct of_device_id sunxi_card_of_match[] = {
+	{ .compatible = "allwinner,sunxi-codec-machine", },
+	{},
+};
+
+static struct platform_driver sunxi_machine_driver = {
+	.driver = {
+		.name = "sunxi-codec-machine",
+		.owner = THIS_MODULE,
+		.pm = &snd_soc_pm_ops,
+		.of_match_table = sunxi_card_of_match,
+	},
+	.probe = sunxi_card_dev_probe,
+	.remove = __exit_p(sunxi_card_dev_remove),
+};
+
+static int __init sunxi_machine_driver_init(void)
+{
+	return platform_driver_register(&sunxi_machine_driver);
+}
+module_init(sunxi_machine_driver_init);
+
+static void __exit sunxi_machine_driver_exit(void)
+{
+	platform_driver_unregister(&sunxi_machine_driver);
+}
+module_exit(sunxi_machine_driver_exit);
+
+module_param_named(switch_state, switch_state, int, S_IRUGO | S_IWUSR);
+
+MODULE_AUTHOR("luguofang <luguofang@allwinnertech.com>");
+MODULE_DESCRIPTION("SUNXI Codec Machine ASoC driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:sunxi-codec-machine");
diff --git a/sound/soc/sunxi/sun50iw12-codec.c b/sound/soc/sunxi/sun50iw12-codec.c
new file mode 100644
index 000000000..85fba41cd
--- /dev/null
+++ b/sound/soc/sunxi/sun50iw12-codec.c
@@ -0,0 +1,2717 @@
+/*
+ * sound\soc\sunxi\sun50iw12-codec.c
+ * (C) Copyright 2019-2021
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * luguofang <luguofang@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/pm.h>
+#include <linux/regulator/consumer.h>
+#include <linux/pinctrl/pinctrl-sunxi.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
+#include <linux/reset.h>
+#include <asm/dma.h>
+#include <sound/pcm.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/core.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <sound/tlv.h>
+#include <linux/sunxi-gpio.h>
+
+#include "sun50iw12-codec.h"
+
+static const struct sample_rate sample_rate_conv[] = {
+	{8000,   5},
+	{11025,  4},
+	{12000,  4},
+	{16000,  3},
+	{22050,  2},
+	{24000,  2},
+	{32000,  1},
+	{44100,  0},
+	{48000,  0},
+	{96000,  7},
+	{192000, 6},
+};
+
+static const DECLARE_TLV_DB_SCALE(dac_vol_tlv, -11925, 75, 0);
+static const DECLARE_TLV_DB_SCALE(adc_vol_tlv, -11925, 75, 0);
+static const DECLARE_TLV_DB_SCALE(digital_tlv, -7424, 116, 0);
+static const DECLARE_TLV_DB_SCALE(hpout_tlv, -4200, 600, 0);
+static const unsigned int lineout_tlv[] = {
+	TLV_DB_RANGE_HEAD(2),
+	0, 1, TLV_DB_SCALE_ITEM(0, 0, 1),
+	2, 31, TLV_DB_SCALE_ITEM(-4350, 150, 1),
+};
+
+static struct reg_label codec_reg_labels[] = {
+	REG_LABEL(SUNXI_DAC_DPC),
+	REG_LABEL(SUNXI_DAC_VOL_CTRL),
+	REG_LABEL(SUNXI_DAC_FIFOC),
+	REG_LABEL(SUNXI_DAC_FIFOS),
+	REG_LABEL(SUNXI_DAC_CNT),
+	REG_LABEL(SUNXI_DAC_DG),
+
+	REG_LABEL(SUNXI_ADC_FIFOC),
+	REG_LABEL(SUNXI_ADC_VOL_CTRL),
+	REG_LABEL(SUNXI_ADC_FIFOS),
+	REG_LABEL(SUNXI_ADC_CNT),
+	REG_LABEL(SUNXI_ADC_DG),
+
+	REG_LABEL(SUNXI_DAC_DAP_CTL),
+	REG_LABEL(SUNXI_ADC_DAP_CTL),
+
+	REG_LABEL(SUNXI_ADCL_REG),
+	REG_LABEL(SUNXI_ADCR_REG),
+	REG_LABEL(SUNXI_DAC_REG),
+	REG_LABEL(SUNXI_MICBIAS_REG),
+	REG_LABEL(SUNXI_BIAS_REG),
+	REG_LABEL(SUNXI_HP_REG),
+	REG_LABEL(SUNXI_HMIC_CTRL),
+	REG_LABEL(SUNXI_HMIC_STS),
+	REG_LABEL_END,
+};
+
+static struct reg_label i2s_reg_labels[] = {
+	REG_LABEL(INTER_I2S_CTL),
+	REG_LABEL(INTER_I2S_FMT0),
+	REG_LABEL(INTER_I2S_FMT1),
+	REG_LABEL(INTER_I2S_CLKDIV),
+	REG_LABEL(INTER_I2S_CHCFG),
+
+	REG_LABEL(INTER_I2S_TX0CHSEL),
+	REG_LABEL(INTER_I2S_TX1CHSEL),
+	REG_LABEL(INTER_I2S_TX2CHSEL),
+	REG_LABEL(INTER_I2S_TX3CHSEL),
+	REG_LABEL(INTER_I2S_TX0CHMAP0),
+	REG_LABEL(INTER_I2S_TX0CHMAP1),
+	REG_LABEL(INTER_I2S_TX1CHMAP0),
+	REG_LABEL(INTER_I2S_TX1CHMAP1),
+	REG_LABEL(INTER_I2S_TX2CHMAP0),
+	REG_LABEL(INTER_I2S_TX2CHMAP1),
+	REG_LABEL(INTER_I2S_TX3CHMAP0),
+	REG_LABEL(INTER_I2S_TX3CHMAP1),
+
+	REG_LABEL(INTER_I2S_RXCHSEL),
+	REG_LABEL(INTER_I2S_RXCHMAP0),
+	REG_LABEL(INTER_I2S_RXCHMAP1),
+	REG_LABEL(INTER_I2S_RXCHMAP2),
+	REG_LABEL(INTER_I2S_RXCHMAP3),
+	REG_LABEL_END,
+};
+
+#if 0
+static void adcdrc_config(struct snd_soc_component *component)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	/* Enable DRC gain Min and Max limit, detect noise, Using Peak Filter */
+	regmap_update_bits(sunxi_codec->codec_regmap,
+			SUNXI_ADC_DRC_CTRL,
+			((0x1 << ADC_DRC_DELAY_BUF_EN) |
+			(0x1 << ADC_DRC_GAIN_MAX_EN) |
+			(0x1 << ADC_DRC_GAIN_MIN_EN) |
+			(0x1 << ADC_DRC_NOISE_DET_EN) |
+			(0x1 << ADC_DRC_SIGNAL_SEL) |
+			(0x1 << ADC_DRC_LT_EN) |
+			(0x1 << ADC_DRC_ET_EN)),
+			((0x1 << ADC_DRC_DELAY_BUF_EN) |
+			(0x1 << ADC_DRC_GAIN_MAX_EN) |
+			(0x1 << ADC_DRC_GAIN_MIN_EN) |
+			(0x1 << ADC_DRC_NOISE_DET_EN) |
+			(0x1 << ADC_DRC_SIGNAL_SEL) |
+			(0x1 << ADC_DRC_LT_EN) |
+			(0x1 << ADC_DRC_ET_EN)));
+
+	/* Left peak filter attack time */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_LPFHAT, (0x000B77F0 >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_LPFLAT, 0x000B77F0 & 0xFFFF);
+	/* Right peak filter attack time */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_RPFHAT, (0x000B77F0 >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_RPFLAT, 0x000B77F0 & 0xFFFF);
+	/* Left peak filter release time */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_LPFHRT, (0x00FFE1F8 >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_LPFLRT, 0x00FFE1F8 & 0xFFFF);
+	/* Right peak filter release time */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_RPFHRT, (0x00FFE1F8 >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_RPFLRT, 0x00FFE1F8 & 0xFFFF);
+
+	/* Left RMS filter attack time */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_LPFHAT, (0x00012BB0 >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_LPFLAT, 0x00012BB0 & 0xFFFF);
+	/* Right RMS filter attack time */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_RPFHAT, (0x00012BB0 >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_RPFLAT, 0x00012BB0 & 0xFFFF);
+
+	/* OPL */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_HOPL, (0xFF641741 >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_LOPL, 0xFF641741 & 0xFFFF);
+	/* OPC */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_HOPC, (0xFC0380F3 >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_LOPC, 0xFC0380F3 & 0xFFFF);
+	/* OPE */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_HOPE, (0xF608C25F >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_LOPE, 0xF608C25F & 0xFFFF);
+	/* LT */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_HLT, (0x035269E0 >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_LLT, 0x035269E0 & 0xFFFF);
+	/* CT */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_HCT, (0x06B3002C >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_LCT, 0x06B3002C & 0xFFFF);
+	/* ET */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_HET, (0x0A139682 >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_LET, 0x0A139682 & 0xFFFF);
+	/* Ki */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_HKI, (0x00222222 >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_LKI, 0x00222222 & 0xFFFF);
+	/* Kc */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_HKC, (0x01000000 >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_LKC, 0x01000000 & 0xFFFF);
+	/* Kn */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_HKN, (0x01C53EF0 >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_LKN, 0x01C53EF0 & 0xFFFF);
+	/* Ke */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_HKE, (0x04234F68 >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_LKE, 0x04234F68 & 0xFFFF);
+
+	/* smooth filter attack time */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_SFHAT, (0x00017665 >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_SFLAT, 0x00017665 & 0xFFFF);
+	/* gain smooth filter release time */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_SFHRT, (0x00000F04 >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_SFLRT, 0x00000F04 & 0xFFFF);
+
+	/* gain max setting */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_MXGHS, (0x69E0F95B >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_MXGLS, 0x69E0F95B & 0xFFFF);
+
+	/* gain min setting */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_MNGHS, (0xF95B2C3F >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_MNGLS, 0xF95B2C3F & 0xFFFF);
+
+	/* smooth filter release and attack time */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_EPSHC, (0x00025600 >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_EPSHC, 0x00025600 & 0xFFFF);
+}
+
+static void adcdrc_enable(struct snd_soc_component *component, bool on)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct codec_dap *adc_dap = &sunxi_codec->adc_dap;
+
+	if (on) {
+		if (adc_dap->drc_enable++ == 0) {
+			regmap_update_bits(sunxi_codec->codec_regmap, SUNXI_ADC_DAP_CTL,
+				(0x1 << ADC_DRC0_EN), (0x1 << ADC_DRC0_EN));
+			if (sunxi_codec->adc_dap_enable++ == 0) {
+				regmap_update_bits(sunxi_codec->codec_regmap, SUNXI_ADC_DAP_CTL,
+					(0x1 << ADC_DAP0_EN), (0x1 << ADC_DAP0_EN));
+			}
+		}
+	} else {
+		if (--adc_dap->drc_enable <= 0) {
+			adc_dap->drc_enable = 0;
+			if (--sunxi_codec->adc_dap_enable <= 0) {
+				sunxi_codec->adc_dap_enable = 0;
+				regmap_update_bits(sunxi_codec->codec_regmap, SUNXI_ADC_DAP_CTL,
+					(0x1 << ADC_DAP0_EN), (0x0 << ADC_DAP0_EN));
+			}
+			regmap_update_bits(sunxi_codec->codec_regmap, SUNXI_ADC_DAP_CTL,
+				(0x1 << ADC_DRC0_EN), (0x0 << ADC_DRC0_EN));
+		}
+	}
+}
+
+static void adchpf_config(struct snd_soc_component *component)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	/* HPF */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_HHPFC, (0xFFFAC1 >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_ADC_DRC_LHPFC, 0xFFFAC1 & 0xFFFF);
+}
+
+static void adchpf_enable(struct snd_soc_component *component, bool on)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct codec_dap *adc_dap = &sunxi_codec->adc_dap;
+
+	if (on) {
+		if (adc_dap->hpf_enable++ == 0) {
+			regmap_update_bits(sunxi_codec->codec_regmap, SUNXI_ADC_DAP_CTL,
+				(0x1 << ADC_HPF0_EN), (0x1 << ADC_HPF0_EN));
+			if (sunxi_codec->adc_dap_enable++ == 0) {
+				regmap_update_bits(sunxi_codec->codec_regmap, SUNXI_ADC_DAP_CTL,
+					(0x1 << ADC_DAP0_EN), (0x1 << ADC_DAP0_EN));
+			}
+		}
+	} else {
+		if (--adc_dap->hpf_enable <= 0) {
+			adc_dap->hpf_enable = 0;
+			if (--sunxi_codec->adc_dap_enable <= 0) {
+				sunxi_codec->adc_dap_enable = 0;
+				regmap_update_bits(sunxi_codec->codec_regmap, SUNXI_ADC_DAP_CTL,
+					(0x1 << ADC_DAP0_EN), (0x0 << ADC_DAP0_EN));
+			}
+			regmap_update_bits(sunxi_codec->codec_regmap, SUNXI_ADC_DAP_CTL,
+				(0x1 << ADC_HPF0_EN), (0x0 << ADC_HPF0_EN));
+		}
+	}
+}
+
+static void dacdrc_config(struct snd_soc_component *component)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	/* Left peak filter attack time */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_LPFHAT, (0x000B77BF >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_LPFLAT, 0x000B77BF & 0xFFFF);
+	/* Right peak filter attack time */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_RPFHAT, (0x000B77F0 >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_RPFLAT, 0x000B77F0 & 0xFFFF);
+
+	/* Left peak filter release time */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_LPFHRT, (0x00FFE1F8 >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_LPFLRT, 0x00FFE1F8 & 0xFFFF);
+	/* Right peak filter release time */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_RPFHRT, (0x00FFE1F8 >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_RPFLRT, 0x00FFE1F8 & 0xFFFF);
+
+	/* Left RMS filter attack time */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_LRMSHAT, (0x00012BB0 >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_LRMSLAT, 0x00012BB0 & 0xFFFF);
+	/* Right RMS filter attack time */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_RRMSHAT, (0x00012BB0 >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_RRMSLAT, 0x00012BB0 & 0xFFFF);
+
+	/* smooth filter attack time */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_SFHAT, (0x00017665 >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_SFLAT, 0x00017665 & 0xFFFF);
+	/* gain smooth filter release time */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_SFHRT, (0x00000F04 >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_SFLRT, 0x00000F04 & 0xFFFF);
+
+	/* OPL */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_HOPL, (0xFE56CB10 >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_LOPL, 0xFE56CB10 & 0xFFFF);
+	/* OPC */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_HOPC, (0xFB04612F >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_LOPC, 0xFB04612F & 0xFFFF);
+	/* OPE */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_HOPE, (0xF608C25F >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_LOPE, 0xF608C25F & 0xFFFF);
+	/* LT */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_HLT, (0x035269E0 >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_LLT, 0x035269E0 & 0xFFFF);
+	/* CT */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_HCT, (0x06B3002C >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_LCT, 0x06B3002C & 0xFFFF);
+	/* ET */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_HET, (0x0A139682 >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_LET, 0x0A139682 & 0xFFFF);
+	/* Ki */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_HKI, (0x00400000 >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_LKI, 0x00400000 & 0xFFFF);
+	/* Kc */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_HKC, (0x00FBCDA5 >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_LKC, 0x00FBCDA5 & 0xFFFF);
+	/* Kn */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_HKN, (0x0179B472 >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_LKN, 0x0179B472 & 0xFFFF);
+	/* Ke */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_HKE, (0x04234F68 >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_LKE, 0x04234F68 & 0xFFFF);
+	/* MXG */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_MXGHS, (0x035269E0 >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_MXGLS, 0x035269E0 & 0xFFFF);
+	/* MNG */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_MNGHS, (0xF95B2C3F >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_MNGLS, 0xF95B2C3F & 0xFFFF);
+	/* EPS */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_EPSHC, (0x00025600 >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_EPSLC, 0x00025600 & 0xFFFF);
+}
+
+static void dacdrc_enable(struct snd_soc_component *component, bool on)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct codec_dap *dac_dap = &sunxi_codec->dac_dap;
+
+	if (on) {
+		if (dac_dap->drc_enable++ == 0) {
+			/* detect noise when ET enable */
+			regmap_update_bits(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_NOISE_DET_EN),
+				(0x1 << DAC_DRC_NOISE_DET_EN));
+
+			/* 0x0:RMS filter; 0x1:Peak filter */
+			regmap_update_bits(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_SIGNAL_SEL),
+				(0x1 << DAC_DRC_SIGNAL_SEL));
+
+			regmap_update_bits(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_GAIN_MAX_EN),
+				(0x1 << DAC_DRC_GAIN_MAX_EN));
+
+			regmap_update_bits(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_GAIN_MIN_EN),
+				(0x1 << DAC_DRC_GAIN_MIN_EN));
+
+			/* delay function enable */
+			regmap_update_bits(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_DELAY_BUF_EN),
+				(0x1 << DAC_DRC_DELAY_BUF_EN));
+
+			regmap_update_bits(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_LT_EN),
+				(0x1 << DAC_DRC_LT_EN));
+			regmap_update_bits(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_ET_EN),
+				(0x1 << DAC_DRC_ET_EN));
+
+			regmap_update_bits(sunxi_codec->codec_regmap, SUNXI_DAC_DAP_CTL,
+				(0x1 << DDAP_DRC_EN),
+				(0x1 << DDAP_DRC_EN));
+
+			if (sunxi_codec->dac_dap_enable++ == 0)
+				regmap_update_bits(sunxi_codec->codec_regmap, SUNXI_DAC_DAP_CTL,
+					(0x1 << DDAP_EN), (0x1 << DDAP_EN));
+		}
+	} else {
+		if (--dac_dap->drc_enable <= 0) {
+			dac_dap->drc_enable = 0;
+			if (--sunxi_codec->dac_dap_enable <= 0) {
+				sunxi_codec->dac_dap_enable = 0;
+				regmap_update_bits(sunxi_codec->codec_regmap, SUNXI_DAC_DAP_CTL,
+					(0x1 << DDAP_EN), (0x0 << DDAP_EN));
+			}
+
+			regmap_update_bits(sunxi_codec->codec_regmap, SUNXI_DAC_DAP_CTL,
+				(0x1 << DDAP_DRC_EN),
+				(0x0 << DDAP_DRC_EN));
+
+			/* detect noise when ET enable */
+			regmap_update_bits(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_NOISE_DET_EN),
+				(0x0 << DAC_DRC_NOISE_DET_EN));
+
+			/* 0x0:RMS filter; 0x1:Peak filter */
+			regmap_update_bits(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_SIGNAL_SEL),
+				(0x0 << DAC_DRC_SIGNAL_SEL));
+
+			/* delay function enable */
+			regmap_update_bits(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_DELAY_BUF_EN),
+				(0x0 << DAC_DRC_DELAY_BUF_EN));
+
+			regmap_update_bits(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_GAIN_MAX_EN),
+				(0x0 << DAC_DRC_GAIN_MAX_EN));
+			regmap_update_bits(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_GAIN_MIN_EN),
+				(0x0 << DAC_DRC_GAIN_MIN_EN));
+
+			regmap_update_bits(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_LT_EN),
+				(0x0 << DAC_DRC_LT_EN));
+			regmap_update_bits(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_ET_EN),
+				(0x0 << DAC_DRC_ET_EN));
+		}
+	}
+}
+
+static void dachpf_config(struct snd_soc_component *component)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	/* HPF */
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_HHPFC, (0xFFFAC1 >> 16) & 0xFFFF);
+	regmap_write(sunxi_codec->codec_regmap, SUNXI_DAC_DRC_LHPFC, 0xFFFAC1 & 0xFFFF);
+}
+
+static void dachpf_enable(struct snd_soc_component *component, bool on)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct codec_dap *dac_dap = &sunxi_codec->dac_dap;
+
+	if (on) {
+		if (dac_dap->hpf_enable++ == 0) {
+			regmap_update_bits(sunxi_codec->codec_regmap, SUNXI_DAC_DAP_CTL,
+				(0x1 << DDAP_HPF_EN), (0x1 << DDAP_HPF_EN));
+
+			if (sunxi_codec->dac_dap_enable++ == 0)
+				regmap_update_bits(sunxi_codec->codec_regmap, SUNXI_DAC_DAP_CTL,
+					(0x1 << DDAP_EN), (0x1 << DDAP_EN));
+		}
+	} else {
+		if (--dac_dap->hpf_enable <= 0) {
+			dac_dap->hpf_enable = 0;
+			if (--sunxi_codec->dac_dap_enable <= 0) {
+				sunxi_codec->dac_dap_enable = 0;
+				regmap_update_bits(sunxi_codec->codec_regmap, SUNXI_DAC_DAP_CTL,
+					(0x1 << DDAP_EN), (0x0 << DDAP_EN));
+			}
+
+			regmap_update_bits(sunxi_codec->codec_regmap, SUNXI_DAC_DAP_CTL,
+				(0x1 << DDAP_HPF_EN),
+				(0x0 << DDAP_HPF_EN));
+		}
+	}
+}
+#endif
+
+/* sunxi codec hub mdoe select */
+static int sunxi_codec_get_hub_mode(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	unsigned int reg_val = 0;
+
+	regmap_read(sunxi_codec->codec_regmap, SUNXI_DAC_DPC, &reg_val);
+
+	ucontrol->value.integer.value[0] =
+				((reg_val & (0x1 << DAC_HUB_EN)) ? 1 : 0);
+
+	return 0;
+}
+
+static int sunxi_codec_set_hub_mode(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	switch (ucontrol->value.integer.value[0]) {
+	case	0:
+		regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_DAC_DPC, (0x1 << DAC_HUB_EN),
+				(0x0 << DAC_HUB_EN));
+		break;
+	case	1:
+		regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_DAC_DPC, (0x1 << DAC_HUB_EN),
+				(0x1 << DAC_HUB_EN));
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static const char * const sunxi_codec_hub_function[] = {
+				"hub_disable", "hub_enable"};
+
+static const struct soc_enum sunxi_codec_hub_mode_enum[] = {
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(sunxi_codec_hub_function),
+			sunxi_codec_hub_function),
+};
+
+/* sunxi codec dac swap func */
+static int sunxi_codec_get_dacswap_mode(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	unsigned int reg_val = 0;
+
+	regmap_read(sunxi_codec->codec_regmap, SUNXI_DAC_DG, &reg_val);
+
+	ucontrol->value.integer.value[0] =
+				((reg_val & (0x1 << DAC_SWAP)) ? 1 : 0);
+
+	return 0;
+}
+
+static int sunxi_codec_set_dacswap_mode(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	switch (ucontrol->value.integer.value[0]) {
+	case	0:
+		regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_DAC_DG, (0x1 << DAC_SWAP),
+				(0x0 << DAC_SWAP));
+		break;
+	case	1:
+		regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_DAC_DG, (0x1 << DAC_SWAP),
+				(0x1 << DAC_SWAP));
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const char * const sunxi_codec_dacswap_function[] = {
+				"Off", "On"};
+
+static const struct soc_enum sunxi_codec_dacswap_func_enum[] = {
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(sunxi_codec_dacswap_function),
+			sunxi_codec_dacswap_function),
+};
+
+/* sunxi codec adc swap func */
+static int sunxi_codec_get_adcswap_mode(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	unsigned int reg_val = 0;
+
+	regmap_read(sunxi_codec->codec_regmap, SUNXI_ADC_DG, &reg_val);
+
+	ucontrol->value.integer.value[0] =
+				((reg_val & (0x1 << ADC_SWAP)) ? 1 : 0);
+
+	return 0;
+}
+
+static int sunxi_codec_set_adcswap_mode(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	switch (ucontrol->value.integer.value[0]) {
+	case	0:
+		regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_ADC_DG, (0x1 << ADC_SWAP),
+				(0x0 << ADC_SWAP));
+		break;
+	case	1:
+		regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_ADC_DG, (0x1 << ADC_SWAP),
+				(0x1 << ADC_SWAP));
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const char * const sunxi_codec_adcswap_function[] = {
+				"Off", "On"};
+
+static const struct soc_enum sunxi_codec_adcswap_func_enum[] = {
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(sunxi_codec_adcswap_function),
+			sunxi_codec_adcswap_function),
+};
+
+/* sunxi codec dac src select */
+static int sunxi_codec_get_dacsrc_mode(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	unsigned int reg_val = 0;
+
+	regmap_read(sunxi_codec->codec_regmap, SUNXI_DAC_DPC, &reg_val);
+
+	ucontrol->value.integer.value[0] =
+				((reg_val & (0x1 << DAC_SRC_SEL)) ? 1 : 0);
+
+	sunxi_codec->dac_data_src = ucontrol->value.integer.value[0];
+
+	return 0;
+}
+
+static int sunxi_codec_set_dacsrc_mode(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	switch (ucontrol->value.integer.value[0]) {
+	case	0:
+		regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_DAC_DPC, (0x1 << DAC_SRC_SEL),
+				(0x0 << DAC_SRC_SEL));
+
+		sunxi_codec->dac_data_src = 0;
+		break;
+	case	1:
+		regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_DAC_DPC, (0x1 << DAC_SRC_SEL),
+				(0x1 << DAC_SRC_SEL));
+
+		sunxi_codec->dac_data_src = 1;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const char * const sunxi_codec_dacsrc_select[] = {
+				"APB", "I2S"};
+
+static const struct soc_enum sunxi_codec_dacsrc_sel_enum[] = {
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(sunxi_codec_dacsrc_select),
+			sunxi_codec_dacsrc_select),
+};
+
+/* SPK Output Control */
+static int sunxi_codec_speaker_event(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *k, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct codec_spk_config *spk_cfg = &(sunxi_codec->spk_cfg);
+//	struct codec_hw_config *hw_cfg = &(sunxi_codec->hw_config);
+
+	switch (event) {
+	case	SND_SOC_DAPM_POST_PMU:
+		if (spk_cfg->spk_used) {
+			gpio_direction_output(spk_cfg->spk_gpio, 1);
+			gpio_set_value(spk_cfg->spk_gpio, spk_cfg->pa_level);
+			/* time delay to wait spk pa work fine */
+			msleep(spk_cfg->pa_msleep);
+		}
+		break;
+	case	SND_SOC_DAPM_PRE_PMD:
+		if (spk_cfg->spk_used) {
+			gpio_set_value(spk_cfg->spk_gpio, !(spk_cfg->pa_level));
+		}
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+/* HPOUT Output Control */
+static int sunxi_codec_hpout_event(struct snd_soc_dapm_widget *w,
+			struct snd_kcontrol *k,	int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+//	struct codec_hw_config *hw_cfg = &(sunxi_codec->hw_config);
+
+	switch (event) {
+	case SND_SOC_DAPM_POST_PMU:
+#if 0
+		if (hw_cfg->dacdrc_cfg & DAP_HP_EN)
+			dacdrc_enable(component, 1);
+		if (hw_cfg->dachpf_cfg & DAP_HP_EN)
+			dachpf_enable(component, 1);
+#endif
+		/*open*/
+		regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_HP_REG, (0x1 << HPINPUTEN),
+				(0x1 << HPINPUTEN));
+		regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_HP_REG, (0x1 << HPOUTPUTEN),
+				(0x1 << HPOUTPUTEN));
+		regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_HP_REG, (0x1 << HPPA_EN),
+				(0x1 << HPPA_EN));
+		break;
+	case SND_SOC_DAPM_PRE_PMD:
+		/*close*/
+		regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_HP_REG, (0x1 << HPPA_EN),
+				(0x0 << HPPA_EN));
+		regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_HP_REG, (0x1 << HPOUTPUTEN),
+				(0x0 << HPOUTPUTEN));
+		regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_HP_REG, (0x1 << HPINPUTEN),
+				(0x0 << HPINPUTEN));
+
+#if 0
+		if (hw_cfg->dacdrc_cfg & DAP_HP_EN)
+			dacdrc_enable(component, 0);
+		if (hw_cfg->dachpf_cfg & DAP_HP_EN)
+			dachpf_enable(component, 0);
+#endif
+		break;
+	}
+
+	return 0;
+}
+
+/* LINEOUT Output Control */
+static int sunxi_codec_lineout_event(struct snd_soc_dapm_widget *w,
+				  struct snd_kcontrol *k, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+//	struct codec_spk_config *spk_cfg = &(sunxi_codec->spk_cfg);
+//	struct codec_hw_config *hw_cfg = &(sunxi_codec->hw_config);
+
+	switch (event) {
+	case	SND_SOC_DAPM_POST_PMU:
+#if 0
+		if (hw_cfg->dacdrc_cfg & DAP_SPK_EN)
+			dacdrc_enable(component, 1);
+		if (hw_cfg->dachpf_cfg & DAP_SPK_EN)
+			dachpf_enable(component, 1);
+#endif
+		/* DACL to left channel LINEOUT Mute control 0:mute 1: not mute */
+		regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_DAC_REG, (0x1 << DAC_LMUTE),
+				(0x1 << DAC_LMUTE));
+
+		regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_DAC_REG, (0x1 << DAC_LINEOUTLEN),
+				(0x1 << DAC_LINEOUTLEN));
+		break;
+	case	SND_SOC_DAPM_PRE_PMD:
+		regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_DAC_REG, (0x1 << DAC_LINEOUTLEN),
+				(0x0 << DAC_LINEOUTLEN));
+
+		/* DACL to left channel LINEOUT Mute control 0:mute 1: not mute */
+		regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_DAC_REG, (0x1 << DAC_LMUTE),
+				(0x0 << DAC_LMUTE));
+
+#if 0
+		if (hw_cfg->dacdrc_cfg & DAP_SPK_EN)
+			dacdrc_enable(component, 0);
+		if (hw_cfg->dachpf_cfg & DAP_SPK_EN)
+			dachpf_enable(component, 0);
+#endif
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+/* Digital DAC Enable */
+static int sunxi_codec_playback_event(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *k, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	switch (event) {
+	case	SND_SOC_DAPM_PRE_PMU:
+		regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_DAC_DPC, (0x1 << DAC_EN),
+				(0x1 << DAC_EN));
+		msleep(30);
+		break;
+	case	SND_SOC_DAPM_POST_PMD:
+		regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_DAC_DPC, (0x1 << DAC_EN),
+				(0x0 << DAC_EN));
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+/* Digital ADC Enable */
+static int sunxi_codec_capture_event(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *k, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	switch (event) {
+	case	SND_SOC_DAPM_POST_PMU:
+		/* delay 80ms to avoid the capture pop at the beginning */
+		mdelay(80);
+		regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_ADC_FIFOC, (0x1 << ADC_EN),
+				(0x1 << ADC_EN));
+		break;
+	case	SND_SOC_DAPM_POST_PMD:
+		regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_ADC_FIFOC, (0x1 << ADC_EN),
+				(0x0 << ADC_EN));
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static const struct snd_kcontrol_new sunxi_codec_controls[] = {
+	/* Audio Hub Output Enable */
+	SOC_ENUM_EXT("Audio Hub Output", sunxi_codec_hub_mode_enum[0],
+				sunxi_codec_get_hub_mode,
+				sunxi_codec_set_hub_mode),
+	/* Audio DAC Channel Output Swap */
+	SOC_ENUM_EXT("DAC Chan Swap", sunxi_codec_dacswap_func_enum[0],
+				sunxi_codec_get_dacswap_mode,
+				sunxi_codec_set_dacswap_mode),
+	/* Audio ADC Channel Input Swap */
+	SOC_ENUM_EXT("ADC Chan Swap", sunxi_codec_adcswap_func_enum[0],
+				sunxi_codec_get_adcswap_mode,
+				sunxi_codec_set_adcswap_mode),
+	/* Codec DAC Output Data Src Select */
+	SOC_ENUM_EXT("DAC Src Select", sunxi_codec_dacsrc_sel_enum[0],
+				sunxi_codec_get_dacsrc_mode,
+				sunxi_codec_set_dacsrc_mode),
+	/* Digital Volume */
+	SOC_SINGLE_TLV("digital volume", SUNXI_DAC_DPC,
+					DAC_DVOL, 0x3F, 1, digital_tlv),
+	/* DAC Volume */
+	SOC_DOUBLE_TLV("DAC Volume", SUNXI_DAC_VOL_CTRL, DAC_VOL_L, DAC_VOL_R,
+		       0xFF, 0, dac_vol_tlv),
+	/* ADC Volume */
+	SOC_DOUBLE_TLV("ADC Volume", SUNXI_ADC_VOL_CTRL, ADC_VOL_L, ADC_VOL_R,
+		       0xFF, 0, adc_vol_tlv),
+	/* LINEOUT Volume */
+	SOC_SINGLE_TLV("LINEOUT Volume", SUNXI_DAC_REG, DAC_LINEOUT_VOL,
+			0x1F, 0, lineout_tlv),
+	/* HPOUT Volume */
+	SOC_SINGLE_TLV("HPOUT Volume", SUNXI_DAC_REG, DAC_HP_GAIN,
+			0x7, 0, hpout_tlv),
+};
+
+/* lineinl controls */
+static const char * const lineinl_src_text[] = {"NULL", "LINEIN2", "LINEIN1"};
+
+static const struct soc_enum lineinl_src_enum =
+	SOC_ENUM_SINGLE(SUNXI_ADCL_REG, ADCL_LINEINL_SEL,
+			ARRAY_SIZE(lineinl_src_text), lineinl_src_text);
+
+static const struct snd_kcontrol_new lineinl_src_mux =
+	SOC_DAPM_ENUM("LINEINL", lineinl_src_enum);
+
+/* lineinr controls */
+static const char * const lineinr_src_text[] = {"NULL", "LINEIN2", "LINEIN1"};
+
+static const struct soc_enum lineinr_src_enum =
+	SOC_ENUM_SINGLE(SUNXI_ADCR_REG, ADCR_LINEINR_SEL,
+			ARRAY_SIZE(lineinr_src_text), lineinr_src_text);
+
+static const struct snd_kcontrol_new lineinr_src_mux =
+	SOC_DAPM_ENUM("LINEINR", lineinr_src_enum);
+
+/*audio dapm widget */
+static const struct snd_soc_dapm_widget sunxi_codec_dapm_widgets[] = {
+	SND_SOC_DAPM_AIF_IN_E("DACL", "Playback", 0, SUNXI_DAC_REG,
+				DACL_EN, 0,
+				sunxi_codec_playback_event,
+				SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+
+	SND_SOC_DAPM_AIF_IN_E("DACR", "Playback", 0, SUNXI_DAC_REG,
+				DACR_EN, 0,
+				sunxi_codec_playback_event,
+				SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+
+	SND_SOC_DAPM_AIF_OUT_E("ADCL", "Capture", 0, SUNXI_ADCL_REG,
+				ADCL_EN, 0,
+				sunxi_codec_capture_event,
+				SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
+
+	SND_SOC_DAPM_AIF_OUT_E("ADCR", "Capture", 0, SUNXI_ADCR_REG,
+				ADCR_EN, 0,
+				sunxi_codec_capture_event,
+				SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
+
+	SND_SOC_DAPM_MUX("LINEINL", SND_SOC_NOPM, 0, 0, &lineinl_src_mux),
+	SND_SOC_DAPM_MUX("LINEINR", SND_SOC_NOPM, 0, 0, &lineinr_src_mux),
+
+	SND_SOC_DAPM_PGA("LINEINL PGA", SUNXI_ADCL_REG, ADCL_LINEINL_EN, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("LINEINR PGA", SUNXI_ADCR_REG, ADCR_LINEINR_EN, 0, NULL, 0),
+
+//	SND_SOC_DAPM_MICBIAS("MainMic Bias", SUNXI_MICBIAS_REG, MMICBIASEN, 0),
+
+	SND_SOC_DAPM_LINE("LINEIN1L", NULL),
+	SND_SOC_DAPM_LINE("LINEIN1R", NULL),
+	SND_SOC_DAPM_LINE("LINEIN2L", NULL),
+	SND_SOC_DAPM_LINE("LINEIN2R", NULL),
+
+	SND_SOC_DAPM_OUTPUT("HPOUTL"),
+	SND_SOC_DAPM_OUTPUT("HPOUTR"),
+
+	SND_SOC_DAPM_OUTPUT("LINEOUTL"),
+	SND_SOC_DAPM_OUTPUT("LINEOUTR"),
+
+	SND_SOC_DAPM_HP("HPOUT", sunxi_codec_hpout_event),
+	SND_SOC_DAPM_LINE("LINEOUT", sunxi_codec_lineout_event),
+	SND_SOC_DAPM_SPK("Speaker", sunxi_codec_speaker_event),
+};
+
+static const struct snd_soc_dapm_route sunxi_codec_dapm_routes[] = {
+	/* LINEIN Input Route */
+	{"LINEINL", "LINEIN1", "LINEIN1L"},
+	{"LINEINL", "LINEIN2", "LINEIN2L"},
+	{"LINEINR", "LINEIN1", "LINEIN1R"},
+	{"LINEINR", "LINEIN2", "LINEIN2R"},
+
+	{"LINEINL PGA", NULL, "LINEINL"},
+	{"LINEINR PGA", NULL, "LINEINR"},
+
+	{"ADCL", NULL, "LINEINL PGA"},
+	{"ADCR", NULL, "LINEINR PGA"},
+
+	/* LINEOUT Output Route */
+	{"LINEOUTL", NULL, "DACL"},
+	{"LINEOUTR", NULL, "DACR"},
+
+	{"LINEOUT", NULL, "LINEOUTL"},
+	{"LINEOUT", NULL, "LINEOUTR"},
+
+	{"Speaker", NULL, "LINEOUT"},
+
+	/* HPOUT Output Route */
+	{"HPOUTL", NULL, "DACL"},
+	{"HPOUTR", NULL, "DACR"},
+
+	{"HPOUT", NULL, "HPOUTL"},
+	{"HPOUT", NULL, "HPOUTR"},
+
+	{"Speaker", NULL, "HPOUT"},
+};
+
+static void sunxi_codec_init(struct snd_soc_component *component)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	/* DAC_VOL_SEL default disabled */
+	regmap_update_bits(sunxi_codec->codec_regmap,
+			SUNXI_DAC_VOL_CTRL, (0x1 << DAC_VOL_SEL),
+			(0x1 << DAC_VOL_SEL));
+
+	/* ADC_VOL_SEL default disabled */
+	regmap_update_bits(sunxi_codec->codec_regmap,
+			SUNXI_ADC_VOL_CTRL, (0x1 << ADC_VOL_SEL),
+			(0x1 << ADC_VOL_SEL));
+
+	/* Enable ADCFDT to overcome niose at the beginning */
+	regmap_update_bits(sunxi_codec->codec_regmap,
+			SUNXI_ADC_FIFOC, (0x7 << ADC_DFEN),
+			(0x7 << ADC_DFEN));
+
+	/* Digital VOL defeult setting */
+	regmap_update_bits(sunxi_codec->codec_regmap,
+			SUNXI_DAC_DPC, 0x3F << DAC_DVOL,
+			sunxi_codec->digital_vol << DAC_DVOL);
+
+	/* LINEOUT VOL defeult setting */
+	regmap_update_bits(sunxi_codec->codec_regmap,
+			SUNXI_DAC_REG, 0x1F << DAC_LINEOUT_VOL,
+			sunxi_codec->lineout_vol << DAC_LINEOUT_VOL);
+
+	/* Headphone Gain defeult setting */
+	regmap_update_bits(sunxi_codec->codec_regmap,
+			SUNXI_DAC_REG, 0x7 << DAC_HP_GAIN,
+			sunxi_codec->hpout_vol << DAC_HP_GAIN);
+
+	/* ADCL/R IOP params default setting */
+	regmap_update_bits(sunxi_codec->codec_regmap,
+			SUNXI_ADCL_REG, 0xFF << ADCL_IOPMICL,
+			0x55 << ADCL_IOPMICL);
+	regmap_update_bits(sunxi_codec->codec_regmap,
+			SUNXI_ADCR_REG, 0xFF << ADCR_IOPMICL,
+			0x55 << ADCR_IOPMICL);
+
+	/* For improve performance of THD+N about HP */
+	regmap_update_bits(sunxi_codec->codec_regmap,
+			SUNXI_HP_REG, (0x3 << CP_CLKS),
+			(0x2 << CP_CLKS));
+
+	/* LINEOUT Output ways default setting: differential output */
+	regmap_update_bits(sunxi_codec->codec_regmap,
+			SUNXI_DAC_REG, 0x1 << DAC_LINEOUTLDIFFEN,
+			0x1 << DAC_LINEOUTLDIFFEN);
+	regmap_update_bits(sunxi_codec->codec_regmap,
+			SUNXI_DAC_REG, 0x1 << DAC_LINEOUTRDIFFEN,
+			0x1 << DAC_LINEOUTRDIFFEN);
+
+	/* To fix some pop noise */
+	regmap_update_bits(sunxi_codec->codec_regmap,
+			SUNXI_HP_REG, (0x1 << HPCALIFIRST),
+			(0x1 << HPCALIFIRST));
+
+	regmap_update_bits(sunxi_codec->codec_regmap,
+			SUNXI_HP_REG, (0x3 << HPPA_DEL),
+			(0x3 << HPPA_DEL));
+
+	regmap_update_bits(sunxi_codec->codec_regmap,
+			SUNXI_DAC_REG, (0x3 << DAC_CPLDO_VOLTAGE),
+			(0x1 << DAC_CPLDO_VOLTAGE));
+
+#if 0
+	if (sunxi_codec->hw_config.adcdrc_cfg)
+		adcdrc_config(component);
+	if (sunxi_codec->hw_config.adchpf_cfg)
+		adchpf_config(component);
+
+	if (sunxi_codec->hw_config.dacdrc_cfg)
+		dacdrc_config(component);
+	if (sunxi_codec->hw_config.dachpf_cfg)
+		dachpf_config(component);
+#endif
+}
+
+static int sunxi_codec_i2s_clk_setting(struct snd_soc_component *component)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct sunxi_codec_i2s_params *i2s_params = &sunxi_codec->i2s_params;
+	unsigned int mclk_div;
+
+	/* inter i2s mclk div setting */
+	if (i2s_params->mclk_div) {
+		switch (i2s_params->mclk_div) {
+		case	1:
+			mclk_div = INTER_I2S_MCLK_DIV_1;
+			break;
+		case	2:
+			mclk_div = INTER_I2S_MCLK_DIV_2;
+			break;
+		case	4:
+			mclk_div = INTER_I2S_MCLK_DIV_3;
+			break;
+		case	6:
+			mclk_div = INTER_I2S_MCLK_DIV_4;
+			break;
+		case	8:
+			mclk_div = INTER_I2S_MCLK_DIV_5;
+			break;
+		case	12:
+			mclk_div = INTER_I2S_MCLK_DIV_6;
+			break;
+		case	16:
+			mclk_div = INTER_I2S_MCLK_DIV_7;
+			break;
+		case	24:
+			mclk_div = INTER_I2S_MCLK_DIV_8;
+			break;
+		case	32:
+			mclk_div = INTER_I2S_MCLK_DIV_9;
+			break;
+		case	48:
+			mclk_div = INTER_I2S_MCLK_DIV_10;
+			break;
+		case	64:
+			mclk_div = INTER_I2S_MCLK_DIV_11;
+			break;
+		case	96:
+			mclk_div = INTER_I2S_MCLK_DIV_12;
+			break;
+		case	128:
+			mclk_div = INTER_I2S_MCLK_DIV_13;
+			break;
+		case	176:
+			mclk_div = INTER_I2S_MCLK_DIV_14;
+			break;
+		case	192:
+			mclk_div = INTER_I2S_MCLK_DIV_15;
+			break;
+		default:
+			LOG_ERR("unsupport mclk_div\n");
+			return -EINVAL;
+		}
+
+		/* setting Mclk output as external codec input clk */
+		regmap_update_bits(sunxi_codec->i2s_regmap,
+				INTER_I2S_CLKDIV, (0xF << I2S_MCLKDIV),
+				(mclk_div << I2S_MCLKDIV));
+
+		regmap_update_bits(sunxi_codec->i2s_regmap,
+				INTER_I2S_CLKDIV, (0x1 << I2S_MCLKOUT_EN),
+				(0x1 << I2S_MCLKOUT_EN));
+	} else {
+		regmap_update_bits(sunxi_codec->i2s_regmap,
+				INTER_I2S_CLKDIV, (0x1 << I2S_MCLKOUT_EN),
+				(0x0 << I2S_MCLKOUT_EN));
+	}
+
+	return 0;
+}
+
+static int sunxi_codec_i2s_fmt_setting(struct snd_soc_component *component,
+							unsigned int fmt)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	unsigned int lrck_polarity, brck_polarity;
+	unsigned int mode;
+
+	/* internal i2s part fmt setting */
+	/* internal i2s master / slave mode setting */
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case	SND_SOC_DAIFMT_CBM_CFM:
+		regmap_update_bits(sunxi_codec->i2s_regmap,
+				INTER_I2S_CTL, (0x1 << I2S_LRCK_OUT),
+				(0x0 << I2S_LRCK_OUT));
+
+		regmap_update_bits(sunxi_codec->i2s_regmap,
+				INTER_I2S_CTL, (0x1 << I2S_BCLK_OUT),
+				(0x0 << I2S_BCLK_OUT));
+		break;
+	case	SND_SOC_DAIFMT_CBS_CFS:
+		regmap_update_bits(sunxi_codec->i2s_regmap,
+				INTER_I2S_CTL, (0x1 << I2S_LRCK_OUT),
+				(0x1 << I2S_LRCK_OUT));
+
+		regmap_update_bits(sunxi_codec->i2s_regmap,
+				INTER_I2S_CTL, (0x1 << I2S_BCLK_OUT),
+				(0x1 << I2S_BCLK_OUT));
+		break;
+	default:
+		LOG_ERR("inter i2s part unknown master/slave format\n");
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case	SND_SOC_DAIFMT_LEFT_J:
+		mode = INTER_I2S_MODE_CTL_LEFT;
+		break;
+	case	SND_SOC_DAIFMT_RIGHT_J:
+		mode = INTER_I2S_MODE_CTL_RIGHT;
+		break;
+	default:
+		LOG_ERR("inter i2s format setting failed, maybe doesn't support it\n");
+		return -EINVAL;
+	}
+
+	regmap_update_bits(sunxi_codec->i2s_regmap,
+			INTER_I2S_CTL, (0x3 << I2S_MODE_SEL),
+			(mode << I2S_MODE_SEL));
+
+	/* linux-4.9 kernel: SND_SOC_DAIFMT_NB_NF: 1 */
+	/* linux-5.4 kernel: SND_SOC_DAIFMT_NB_NF: 0 */
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case	SND_SOC_DAIFMT_NB_NF:
+		lrck_polarity = INTER_I2S_LRCK_POLARITY_NOR;
+		brck_polarity = INTER_I2S_BCLK_POLARITY_NOR;
+		break;
+	case	SND_SOC_DAIFMT_NB_IF:
+		lrck_polarity = INTER_I2S_LRCK_POLARITY_INV;
+		brck_polarity = INTER_I2S_BCLK_POLARITY_NOR;
+		break;
+	case	SND_SOC_DAIFMT_IB_NF:
+		lrck_polarity = INTER_I2S_LRCK_POLARITY_NOR;
+		brck_polarity = INTER_I2S_BCLK_POLARITY_INV;
+		break;
+	case	SND_SOC_DAIFMT_IB_IF:
+		lrck_polarity = INTER_I2S_LRCK_POLARITY_INV;
+		brck_polarity = INTER_I2S_BCLK_POLARITY_INV;
+		break;
+	default:
+		LOG_ERR("inter i2s part: invert clk setting failed!\n");
+		return -EINVAL;
+	}
+
+	if (((fmt & SND_SOC_DAIFMT_FORMAT_MASK) == SND_SOC_DAIFMT_DSP_A) ||
+		((fmt & SND_SOC_DAIFMT_FORMAT_MASK) == SND_SOC_DAIFMT_DSP_B)) {
+		regmap_update_bits(sunxi_codec->i2s_regmap,
+				INTER_I2S_FMT0, (0x1 << I2S_LRCK_POLARITY),
+				((lrck_polarity^1) << I2S_LRCK_POLARITY));
+	} else {
+		regmap_update_bits(sunxi_codec->i2s_regmap,
+				INTER_I2S_FMT0, (0x1 << I2S_LRCK_POLARITY),
+				(lrck_polarity << I2S_LRCK_POLARITY));
+	}
+
+	regmap_update_bits(sunxi_codec->i2s_regmap,
+			INTER_I2S_FMT0, (0x1 << I2S_BCLK_POLARITY),
+			(brck_polarity << I2S_BCLK_POLARITY));
+
+	return 0;
+}
+
+static int sunxi_codec_i2s_clkdiv_setting(struct snd_soc_component *component,
+								int clk_div)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct sunxi_codec_i2s_params *i2s_params = &sunxi_codec->i2s_params;
+	unsigned int bclk_div, div_ratio;
+
+	/* internal i2s part clkdiv setting */
+	if (i2s_params->tdm_config) {
+		/* I2S/TDM two channel mode */
+		div_ratio = clk_div / (i2s_params->pcm_lrck_period * 2);
+	} else {
+		/* PCM mode */
+		div_ratio = clk_div / i2s_params->pcm_lrck_period;
+	}
+
+	switch (div_ratio) {
+	case	1:
+		bclk_div = INTER_I2S_BCLK_DIV_1;
+		break;
+	case	2:
+		bclk_div = INTER_I2S_BCLK_DIV_2;
+		break;
+	case	4:
+		bclk_div = INTER_I2S_BCLK_DIV_3;
+		break;
+	case	6:
+		bclk_div = INTER_I2S_BCLK_DIV_4;
+		break;
+	case	8:
+		bclk_div = INTER_I2S_BCLK_DIV_5;
+		break;
+	case	12:
+		bclk_div = INTER_I2S_BCLK_DIV_6;
+		break;
+	case	16:
+		bclk_div = INTER_I2S_BCLK_DIV_7;
+		break;
+	case	24:
+		bclk_div = INTER_I2S_BCLK_DIV_8;
+		break;
+	case	32:
+		bclk_div = INTER_I2S_BCLK_DIV_9;
+		break;
+	case	48:
+		bclk_div = INTER_I2S_BCLK_DIV_10;
+		break;
+	case	64:
+		bclk_div = INTER_I2S_BCLK_DIV_11;
+		break;
+	case	96:
+		bclk_div = INTER_I2S_BCLK_DIV_12;
+		break;
+	case	128:
+		bclk_div = INTER_I2S_BCLK_DIV_13;
+		break;
+	case	176:
+		bclk_div = INTER_I2S_BCLK_DIV_14;
+		break;
+	case	192:
+		bclk_div = INTER_I2S_BCLK_DIV_15;
+		break;
+	default:
+		LOG_ERR("inter i2s unsupport clk_div\n");
+		return -EINVAL;
+	}
+
+	LOG_ERR("clk_div: %d, pcm_lrck_period: %d, div_ratio: %d, bclk_div: %d\n",
+		clk_div, i2s_params->pcm_lrck_period, div_ratio, bclk_div);
+
+	/* setting bclk div */
+	regmap_update_bits(sunxi_codec->i2s_regmap,
+			INTER_I2S_CLKDIV, (0xF << I2S_BCLKDIV),
+			(bclk_div << I2S_BCLKDIV));
+
+	return 0;
+}
+
+static int sunxi_codec_i2s_init(struct snd_soc_component *component)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct sunxi_codec_i2s_params *i2s_params = &sunxi_codec->i2s_params;
+	unsigned int ret = 0;
+
+	i2s_params->i2s_global_enable = 0;
+
+	regmap_update_bits(sunxi_codec->i2s_regmap,
+			INTER_I2S_FMT0, (0x1 << I2S_LRCK_WIDTH),
+			(i2s_params->frame_type << I2S_LRCK_WIDTH));
+
+	regmap_update_bits(sunxi_codec->i2s_regmap,
+			INTER_I2S_FMT0, (0x3FF << I2S_LRCK_PERIOD),
+			((i2s_params->pcm_lrck_period - 1) << I2S_LRCK_PERIOD));
+
+	regmap_update_bits(sunxi_codec->i2s_regmap,
+			INTER_I2S_FMT0, (0x7 << I2S_SLOT_WIDTH),
+			(((i2s_params->slot_width_select >> 2) - 1) << I2S_SLOT_WIDTH));
+
+	/*
+	 * MSB on the transmit format, always be first.
+	 * default using Linear-PCM, without no companding.
+	 * A-law<Eourpean standard> or U-law<US-Japan> not working ok.
+	 */
+	/* TX setting MSB first default */
+	regmap_update_bits(sunxi_codec->i2s_regmap,
+			INTER_I2S_FMT1, (0x1 << I2S_TXMLS),
+			(0x0 << I2S_TXMLS));
+
+	/* RX setting MSB first default */
+	regmap_update_bits(sunxi_codec->i2s_regmap,
+			INTER_I2S_FMT1, (0x1 << I2S_RXMLS),
+			(0x0 << I2S_RXMLS));
+
+	/* sign extend setting default */
+	regmap_update_bits(sunxi_codec->i2s_regmap,
+			INTER_I2S_FMT1, (0x3 << I2S_SEXT),
+			(0x3 << I2S_SEXT));
+
+	ret = sunxi_codec_i2s_clk_setting(component);
+	if (ret) {
+		LOG_ERR("inter i2s clk settine faild!\n");
+	}
+
+	ret = sunxi_codec_i2s_fmt_setting(component, (i2s_params->audio_format
+		| (i2s_params->signal_inversion << 8)
+		| (i2s_params->daudio_master << 12)));
+	if (ret) {
+		LOG_ERR("inter i2s clk settine faild!\n");
+	}
+
+	return ret;
+}
+
+
+static int sunxi_codec_startup(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+#if 0
+	struct snd_soc_component *component = dai->component;
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		if (sunxi_codec->hw_config.adchpf_cfg)
+			adchpf_enable(component, 1);
+	}
+#endif
+
+	return 0;
+}
+
+static int sunxi_codec_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct snd_soc_component *component = dai->component;
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	int i = 0;
+
+	switch (params_format(params)) {
+	case	SNDRV_PCM_FORMAT_S16_LE:
+		/* internal i2s part 16bit setting */
+		regmap_update_bits(sunxi_codec->i2s_regmap,
+				INTER_I2S_FMT0, (0x7 << I2S_SR),
+				(0x3 << I2S_SR));
+
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			/* codec part playback bit setting */
+			regmap_update_bits(sunxi_codec->codec_regmap,
+					SUNXI_DAC_FIFOC, (0x3 << DAC_FIFO_MODE),
+					(0x3 << DAC_FIFO_MODE));
+			regmap_update_bits(sunxi_codec->codec_regmap,
+					SUNXI_DAC_FIFOC, (0x1 << DAC_SAMPLE_BITS),
+					(0x0 << DAC_SAMPLE_BITS));
+		} else {
+			/* codec part capture bit setting */
+			regmap_update_bits(sunxi_codec->codec_regmap,
+					SUNXI_ADC_FIFOC, (0x1 << ADC_FIFO_MODE),
+					(0x1 << ADC_FIFO_MODE));
+			regmap_update_bits(sunxi_codec->codec_regmap,
+					SUNXI_ADC_FIFOC, (0x1 << ADC_SAMPLE_BITS),
+					(0x0 << ADC_SAMPLE_BITS));
+		}
+		break;
+	case	SNDRV_PCM_FORMAT_S24_LE:
+		/* internal i2s part 20bit setting */
+		regmap_update_bits(sunxi_codec->i2s_regmap,
+				INTER_I2S_FMT0, (0x7 << I2S_SR),
+				(0x4 << I2S_SR));
+
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			/* codec part playback bit setting */
+			regmap_update_bits(sunxi_codec->codec_regmap,
+					SUNXI_DAC_FIFOC, (0x3 << DAC_FIFO_MODE),
+					(0x0 << DAC_FIFO_MODE));
+			regmap_update_bits(sunxi_codec->codec_regmap,
+					SUNXI_DAC_FIFOC, (0x1 << DAC_SAMPLE_BITS),
+					(0x1 << DAC_SAMPLE_BITS));
+		} else {
+			/* codec part capture bit setting */
+			regmap_update_bits(sunxi_codec->codec_regmap,
+					SUNXI_ADC_FIFOC, (0x1 << ADC_FIFO_MODE),
+					(0x0 << ADC_FIFO_MODE));
+			regmap_update_bits(sunxi_codec->codec_regmap,
+					SUNXI_ADC_FIFOC, (0x1 << ADC_SAMPLE_BITS),
+					(0x1 << ADC_SAMPLE_BITS));
+		}
+		break;
+	default:
+		LOG_ERR("unsupprt format!\n");
+		break;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(sample_rate_conv); i++) {
+		if (sample_rate_conv[i].samplerate == params_rate(params)) {
+			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+				regmap_update_bits(sunxi_codec->codec_regmap,
+					SUNXI_DAC_FIFOC, (0x7 << DAC_FS),
+					(sample_rate_conv[i].rate_bit << DAC_FS));
+			} else {
+				if (sample_rate_conv[i].samplerate > 48000) {
+					return -EINVAL;
+				}
+				regmap_update_bits(sunxi_codec->codec_regmap,
+					SUNXI_ADC_FIFOC, (0x7 << ADC_FS),
+					(sample_rate_conv[i].rate_bit<<ADC_FS));
+			}
+		}
+	}
+
+#if 0
+	/* reset the adchpf func setting for different sampling */
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		if (sunxi_codec->hw_config.adchpf_cfg) {
+			if (params_rate(params) == 16000) {
+				regmap_write(sunxi_codec->codec_regmap,
+						SUNXI_ADC_DRC_HHPFC,
+						(0x00F623A5 >> 16) & 0xFFFF);
+
+				regmap_write(sunxi_codec->codec_regmap,
+						SUNXI_ADC_DRC_LHPFC,
+						0x00F623A5 & 0xFFFF);
+			} else if (params_rate(params) == 44100) {
+				regmap_write(sunxi_codec->codec_regmap,
+						SUNXI_ADC_DRC_HHPFC,
+						(0x00FC60DB >> 16) & 0xFFFF);
+				regmap_write(sunxi_codec->codec_regmap,
+						SUNXI_ADC_DRC_LHPFC,
+						0x00FC60DB & 0xFFFF);
+			} else {
+				regmap_write(sunxi_codec->codec_regmap,
+						SUNXI_ADC_DRC_HHPFC,
+						(0x00FCABB3 >> 16) & 0xFFFF);
+				regmap_write(sunxi_codec->codec_regmap,
+						SUNXI_ADC_DRC_LHPFC,
+						0x00FCABB3 & 0xFFFF);
+			}
+		}
+	}
+#endif
+
+	/* internal codec part channels setting and mapping */
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		/* default setting TX0 */
+		regmap_write(sunxi_codec->i2s_regmap,
+				INTER_I2S_TX0CHMAP0,
+				0xFEDCBA98);
+
+		regmap_write(sunxi_codec->i2s_regmap,
+				INTER_I2S_TX0CHMAP1,
+				0x76543210);
+
+		regmap_update_bits(sunxi_codec->i2s_regmap,
+				INTER_I2S_TX0CHSEL, (0xF << I2S_TX0_CHSEL),
+				((params_channels(params)-1) << I2S_TX0_CHSEL));
+
+		regmap_update_bits(sunxi_codec->i2s_regmap,
+				INTER_I2S_TX0CHSEL, (0xFFFF << I2S_TX0_CHEN),
+				((0x1 << params_channels(params))-1) << I2S_TX0_CHEN);
+
+	} else {
+		/* default setting RX */
+		regmap_write(sunxi_codec->i2s_regmap,
+				INTER_I2S_RXCHMAP3,
+				0x03020100);
+
+		regmap_update_bits(sunxi_codec->i2s_regmap,
+				INTER_I2S_RXCHSEL, (0xF << I2S_RX_CHSEL),
+				((params_channels(params)-1) << I2S_RX_CHSEL));
+	}
+
+	/* codec part channels setting */
+	switch (params_channels(params)) {
+	case 1:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			regmap_update_bits(sunxi_codec->codec_regmap,
+					SUNXI_DAC_FIFOC, (0x1 << DAC_MONO_EN),
+					0x1 << DAC_MONO_EN);
+		} else {
+			regmap_update_bits(sunxi_codec->codec_regmap,
+					SUNXI_ADC_FIFOC, (0x3 << ADC_CHAN_EN),
+					(0x1 << ADC_CHAN_EN));
+		}
+		break;
+	case 2:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			regmap_update_bits(sunxi_codec->codec_regmap,
+					SUNXI_DAC_FIFOC, (0x1 << DAC_MONO_EN),
+					(0x0 << DAC_MONO_EN));
+		} else {
+			regmap_update_bits(sunxi_codec->codec_regmap,
+					SUNXI_ADC_FIFOC, (0x3 << ADC_CHAN_EN),
+					(0x3 << ADC_CHAN_EN));
+		}
+		break;
+	default:
+		LOG_ERR("[%s] only support mono or stereo mode.\n", __func__);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sunxi_codec_set_sysclk(struct snd_soc_dai *dai,
+			int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_component *component = dai->component;
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	switch (clk_id) {
+	case	0:
+		/* For setting the clk source to 90.3168M to surpport playback */
+#if 0
+		if (clk_set_parent(sunxi_codec->dacclk, sunxi_codec->pllcomdiv5)) {
+			LOG_ERR("set parent of dacclk to pllcomdiv5 failed\n");
+			return -EINVAL;
+		}
+#endif
+		if (clk_set_rate(sunxi_codec->dacclk, freq)) {
+			LOG_ERR("codec set dac clk rate failed\n");
+			return -EINVAL;
+		}
+		break;
+	case	1:
+#if 0
+		/* For setting the clk source to 90.3168M to surpport capture */
+		if (clk_set_parent(sunxi_codec->adcclk, sunxi_codec->pllcomdiv5)) {
+			LOG_ERR("set parent of adcclk to pllcomdiv5 failed\n");
+			return -EINVAL;
+		}
+#endif
+		if (clk_set_rate(sunxi_codec->adcclk, freq)) {
+			LOG_ERR("codec set adc clk rate failed\n");
+			return -EINVAL;
+		}
+		break;
+	case	2:
+		/* For setting the clk source to 98.304M to surpport playback */
+		if (clk_set_parent(sunxi_codec->dacclk, sunxi_codec->pllclk)) {
+			LOG_ERR("set parent of dacclk to pllclk failed\n");
+			return -EINVAL;
+		}
+
+		if (clk_set_rate(sunxi_codec->dacclk, freq)) {
+			LOG_ERR("codec set dac clk rate failed\n");
+			return -EINVAL;
+		}
+		break;
+	case	3:
+		/* For setting the clk source to 98.304M to surpport capture */
+		if (clk_set_parent(sunxi_codec->adcclk, sunxi_codec->pllclk)) {
+			LOG_ERR("set parent of adcclk to pllclk failed\n");
+			return -EINVAL;
+		}
+
+		if (clk_set_rate(sunxi_codec->adcclk, freq)) {
+			LOG_ERR("codec set adc clk rate failed\n");
+			return -EINVAL;
+		}
+		break;
+	default:
+		LOG_ERR("Bad clk params input!\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sunxi_codec_set_clkdiv(struct snd_soc_dai *dai,
+						int clk_id, int clk_div)
+{
+	struct snd_soc_component *component = dai->component;
+	unsigned int ret = 0;
+
+	/* inter i2s clk div setting */
+	ret = sunxi_codec_i2s_clkdiv_setting(component, clk_div);
+
+	return ret;
+}
+
+static void sunxi_codec_shutdown(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+#if 0
+	struct snd_soc_component *component = dai->component;
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		if (sunxi_codec->hw_config.adchpf_cfg)
+			adchpf_enable(component, 0);
+	}
+#endif
+}
+
+static int sunxi_codec_prepare(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	struct snd_soc_component *component = dai->component;
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_DAC_FIFOC, (0x1 << DAC_FIFO_FLUSH),
+				(0x1 << DAC_FIFO_FLUSH));
+		regmap_write(sunxi_codec->codec_regmap,
+				SUNXI_DAC_FIFOS,
+				(0x1 << DAC_TXE_INT | 0x1 << DAC_TXU_INT | 0x1 << DAC_TXO_INT));
+		regmap_write(sunxi_codec->codec_regmap,
+				SUNXI_DAC_CNT,
+				0x0);
+	} else {
+		regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_ADC_FIFOC, (0x1 << ADC_FIFO_FLUSH),
+				(0x1 << ADC_FIFO_FLUSH));
+		regmap_write(sunxi_codec->codec_regmap,
+				SUNXI_ADC_FIFOS,
+				(0x1 << ADC_RXA_INT | 0x1 << ADC_RXO_INT));
+		regmap_write(sunxi_codec->codec_regmap,
+				SUNXI_ADC_CNT,
+				0x0);
+	}
+
+	return 0;
+}
+
+static void sunxi_codec_enable(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai, bool enable)
+{
+	struct sunxi_codec_info *sunxi_codec =
+				snd_soc_component_get_drvdata(dai->component);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_DAC_FIFOC, (0x1 << DAC_DRQ_EN),
+				(enable << DAC_DRQ_EN));
+	} else {
+		regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_ADC_FIFOC, (0x1 << ADC_DRQ_EN),
+				(enable << ADC_DRQ_EN));
+	}
+}
+
+static void sunxi_codec_i2s_enable(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai, bool enable)
+{
+	struct sunxi_codec_info *sunxi_codec =
+				snd_soc_component_get_drvdata(dai->component);
+	struct sunxi_codec_i2s_params *i2s_params = &sunxi_codec->i2s_params;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		/* internal i2s tx enable */
+		regmap_update_bits(sunxi_codec->i2s_regmap,
+				INTER_I2S_CTL, (0x1 << I2S_DOUT0_EN),
+				(enable << I2S_DOUT0_EN));
+
+		regmap_update_bits(sunxi_codec->i2s_regmap,
+				INTER_I2S_CTL, (0x1 << I2S_TXEN),
+				(enable << I2S_TXEN));
+	} else {
+		/* internal i2s rx enable */
+		regmap_update_bits(sunxi_codec->i2s_regmap,
+				INTER_I2S_CTL, (0x1 << I2S_RXEN),
+				(enable << I2S_RXEN));
+	}
+
+	/* internal i2s global enable */
+	if (enable) {
+		if (i2s_params->i2s_global_enable++ == 0) {
+			regmap_update_bits(sunxi_codec->i2s_regmap,
+					INTER_I2S_CTL, (0x1 << I2S_GEN),
+					(0x1 << I2S_GEN));
+		}
+	} else {
+		if (--i2s_params->i2s_global_enable <= 0) {
+			i2s_params->i2s_global_enable = 0;
+			regmap_update_bits(sunxi_codec->i2s_regmap,
+					INTER_I2S_CTL, (0x1 << I2S_GEN),
+					(0x0 << I2S_GEN));
+		}
+	}
+}
+
+static int sunxi_codec_trigger(struct snd_pcm_substream *substream,
+				int cmd, struct snd_soc_dai *dai)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(dai->component);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		/* if dac data src is form i2s, then should enable it first */
+		if (sunxi_codec->dac_data_src == 1) {
+			/* internal i2s part enable */
+			sunxi_codec_i2s_enable(substream, dai, true);
+		} else {
+			/* internal codec part enable */
+			sunxi_codec_enable(substream, dai, true);
+		}
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		/* if dac data src is form i2s, then should disable it first */
+		if (sunxi_codec->dac_data_src == 1) {
+			/* internal i2s part disable */
+			sunxi_codec_i2s_enable(substream, dai, false);
+		} else {
+			/* internal codec part disable */
+			sunxi_codec_enable(substream, dai, false);
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops sunxi_codec_dai_ops = {
+	.startup	= sunxi_codec_startup,
+	.hw_params	= sunxi_codec_hw_params,
+	.shutdown	= sunxi_codec_shutdown,
+	.set_sysclk	= sunxi_codec_set_sysclk,
+	.set_clkdiv	= sunxi_codec_set_clkdiv,
+	.trigger	= sunxi_codec_trigger,
+	.prepare	= sunxi_codec_prepare,
+};
+
+static struct snd_soc_dai_driver sunxi_codec_dai[] = {
+	{
+		.name	= "sun50iw12codec",
+		.playback = {
+			.stream_name = "Playback",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates	= SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE,
+		},
+		.capture = {
+			.stream_name = "Capture",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = SNDRV_PCM_RATE_8000_48000
+				| SNDRV_PCM_RATE_KNOT,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE,
+		},
+		.ops = &sunxi_codec_dai_ops,
+	},
+};
+
+static int sunxi_codec_probe(struct snd_soc_component *component)
+{
+	struct snd_soc_dapm_context *dapm = &component->dapm;
+	int ret;
+
+	ret = snd_soc_add_component_controls(component, sunxi_codec_controls,
+					ARRAY_SIZE(sunxi_codec_controls));
+	if (ret) {
+		LOG_ERR("failed to register codec controls!\n");
+		return -EINVAL;
+	}
+
+	snd_soc_dapm_new_controls(dapm, sunxi_codec_dapm_widgets,
+				ARRAY_SIZE(sunxi_codec_dapm_widgets));
+	snd_soc_dapm_add_routes(dapm, sunxi_codec_dapm_routes,
+				ARRAY_SIZE(sunxi_codec_dapm_routes));
+
+	sunxi_codec_init(component);
+
+	sunxi_codec_i2s_init(component);
+
+	return 0;
+}
+
+static void sunxi_codec_remove(struct snd_soc_component *component)
+{
+
+}
+
+static int save_audio_reg(struct sunxi_codec_info *sunxi_codec)
+{
+	int i = 0;
+
+	while (codec_reg_labels[i].name != NULL) {
+		regmap_read(sunxi_codec->codec_regmap,
+				codec_reg_labels[i].address,
+				&codec_reg_labels[i].value);
+		i++;
+	}
+
+	while (i2s_reg_labels[i].name != NULL) {
+		regmap_read(sunxi_codec->i2s_regmap,
+				i2s_reg_labels[i].address,
+				&i2s_reg_labels[i].value);
+		i++;
+	}
+
+	return 0;
+}
+
+static int echo_audio_reg(struct sunxi_codec_info *sunxi_codec)
+{
+	int i = 0;
+
+	while (codec_reg_labels[i].name != NULL) {
+		regmap_write(sunxi_codec->codec_regmap,
+				codec_reg_labels[i].address,
+				codec_reg_labels[i].value);
+		i++;
+	}
+
+	while (i2s_reg_labels[i].name != NULL) {
+		regmap_write(sunxi_codec->i2s_regmap,
+				i2s_reg_labels[i].address,
+				i2s_reg_labels[i].value);
+		i++;
+	}
+
+	return 0;
+}
+
+static int sunxi_codec_suspend(struct snd_soc_component *component)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct codec_spk_config *spk_cfg = &(sunxi_codec->spk_cfg);
+
+	pr_debug("Enter %s\n", __func__);
+	save_audio_reg(sunxi_codec);
+
+	if (spk_cfg->spk_used)
+		gpio_set_value(spk_cfg->spk_gpio, !(spk_cfg->pa_level));
+
+	if (sunxi_codec->vol_supply.avcc)
+		regulator_disable(sunxi_codec->vol_supply.avcc);
+
+	if (sunxi_codec->vol_supply.cpvin)
+		regulator_disable(sunxi_codec->vol_supply.cpvin);
+
+	clk_disable_unprepare(sunxi_codec->dacclk);
+	clk_disable_unprepare(sunxi_codec->adcclk);
+	clk_disable_unprepare(sunxi_codec->pllclk);
+	clk_disable_unprepare(sunxi_codec->codec_clk_bus);
+	reset_control_assert(sunxi_codec->codec_clk_rst);
+
+	pr_debug("End %s\n", __func__);
+
+	return 0;
+}
+
+static int sunxi_codec_resume(struct snd_soc_component *component)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct codec_spk_config *spk_cfg = &(sunxi_codec->spk_cfg);
+	unsigned int ret;
+
+	pr_debug("Enter %s\n", __func__);
+
+	if (sunxi_codec->vol_supply.avcc) {
+		ret = regulator_enable(sunxi_codec->vol_supply.avcc);
+		if (ret)
+			LOG_ERR("[%s]: resume avcc enable failed!\n", __func__);
+	}
+
+	if (sunxi_codec->vol_supply.cpvin) {
+		ret = regulator_enable(sunxi_codec->vol_supply.cpvin);
+		if (ret)
+			LOG_ERR("[%s]: resume cpvin enable failed!\n", __func__);
+	}
+
+	if (clk_set_rate(sunxi_codec->pllclk, 98304000)) {
+		LOG_ERR("audiocodec: resume codec source set pllclk rate failed\n");
+		return -EBUSY;
+	}
+
+	if (reset_control_deassert(sunxi_codec->codec_clk_rst)) {
+		LOG_ERR("audiocodec: resume deassert the codec reset failed\n");
+		return -EBUSY;
+	}
+
+	if (clk_prepare_enable(sunxi_codec->codec_clk_bus)) {
+		LOG_ERR("enable codec bus clk failed, resume exit\n");
+		return -EBUSY;
+	}
+
+	if (clk_prepare_enable(sunxi_codec->pllclk)) {
+		LOG_ERR("enable pllclk failed, resume exit\n");
+		return -EBUSY;
+	}
+
+	if (clk_prepare_enable(sunxi_codec->dacclk)) {
+		LOG_ERR("enable dacclk failed, resume exit\n");
+		return -EBUSY;
+	}
+
+	if (clk_prepare_enable(sunxi_codec->adcclk)) {
+		LOG_ERR("enable  adcclk failed, resume exit\n");
+		clk_disable_unprepare(sunxi_codec->adcclk);
+		return -EBUSY;
+	}
+
+	if (spk_cfg->spk_used) {
+		gpio_direction_output(spk_cfg->spk_gpio, 1);
+		gpio_set_value(spk_cfg->spk_gpio, !(spk_cfg->pa_level));
+	}
+
+	sunxi_codec_init(component);
+	echo_audio_reg(sunxi_codec);
+
+	pr_debug("End %s\n", __func__);
+
+	return 0;
+}
+
+static unsigned int sunxi_codec_read(struct snd_soc_component *component,
+					unsigned int reg)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	unsigned int reg_val = 0;
+
+	regmap_read(sunxi_codec->codec_regmap, reg, &reg_val);
+
+	return reg_val;
+}
+
+static int sunxi_codec_write(struct snd_soc_component *component,
+				unsigned int reg, unsigned int val)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	regmap_write(sunxi_codec->codec_regmap, reg, val);
+
+	return 0;
+};
+
+static struct snd_soc_component_driver soc_codec_dev_sunxi = {
+	.probe = sunxi_codec_probe,
+	.remove = sunxi_codec_remove,
+	.suspend = sunxi_codec_suspend,
+	.resume = sunxi_codec_resume,
+	.read = sunxi_codec_read,
+	.write = sunxi_codec_write,
+};
+
+/* audiocodec reg dump about */
+static ssize_t show_audio_reg(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct sunxi_codec_info *sunxi_codec = dev_get_drvdata(dev);
+	unsigned int size1 = ARRAY_SIZE(codec_reg_labels);
+	unsigned int size2 = ARRAY_SIZE(i2s_reg_labels);
+	unsigned int reg_val = 0;
+	int count = 0, i = 0;
+
+	count += sprintf(buf, "dump audiocodec reg --> codec part:\n");
+
+	while ((i < size1) && (codec_reg_labels[i].name != NULL)) {
+		regmap_read(sunxi_codec->codec_regmap,
+				codec_reg_labels[i].address, &reg_val);
+		count += sprintf(buf + count, "%-20s [0x%03x]: 0x%-10x save_val:0x%x\n",
+			codec_reg_labels[i].name, (codec_reg_labels[i].address),
+			reg_val, codec_reg_labels[i].value);
+		i++;
+	}
+
+	count += sprintf(buf, "dump audiocodec reg --> internal i2s part:\n");
+
+	while ((i < size2) && (i2s_reg_labels[i].name != NULL)) {
+		regmap_read(sunxi_codec->i2s_regmap,
+				i2s_reg_labels[i].address, &reg_val);
+		count += sprintf(buf + count, "%-20s [0x%03x]: 0x%-10x save_val:0x%x\n",
+			i2s_reg_labels[i].name, (i2s_reg_labels[i].address),
+			reg_val, i2s_reg_labels[i].value);
+		i++;
+	}
+
+	return count;
+}
+
+/* Note:
+ * param 1: 0 -> codec part;	1 -> internal i2s part;
+ * param 2: 0 -> to read;		1 -> to write;
+ * param 3: the reg value what you want to read or write;
+ * param 4: the write value what you want to write in;
+ * For Examples:
+READ:
+*	read the codec part reg's value:
+		echo 0,0,0x00 > audiocodec_reg
+*	read the internal i2s part reg's value:
+		echo 1,0,0x00 > audiocodec_reg
+WRITE:
+	write the value:0x0a to the codec part reg: 0x00:
+		echo 0,1,0x00,0x0a > audiocodec_reg
+	write the value:0x0a to the internal i2s part reg: 0x00:
+		echo 1,1,0x00,0x0a > audiocodec_reg
+*/
+static ssize_t store_audio_reg(struct device *dev, struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	struct sunxi_codec_info *sunxi_codec = dev_get_drvdata(dev);
+	int input_reg_val = 0;
+	int input_reg_offset = 0;
+	int reg_flag;
+	int rw_flag;
+	int ret;
+
+	ret = sscanf(buf, "%d,%d,0x%x,0x%x",
+			&reg_flag, &rw_flag, &input_reg_offset, &input_reg_val);
+
+	LOG_INFO("reg flag:%d, rw_flag:%d, reg_offset:%d, reg_val:0x%x\n",
+			reg_flag, rw_flag, input_reg_offset, input_reg_val);
+
+	if (!(reg_flag == 1 || reg_flag == 0)) {
+		LOG_ERR("the reg_flag input false! -> 0: codec part; 1: internal i2s part;\n");
+		ret = count;
+		goto out;
+	}
+
+	if (!(rw_flag == 1 || rw_flag == 0)) {
+		LOG_ERR("the rw_flag input false! -> 0: to read; 1: to write;\n");
+		ret = count;
+		goto out;
+	}
+
+	if (reg_flag == 0) {
+		if (input_reg_offset > SUNXI_HMIC_STS) {
+			LOG_ERR("ERROR: the reg offset[0x%03x] > THE MAX REG[0x%03x]\n",
+				input_reg_offset, SUNXI_HMIC_STS);
+			ret = count;
+			goto out;
+		}
+
+		if (rw_flag) {
+			regmap_write(sunxi_codec->codec_regmap,
+					input_reg_offset, input_reg_val);
+		} else {
+			regmap_read(sunxi_codec->codec_regmap,
+					input_reg_offset, &input_reg_val);
+			LOG_INFO("\n\n Reg[0x%x] : 0x%08x\n\n",
+					input_reg_offset, input_reg_val);
+		}
+	}
+
+	if (reg_flag == 1) {
+		if (input_reg_offset > INTER_I2S_REV) {
+			LOG_ERR("ERROR: the reg offset[0x%03x] > THE MAX REG[0x%03x]\n",
+				input_reg_offset, SUNXI_BIAS_REG);
+			ret = count;
+			goto out;
+		}
+
+		if (rw_flag) {
+			regmap_write(sunxi_codec->i2s_regmap,
+					input_reg_offset, input_reg_val);
+		} else {
+			regmap_read(sunxi_codec->i2s_regmap,
+					input_reg_offset, &input_reg_val);
+			LOG_INFO("\n\n Reg[0x%x] : 0x%08x\n\n",
+					input_reg_offset, input_reg_val);
+		}
+	}
+
+	ret = count;
+out:
+	return ret;
+}
+
+static DEVICE_ATTR(audiocodec_reg, 0644, show_audio_reg, store_audio_reg);
+
+static struct attribute *audio_debug_attrs[] = {
+	&dev_attr_audiocodec_reg.attr,
+	NULL,
+};
+
+static struct attribute_group audio_debug_attr_group = {
+	.name   = "audiocodec_reg_dump",
+	.attrs  = audio_debug_attrs,
+};
+
+/* codec regmap configuration */
+static const struct regmap_config sunxi_codec_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = SUNXI_HMIC_STS,
+	.cache_type = REGCACHE_NONE,
+};
+
+/* internal i2s regmap configuration */
+static const struct regmap_config sunxi_i2s_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = INTER_I2S_REV,
+	.cache_type = REGCACHE_NONE,
+};
+
+static int sunxi_codec_regulator_init(struct platform_device *pdev,
+				struct sunxi_codec_info *sunxi_codec)
+{
+	int ret = 0;
+
+	sunxi_codec->vol_supply.avcc = regulator_get(&pdev->dev, "avcc");
+	if (IS_ERR(sunxi_codec->vol_supply.avcc)) {
+		LOG_ERR("get audio avcc failed\n");
+	} else {
+		ret = regulator_set_voltage(sunxi_codec->vol_supply.avcc,
+							1800000, 1800000);
+		if (ret) {
+			LOG_ERR("avcc set vol failed\n");
+			goto err_regulator_avcc;
+		}
+
+		ret = regulator_enable(sunxi_codec->vol_supply.avcc);
+		if (ret) {
+			LOG_ERR("avcc enable failed!\n");
+			goto err_regulator_avcc;
+		}
+	}
+
+	sunxi_codec->vol_supply.cpvin = regulator_get(&pdev->dev, "cpvin");
+	if (IS_ERR(sunxi_codec->vol_supply.cpvin)) {
+		LOG_ERR("get audio cpvin failed\n");
+		goto err_regulator_avcc;
+	} else {
+		ret = regulator_set_voltage(sunxi_codec->vol_supply.cpvin,
+							1800000, 1800000);
+		if (ret) {
+			LOG_ERR("cpvin set vol failed\n");
+			goto err_regulator_cpvin;
+		}
+
+		ret = regulator_enable(sunxi_codec->vol_supply.cpvin);
+		if (ret) {
+			LOG_ERR("cpvin enable failed!\n");
+			goto err_regulator_cpvin;
+		}
+	}
+
+	return 0;
+
+err_regulator_cpvin:
+	regulator_put(sunxi_codec->vol_supply.cpvin);
+err_regulator_avcc:
+	regulator_put(sunxi_codec->vol_supply.avcc);
+	return ret;
+}
+
+static int sunxi_codec_clk_init(struct device_node *np,
+				struct platform_device *pdev,
+				struct sunxi_codec_info *sunxi_codec)
+{
+	int ret = 0;
+
+	/* get the parent clk and the module clk */
+	sunxi_codec->pllclk = of_clk_get_by_name(np, "pll_audio");
+	sunxi_codec->dacclk = of_clk_get_by_name(np, "codec_dac");
+	sunxi_codec->adcclk = of_clk_get_by_name(np, "codec_adc");
+	sunxi_codec->codec_clk_bus = of_clk_get_by_name(np, "codec_bus");
+	sunxi_codec->codec_clk_rst = devm_reset_control_get(&pdev->dev, NULL);
+
+	if (reset_control_deassert(sunxi_codec->codec_clk_rst)) {
+		LOG_ERR("deassert the codec reset failed\n");
+		goto err_devm_kfree;
+	}
+
+	if (clk_set_parent(sunxi_codec->dacclk, sunxi_codec->pllclk)) {
+		LOG_ERR("set parent of dacclk to pllclk failed\n");
+		goto err_devm_kfree;
+	}
+
+	if (clk_set_parent(sunxi_codec->adcclk, sunxi_codec->pllclk)) {
+		LOG_ERR("set parent of adcclk to pllclk failed\n");
+		goto err_devm_kfree;
+	}
+
+	if (clk_set_rate(sunxi_codec->pllclk, 98304000)) {
+		LOG_ERR("codec source set pllclk rate failed\n");
+		goto err_devm_kfree;
+	}
+
+	if (clk_prepare_enable(sunxi_codec->codec_clk_bus)) {
+		LOG_ERR("codec clk bus enable failed\n");
+		goto err_devm_kfree;
+	}
+
+	if (clk_prepare_enable(sunxi_codec->pllclk)) {
+		LOG_ERR("pllclk enable failed\n");
+		goto err_bus_kfree;
+	}
+
+	if (clk_prepare_enable(sunxi_codec->dacclk)) {
+		LOG_ERR("dacclk enable failed\n");
+		goto err_pllclk_kfree;
+	}
+
+	if (clk_prepare_enable(sunxi_codec->adcclk)) {
+		LOG_ERR("moduleclk enable failed\n");
+		goto err_dacclk_kfree;
+	}
+
+	return 0;
+
+err_dacclk_kfree:
+	clk_disable_unprepare(sunxi_codec->dacclk);
+err_pllclk_kfree:
+	clk_disable_unprepare(sunxi_codec->pllclk);
+err_bus_kfree:
+	clk_disable_unprepare(sunxi_codec->codec_clk_bus);
+err_devm_kfree:
+	return ret;
+}
+
+static int sunxi_codec_parse_params(struct device_node *np,
+				struct platform_device *pdev,
+				struct sunxi_codec_info *sunxi_codec)
+{
+	struct sunxi_codec_i2s_params *i2s_params = &sunxi_codec->i2s_params;
+	unsigned int temp_val = 0;
+	int ret = 0;
+
+	/* get the special property form the board.dts */
+	ret = of_property_read_u32(np, "digital_vol", &temp_val);
+	if (ret < 0) {
+		LOG_WARN("digital volume get failed, use default value: 0\n");
+		sunxi_codec->digital_vol = 0;
+	} else {
+		sunxi_codec->digital_vol = temp_val;
+	}
+
+	/* lineout volume */
+	ret = of_property_read_u32(np, "lineout_vol", &temp_val);
+	if (ret < 0) {
+		LOG_WARN("lineout volume get failed, use default value: 0\n");
+		sunxi_codec->lineout_vol = 0;
+	} else {
+		sunxi_codec->lineout_vol = temp_val;
+	}
+
+	/* hpout volume */
+	ret = of_property_read_u32(np, "hpout_vol", &temp_val);
+	if (ret < 0) {
+		LOG_WARN("hpout volume get failed, use default value: 0\n");
+		sunxi_codec->hpout_vol = 0;
+	} else {
+		sunxi_codec->hpout_vol = temp_val;
+	}
+
+	/* PA/SPK enable property */
+	ret = of_property_read_u32(np, "spk_used", &temp_val);
+	if (ret < 0) {
+		LOG_WARN("spk_used get failed, use default value: 0\n");
+		sunxi_codec->spk_cfg.spk_used = 0;
+	} else {
+		sunxi_codec->spk_cfg.spk_used = temp_val;
+	}
+
+	/* Pa's delay time(ms) to work fine */
+	ret = of_property_read_u32(np, "pa_msleep_time", &temp_val);
+	if (ret < 0) {
+		LOG_WARN("pa_msleep get failed, use default value: 160\n");
+		sunxi_codec->spk_cfg.pa_msleep = 160;
+	} else {
+		sunxi_codec->spk_cfg.pa_msleep = temp_val;
+	}
+
+	/* PA/SPK enable property */
+	ret = of_property_read_u32(np, "pa_level", &temp_val);
+	if (ret < 0) {
+		LOG_WARN("pa_level get failed, use default value: 1\n");
+		sunxi_codec->spk_cfg.pa_level = 1;
+	} else {
+		sunxi_codec->spk_cfg.pa_level = temp_val;
+	}
+
+	LOG_INFO("digital_vol:%d, lineout_vol:%d, hpout_vol:%d, spk_used:%d, pa_msleep_time:%d, pa_level:%d\n",
+		sunxi_codec->digital_vol,
+		sunxi_codec->lineout_vol,
+		sunxi_codec->hpout_vol,
+		sunxi_codec->spk_cfg.spk_used,
+		sunxi_codec->spk_cfg.pa_msleep,
+		sunxi_codec->spk_cfg.pa_level);
+
+	/* get the inter i2s params */
+	ret = of_property_read_u32(np, "daudio_master", &temp_val);
+	if (ret < 0) {
+		LOG_WARN("inter i2s daudio_master config missing or invalid\n");
+		i2s_params->daudio_master = 4;
+	} else {
+		i2s_params->daudio_master = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "audio_format", &temp_val);
+	if (ret < 0) {
+		LOG_WARN("inter i2s audio_format config missing or invalid\n");
+		i2s_params->audio_format = 1;
+	} else {
+		i2s_params->audio_format = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "signal_inversion", &temp_val);
+	if (ret < 0) {
+		LOG_WARN("inter i2s signal_inversion config missing or invalid\n");
+		i2s_params->signal_inversion = 1;
+	} else {
+		i2s_params->signal_inversion = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "pcm_lrck_period", &temp_val);
+	if (ret < 0) {
+		LOG_WARN("inter i2s pcm_lrck_period config missing or invalid\n");
+		i2s_params->pcm_lrck_period = 0;
+	} else {
+		i2s_params->pcm_lrck_period = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "slot_width_select", &temp_val);
+	if (ret < 0) {
+		LOG_WARN("inter i2s slot_width_select config missing or invalid\n");
+		i2s_params->slot_width_select = 0;
+	} else {
+		i2s_params->slot_width_select = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "frametype", &temp_val);
+	if (ret < 0) {
+		LOG_WARN("inter i2s frametype config missing or invalid\n");
+		i2s_params->frame_type = 0;
+	} else {
+		i2s_params->frame_type = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "mclk_div", &temp_val);
+	if (ret < 0) {
+		LOG_WARN("inter i2s mclk_div config missing or invalid\n");
+		i2s_params->mclk_div = 0;
+	} else {
+		i2s_params->mclk_div = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "tdm_config", &temp_val);
+	if (ret < 0) {
+		LOG_WARN("inter i2s tdm_config config missing or invalid\n");
+		i2s_params->tdm_config = 1;
+	} else {
+		i2s_params->tdm_config = temp_val;
+	}
+
+	LOG_INFO("inter i2s params: daudio_master:%d, audio_format:%d, signal_inversion:%d,"
+		"pcm_lrck_period:0x%x, slot_width_select:0x%x, frametype:0x%x,"
+		"mclk_div:0x%x, tdm_config:0x%x\n",
+		i2s_params->daudio_master,
+		i2s_params->audio_format,
+		i2s_params->signal_inversion,
+		i2s_params->pcm_lrck_period,
+		i2s_params->slot_width_select,
+		i2s_params->frame_type,
+		i2s_params->mclk_div,
+		i2s_params->tdm_config);
+
+#if 0
+	/* ADC/DAC DRC/HPF func enable property */
+	ret = of_property_read_u32(np, "adcdrc_cfg", &temp_val);
+	if (ret < 0) {
+		LOG_ERR("[%s] adcdrc_cfg configs missing or invalid.\n", __func__);
+	} else {
+		sunxi_codec->hw_config.adcdrc_cfg = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "adchpf_cfg", &temp_val);
+	if (ret < 0) {
+		LOG_ERR("[%s] adchpf_cfg configs missing or invalid.\n", __func__);
+	} else {
+		sunxi_codec->hw_config.adchpf_cfg = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "dacdrc_cfg", &temp_val);
+	if (ret < 0) {
+		LOG_ERR("[%s] dacdrc_cfg configs missing or invalid.\n", __func__);
+	} else {
+		sunxi_codec->hw_config.dacdrc_cfg = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "dachpf_cfg", &temp_val);
+	if (ret < 0) {
+		LOG_ERR("[%s] dachpf_cfg configs missing or invalid.\n", __func__);
+	} else {
+		sunxi_codec->hw_config.dachpf_cfg = temp_val;
+	}
+
+	pr_debug("adcdrc_cfg:%d, adchpf_cfg:%d, dacdrc_cfg:%d, dachpf:%d\n",
+		sunxi_codec->hw_config.adcdrc_cfg,
+		sunxi_codec->hw_config.adchpf_cfg,
+		sunxi_codec->hw_config.dacdrc_cfg,
+		sunxi_codec->hw_config.dachpf_cfg);
+#endif
+
+	/* get the gpio number to control external speaker */
+	if (sunxi_codec->spk_cfg.spk_used) {
+		ret = of_get_named_gpio(np, "gpio-spk", 0);
+		if (ret >= 0) {
+			sunxi_codec->spk_cfg.spk_used = 1;
+			sunxi_codec->spk_cfg.spk_gpio = ret;
+			if (!gpio_is_valid(sunxi_codec->spk_cfg.spk_gpio)) {
+				LOG_ERR("gpio-spk is invalid\n");
+				return -EINVAL;
+			} else {
+				pr_debug("gpio-spk:%d\n",
+					sunxi_codec->spk_cfg.spk_gpio);
+				ret = devm_gpio_request(&pdev->dev,
+					sunxi_codec->spk_cfg.spk_gpio, "SPK");
+				if (ret) {
+					LOG_ERR("failed to request gpio-spk gpio\n");
+					return -EBUSY;
+				}
+			}
+		} else {
+			sunxi_codec->spk_cfg.spk_used = 0;
+			LOG_ERR("gpio-spk get faild!\n");
+		}
+	}
+
+	return ret;
+}
+
+static int sunxi_codec_mem_init(struct device_node *np,
+				struct platform_device *pdev,
+				struct sunxi_codec_info *sunxi_codec)
+{
+	struct resource res;
+	struct resource *memregion = NULL;
+	int ret = 0;
+
+	ret = of_address_to_resource(np, 0, &res);
+	if (ret) {
+		LOG_ERR("Failed to get sunxi codec resource\n");
+		return -EINVAL;
+	}
+
+	memregion = devm_request_mem_region(&pdev->dev, res.start,
+				resource_size(&res), "sunxi-internal-codec");
+	if (!memregion) {
+		LOG_ERR("sunxi memory region already claimed\n");
+		return -EINVAL;
+	}
+
+	sunxi_codec->codec_addr = devm_ioremap(&pdev->dev,
+					res.start, resource_size(&res));
+	if (!sunxi_codec->codec_addr) {
+		LOG_ERR("sunxi codec_addr ioremap failed\n");
+		return -EINVAL;
+	}
+
+	sunxi_codec->codec_regmap = devm_regmap_init_mmio(&pdev->dev,
+				sunxi_codec->codec_addr,
+				&sunxi_codec_regmap_config);
+	if (IS_ERR_OR_NULL(sunxi_codec->codec_regmap)) {
+		LOG_ERR("codec regmap init failed\n");
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+static int sunxi_codec_i2s_mem_init(struct device_node *np,
+				struct platform_device *pdev,
+				struct sunxi_codec_info *sunxi_codec)
+{
+	struct resource res;
+	struct resource *memregion = NULL;
+	int ret = 0;
+
+	ret = of_address_to_resource(np, 1, &res);
+	if (ret) {
+		LOG_ERR("Failed to get sunxi codec internal i2s resource\n");
+		return -EINVAL;
+	}
+
+	memregion = devm_request_mem_region(&pdev->dev, res.start,
+				resource_size(&res), "sunxi-internal-codec");
+	if (!memregion) {
+		LOG_ERR("sunxi memory region already claimed\n");
+		return -EINVAL;
+	}
+
+	sunxi_codec->i2s_addr = devm_ioremap(&pdev->dev,
+					res.start, resource_size(&res));
+	if (!sunxi_codec->i2s_addr) {
+		LOG_ERR("sunxi i2s_addr ioremap failed\n");
+		return -EINVAL;
+	}
+
+	sunxi_codec->i2s_regmap = devm_regmap_init_mmio(&pdev->dev,
+				sunxi_codec->i2s_addr,
+				&sunxi_i2s_regmap_config);
+	if (IS_ERR_OR_NULL(sunxi_codec->i2s_regmap)) {
+		LOG_ERR("regmap init failed\n");
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+static int sunxi_internal_codec_probe(struct platform_device *pdev)
+{
+	struct sunxi_codec_info *sunxi_codec;
+	struct device_node *np = pdev->dev.of_node;
+	int ret;
+
+	if (IS_ERR_OR_NULL(np)) {
+		LOG_ERR("pdev->dev.of_node is err.\n");
+		ret = -EFAULT;
+		goto err_node_put;
+	}
+
+	sunxi_codec = devm_kzalloc(&pdev->dev,
+				sizeof(struct sunxi_codec_info), GFP_KERNEL);
+	if (!sunxi_codec) {
+		LOG_ERR("Can't allocate sunxi codec memory\n");
+		ret = -ENOMEM;
+		goto err_node_put;
+	}
+	dev_set_drvdata(&pdev->dev, sunxi_codec);
+	sunxi_codec->dev = &pdev->dev;
+
+	/* module regulator init */
+	if (sunxi_codec_regulator_init(pdev, sunxi_codec) != 0) {
+		LOG_ERR("Failed to init sunxi audio regulator\n");
+		ret = -EINVAL;
+		goto err_devm_kfree;
+	}
+
+	/* module params init */
+	if (sunxi_codec_parse_params(np, pdev, sunxi_codec) != 0) {
+		LOG_ERR("Failed to parse sunxi audio params\n");
+		ret = -EINVAL;
+		goto err_devm_kfree;
+	}
+
+	/* module clk init */
+	if (sunxi_codec_clk_init(np, pdev, sunxi_codec) != 0) {
+		LOG_ERR("Failed to init sunxi audio clk\n");
+		ret = -EFAULT;
+		goto err_devm_kfree;
+	}
+
+	/* module codec reg_base */
+	if (sunxi_codec_mem_init(np, pdev, sunxi_codec) != 0) {
+		LOG_ERR("Failed to init sunxi codec reg mem\n");
+		ret = -EFAULT;
+		goto err_devm_kfree;
+	}
+
+	/* module internal i2s reg_base */
+	if (sunxi_codec_i2s_mem_init(np, pdev, sunxi_codec) != 0) {
+		LOG_ERR("Failed to init sunxi codec reg mem\n");
+		ret = -EFAULT;
+		goto err_devm_kfree;
+	}
+
+	/* CODEC DAI cfg and register */
+	ret = devm_snd_soc_register_component(&pdev->dev, &soc_codec_dev_sunxi,
+				sunxi_codec_dai, ARRAY_SIZE(sunxi_codec_dai));
+	if (ret < 0) {
+		LOG_ERR("register codec failed\n");
+		goto err_devm_kfree;
+	}
+
+	ret  = sysfs_create_group(&pdev->dev.kobj, &audio_debug_attr_group);
+	if (ret) {
+		LOG_WARN("failed to create attr group\n");
+		goto err_devm_kfree;
+	}
+
+	LOG_WARN("codec probe finished.\n");
+
+	return 0;
+
+err_devm_kfree:
+	devm_kfree(&pdev->dev, sunxi_codec);
+err_node_put:
+	of_node_put(np);
+	return ret;
+}
+
+static int  __exit sunxi_internal_codec_remove(struct platform_device *pdev)
+{
+	struct sunxi_codec_info *sunxi_codec = dev_get_drvdata(&pdev->dev);
+	struct codec_spk_config *spk_cfg = &(sunxi_codec->spk_cfg);
+
+	if (spk_cfg->spk_used) {
+		devm_gpio_free(&pdev->dev,
+					sunxi_codec->spk_cfg.spk_gpio);
+	}
+
+	if (sunxi_codec->vol_supply.avcc) {
+		regulator_disable(sunxi_codec->vol_supply.avcc);
+		regulator_put(sunxi_codec->vol_supply.avcc);
+	}
+
+	if (sunxi_codec->vol_supply.cpvin) {
+		regulator_disable(sunxi_codec->vol_supply.cpvin);
+		regulator_put(sunxi_codec->vol_supply.cpvin);
+	}
+
+	sysfs_remove_group(&pdev->dev.kobj, &audio_debug_attr_group);
+
+	snd_soc_unregister_component(&pdev->dev);
+
+	clk_disable_unprepare(sunxi_codec->dacclk);
+	clk_put(sunxi_codec->dacclk);
+	clk_disable_unprepare(sunxi_codec->adcclk);
+	clk_put(sunxi_codec->adcclk);
+	clk_disable_unprepare(sunxi_codec->pllclk);
+	clk_put(sunxi_codec->pllclk);
+	clk_disable_unprepare(sunxi_codec->codec_clk_bus);
+	clk_put(sunxi_codec->codec_clk_bus);
+	reset_control_assert(sunxi_codec->codec_clk_rst);
+
+	devm_iounmap(&pdev->dev, sunxi_codec->codec_addr);
+	devm_iounmap(&pdev->dev, sunxi_codec->i2s_addr);
+
+	devm_kfree(&pdev->dev, sunxi_codec);
+	platform_set_drvdata(pdev, NULL);
+
+	LOG_WARN("codec remove finished.\n");
+
+	return 0;
+}
+
+static const struct of_device_id sunxi_internal_codec_of_match[] = {
+	{ .compatible = "allwinner,sunxi-internal-codec", },
+	{},
+};
+
+static struct platform_driver sunxi_internal_codec_driver = {
+	.driver = {
+		.name = "sunxi-internal-codec",
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_internal_codec_of_match,
+	},
+	.probe = sunxi_internal_codec_probe,
+	.remove = __exit_p(sunxi_internal_codec_remove),
+};
+module_platform_driver(sunxi_internal_codec_driver);
+
+MODULE_DESCRIPTION("SUNXI Codec ASoC driver");
+MODULE_AUTHOR("luguofang <luguofang@allwinnertech.com>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:sunxi-internal-codec");
diff --git a/sound/soc/sunxi/sun50iw12-codec.h b/sound/soc/sunxi/sun50iw12-codec.h
new file mode 100644
index 000000000..b2cd2709a
--- /dev/null
+++ b/sound/soc/sunxi/sun50iw12-codec.h
@@ -0,0 +1,729 @@
+/*
+ * sound\soc\sunxi\sun50iw12-codec.h
+ * (C) Copyright 2019-2021
+ * allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * luguofang <luguofang@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#ifndef _SUN50IW12_CODEC_H
+#define _SUN50IW12_CODEC_H
+
+#include "sunxi-pcm.h"
+
+/************** Audio Codec Register **************/
+/* Base Address : 0x02030000 */
+/* Digital Domain Register */
+#define SUNXI_DAC_DPC		0x00
+#define SUNXI_DAC_VOL_CTRL	0x04
+
+#define SUNXI_DAC_FIFOC		0x10
+#define SUNXI_DAC_FIFOS		0x14
+
+#define SUNXI_DAC_TXDATA	0X20
+#define SUNXI_DAC_CNT		0x24
+#define SUNXI_DAC_DG		0x28
+
+#define	SUNXI_ADC_FIFOC		0x30
+#define	SUNXI_ADC_VOL_CTRL	0x34
+#define SUNXI_ADC_FIFOS		0x38
+
+#define SUNXI_ADC_RXDATA	0x40
+#define SUNXI_ADC_CNT		0x44
+#define SUNXI_ADC_DG		0x4C
+
+#define SUNXI_DAC_DAP_CTL	0xF0
+#define SUNXI_ADC_DAP_CTL	0xF8
+
+#define SUNXI_DAC_DRC_HHPFC	0x100
+#define SUNXI_DAC_DRC_LHPFC	0x104
+#define SUNXI_DAC_DRC_CTRL	0x108
+#define SUNXI_DAC_DRC_LPFHAT	0x10C
+#define SUNXI_DAC_DRC_LPFLAT	0x110
+#define SUNXI_DAC_DRC_RPFHAT	0x114
+#define SUNXI_DAC_DRC_RPFLAT	0x118
+#define SUNXI_DAC_DRC_LPFHRT	0x11C
+#define SUNXI_DAC_DRC_LPFLRT	0x120
+#define SUNXI_DAC_DRC_RPFHRT	0x124
+#define SUNXI_DAC_DRC_RPFLRT	0x128
+#define SUNXI_DAC_DRC_LRMSHAT	0x12C
+#define SUNXI_DAC_DRC_LRMSLAT	0x130
+#define SUNXI_DAC_DRC_RRMSHAT	0x134
+#define SUNXI_DAC_DRC_RRMSLAT	0x138
+#define SUNXI_DAC_DRC_HCT	0x13C
+#define SUNXI_DAC_DRC_LCT	0x140
+#define SUNXI_DAC_DRC_HKC	0x144
+#define SUNXI_DAC_DRC_LKC	0x148
+#define SUNXI_DAC_DRC_HOPC	0x14C
+#define SUNXI_DAC_DRC_LOPC	0x150
+#define SUNXI_DAC_DRC_HLT	0x154
+#define SUNXI_DAC_DRC_LLT	0x158
+#define SUNXI_DAC_DRC_HKI	0x15C
+#define SUNXI_DAC_DRC_LKI	0x160
+#define SUNXI_DAC_DRC_HOPL	0x164
+#define SUNXI_DAC_DRC_LOPL	0x168
+#define SUNXI_DAC_DRC_HET	0x16C
+#define SUNXI_DAC_DRC_LET	0x170
+#define SUNXI_DAC_DRC_HKE	0x174
+#define SUNXI_DAC_DRC_LKE	0x178
+#define SUNXI_DAC_DRC_HOPE	0x17C
+#define SUNXI_DAC_DRC_LOPE	0x180
+#define SUNXI_DAC_DRC_HKN	0x184
+#define SUNXI_DAC_DRC_LKN	0x188
+#define SUNXI_DAC_DRC_SFHAT	0x18C
+#define SUNXI_DAC_DRC_SFLAT	0x190
+#define SUNXI_DAC_DRC_SFHRT	0x194
+#define SUNXI_DAC_DRC_SFLRT	0x198
+#define SUNXI_DAC_DRC_MXGHS	0x19C
+#define SUNXI_DAC_DRC_MXGLS	0x1A0
+#define SUNXI_DAC_DRC_MNGHS	0x1A4
+#define SUNXI_DAC_DRC_MNGLS	0x1A8
+#define SUNXI_DAC_DRC_EPSHC	0x1AC
+#define SUNXI_DAC_DRC_EPSLC	0x1B0
+#define SUNXI_DAC_DRC_OPT	0x1B4
+#define SUNXI_DAC_DRC_HPFHGAIN	0x1B8
+#define SUNXI_DAC_DRC_HPFLGAIN	0x1BC
+
+#define SUNXI_ADC_DRC_HHPFC	0x200
+#define SUNXI_ADC_DRC_LHPFC	0x204
+#define SUNXI_ADC_DRC_CTRL	0x208
+#define SUNXI_ADC_DRC_LPFHAT	0x20C
+#define SUNXI_ADC_DRC_LPFLAT	0x210
+#define SUNXI_ADC_DRC_RPFHAT	0x214
+#define SUNXI_ADC_DRC_RPFLAT	0x218
+#define SUNXI_ADC_DRC_LPFHRT	0x21C
+#define SUNXI_ADC_DRC_LPFLRT	0x220
+#define SUNXI_ADC_DRC_RPFHRT	0x224
+#define SUNXI_ADC_DRC_RPFLRT	0x228
+#define SUNXI_ADC_DRC_LRMSHAT	0x22C
+#define SUNXI_ADC_DRC_LRMSLAT	0x230
+#define SUNXI_ADC_DRC_HCT	0x23C
+#define SUNXI_ADC_DRC_LCT	0x240
+#define SUNXI_ADC_DRC_HKC	0x244
+#define SUNXI_ADC_DRC_LKC	0x248
+#define SUNXI_ADC_DRC_HOPC	0x24C
+#define SUNXI_ADC_DRC_LOPC	0x250
+#define SUNXI_ADC_DRC_HLT	0x254
+#define SUNXI_ADC_DRC_LLT	0x258
+#define SUNXI_ADC_DRC_HKI	0x25C
+#define SUNXI_ADC_DRC_LKI	0x260
+#define SUNXI_ADC_DRC_HOPL	0x264
+#define SUNXI_ADC_DRC_LOPL	0x268
+#define SUNXI_ADC_DRC_HET	0x26C
+#define SUNXI_ADC_DRC_LET	0x270
+#define SUNXI_ADC_DRC_HKE	0x274
+#define SUNXI_ADC_DRC_LKE	0x278
+#define SUNXI_ADC_DRC_HOPE	0x27C
+#define SUNXI_ADC_DRC_LOPE	0x280
+#define SUNXI_ADC_DRC_HKN	0x284
+#define SUNXI_ADC_DRC_LKN	0x288
+#define SUNXI_ADC_DRC_SFHAT	0x28C
+#define SUNXI_ADC_DRC_SFLAT	0x290
+#define SUNXI_ADC_DRC_SFHRT	0x294
+#define SUNXI_ADC_DRC_SFLRT	0x298
+#define SUNXI_ADC_DRC_MXGHS	0x29C
+#define SUNXI_ADC_DRC_MXGLS	0x2A0
+#define SUNXI_ADC_DRC_MNGHS	0x2A4
+#define SUNXI_ADC_DRC_MNGLS	0x2A8
+#define SUNXI_ADC_DRC_EPSHC	0x2AC
+#define SUNXI_ADC_DRC_EPSLC	0x2B0
+#define SUNXI_ADC_DRC_OPT	0x2B4
+#define SUNXI_ADC_DRC_HPFHGAIN	0x2B8
+#define SUNXI_ADC_DRC_HPFLGAIN	0x2BC
+
+#define SUNXI_AC_VERSION	0x2C0
+
+/* Analog Domain Register */
+#define SUNXI_ADCL_REG		0x300
+#define SUNXI_ADCR_REG		0x304
+#define SUNXI_DAC_REG		0x310
+#define SUNXI_MICBIAS_REG	0x318
+#define SUNXI_BIAS_REG		0x320
+#define SUNXI_HP_REG		0x324
+#define SUNXI_HMIC_CTRL		0x328
+#define SUNXI_HMIC_STS		0x32c
+
+/* SUNXI_DAC_DPC:0x00 */
+#define DAC_EN			31
+#define I2S_CLK_SEL		30
+#define DAC_SRC_SEL		29
+#define DAC_MODQU		25
+#define DAC_DWA_EN		24
+#define DAC_HPF_EN		18
+#define DAC_DVOL		12
+#define DAC_HUB_EN		0
+
+/* SUNXI_DAC_VOL_CTRL:0x04 */
+#define DAC_VOL_SEL		16
+#define DAC_VOL_L		8
+#define DAC_VOL_R		0
+
+/* SUNXI_DAC_FIFOC:0x10 */
+#define DAC_FS			29
+#define DAC_FIR_VER		28
+#define DAC_SEND_LASAT		26
+#define DAC_FIFO_MODE		24
+#define DAC_DRQ_CLR_CNT		21
+#define DAC_TRIG_LEVEL		8
+#define DAC_MONO_EN		6
+#define DAC_SAMPLE_BITS		5
+#define DAC_DRQ_EN		4
+#define DAC_IRQ_EN		3
+#define DAC_UNDERRUN_IRQ_EN	2
+#define DAC_OVERRUN_IRQ_EN	1
+#define DAC_FIFO_FLUSH		0
+
+/* SUNXI_DAC_FIFOS:0x14 */
+#define	DAC_TX_EMPTY		23
+#define	DAC_TXE_CNT		8
+#define	DAC_TXE_INT		3
+#define	DAC_TXU_INT		2
+#define	DAC_TXO_INT		1
+
+/* SUNXI_DAC_TXDATA:0x20 */
+#define DAC_TX_DATA		0
+
+/* SUNXI_DAC_CNT:0x24 */
+#define DAC_TX_CNT		0
+
+/* SUNXI_DAC_DG:0x28 */
+#define	DAC_MODU_SEL		11
+#define	DAC_PATTERN_SEL		9
+#define	DAC_CODEC_CLK_SEL	8
+#define	DAC_SWAP		6
+#define	ADDA_LOOP_MODE		0
+
+/* SUNXI_ADC_FIFOC:0x30 */
+#define ADC_FS			29
+#define ADC_EN			28
+#define ADC_FDT			26
+#define ADC_DFEN		25
+#define ADC_FIFO_MODE		24
+#define ADC_RX_SYNC_START	21
+#define ADC_RX_SYNC_EN		20
+#define ADC_VOL_SEL		17
+#define ADC_SAMPLE_BITS		16
+#define ADC_CHAN_EN		12
+#define ADC_TRIG_LEVEL		4
+#define ADC_DRQ_EN		3
+#define ADC_IRQ_EN		2
+#define ADC_OVERRUN_IRQ_EN	1
+#define ADC_FIFO_FLUSH		0
+
+/* SUNXI_ADC_VOL_CTRL:0x34 */
+#define ADC_VOL_L		8
+#define ADC_VOL_R		0
+
+/* SUNXI_ADC_FIFOS:0x38 */
+#define	ADC_RXA			23
+#define	ADC_RXA_CNT		8
+#define	ADC_RXA_INT		3
+#define	ADC_RXO_INT		1
+
+/* SUNXI_ADC_RXDATA:0x40 */
+#define ADC_RX_DATA		0
+
+/* SUNXI_ADC_CNT:0x44 */
+#define ADC_RX_CNT		0
+
+/* SUNXI_ADC_DG:0x4C */
+#define	ADC_SWAP		24
+
+/* SUNXI_DAC_DAP_CTL:0xF0 */
+#define	DAC_DAP_EN		31
+#define	DAC_DAP_DRC_EN		29
+#define	DAC_DAP_HPF_EN		28
+
+/* SUNXI_ADC_DAP_CTL:0xF8 */
+#define	ADC_DAP0_EN		31
+#define	ADC_DRC0_EN		29
+#define	ADC_HPF0_EN		28
+
+/* SUNXI_DAC_DRC_HHPFC : 0x100*/
+#define DAC_HHPF_CONF		0
+
+/* SUNXI_DAC_DRC_LHPFC : 0x104*/
+#define DAC_LHPF_CONF		0
+
+/* SUNXI_DAC_DRC_CTRL : 0x108*/
+#define DAC_DRC_DELAY_OUT_STATE		15
+#define DAC_DRC_SIGNAL_DELAY		8
+#define DAC_DRC_DELAY_BUF_EN		7
+#define DAC_DRC_GAIN_MAX_EN		6
+#define DAC_DRC_GAIN_MIN_EN		5
+#define DAC_DRC_NOISE_DET_EN		4
+#define DAC_DRC_SIGNAL_SEL		3
+#define DAC_DRC_DELAY_EN		2
+#define DAC_DRC_LT_EN			1
+#define DAC_DRC_ET_EN			0
+
+/* SUNXI_ADC_DRC_HHPFC : 0x200*/
+#define ADC_HHPF_CONF		0
+
+/* SUNXI_ADC_DRC_LHPFC : 0x204*/
+#define ADC_LHPF_CONF		0
+
+/* SUNXI_ADC_DRC_CTRL : 0x208*/
+#define ADC_DRC_DELAY_OUT_STATE		15
+#define ADC_DRC_SIGNAL_DELAY		8
+#define ADC_DRC_DELAY_BUF_EN		7
+#define ADC_DRC_GAIN_MAX_EN		6
+#define ADC_DRC_GAIN_MIN_EN		5
+#define ADC_DRC_NOISE_DET_EN		4
+#define ADC_DRC_SIGNAL_SEL		3
+#define ADC_DRC_DELAY_EN		2
+#define ADC_DRC_LT_EN			1
+#define ADC_DRC_ET_EN			0
+
+/* Anolog Register */
+/* SUNXI_ADCL_REG : 0x300 */
+#define ADCL_EN			31
+#define ADCL_DITHER_RESET	29
+#define ADCL_LINEINL_EN		19
+#define ADCL_LINEINL_SEL	16
+#define ADCL_IOPAAFL		6
+#define ADCL_IOPSDML1		4
+#define ADCL_IOPSDML2		2
+#define ADCL_IOPMICL		0
+
+/* SUNXI_ADCR_REG : 0x304 */
+#define ADCR_EN			31
+#define ADCR_DITHER_RESET	29
+#define ADCR_LINEINR_EN		19
+#define ADCR_LINEINR_SEL	16
+#define ADCR_IOPAAFL		6
+#define ADCR_IOPSDML1		4
+#define ADCR_IOPSDML2		2
+#define ADCR_IOPMICL		0
+
+/* SUNXI_DAC_REG : 0x310 */
+#define DAC_CUR_TEST_SELECT	31
+#define DAC_HP_GAIN		28
+#define DAC_CPLDO_EN		27
+#define DAC_CPLDO_VOLTAGE	24
+#define DAC_OPDRV_CUR		22
+#define	DAC_VRA2_IOPVRS		20
+#define	DAC_ILINEOUTAMPS	18
+#define DAC_IOPDACS		16
+#define DACL_EN			15
+#define DACR_EN			14
+#define DAC_LINEOUTLEN		13
+#define DAC_LMUTE		12
+#define DAC_LINEOUTREN		11
+#define DAC_RMUTE		10
+#define DAC_LINEOUTLDIFFEN	6
+#define DAC_LINEOUTRDIFFEN	5
+#define DAC_LINEOUT_VOL		0
+
+/* SUNXI_MICBIAS_REG : 0x318 */
+#define SELDETADCFS		28
+#define SELDETADCDB		26
+#define SELDETADCBF		24
+#define JACKDETEN		23
+#define SELDETADCDY		21
+#define MICADCEN		20
+#define POPFREE			19
+#define DETMODE			18
+#define AUTOPLEN		17
+#define MICDETPL		16
+#define HMICBIASEN		15
+#define HBIASSEL		13
+#define	HMICBIAS_CHOP_EN	12
+#define HMICBIAS_CHOP_CLK_SEL	10
+#define MMICBIASEN		7
+#define	MBIASSEL		5
+#define	MMICBIAS_CHOP_EN	4
+#define MMICBIAS_CHOP_CLK_SEL	2
+
+/* SUNXI_BIAS_REG : 0x320 */
+#define AC_BIASDATA		0
+
+/* SUNXI_HP_REG : 0x324 */
+#define HPRCALIVERIFY		24
+#define HPLCALIVERIFY		16
+#define HPPA_EN			15
+#define HPINPUTEN		11
+#define HPOUTPUTEN		10
+#define HPPA_DEL		8
+#define CP_CLKS			6
+#define HPCALIMODE		5
+#define HPCALIVERIFY		4
+#define HPCALIFIRST		3
+#define HPCALICKS		0
+
+/* SUNXI_HMIC_CTRL : 0x328 */
+#define HMIC_SAMPLE_SEL		21
+#define MDATA_THRESHOLD		16
+#define HMIC_SF			14
+#define HMIC_M			10
+#define HMIC_N			6
+#define MDATA_THRESHOLD_DB	3
+#define JACK_OUT_IRQ_EN		2
+#define JACK_IN_IRQ_EN		1
+#define MIC_DET_IRQ_EN		0
+
+/* SUNXI_HMIC_STS : 0x32c */
+#define MDATA_DISCARD		13
+#define	HMIC_DATA		8
+#define JACK_DET_OUT_ST		4
+#define JACK_DET_OIRQ		4
+#define JACK_DET_IIN_ST 	3
+#define JACK_DET_IIRQ		3
+#define MIC_DET_ST		0
+
+
+
+/************** Internal I2S Register **************/
+/* Base Address : 0x02031000 */
+#define INTER_I2S_CTL		0x00
+#define INTER_I2S_FMT0		0x04
+#define INTER_I2S_FMT1		0x08
+#define INTER_I2S_ISTA		0x0C
+#define INTER_I2S_RXFIFO	0x10
+#define INTER_I2S_FCTL		0x14
+#define INTER_I2S_FSTA		0X18
+#define	INTER_I2S_INT		0X1C
+#define INTER_I2S_TXFIFIO	0X20
+#define INTER_I2S_CLKDIV	0X24
+#define INTER_I2S_TXCNT		0X28
+#define INTER_I2S_RXCNT		0X2C
+#define INTER_I2S_CHCFG		0X30
+#define INTER_I2S_TX0CHSEL	0X34
+#define INTER_I2S_TX1CHSEL	0X38
+#define INTER_I2S_TX2CHSEL	0X3C
+#define INTER_I2S_TX3CHSEL	0X40
+#define INTER_I2S_TX0CHMAP0	0X44
+#define INTER_I2S_TX0CHMAP1	0X48
+#define INTER_I2S_TX1CHMAP0	0X4C
+#define INTER_I2S_TX1CHMAP1	0X50
+#define INTER_I2S_TX2CHMAP0	0X54
+#define INTER_I2S_TX2CHMAP1	0X58
+#define INTER_I2S_TX3CHMAP0	0X5C
+#define INTER_I2S_TX3CHMAP1	0X60
+#define INTER_I2S_RXCHSEL	0X64
+#define INTER_I2S_RXCHMAP0	0X68
+#define INTER_I2S_RXCHMAP1	0X6C
+#define INTER_I2S_RXCHMAP2	0X70
+#define INTER_I2S_RXCHMAP3	0X74
+#define INTER_I2S_DBG		0x78
+#define INTER_I2S_REV		0x7C
+
+/* INTER_I2S_CTL : 0x00 */
+#define I2S_BCLK_OUT		18
+#define I2S_LRCK_OUT		17
+#define I2S_DOUT3_EN		11
+#define I2S_DOUT2_EN		10
+#define I2S_DOUT1_EN		9
+#define I2S_DOUT0_EN		8
+#define I2S_OUT_MUTE		6
+#define I2S_MODE_SEL		4
+#define I2S_LOOP		3
+#define I2S_TXEN		2
+#define I2S_RXEN		1
+#define I2S_GEN			0
+
+/* INTER_I2S_FMT0 : 0x04 */
+#define I2S_LRCK_WIDTH		30
+#define I2S_LRCK_POLARITY	19
+#define I2S_LRCK_PERIOD		8
+#define I2S_BCLK_POLARITY	7
+#define I2S_SR			4
+#define I2S_EDGE_TRANSFER	3
+#define I2S_SLOT_WIDTH		0
+
+/* INTER_I2S_FMT1 : 0x08 */
+#define I2S_RXMLS		7
+#define I2S_TXMLS		6
+#define I2S_SEXT		4
+
+/* INTER_I2S_CLKDIV : 0x24 */
+#define I2S_MCLKOUT_EN		8
+#define I2S_BCLKDIV		4
+#define I2S_MCLKDIV		0
+
+/* INTER_I2S_CHCFG : 0x30 */
+#define I2S_TX_SLOT_HIZ		9
+#define I2S_TX_STATE		8
+
+/* INTER_I2S_TX0CHSEL : 0x34 */
+#define I2S_TX0_CHSEL		16
+#define I2S_TX0_CHEN		0
+
+/* INTER_I2S_TX1CHSEL : 0x38 */
+#define I2S_TX1_CHSEL		16
+#define I2S_TX1_CHEN		0
+
+/* INTER_I2S_TX2CHSEL : 0x3C */
+#define I2S_TX2_CHSEL		16
+#define I2S_TX2_CHEN		0
+
+/* INTER_I2S_TX3CHSEL : 0x40 */
+#define I2S_TX3_CHSEL		16
+#define I2S_TX3_CHEN		0
+
+/* INTER_I2S_TX0CHMAP0 : 0x44 */
+#define I2S_TX0_CH15_MAP	28
+#define I2S_TX0_CH14_MAP	24
+#define I2S_TX0_CH13_MAP	20
+#define I2S_TX0_CH12_MAP	16
+#define I2S_TX0_CH11_MAP	12
+#define I2S_TX0_CH10_MAP	8
+#define I2S_TX0_CH9_MAP		4
+#define I2S_TX0_CH8_MAP		0
+
+/* INTER_I2S_TX0CHMAP1 : 0x48 */
+#define I2S_TX0_CH7_MAP		28
+#define I2S_TX0_CH6_MAP		24
+#define I2S_TX0_CH5_MAP		20
+#define I2S_TX0_CH4_MAP		16
+#define I2S_TX0_CH3_MAP		12
+#define I2S_TX0_CH2_MAP		8
+#define I2S_TX0_CH1_MAP		4
+#define I2S_TX0_CH0_MAP		0
+
+/* INTER_I2S_TX1CHMAP0 : 0x4C */
+#define I2S_TX1_CH15_MAP	28
+#define I2S_TX1_CH14_MAP	24
+#define I2S_TX1_CH13_MAP	20
+#define I2S_TX1_CH12_MAP	16
+#define I2S_TX1_CH11_MAP	12
+#define I2S_TX1_CH10_MAP	8
+#define I2S_TX1_CH9_MAP		4
+#define I2S_TX1_CH8_MAP		0
+
+/* INTER_I2S_TX1CHMAP1 : 0x50 */
+#define I2S_TX1_CH7_MAP		28
+#define I2S_TX1_CH6_MAP		24
+#define I2S_TX1_CH5_MAP		20
+#define I2S_TX1_CH4_MAP		16
+#define I2S_TX1_CH3_MAP		12
+#define I2S_TX1_CH2_MAP		8
+#define I2S_TX1_CH1_MAP		4
+#define I2S_TX1_CH0_MAP		0
+
+/* INTER_I2S_TX2CHMAP0 : 0x54 */
+#define I2S_TX2_CH15_MAP	28
+#define I2S_TX2_CH14_MAP	24
+#define I2S_TX2_CH13_MAP	20
+#define I2S_TX2_CH12_MAP	16
+#define I2S_TX2_CH11_MAP	12
+#define I2S_TX2_CH10_MAP	8
+#define I2S_TX2_CH9_MAP		4
+#define I2S_TX2_CH8_MAP		0
+
+/* INTER_I2S_TX2CHMAP1 : 0x58 */
+#define I2S_TX2_CH7_MAP		28
+#define I2S_TX2_CH6_MAP		24
+#define I2S_TX2_CH5_MAP		20
+#define I2S_TX2_CH4_MAP		16
+#define I2S_TX2_CH3_MAP		12
+#define I2S_TX2_CH2_MAP		8
+#define I2S_TX2_CH1_MAP		4
+#define I2S_TX2_CH0_MAP		0
+
+/* INTER_I2S_TX3CHMAP0 : 0x5C */
+#define I2S_TX3_CH15_MAP	28
+#define I2S_TX3_CH14_MAP	24
+#define I2S_TX3_CH13_MAP	20
+#define I2S_TX3_CH12_MAP	16
+#define I2S_TX3_CH11_MAP	12
+#define I2S_TX3_CH10_MAP	8
+#define I2S_TX3_CH9_MAP		4
+#define I2S_TX3_CH8_MAP		0
+
+/* INTER_I2S_TX3CHMAP1 : 0x60 */
+#define I2S_TX3_CH7_MAP		28
+#define I2S_TX3_CH6_MAP		24
+#define I2S_TX3_CH5_MAP		20
+#define I2S_TX3_CH4_MAP		16
+#define I2S_TX3_CH3_MAP		12
+#define I2S_TX3_CH2_MAP		8
+#define I2S_TX3_CH1_MAP		4
+#define I2S_TX3_CH0_MAP		0
+
+/* INTER_I2S_RXCHSEL : 0x64 */
+#define I2S_RX_CHSEL		16
+
+/* INTER_I2S_RXCHMAP0 : 0x68 */
+#define I2S_RX_CH15_SEL		28
+#define I2S_RX_CH15_MAP		24
+#define I2S_RX_CH14_SEL		20
+#define I2S_RX_CH14_MAP		16
+#define I2S_RX_CH13_SEL		12
+#define I2S_RX_CH13_MAP		8
+#define I2S_RX_CH12_SEL		4
+#define I2S_RX_CH12_MAP		0
+
+/* INTER_I2S_RXCHMAP1 : 0x6C */
+#define I2S_RX_CH11_SEL		28
+#define I2S_RX_CH11_MAP		24
+#define I2S_RX_CH10_SEL		20
+#define I2S_RX_CH10_MAP		16
+#define I2S_RX_CH9_SEL		12
+#define I2S_RX_CH9_MAP		8
+#define I2S_RX_CH8_SEL		4
+#define I2S_RX_CH8_MAP		0
+
+/* INTER_I2S_RXCHMAP2 : 0x70 */
+#define I2S_RX_CH7_SEL		28
+#define I2S_RX_CH7_MAP		24
+#define I2S_RX_CH6_SEL		20
+#define I2S_RX_CH6_MAP		16
+#define I2S_RX_CH5_SEL		12
+#define I2S_RX_CH5_MAP		8
+#define I2S_RX_CH4_SEL		4
+#define I2S_RX_CH4_MAP		0
+
+/* INTER_I2S_RXCHMAP3 : 0x74 */
+#define I2S_RX_CH3_SEL		28
+#define I2S_RX_CH3_MAP		24
+#define I2S_RX_CH2_SEL		20
+#define I2S_RX_CH2_MAP		16
+#define I2S_RX_CH1_SEL		12
+#define I2S_RX_CH1_MAP		8
+#define I2S_RX_CH0_SEL		4
+#define I2S_RX_CH0_MAP		0
+
+/* INTER_I2S_REV : 0x7C */
+#define I2S_REV
+
+/************** Other Definitions **************/
+/* INTER_I2S_CTL:0x00 */
+#define	INTER_I2S_MODE_CTL_LEFT		1
+#define	INTER_I2S_MODE_CTL_RIGHT	2
+
+#define	INTER_I2S_LRCK_POLARITY_NOR	0
+#define	INTER_I2S_LRCK_POLARITY_INV	1
+#define	INTER_I2S_BCLK_POLARITY_NOR	0
+#define	INTER_I2S_BCLK_POLARITY_INV	1
+
+/* INTER_I2S_CLKDIV : 0x24 */
+/* Inter i2s bclk div level */
+#define	INTER_I2S_BCLK_DIV_1		1
+#define	INTER_I2S_BCLK_DIV_2		2
+#define	INTER_I2S_BCLK_DIV_3		3
+#define	INTER_I2S_BCLK_DIV_4		4
+#define	INTER_I2S_BCLK_DIV_5		5
+#define	INTER_I2S_BCLK_DIV_6		6
+#define	INTER_I2S_BCLK_DIV_7		7
+#define	INTER_I2S_BCLK_DIV_8		8
+#define	INTER_I2S_BCLK_DIV_9		9
+#define	INTER_I2S_BCLK_DIV_10		10
+#define	INTER_I2S_BCLK_DIV_11		11
+#define	INTER_I2S_BCLK_DIV_12		12
+#define	INTER_I2S_BCLK_DIV_13		13
+#define	INTER_I2S_BCLK_DIV_14		14
+#define	INTER_I2S_BCLK_DIV_15		15
+/* Inter i2s mclk div level */
+#define	INTER_I2S_MCLK_DIV_1		1
+#define	INTER_I2S_MCLK_DIV_2		2
+#define	INTER_I2S_MCLK_DIV_3		3
+#define	INTER_I2S_MCLK_DIV_4		4
+#define	INTER_I2S_MCLK_DIV_5		5
+#define	INTER_I2S_MCLK_DIV_6		6
+#define	INTER_I2S_MCLK_DIV_7		7
+#define	INTER_I2S_MCLK_DIV_8		8
+#define	INTER_I2S_MCLK_DIV_9		9
+#define	INTER_I2S_MCLK_DIV_10		10
+#define	INTER_I2S_MCLK_DIV_11		11
+#define	INTER_I2S_MCLK_DIV_12		12
+#define	INTER_I2S_MCLK_DIV_13		13
+#define	INTER_I2S_MCLK_DIV_14		14
+#define	INTER_I2S_MCLK_DIV_15		15
+
+/*125ms * (HP_DEBOUCE_TIME+1)*/
+#define HP_DEBOUCE_TIME		0x1
+
+#define REG_LABEL(constant)	{#constant, constant, 0}
+#define REG_LABEL_END           {NULL, 0, 0}
+
+/* debug printk */
+#define LOG_ERR(fmt, arg...)	pr_err("[AUDIOCODEC][%s][%d]:" fmt "\n", __func__, __LINE__, ##arg)
+#define LOG_WARN(fmt, arg...)	pr_warn("[AUDIOCODEC][%s][%d]:" fmt "\n", __func__, __LINE__, ##arg)
+#define LOG_INFO(fmt, arg...)	pr_info("[AUDIOCODEC][%s][%d]:" fmt "\n", __func__, __LINE__, ##arg)
+
+struct reg_label {
+	const char *name;
+	const unsigned int address;
+	unsigned int value;
+};
+
+struct sample_rate {
+	unsigned int samplerate;
+	unsigned int rate_bit;
+};
+
+struct voltage_supply {
+	struct regulator *avcc;
+	struct regulator *cpvin;
+};
+
+struct codec_spk_config {
+	u32 spk_gpio;
+	u32 pa_msleep;
+	bool spk_used;
+	bool pa_level;
+};
+
+struct codec_hw_algo_config {
+	bool adcdrc_used;
+	bool dacdrc_used;
+	bool adchpf_used;
+	bool dachpf_used;
+};
+
+struct sunxi_codec_i2s_params {
+	unsigned int i2s_global_enable;
+	unsigned int daudio_master;
+	unsigned int audio_format;
+	unsigned int signal_inversion;
+	unsigned int pcm_lrck_period;
+	unsigned int slot_width_select;
+	unsigned int frame_type;
+	unsigned int tdm_config;
+	unsigned int mclk_div;
+};
+
+struct sunxi_codec_info {
+	struct device *dev;
+	/* module reg resource about */
+	void __iomem *codec_addr;
+	void __iomem *i2s_addr;
+	struct regmap *codec_regmap;
+	struct regmap *i2s_regmap;
+
+	/* module clk about */
+	struct clk *pllclk;
+	struct clk *dacclk;
+	struct clk *adcclk;
+	struct clk *codec_clk_bus;
+	struct reset_control *codec_clk_rst;
+
+	/* module regulator about */
+	struct voltage_supply vol_supply;
+
+	/* module private data about */
+	u32 digital_vol;
+	u32 lineout_vol;
+	u32 hpout_vol;
+
+	/* module speaker output about */
+	struct codec_spk_config spk_cfg;
+
+	/* module hardware algo about */
+	struct codec_hw_algo_config algo_cfg;
+
+	/* codec output data src select */
+	int dac_data_src; /* 0 -> APB; 1 -> I2S */
+
+	/* internal i2s part params about */
+	struct sunxi_codec_i2s_params i2s_params;
+};
+
+#endif /* __SUN50IW12_CODEC_H */
diff --git a/sound/soc/sunxi/sun50iw12-sndcodec.c b/sound/soc/sunxi/sun50iw12-sndcodec.c
new file mode 100644
index 000000000..6e22dd0ff
--- /dev/null
+++ b/sound/soc/sunxi/sun50iw12-sndcodec.c
@@ -0,0 +1,891 @@
+/*
+ * sound\soc\sunxi\sun50iw12-sndcodec.c
+ * (C) Copyright 2021-2026
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * huangxin <huangxin@Reuuimllatech.com>
+ * liushaohua <liushaohua@allwinnertech.com>
+ * yumingfengng <yumingfeng@allwinnertech.com>
+ * luguofang <luguofang@allwinnertech.com>
+ * Dby <Dby@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+#include <linux/gpio.h>
+#include <linux/io.h>
+#include <linux/input.h>
+#include <linux/of.h>
+#include <linux/delay.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/jack.h>
+#include <sound/pcm_params.h>
+#include <sound/soc-dapm.h>
+
+#include "sun50iw12-codec.h"
+
+static int mdata_threshold = 0x10;
+module_param(mdata_threshold, int, 0644);
+MODULE_PARM_DESC(mdata_threshold, "SUNXI hmic data threshold");
+
+typedef enum {
+	RESUME_IRQ  = 0x0,
+	SYSINIT_IRQ = 0x1,
+	OTHER_IRQ   = 0x2,
+} _jack_irq_times;
+
+enum HPDETECTWAY {
+	HP_DETECT_LOW = 0x0,
+	HP_DETECT_HIGH = 0x1,
+};
+
+enum dectect_jack {
+	PLUG_OUT = 0x0,
+	PLUG_IN  = 0x1,
+};
+
+enum JACK_FUNCTION {
+	JACK_ENABLE = 0x1,
+	JACK_DISABLE = 0x0,
+};
+
+static bool is_irq;
+static int switch_state;
+
+struct sunxi_card_priv {
+	struct snd_soc_card *card;
+	struct snd_soc_component *component;
+	struct delayed_work hs_init_work;
+	struct delayed_work hs_detect_work;
+	struct delayed_work hs_button_work;
+	struct delayed_work hs_checkplug_work;
+	struct mutex jack_mlock;
+	struct snd_soc_jack jack;
+	struct timespec64 tv_headset_plugin;	/*4*/
+	_jack_irq_times jack_irq_times;
+	u32 detect_state;
+	u32 jackirq;				/*switch irq*/
+	u32 HEADSET_DATA;			/*threshod for switch insert*/
+	u32 headset_basedata;
+	u32 switch_status;
+	u32 key_volup;
+	u32 key_voldown;
+	u32 key_hook;
+	u32 key_voiceassist;
+	u32 hp_detect_case;
+	u32 jack_func;
+};
+
+/*
+ * Identify the jack type as Headset/Headphone/None
+ */
+static int sunxi_check_jack_type(struct snd_soc_jack *jack)
+{
+	struct sunxi_card_priv *priv = container_of(jack,
+						struct sunxi_card_priv, jack);
+	struct sunxi_codec_info *sunxi_codec =
+				snd_soc_component_get_drvdata(priv->component);
+	u32 jack_type = 0, tempdata = 0;
+	u32 reg_val = 0;
+
+	regmap_read(sunxi_codec->codec_regmap, SUNXI_HMIC_STS, &reg_val);
+	tempdata = (reg_val >> HMIC_DATA) & 0x1f;
+	priv->headset_basedata = tempdata;
+
+	if (tempdata >= priv->HEADSET_DATA) {
+		/* headset:4 */
+		jack_type = SND_JACK_HEADSET;
+	} else {
+		/* headphone:3, disable hbias and adc */
+		regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_MICBIAS_REG, (0x1 << HMICBIASEN),
+				(0x0 << HMICBIASEN));
+		regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_MICBIAS_REG, (0x1 << MICADCEN),
+				(0x0 << MICADCEN));
+		jack_type = SND_JACK_HEADPHONE;
+	}
+
+	return jack_type;
+}
+
+/* Checks hs insertion by mdet */
+static void sunxi_check_hs_plug(struct work_struct *work)
+{
+	struct sunxi_card_priv *priv = container_of(work, struct sunxi_card_priv,
+						    hs_checkplug_work.work);
+	struct sunxi_codec_info *sunxi_codec =
+				snd_soc_component_get_drvdata(priv->component);
+
+	mutex_lock(&priv->jack_mlock);
+	if (priv->detect_state != PLUG_IN) {
+		/* Enable MDET */
+		regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_HMIC_CTRL, (0x1 << MIC_DET_IRQ_EN),
+				(0x1 << MIC_DET_IRQ_EN));
+		regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_MICBIAS_REG, (0x1 << MICADCEN),
+				(0x1 << MICADCEN));
+		/* Enable PA */
+		/*
+		regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_HEADPHONE_REG, (0x1 << HPPA_EN),
+				(0x1 << HPPA_EN));
+		*/
+	} else {
+		/*
+		 * Enable HPPA_EN
+		 * FIXME:When the Audio HAL is not at the do_output_standby,
+		 * apk not play the music at the same time, we can insert
+		 * headset now and click to play music immediately in the apk,
+		 * the Audio HAL will write data to the card and not update
+		 * the stream routing. Because we also set mute when
+		 * the mdet come into force, so that the dapm will not update
+		 * and it makes the mute.
+		 */
+		/*
+		regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_HEADPHONE_REG, (0x1 << HPPA_EN),
+				(0x1 << HPPA_EN));
+		*/
+	}
+	mutex_unlock(&priv->jack_mlock);
+}
+
+/* Checks jack insertion and identifies the jack type.*/
+static void sunxi_check_hs_detect_status(struct work_struct *work)
+{
+	int jack_type = 0, reg_val = 0;
+	struct sunxi_card_priv *priv = container_of(work,
+						    struct sunxi_card_priv,
+						    hs_detect_work.work);
+	struct sunxi_codec_info *sunxi_codec =
+				snd_soc_component_get_drvdata(priv->component);
+
+	mutex_lock(&priv->jack_mlock);
+	if (priv->detect_state == PLUG_IN) {
+		/* enable hbias and adc */
+		regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_MICBIAS_REG, (0x1 << HMICBIASEN),
+				(0x1 << HMICBIASEN));
+		regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_MICBIAS_REG, (0x1 << MICADCEN),
+				(0x1 << MICADCEN));
+		msleep(100);
+		jack_type = sunxi_check_jack_type(&priv->jack);
+		if (jack_type != priv->switch_status) {
+			priv->switch_status = jack_type;
+			snd_jack_report(priv->jack.jack, jack_type);
+			LOG_INFO("plugin --> switch:%d", jack_type);
+			switch_state = jack_type;
+		}
+
+		/* if SND_JACK_HEADSET,enable mic detect irq */
+		if (jack_type == SND_JACK_HEADSET) {
+			regmap_read(sunxi_codec->codec_regmap, SUNXI_HMIC_STS, &reg_val);
+			priv->headset_basedata = (reg_val >> HMIC_DATA) & 0x1f;
+			if (priv->headset_basedata > 3)
+				priv->headset_basedata -= 3;
+
+			usleep_range(1000, 2000);
+			regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_HMIC_CTRL, (0x1f << MDATA_THRESHOLD),
+				(priv->headset_basedata << MDATA_THRESHOLD));
+			regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_HMIC_CTRL, (0x1 << MIC_DET_IRQ_EN),
+				(0x1 << MIC_DET_IRQ_EN));
+		} else if (jack_type == SND_JACK_HEADPHONE) {
+			/* if is HEADPHONE 3, close mic detect irq */
+			regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_HMIC_CTRL, (0x1 << MIC_DET_IRQ_EN),
+				(0x0 << MIC_DET_IRQ_EN));
+		}
+	} else {
+		priv->switch_status = 0;
+		snd_jack_report(priv->jack.jack, priv->switch_status);
+		switch_state = priv->switch_status;
+		LOG_INFO("plugout --> switch:%d", priv->switch_status);
+		regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_MICBIAS_REG, (0x1 << HMICBIASEN),
+				(0x0 << HMICBIASEN));
+		regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_MICBIAS_REG, (0x1 << MICADCEN),
+				(0x0 << MICADCEN));
+		regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_HMIC_CTRL, (0x1f << MDATA_THRESHOLD),
+				(mdata_threshold << MDATA_THRESHOLD));
+		regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_HMIC_CTRL, (0x1 << MIC_DET_IRQ_EN),
+				(0x0 << MIC_DET_IRQ_EN));
+	}
+	mutex_unlock(&priv->jack_mlock);
+}
+
+static void sunxi_hs_init_work(struct work_struct *work)
+{
+	struct sunxi_card_priv *priv = container_of(work,
+						    struct sunxi_card_priv,
+						    hs_init_work.work);
+
+	mutex_lock(&priv->jack_mlock);
+	if (is_irq == true) {
+		is_irq = false;
+	} else {
+		if ((priv->hp_detect_case == HP_DETECT_LOW) ||
+		    (priv->jack_irq_times == RESUME_IRQ)) {
+			/*
+			 * It should be report after resume.
+			 * If the headset plugout after suspend, the system
+			 * can not know the state, so we should reset here
+			 * when resume.
+			 */
+			LOG_INFO("resume-->report switch");
+			priv->switch_status = 0;
+			snd_jack_report(priv->jack.jack, priv->switch_status);
+			switch_state = 0;
+		}
+	}
+	priv->jack_irq_times = OTHER_IRQ;
+	mutex_unlock(&priv->jack_mlock);
+}
+
+/* Check for hook release */
+static void sunxi_check_hs_button_status(struct work_struct *work)
+{
+	u32 i = 0;
+	struct sunxi_card_priv *priv = container_of(work,
+						    struct sunxi_card_priv,
+						    hs_button_work.work);
+
+	mutex_lock(&priv->jack_mlock);
+	for (i = 0; i < 1; i++) {
+		if (priv->key_hook == 0) {
+			LOG_INFO("Hook (2)!!");
+			priv->switch_status &= ~SND_JACK_BTN_0;
+			snd_jack_report(priv->jack.jack, priv->switch_status);
+			break;
+		}
+		/* may msleep 8 */
+		msleep(20);
+	}
+	mutex_unlock(&priv->jack_mlock);
+}
+
+static irqreturn_t jack_interrupt(int irq, void *dev_id)
+{
+	struct sunxi_card_priv *priv = dev_id;
+	struct sunxi_codec_info *sunxi_codec =
+				snd_soc_component_get_drvdata(priv->component);
+	struct timespec64 tv;
+	u32 tempdata = 0, regval = 0;
+	int jack_state = 0;
+
+	if (priv->jack_irq_times == RESUME_IRQ ||
+	    priv->jack_irq_times == SYSINIT_IRQ) {
+		LOG_INFO("is_irq is ture");
+		is_irq = true;
+		priv->jack_irq_times = OTHER_IRQ;
+	}
+
+	regmap_read(sunxi_codec->codec_regmap, SUNXI_HMIC_STS, &jack_state);
+
+	/*
+	if (priv->detect_state != PLUG_IN) {
+		//when headphone half-insertion, MIC_DET IRQ will be trigger.
+		if (jack_state & (1 << MIC_DET_ST)) {
+			regmap_read(sunxi_codec->codec_regmap, SUNXI_HMIC_CTRL, &regval);
+			regval &= ~(0x1 << MIC_DET_IRQ_EN);
+			regmap_write(sunxi_codec->codec_regmap, SUNXI_HMIC_CTRL, regval);
+
+			regmap_read(sunxi_codec->codec_regmap, SUNXI_MICBIAS_REG, &regval);
+			regval &= ~(0x1 << MICADCEN);
+			regmap_write(sunxi_codec->codec_regmap, SUNXI_MICBIAS_REG, regval);
+
+			//clear mic detect status
+			regmap_read(sunxi_codec->codec_regmap, SUNXI_HMIC_STS, &regval);
+			regval &= ~(0x1 << JACK_DET_IIN_ST);
+			regval &= ~(0x1 << JACK_DET_OUT_ST);
+			regval |= 0x1 << MIC_DET_ST;
+			regmap_write(sunxi_codec->codec_regmap, SUNXI_HMIC_STS, regval);
+
+			//prevent mic detect false trigger
+			schedule_delayed_work(&priv->hs_checkplug_work,
+				msecs_to_jiffies(700));
+		}
+	}
+	*/
+
+	/* headphone plugin */
+	if (jack_state & (1 << JACK_DET_IIN_ST)) {
+		regval = jack_state;
+		regval &= ~(0x1 << JACK_DET_OUT_ST);
+		regmap_write(sunxi_codec->codec_regmap, SUNXI_HMIC_STS, regval);
+		priv->detect_state = PLUG_IN;
+		/* get jack insert time to set mic det dead time */
+		ktime_get_real_ts64(&priv->tv_headset_plugin);
+		schedule_delayed_work(&priv->hs_detect_work,
+				      msecs_to_jiffies(10));
+	}
+
+	/* headphone plugout */
+	if (jack_state & (1 << JACK_DET_OUT_ST)) {
+		regval = jack_state;
+		regval &= ~(0x1 << JACK_DET_IIN_ST);
+		regmap_write(sunxi_codec->codec_regmap, SUNXI_HMIC_STS, regval);
+		priv->detect_state = PLUG_OUT;
+		schedule_delayed_work(&priv->hs_detect_work,
+				      msecs_to_jiffies(10));
+	}
+
+	/* headphone btn event */
+	if ((priv->detect_state == PLUG_IN) &&
+	    (jack_state & (1 << MIC_DET_ST))) {
+		regval = jack_state;
+		regval &= ~(0x1 << JACK_DET_IIN_ST);
+		regval &= ~(0x1 << JACK_DET_OUT_ST);
+		regmap_write(sunxi_codec->codec_regmap, SUNXI_HMIC_STS, regval);
+
+		/* plugin less 1s, not operate */
+		ktime_get_real_ts64(&tv);
+		if (abs(tv.tv_sec - priv->tv_headset_plugin.tv_sec) < 1)
+			return IRQ_HANDLED;
+
+		regmap_read(sunxi_codec->codec_regmap, SUNXI_HMIC_STS, &tempdata);
+		tempdata = (tempdata & 0x1f00) >> 8;
+		LOG_ERR("KEY tempdata: %d", tempdata);
+
+		if (tempdata == 2) {
+			priv->key_hook = 0;
+			priv->key_voldown = 0;
+			priv->key_voiceassist = 0;
+			priv->key_volup++;
+			if (priv->key_volup == 1) {
+				LOG_INFO("Volume ++");
+				priv->key_volup = 0;
+				priv->switch_status |= SND_JACK_BTN_1;
+				snd_jack_report(priv->jack.jack,
+						priv->switch_status);
+				priv->switch_status &= ~SND_JACK_BTN_1;
+				snd_jack_report(priv->jack.jack,
+						priv->switch_status);
+			}
+		} else if ((tempdata == 5) || tempdata == 4) {
+			priv->key_volup = 0;
+			priv->key_hook = 0;
+			priv->key_voiceassist = 0;
+			priv->key_voldown++;
+			if (priv->key_voldown == 1) {
+				LOG_INFO("Volume --");
+				priv->key_voldown = 0;
+				priv->switch_status |= SND_JACK_BTN_2;
+				snd_jack_report(priv->jack.jack,
+						priv->switch_status);
+				priv->switch_status &= ~SND_JACK_BTN_2;
+				snd_jack_report(priv->jack.jack,
+						priv->switch_status);
+			}
+		} else if (tempdata == 1) {
+			priv->key_volup = 0;
+			priv->key_hook = 0;
+			priv->key_voldown = 0;
+			priv->key_voiceassist++;
+			if (priv->key_voiceassist == 1) {
+				LOG_INFO("Voice Assistant Open");
+				priv->key_voiceassist = 0;
+				priv->switch_status |= SND_JACK_BTN_3;
+				snd_jack_report(priv->jack.jack,
+						priv->switch_status);
+				priv->switch_status &= ~SND_JACK_BTN_3;
+				snd_jack_report(priv->jack.jack,
+						priv->switch_status);
+			}
+		} else if (tempdata == 0x0) {
+			priv->key_volup = 0;
+			priv->key_voldown = 0;
+			priv->key_voiceassist = 0;
+			priv->key_hook++;
+			if (priv->key_hook >= 1) {
+				priv->key_hook = 0;
+				if ((priv->switch_status & SND_JACK_BTN_0)
+				    == 0) {
+					priv->switch_status |= SND_JACK_BTN_0;
+					snd_jack_report(priv->jack.jack,
+							priv->switch_status);
+					LOG_INFO("Hook (1)");
+				}
+				schedule_delayed_work(&priv->hs_button_work,
+						      msecs_to_jiffies(180));
+			}
+		} else {
+			LOG_ERR("tempdata:0x%x,Key data err:",
+				 tempdata);
+			priv->key_volup = 0;
+			priv->key_voldown = 0;
+			priv->key_hook = 0;
+			priv->key_voiceassist = 0;
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+static const struct snd_kcontrol_new sunxi_card_controls[] = {
+	SOC_DAPM_PIN_SWITCH("HPOUT"),
+	SOC_DAPM_PIN_SWITCH("LINEOUT"),
+	SOC_DAPM_PIN_SWITCH("Speaker"),
+};
+
+static void sunxi_hs_reg_init(struct sunxi_card_priv *priv)
+{
+	struct sunxi_codec_info *sunxi_codec =
+				snd_soc_component_get_drvdata(priv->component);
+
+	/*
+	regmap_update_bits(sunxi_codec->codec_regmap,
+			SUNXI_HMIC_CTRL, (0xffff << 0),
+			(0x0 << 0));
+	*/
+	regmap_update_bits(sunxi_codec->codec_regmap,
+			SUNXI_HMIC_CTRL, (0x1f << MDATA_THRESHOLD),
+			(0x17 << MDATA_THRESHOLD));
+	/*
+	regmap_update_bits(sunxi_codec->codec_regmap,
+			SUNXI_HMIC_STS, (0xffff << 0),
+			(0x6000 << 0));
+	*/
+	/*
+	regmap_update_bits(sunxi_codec->codec_regmap,
+			SUNXI_MICBIAS_REG, (0x7f << SELDETADCBF),
+			(0x40 << SELDETADCBF));
+	*/
+	if (priv->hp_detect_case == HP_DETECT_LOW) {
+		regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_MICBIAS_REG, (0x1 << AUTOPLEN),
+				(0x1 << AUTOPLEN));
+		regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_MICBIAS_REG, (0x1 << DETMODE),
+				(0x0 << DETMODE));
+	} else {
+		regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_MICBIAS_REG, (0x1 << AUTOPLEN),
+				(0x0 << AUTOPLEN));
+		regmap_update_bits(sunxi_codec->codec_regmap,
+				SUNXI_MICBIAS_REG, (0x1 << DETMODE),
+				(0x1 << DETMODE));
+	}
+	regmap_update_bits(sunxi_codec->codec_regmap,
+			SUNXI_HMIC_CTRL, (0xf << HMIC_N),
+			(HP_DEBOUCE_TIME << HMIC_N));
+	regmap_update_bits(sunxi_codec->codec_regmap,
+			SUNXI_MICBIAS_REG, (0x1 << JACKDETEN),
+			(0x1 << JACKDETEN));
+	regmap_update_bits(sunxi_codec->codec_regmap,
+			SUNXI_HMIC_CTRL, (0x1 << JACK_IN_IRQ_EN),
+			(0x1 << JACK_IN_IRQ_EN));
+	regmap_update_bits(sunxi_codec->codec_regmap,
+			SUNXI_HMIC_CTRL, (0x1 << JACK_OUT_IRQ_EN),
+			(0x1 << JACK_OUT_IRQ_EN));
+
+	/*
+	regmap_update_bits(sunxi_codec->codec_regmap,
+			SUNXI_MICBIAS_REG, (0x1 << HMICBIASEN),
+			(0x1 << HMICBIASEN));
+	regmap_update_bits(sunxi_codec->codec_regmap,
+			SUNXI_MICBIAS_REG, (0x1 << MICADCEN),
+			(0x1 << MICADCEN));
+	*/
+
+	/*
+	regmap_update_bits(sunxi_codec->codec_regmap,
+			SUNXI_HMIC_CTRL, (0x1 << MIC_DET_IRQ_EN),
+			(0x1 << MIC_DET_IRQ_EN));
+	*/
+
+	schedule_delayed_work(&priv->hs_init_work, msecs_to_jiffies(10));
+}
+
+static void snd_sunxi_unregister_jack(struct sunxi_card_priv *priv)
+{
+	/*
+	 * Set process button events to false so that the button
+	 * delayed work will not be scheduled.
+	 */
+	cancel_delayed_work_sync(&priv->hs_detect_work);
+	cancel_delayed_work_sync(&priv->hs_button_work);
+	cancel_delayed_work_sync(&priv->hs_init_work);
+	free_irq(priv->jackirq, priv);
+}
+
+/*
+ * Card initialization
+ */
+static int sunxi_card_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_component *component = rtd->codec_dai->component;
+	struct snd_soc_dapm_context *dapm = &component->dapm;
+	struct sunxi_card_priv *priv = snd_soc_card_get_drvdata(rtd->card);
+	int ret;
+
+	priv->component = rtd->codec_dai->component;
+
+	ret = snd_soc_card_jack_new(rtd->card, "sunxi Audio Jack",
+			       SND_JACK_HEADSET | SND_JACK_HEADPHONE |
+				   SND_JACK_BTN_0 | SND_JACK_BTN_1 |
+				   SND_JACK_BTN_2 | SND_JACK_BTN_3,
+			       &priv->jack, NULL, 0);
+	if (ret) {
+		LOG_ERR("jack creation failed");
+		return ret;
+	}
+
+	snd_jack_set_key(priv->jack.jack, SND_JACK_BTN_0, KEY_MEDIA);
+	snd_jack_set_key(priv->jack.jack, SND_JACK_BTN_1, KEY_VOLUMEUP);
+	snd_jack_set_key(priv->jack.jack, SND_JACK_BTN_2, KEY_VOLUMEDOWN);
+	snd_jack_set_key(priv->jack.jack, SND_JACK_BTN_3, KEY_VOICECOMMAND);
+
+	snd_soc_dapm_disable_pin(dapm, "LINEOUT");
+	snd_soc_dapm_disable_pin(dapm, "HPOUT");
+	snd_soc_dapm_disable_pin(dapm, "Speaker");
+
+	snd_soc_dapm_sync(dapm);
+
+	LOG_WARN("card init finished");
+
+	return 0;
+}
+
+static int sunxi_card_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	/* struct snd_soc_card *card = rtd->card; */
+	unsigned int freq, clk_div;
+	int ret;
+	int stream_flag;
+
+	switch (params_rate(params)) {
+	case	8000:
+	case	12000:
+	case	16000:
+	case	24000:
+	case	32000:
+	case	48000:
+	case	96000:
+	case	192000:
+		freq = 24576000;
+		break;
+	case	11025:
+	case	22050:
+	case	44100:
+		freq = 22579200;
+		break;
+	default:
+		LOG_ERR("invalid rate setting");
+		return -EINVAL;
+	}
+
+	/* the substream type: 0->playback, 1->capture */
+	stream_flag = substream->stream;
+	LOG_INFO("stream_flag: %d", stream_flag);
+
+	/* To surpport playback and capture func in different freq point */
+	if (freq == 22579200) {
+		if (stream_flag == 0) {
+			ret = snd_soc_dai_set_sysclk(codec_dai, 0, freq, 0);
+			if (ret < 0) {
+				LOG_ERR("set codec dai sysclk faided, freq:%d", freq);
+				return ret;
+			}
+		}
+	}
+
+	if (freq == 22579200) {
+		if (stream_flag == 1) {
+			ret = snd_soc_dai_set_sysclk(codec_dai, 1, freq, 0);
+			if (ret < 0) {
+				LOG_ERR("set codec dai sysclk faided, freq:%d", freq);
+				return ret;
+			}
+		}
+	}
+
+	if (freq == 24576000) {
+		if (stream_flag == 0) {
+			ret = snd_soc_dai_set_sysclk(codec_dai, 2, freq, 0);
+			if (ret < 0) {
+				LOG_ERR("set codec dai sysclk faided, freq:%d", freq);
+				return ret;
+			}
+		}
+	}
+
+	if (freq == 24576000) {
+			if (stream_flag == 1) {
+			ret = snd_soc_dai_set_sysclk(codec_dai, 3, freq, 0);
+			if (ret < 0) {
+				LOG_ERR("set codec dai sysclk faided, freq:%d", freq);
+				return ret;
+			}
+		}
+	}
+
+	/* inter i2s clkdiv setting */
+	clk_div = freq / params_rate(params);
+
+	ret = snd_soc_dai_set_clkdiv(codec_dai, 0, clk_div);
+	if (ret < 0) {
+		LOG_ERR("inter i2s set clkdiv faided, clkdiv:%d", clk_div);
+		return ret;
+	}
+
+	return 0;
+}
+
+static struct snd_soc_ops sunxi_card_ops = {
+	.hw_params = sunxi_card_hw_params,
+};
+
+SND_SOC_DAILINK_DEFS(sun50iw12p1_dai_link,
+	DAILINK_COMP_ARRAY(COMP_CPU("sunxi-dummy-cpudai")),
+	DAILINK_COMP_ARRAY(COMP_CODEC("sunxi-internal-codec", "sun50iw12codec")),
+	DAILINK_COMP_ARRAY(COMP_PLATFORM("sunxi-dummy-cpudai")));
+
+static struct snd_soc_dai_link sunxi_card_dai_link[] = {
+	{
+		.name		= "audiocodec",
+		.stream_name	= "SUNXI-CODEC",
+		.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF
+				| SND_SOC_DAIFMT_CBM_CFM,
+		.init		= sunxi_card_init,
+		.ops		= &sunxi_card_ops,
+		SND_SOC_DAILINK_REG(sun50iw12p1_dai_link),
+	},
+};
+
+static int sunxi_card_suspend(struct snd_soc_card *card)
+{
+	struct sunxi_card_priv *priv = snd_soc_card_get_drvdata(card);
+	struct sunxi_codec_info *sunxi_codec =
+				snd_soc_component_get_drvdata(priv->component);
+
+	disable_irq(priv->jackirq);
+
+	regmap_update_bits(sunxi_codec->codec_regmap,
+			SUNXI_HMIC_CTRL, (0x1 << MIC_DET_IRQ_EN),
+			(0x0 << MIC_DET_IRQ_EN));
+	regmap_update_bits(sunxi_codec->codec_regmap,
+			SUNXI_HMIC_CTRL, (0x1 << JACK_IN_IRQ_EN),
+			(0x0 << JACK_IN_IRQ_EN));
+	regmap_update_bits(sunxi_codec->codec_regmap,
+			SUNXI_HMIC_CTRL, (0x1 << JACK_OUT_IRQ_EN),
+			(0x0 << JACK_OUT_IRQ_EN));
+	regmap_update_bits(sunxi_codec->codec_regmap,
+			SUNXI_MICBIAS_REG, (0x1 << JACKDETEN),
+			(0x0 << JACKDETEN));
+
+	LOG_INFO("suspend");
+
+	return 0;
+}
+
+static int sunxi_card_resume(struct snd_soc_card *card)
+{
+	struct sunxi_card_priv *priv = snd_soc_card_get_drvdata(card);
+
+	enable_irq(priv->jackirq);
+	priv->jack_irq_times = RESUME_IRQ;
+	priv->detect_state = PLUG_OUT;/*todo..?*/
+	sunxi_hs_reg_init(priv);
+	LOG_INFO("resume");
+
+	return 0;
+}
+
+static struct snd_soc_card snd_soc_sunxi_card = {
+	.name			= "audiocodec",
+	.owner			= THIS_MODULE,
+	.dai_link		= sunxi_card_dai_link,
+	.num_links		= ARRAY_SIZE(sunxi_card_dai_link),
+	.suspend_post		= sunxi_card_suspend,
+	.resume_post		= sunxi_card_resume,
+
+};
+
+static int sunxi_card_dev_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	u32 temp_val;
+	struct sunxi_card_priv *priv = NULL;
+	struct device_node *np = pdev->dev.of_node;
+	struct snd_soc_card *card = &snd_soc_sunxi_card;
+//	struct snd_soc_dapm_context *dapm = &card->dapm;
+
+	if (!np) {
+		LOG_ERR("can not get dt node for this device");
+		return -EINVAL;
+	}
+
+	/* dai link */
+	sunxi_card_dai_link[0].cpus->dai_name = NULL;
+	sunxi_card_dai_link[0].cpus->of_node = of_parse_phandle(np,
+					"sunxi,cpudai-controller", 0);
+	if (!sunxi_card_dai_link[0].cpus->of_node) {
+		LOG_ERR("Property 'sunxi,cpudai-controller' missing or invalid");
+		ret = -EINVAL;
+		goto err_devm_kfree;
+	} else {
+		sunxi_card_dai_link[0].platforms->name = NULL;
+		sunxi_card_dai_link[0].platforms->of_node =
+				sunxi_card_dai_link[0].cpus->of_node;
+	}
+	sunxi_card_dai_link[0].codecs->name = NULL;
+	sunxi_card_dai_link[0].codecs->of_node = of_parse_phandle(np,
+						"sunxi,audio-codec", 0);
+	if (!sunxi_card_dai_link[0].codecs->of_node) {
+		LOG_ERR("Property 'sunxi,audio-codec' missing or invalid");
+		ret = -EINVAL;
+		goto err_devm_kfree;
+	}
+
+	/* register the soc card */
+	card->dev = &pdev->dev;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(struct sunxi_card_priv),
+			    GFP_KERNEL);
+	if (!priv) {
+		LOG_ERR("devm_kzalloc failed %d", ret);
+		return -ENOMEM;
+	}
+	priv->card = card;
+
+	snd_soc_card_set_drvdata(card, priv);
+
+	ret = snd_soc_register_card(card);
+	if (ret) {
+		LOG_ERR("snd_soc_register_card failed %d", ret);
+		goto err_devm_kfree;
+	}
+
+	ret = snd_soc_add_card_controls(card, sunxi_card_controls,
+					ARRAY_SIZE(sunxi_card_controls));
+	if (ret) {
+		LOG_ERR("failed to register codec controls");
+	}
+
+	ret = of_property_read_u32(np, "jack_enable", &temp_val);
+	if (ret < 0) {
+		LOG_ERR("jack_enable missing, use default enable jack");
+		priv->jack_func = JACK_ENABLE;
+	} else {
+		priv->jack_func = temp_val;
+	}
+	if (priv->jack_func == JACK_DISABLE)
+		return 0;
+
+	ret = of_property_read_u32(np, "hp_detect_case", &temp_val);
+	if (ret < 0) {
+		LOG_ERR("hp_detect_case missing, use default hp_detect_low");
+		priv->hp_detect_case = HP_DETECT_LOW;
+	} else {
+		priv->hp_detect_case = temp_val;
+	}
+
+	/* initial the parameters for judge switch state */
+	priv->jack_irq_times = SYSINIT_IRQ;
+	priv->HEADSET_DATA = 0xA;
+	priv->detect_state = PLUG_OUT;
+	mutex_init(&priv->jack_mlock);
+	INIT_DELAYED_WORK(&priv->hs_detect_work, sunxi_check_hs_detect_status);
+	INIT_DELAYED_WORK(&priv->hs_button_work, sunxi_check_hs_button_status);
+	INIT_DELAYED_WORK(&priv->hs_init_work, sunxi_hs_init_work);
+	INIT_DELAYED_WORK(&priv->hs_checkplug_work, sunxi_check_hs_plug);
+
+	priv->jackirq = platform_get_irq(pdev, 0);
+	if (priv->jackirq < 0) {
+		LOG_ERR("irq get failed");
+		ret = -ENODEV;
+	}
+	ret = request_irq(priv->jackirq, jack_interrupt, 0, "audio jack irq",
+			  priv);
+
+	sunxi_hs_reg_init(priv);
+
+	LOG_INFO("register card finished");
+	return 0;
+
+err_devm_kfree:
+	devm_kfree(&pdev->dev, priv);
+	return ret;
+}
+
+static int __exit sunxi_card_dev_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+	struct sunxi_card_priv *priv = snd_soc_card_get_drvdata(card);
+	struct sunxi_codec_info *sunxi_codec =
+				snd_soc_component_get_drvdata(priv->component);
+
+	regmap_update_bits(sunxi_codec->codec_regmap,
+			SUNXI_HMIC_CTRL, (0x1 << JACK_IN_IRQ_EN),
+			(0x0 << JACK_IN_IRQ_EN));
+	regmap_update_bits(sunxi_codec->codec_regmap,
+			SUNXI_HMIC_CTRL, (0x1 << JACK_OUT_IRQ_EN),
+			(0x0 << JACK_OUT_IRQ_EN));
+	regmap_update_bits(sunxi_codec->codec_regmap,
+			SUNXI_MICBIAS_REG, (0x1 << JACKDETEN),
+			(0x0 << JACKDETEN));
+	regmap_update_bits(sunxi_codec->codec_regmap,
+			SUNXI_MICBIAS_REG, (0x1 << HMICBIASEN),
+			(0x0 << HMICBIASEN));
+
+	snd_sunxi_unregister_jack(priv);
+	snd_soc_unregister_card(card);
+	devm_kfree(&pdev->dev, priv);
+
+	LOG_WARN("unregister card finished");
+
+	return 0;
+}
+
+static const struct of_device_id sunxi_card_of_match[] = {
+	{ .compatible = "allwinner,sunxi-codec-machine", },
+	{},
+};
+
+static struct platform_driver sunxi_machine_driver = {
+	.driver = {
+		.name = "sunxi-codec-machine",
+		.owner = THIS_MODULE,
+		.pm = &snd_soc_pm_ops,
+		.of_match_table = sunxi_card_of_match,
+	},
+	.probe = sunxi_card_dev_probe,
+	.remove = __exit_p(sunxi_card_dev_remove),
+};
+
+static int __init sunxi_machine_driver_init(void)
+{
+	return platform_driver_register(&sunxi_machine_driver);
+}
+module_init(sunxi_machine_driver_init);
+
+static void __exit sunxi_machine_driver_exit(void)
+{
+	platform_driver_unregister(&sunxi_machine_driver);
+}
+module_exit(sunxi_machine_driver_exit);
+
+module_param_named(switch_state, switch_state, int, S_IRUGO | S_IWUSR);
+
+MODULE_DESCRIPTION("SUNXI Codec Machine ASoC driver");
+MODULE_AUTHOR("Dby <Dby@allwinnertech.com>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:sunxi-codec-machine");
diff --git a/sound/soc/sunxi/sun8iw20-codec.c b/sound/soc/sunxi/sun8iw20-codec.c
new file mode 100644
index 000000000..b53e4bdf5
--- /dev/null
+++ b/sound/soc/sunxi/sun8iw20-codec.c
@@ -0,0 +1,2692 @@
+/*
+ * sound\soc\sunxi\sun8iw20-codec.c
+ * (C) Copyright 2021-2026
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * yumingfeng <yumingfeng@allwinnertech.com>
+ * luguofang <luguofang@allwinnertech.com>
+ * Dby <Dby@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/pm.h>
+#include <linux/regulator/consumer.h>
+#include <linux/pinctrl/pinctrl-sunxi.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
+#include <linux/reset.h>
+#include <asm/dma.h>
+#include <sound/pcm.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/core.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <sound/tlv.h>
+#include <linux/sunxi-gpio.h>
+#include <linux/sunxi-sid.h>
+
+#include "sun8iw20-codec.h"
+
+#define LOG_ERR(fmt, arg...)	pr_err("[AUDIOCODEC][%s][%d]:" fmt "\n", __func__, __LINE__, ##arg)
+#define LOG_WARN(fmt, arg...)	pr_warn("[AUDIOCODEC][%s][%d]:" fmt "\n", __func__, __LINE__, ##arg)
+#define LOG_INFO(fmt, arg...)	pr_info("[AUDIOCODEC][%s][%d]:" fmt "\n", __func__, __LINE__, ##arg)
+#define LOG_DEBUG(fmt, arg...)	pr_debug("[AUDIOCODEC][%s][%d]:" fmt "\n", __func__, __LINE__, ##arg)
+
+/* digital audio process function */
+enum sunxi_hw_dap {
+	DAP_HP_EN = 0x1,
+	DAP_SPK_EN = 0x2,
+	/* DAP_HP_EN | DAP_SPK_EN */
+	DAP_HPSPK_EN = 0x3,
+};
+
+static const struct sample_rate sample_rate_conv[] = {
+	{8000,   5},
+	{11025,  4},
+	{12000,  4},
+	{16000,  3},
+	{22050,  2},
+	{24000,  2},
+	{32000,  1},
+	{44100,  0},
+	{48000,  0},
+	{96000,  7},
+	{192000, 6},
+};
+
+static const DECLARE_TLV_DB_SCALE(digital_tlv, -7424, 116, 0);
+static const DECLARE_TLV_DB_SCALE(dac_vol_tlv, -11925, 75, 0);
+static const DECLARE_TLV_DB_SCALE(adc_vol_tlv, -11925, 75, 0);
+static const DECLARE_TLV_DB_SCALE(mic_gain_tlv, 0, 100, 0);
+static const DECLARE_TLV_DB_SCALE(fmin_gain_tlv, 0, 600, 0);
+static const DECLARE_TLV_DB_SCALE(linein_gain_tlv, 0, 600, 0);
+static const DECLARE_TLV_DB_SCALE(headphone_gain_tlv, -4200, 600, 0);
+static const unsigned int lineout_tlv[] = {
+	TLV_DB_RANGE_HEAD(2),
+	0, 1, TLV_DB_SCALE_ITEM(0, 0, 1),
+	2, 31, TLV_DB_SCALE_ITEM(-4350, 150, 1),
+};
+
+static struct reg_label reg_labels[] = {
+	REG_LABEL(SUNXI_DAC_DPC),
+	REG_LABEL(SUNXI_DAC_VOL_CTRL),
+	REG_LABEL(SUNXI_DAC_FIFOC),
+	REG_LABEL(SUNXI_DAC_FIFOS),
+	REG_LABEL(SUNXI_DAC_TXDATA),
+	REG_LABEL(SUNXI_DAC_CNT),
+	REG_LABEL(SUNXI_DAC_DG),
+	REG_LABEL(SUNXI_ADC_FIFOC),
+	REG_LABEL(SUNXI_ADC_VOL_CTRL),
+	REG_LABEL(SUNXI_ADC_FIFOS),
+	REG_LABEL(SUNXI_ADC_RXDATA),
+	REG_LABEL(SUNXI_ADC_CNT),
+	REG_LABEL(SUNXI_ADC_DG),
+	REG_LABEL(SUNXI_ADC_DIG_CTRL),
+	REG_LABEL(SUNXI_VRA1SPEEDUP_DOWN_CTRL),
+#ifdef SUNXI_CODEC_DAP_ENABLE
+	REG_LABEL(SUNXI_DAC_DAP_CTL),
+	REG_LABEL(SUNXI_ADC_DAP_CTL),
+#endif
+	REG_LABEL(SUNXI_ADC1_REG),
+	REG_LABEL(SUNXI_ADC2_REG),
+	REG_LABEL(SUNXI_ADC3_REG),
+	REG_LABEL(SUNXI_DAC_REG),
+	REG_LABEL(SUNXI_MICBIAS_REG),
+	REG_LABEL(SUNXI_RAMP_REG),
+	REG_LABEL(SUNXI_BIAS_REG),
+	REG_LABEL(SUNXI_HMIC_CTRL),
+	REG_LABEL(SUNXI_HMIC_STS),
+	REG_LABEL(SUNXI_HP2_REG),
+	REG_LABEL(SUNXI_POWER_REG),
+	REG_LABEL(SUNXI_ADC_CUR_REG),
+	REG_LABEL_END,
+};
+
+#ifdef SUNXI_CODEC_DAP_ENABLE
+static void adcdrc_config(struct snd_soc_component *component)
+{
+	/* Enable DRC gain Min and Max limit, detect noise, Using Peak Filter */
+	snd_soc_component_update_bits(component, SUNXI_ADC_DRC_CTRL,
+		((0x1 << ADC_DRC_DELAY_BUF_EN) |
+		(0x1 << ADC_DRC_GAIN_MAX_EN) | (0x1 << ADC_DRC_GAIN_MIN_EN) |
+		(0x1 << ADC_DRC_NOISE_DET_EN) |
+		(0x1 << ADC_DRC_SIGNAL_SEL) |
+		(0x1 << ADC_DRC_LT_EN) | (0x1 << ADC_DRC_ET_EN)),
+		((0x1 << ADC_DRC_DELAY_BUF_EN) |
+		(0x1 << ADC_DRC_GAIN_MAX_EN) | (0x1 << ADC_DRC_GAIN_MIN_EN) |
+		(0x1 << ADC_DRC_NOISE_DET_EN) |
+		(0x1 << ADC_DRC_SIGNAL_SEL) |
+		(0x1 << ADC_DRC_LT_EN) | (0x1 << ADC_DRC_ET_EN)));
+
+	/* Left peak filter attack time */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LPFHAT, (0x000B77F0 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LPFLAT, 0x000B77F0 & 0xFFFF);
+	/* Right peak filter attack time */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_RPFHAT, (0x000B77F0 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_RPFLAT, 0x000B77F0 & 0xFFFF);
+	/* Left peak filter release time */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LPFHRT, (0x00FFE1F8 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LPFLRT, 0x00FFE1F8 & 0xFFFF);
+	/* Right peak filter release time */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_RPFHRT, (0x00FFE1F8 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_RPFLRT, 0x00FFE1F8 & 0xFFFF);
+
+	/* Left RMS filter attack time */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LPFHAT, (0x00012BB0 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LPFLAT, 0x00012BB0 & 0xFFFF);
+	/* Right RMS filter attack time */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_RPFHAT, (0x00012BB0 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_RPFLAT, 0x00012BB0 & 0xFFFF);
+
+	/* OPL */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_HOPL, (0xFF641741 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LOPL, 0xFF641741 & 0xFFFF);
+	/* OPC */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_HOPC, (0xFC0380F3 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LOPC, 0xFC0380F3 & 0xFFFF);
+	/* OPE */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_HOPE, (0xF608C25F >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LOPE, 0xF608C25F & 0xFFFF);
+	/* LT */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_HLT, (0x035269E0 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LLT, 0x035269E0 & 0xFFFF);
+	/* CT */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_HCT, (0x06B3002C >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LCT, 0x06B3002C & 0xFFFF);
+	/* ET */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_HET, (0x0A139682 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LET, 0x0A139682 & 0xFFFF);
+	/* Ki */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_HKI, (0x00222222 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LKI, 0x00222222 & 0xFFFF);
+	/* Kc */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_HKC, (0x01000000 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LKC, 0x01000000 & 0xFFFF);
+	/* Kn */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_HKN, (0x01C53EF0 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LKN, 0x01C53EF0 & 0xFFFF);
+	/* Ke */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_HKE, (0x04234F68 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LKE, 0x04234F68 & 0xFFFF);
+
+	/* smooth filter attack time */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_SFHAT, (0x00017665 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_SFLAT, 0x00017665 & 0xFFFF);
+	/* gain smooth filter release time */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_SFHRT, (0x00000F04 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_SFLRT, 0x00000F04 & 0xFFFF);
+
+	/* gain max setting */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_MXGHS, (0x69E0F95B >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_MXGLS, 0x69E0F95B & 0xFFFF);
+
+	/* gain min setting */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_MNGHS, (0xF95B2C3F >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_MNGLS, 0xF95B2C3F & 0xFFFF);
+
+	/* smooth filter release and attack time */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_EPSHC, (0x00025600 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_EPSHC, 0x00025600 & 0xFFFF);
+}
+
+static void adcdrc_enable(struct snd_soc_component *component, bool on)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct codec_dap *adc_dap = &sunxi_codec->adc_dap;
+
+	if (on) {
+		if (adc_dap->drc_enable++ == 0) {
+			snd_soc_component_update_bits(component, SUNXI_ADC_DAP_CTL,
+				(0x1 << ADC_DRC0_EN), (0x1 << ADC_DRC0_EN));
+			snd_soc_component_update_bits(component, SUNXI_ADC_DAP_CTL,
+				(0x1 << ADC_DRC1_EN), (0x1 << ADC_DRC1_EN));
+			if (sunxi_codec->adc_dap_enable++ == 0) {
+				snd_soc_component_update_bits(component, SUNXI_ADC_DAP_CTL,
+					(0x1 << ADC_DAP0_EN), (0x1 << ADC_DAP0_EN));
+				snd_soc_component_update_bits(component, SUNXI_ADC_DAP_CTL,
+					(0x1 << ADC_DAP1_EN), (0x1 << ADC_DAP1_EN));
+			}
+		}
+	} else {
+		if (--adc_dap->drc_enable <= 0) {
+			adc_dap->drc_enable = 0;
+			if (--sunxi_codec->adc_dap_enable <= 0) {
+				sunxi_codec->adc_dap_enable = 0;
+				snd_soc_component_update_bits(component, SUNXI_ADC_DAP_CTL,
+					(0x1 << ADC_DAP0_EN), (0x0 << ADC_DAP0_EN));
+				snd_soc_component_update_bits(component, SUNXI_ADC_DAP_CTL,
+					(0x1 << ADC_DAP1_EN), (0x0 << ADC_DAP1_EN));
+			}
+			snd_soc_component_update_bits(component, SUNXI_ADC_DAP_CTL,
+				(0x1 << ADC_DRC0_EN), (0x0 << ADC_DRC0_EN));
+			snd_soc_component_update_bits(component, SUNXI_ADC_DAP_CTL,
+				(0x1 << ADC_DRC1_EN), (0x0 << ADC_DRC1_EN));
+		}
+	}
+}
+
+static void adchpf_config(struct snd_soc_component *component)
+{
+	/* HPF */
+	snd_soc_component_write(component, SUNXI_ADC_DRC_HHPFC, (0xFFFAC1 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_ADC_DRC_LHPFC, 0xFFFAC1 & 0xFFFF);
+}
+
+static void adchpf_enable(struct snd_soc_component *component, bool on)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct codec_dap *adc_dap = &sunxi_codec->adc_dap;
+
+	if (on) {
+		if (adc_dap->hpf_enable++ == 0) {
+			snd_soc_component_update_bits(component, SUNXI_ADC_DAP_CTL,
+				(0x1 << ADC_HPF0_EN), (0x1 << ADC_HPF0_EN));
+			snd_soc_component_update_bits(component, SUNXI_ADC_DAP_CTL,
+				(0x1 << ADC_HPF1_EN), (0x1 << ADC_HPF1_EN));
+			if (sunxi_codec->adc_dap_enable++ == 0) {
+				snd_soc_component_update_bits(component, SUNXI_ADC_DAP_CTL,
+					(0x1 << ADC_DAP0_EN), (0x1 << ADC_DAP0_EN));
+				snd_soc_component_update_bits(component, SUNXI_ADC_DAP_CTL,
+					(0x1 << ADC_DAP1_EN), (0x1 << ADC_DAP1_EN));
+			}
+		}
+	} else {
+		if (--adc_dap->hpf_enable <= 0) {
+			adc_dap->hpf_enable = 0;
+			if (--sunxi_codec->adc_dap_enable <= 0) {
+				sunxi_codec->adc_dap_enable = 0;
+				snd_soc_component_update_bits(component, SUNXI_ADC_DAP_CTL,
+					(0x1 << ADC_DAP0_EN), (0x0 << ADC_DAP0_EN));
+				snd_soc_component_update_bits(component, SUNXI_ADC_DAP_CTL,
+					(0x1 << ADC_DAP1_EN), (0x0 << ADC_DAP1_EN));
+			}
+			snd_soc_component_update_bits(component, SUNXI_ADC_DAP_CTL,
+				(0x1 << ADC_HPF0_EN), (0x0 << ADC_HPF0_EN));
+			snd_soc_component_update_bits(component, SUNXI_ADC_DAP_CTL,
+				(0x1 << ADC_HPF1_EN), (0x0 << ADC_HPF1_EN));
+		}
+	}
+}
+
+static void dacdrc_config(struct snd_soc_component *component)
+{
+	/* Left peak filter attack time */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LPFHAT, (0x000B77BF >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LPFLAT, 0x000B77BF & 0xFFFF);
+	/* Right peak filter attack time */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_RPFHAT, (0x000B77F0 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_RPFLAT, 0x000B77F0 & 0xFFFF);
+
+	/* Left peak filter release time */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LPFHRT, (0x00FFE1F8 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LPFLRT, 0x00FFE1F8 & 0xFFFF);
+	/* Right peak filter release time */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_RPFHRT, (0x00FFE1F8 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_RPFLRT, 0x00FFE1F8 & 0xFFFF);
+
+	/* Left RMS filter attack time */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LRMSHAT, (0x00012BB0 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LRMSLAT, 0x00012BB0 & 0xFFFF);
+	/* Right RMS filter attack time */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_RRMSHAT, (0x00012BB0 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_RRMSLAT, 0x00012BB0 & 0xFFFF);
+
+	/* smooth filter attack time */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_SFHAT, (0x00017665 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_SFLAT, 0x00017665 & 0xFFFF);
+	/* gain smooth filter release time */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_SFHRT, (0x00000F04 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_SFLRT, 0x00000F04 & 0xFFFF);
+
+	/* OPL */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_HOPL, (0xFE56CB10 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LOPL, 0xFE56CB10 & 0xFFFF);
+	/* OPC */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_HOPC, (0xFB04612F >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LOPC, 0xFB04612F & 0xFFFF);
+	/* OPE */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_HOPE, (0xF608C25F >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LOPE, 0xF608C25F & 0xFFFF);
+	/* LT */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_HLT, (0x035269E0 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LLT, 0x035269E0 & 0xFFFF);
+	/* CT */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_HCT, (0x06B3002C >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LCT, 0x06B3002C & 0xFFFF);
+	/* ET */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_HET, (0x0A139682 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LET, 0x0A139682 & 0xFFFF);
+	/* Ki */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_HKI, (0x00400000 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LKI, 0x00400000 & 0xFFFF);
+	/* Kc */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_HKC, (0x00FBCDA5 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LKC, 0x00FBCDA5 & 0xFFFF);
+	/* Kn */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_HKN, (0x0179B472 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LKN, 0x0179B472 & 0xFFFF);
+	/* Ke */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_HKE, (0x04234F68 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LKE, 0x04234F68 & 0xFFFF);
+	/* MXG */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_MXGHS, (0x035269E0 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_MXGLS, 0x035269E0 & 0xFFFF);
+	/* MNG */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_MNGHS, (0xF95B2C3F >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_MNGLS, 0xF95B2C3F & 0xFFFF);
+	/* EPS */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_EPSHC, (0x00025600 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_EPSLC, 0x00025600 & 0xFFFF);
+}
+
+static void dacdrc_enable(struct snd_soc_component *component, bool on)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct codec_dap *dac_dap = &sunxi_codec->dac_dap;
+
+	if (on) {
+		if (dac_dap->drc_enable++ == 0) {
+			/* detect noise when ET enable */
+			snd_soc_component_update_bits(component, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_NOISE_DET_EN),
+				(0x1 << DAC_DRC_NOISE_DET_EN));
+
+			/* 0x0:RMS filter; 0x1:Peak filter */
+			snd_soc_component_update_bits(component, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_SIGNAL_SEL),
+				(0x1 << DAC_DRC_SIGNAL_SEL));
+
+			snd_soc_component_update_bits(component, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_GAIN_MAX_EN),
+				(0x1 << DAC_DRC_GAIN_MAX_EN));
+
+			snd_soc_component_update_bits(component, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_GAIN_MIN_EN),
+				(0x1 << DAC_DRC_GAIN_MIN_EN));
+
+			/* delay function enable */
+			snd_soc_component_update_bits(component, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_DELAY_BUF_EN),
+				(0x1 << DAC_DRC_DELAY_BUF_EN));
+
+			snd_soc_component_update_bits(component, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_LT_EN),
+				(0x1 << DAC_DRC_LT_EN));
+			snd_soc_component_update_bits(component, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_ET_EN),
+				(0x1 << DAC_DRC_ET_EN));
+
+			snd_soc_component_update_bits(component, SUNXI_DAC_DAP_CTL,
+				(0x1 << DDAP_DRC_EN),
+				(0x1 << DDAP_DRC_EN));
+
+			if (sunxi_codec->dac_dap_enable++ == 0)
+				snd_soc_component_update_bits(component, SUNXI_DAC_DAP_CTL,
+					(0x1 << DDAP_EN), (0x1 << DDAP_EN));
+		}
+	} else {
+		if (--dac_dap->drc_enable <= 0) {
+			dac_dap->drc_enable = 0;
+			if (--sunxi_codec->dac_dap_enable <= 0) {
+				sunxi_codec->dac_dap_enable = 0;
+				snd_soc_component_update_bits(component, SUNXI_DAC_DAP_CTL,
+					(0x1 << DDAP_EN), (0x0 << DDAP_EN));
+			}
+
+			snd_soc_component_update_bits(component, SUNXI_DAC_DAP_CTL,
+				(0x1 << DDAP_DRC_EN),
+				(0x0 << DDAP_DRC_EN));
+
+			/* detect noise when ET enable */
+			snd_soc_component_update_bits(component, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_NOISE_DET_EN),
+				(0x0 << DAC_DRC_NOISE_DET_EN));
+
+			/* 0x0:RMS filter; 0x1:Peak filter */
+			snd_soc_component_update_bits(component, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_SIGNAL_SEL),
+				(0x0 << DAC_DRC_SIGNAL_SEL));
+
+			/* delay function enable */
+			snd_soc_component_update_bits(component, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_DELAY_BUF_EN),
+				(0x0 << DAC_DRC_DELAY_BUF_EN));
+
+			snd_soc_component_update_bits(component, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_GAIN_MAX_EN),
+				(0x0 << DAC_DRC_GAIN_MAX_EN));
+			snd_soc_component_update_bits(component, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_GAIN_MIN_EN),
+				(0x0 << DAC_DRC_GAIN_MIN_EN));
+
+			snd_soc_component_update_bits(component, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_LT_EN),
+				(0x0 << DAC_DRC_LT_EN));
+			snd_soc_component_update_bits(component, SUNXI_DAC_DRC_CTRL,
+				(0x1 << DAC_DRC_ET_EN),
+				(0x0 << DAC_DRC_ET_EN));
+		}
+	}
+}
+
+static void dachpf_config(struct snd_soc_component *component)
+{
+	/* HPF */
+	snd_soc_component_write(component, SUNXI_DAC_DRC_HHPFC, (0xFFFAC1 >> 16) & 0xFFFF);
+	snd_soc_component_write(component, SUNXI_DAC_DRC_LHPFC, 0xFFFAC1 & 0xFFFF);
+}
+
+static void dachpf_enable(struct snd_soc_component *component, bool on)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct codec_dap *dac_dap = &sunxi_codec->dac_dap;
+
+	if (on) {
+		if (dac_dap->hpf_enable++ == 0) {
+			snd_soc_component_update_bits(component, SUNXI_DAC_DAP_CTL,
+				(0x1 << DDAP_HPF_EN), (0x1 << DDAP_HPF_EN));
+
+			if (sunxi_codec->dac_dap_enable++ == 0)
+				snd_soc_component_update_bits(component, SUNXI_DAC_DAP_CTL,
+					(0x1 << DDAP_EN), (0x1 << DDAP_EN));
+		}
+	} else {
+		if (--dac_dap->hpf_enable <= 0) {
+			dac_dap->hpf_enable = 0;
+			if (--sunxi_codec->dac_dap_enable <= 0) {
+				sunxi_codec->dac_dap_enable = 0;
+				snd_soc_component_update_bits(component, SUNXI_DAC_DAP_CTL,
+					(0x1 << DDAP_EN), (0x0 << DDAP_EN));
+			}
+
+			snd_soc_component_update_bits(component, SUNXI_DAC_DAP_CTL,
+				(0x1 << DDAP_HPF_EN),
+				(0x0 << DDAP_HPF_EN));
+		}
+	}
+}
+#endif
+
+int sunxi_get_gain_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	unsigned int invert = mc->invert;
+	unsigned int shift = mc->shift;
+	int max = mc->max;
+	int min = mc->min;
+	u32 val_tmp;
+
+	switch (shift) {
+	case MIC1_GAIN_SHIFT:
+		val_tmp = sunxi_codec->mic1gain;
+	break;
+	case MIC2_GAIN_SHIFT:
+		val_tmp = sunxi_codec->mic2gain;
+	break;
+	case MIC3_GAIN_SHIFT:
+		val_tmp = sunxi_codec->mic3gain;
+	break;
+	case HP_GAIN_SHIFT:
+		val_tmp = sunxi_codec->headphonegain;
+	break;
+	default:
+		LOG_ERR("the gain is null");
+	break;
+	}
+
+	if (val_tmp > max || val_tmp < min)
+		return -1;
+
+	ucontrol->value.integer.value[0] = val_tmp - min;
+	if (invert)
+		ucontrol->value.integer.value[0] =
+			max - ucontrol->value.integer.value[0];
+
+	return 0;
+}
+
+int sunxi_put_gain_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	unsigned int invert = mc->invert;
+	unsigned int shift = mc->shift;
+	int max = mc->max;
+	int min = mc->min;
+	u32 val_tmp;
+
+	val_tmp = ucontrol->value.integer.value[0] + min;
+	if (invert)
+		val_tmp = max - val_tmp;
+
+	switch (shift) {
+	case MIC1_GAIN_SHIFT:
+		sunxi_codec->mic1gain = val_tmp;
+		if (sunxi_codec->mic1gain_now)
+			snd_soc_component_update_bits(component,
+				SUNXI_ADC1_REG,
+				(0x1F<<ADC1_PGA_GAIN_CTRL),
+				(sunxi_codec->mic1gain<<ADC1_PGA_GAIN_CTRL));
+	break;
+	case MIC2_GAIN_SHIFT:
+		sunxi_codec->mic2gain = val_tmp;
+		if (sunxi_codec->mic2gain_now)
+			snd_soc_component_update_bits(component,
+				SUNXI_ADC2_REG,
+				(0x1F<<ADC2_PGA_GAIN_CTRL),
+				(sunxi_codec->mic2gain<<ADC2_PGA_GAIN_CTRL));
+	break;
+	case MIC3_GAIN_SHIFT:
+		sunxi_codec->mic3gain = val_tmp;
+		if (sunxi_codec->mic3gain_now)
+			snd_soc_component_update_bits(component,
+				SUNXI_ADC3_REG,
+				(0x1F<<ADC3_PGA_GAIN_CTRL),
+				(sunxi_codec->mic3gain<<ADC3_PGA_GAIN_CTRL));
+	break;
+	case HP_GAIN_SHIFT:
+		sunxi_codec->headphonegain = val_tmp;
+		if (sunxi_codec->hpgain_now)
+			snd_soc_component_update_bits(component,
+				SUNXI_HP2_REG,
+				0x7 << HEADPHONE_GAIN,
+				sunxi_codec->headphonegain << HEADPHONE_GAIN);
+	break;
+	default:
+		LOG_ERR("the gain is null");
+	break;
+	}
+
+	return 0;
+}
+
+static int sunxi_codec_playback_event(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *k, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+
+	switch (event) {
+	case	SND_SOC_DAPM_PRE_PMU:
+		/* DACL to left channel LINEOUT Mute control 0:mute 1: not mute */
+		msleep(30);
+		snd_soc_component_update_bits(component, SUNXI_DAC_REG,
+				(0x1 << DACLMUTE) | (0x1 << DACRMUTE),
+				(0x1 << DACLMUTE) | (0x1 << DACRMUTE));
+		snd_soc_component_update_bits(component, SUNXI_DAC_DPC,
+				(0x1<<EN_DAC), (0x1<<EN_DAC));
+		break;
+	case	SND_SOC_DAPM_POST_PMD:
+		snd_soc_component_update_bits(component, SUNXI_DAC_DPC,
+				(0x1<<EN_DAC), (0x0<<EN_DAC));
+		/* DACL to left channel LINEOUT Mute control 0:mute 1: not mute */
+		snd_soc_component_update_bits(component, SUNXI_DAC_REG,
+				(0x1 << DACLMUTE) | (0x1 << DACRMUTE),
+				(0x0 << DACLMUTE) | (0x0 << DACRMUTE));
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+#ifdef SUNXI_CODEC_HUB_ENABLE
+static int sunxi_codec_get_hub_mode(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	unsigned int reg_val;
+
+	reg_val = snd_soc_component_read32(component, SUNXI_DAC_DPC);
+
+	ucontrol->value.integer.value[0] =
+				((reg_val & (0x1 << DAC_HUB_EN)) ? 1 : 0);
+
+	return 0;
+}
+
+static int sunxi_codec_set_hub_mode(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+
+	switch (ucontrol->value.integer.value[0]) {
+	case	0:
+		snd_soc_component_update_bits(component, SUNXI_DAC_DPC,
+				(0x1 << DAC_HUB_EN), (0x0 << DAC_HUB_EN));
+		break;
+	case	1:
+		snd_soc_component_update_bits(component, SUNXI_DAC_DPC,
+				(0x1 << DAC_HUB_EN), (0x1 << DAC_HUB_EN));
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/* sunxi codec hub mdoe select */
+static const char * const sunxi_codec_hub_function[] = {
+				"hub_disable", "hub_enable"};
+
+static const struct soc_enum sunxi_codec_hub_mode_enum[] = {
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(sunxi_codec_hub_function),
+			sunxi_codec_hub_function),
+};
+#endif
+
+#ifdef SUNXI_CODEC_ADCSWAP_ENABLE
+static int sunxi_codec_get_adcswap1_mode(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	unsigned int reg_val;
+
+	reg_val = snd_soc_component_read32(component, SUNXI_ADC_DG);
+
+	ucontrol->value.integer.value[0] =
+				((reg_val & (0x1 << AD_SWP1)) ? 1 : 0);
+
+	return 0;
+}
+
+static int sunxi_codec_set_adcswap1_mode(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+
+	switch (ucontrol->value.integer.value[0]) {
+	case	0:
+		snd_soc_component_update_bits(component, SUNXI_ADC_DG,
+				(0x1 << AD_SWP1), (0x0 << AD_SWP1));
+		break;
+	case	1:
+		snd_soc_component_update_bits(component, SUNXI_ADC_DG,
+				(0x1 << AD_SWP1), (0x1 << AD_SWP1));
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sunxi_codec_get_adcswap2_mode(struct snd_kcontrol *kcontrol,
+					 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	unsigned int reg_val;
+
+	reg_val = snd_soc_component_read32(component, SUNXI_ADC_DG);
+
+	ucontrol->value.integer.value[0] =
+				((reg_val & (0x1 << AD_SWP2)) ? 1 : 0);
+
+	return 0;
+}
+
+static int sunxi_codec_set_adcswap2_mode(struct snd_kcontrol *kcontrol,
+					 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+
+	switch (ucontrol->value.integer.value[0]) {
+	case	0:
+		snd_soc_component_update_bits(component, SUNXI_ADC_DG,
+				(0x1 << AD_SWP2), (0x0 << AD_SWP2));
+		break;
+	case	1:
+		snd_soc_component_update_bits(component, SUNXI_ADC_DG,
+				(0x1 << AD_SWP2), (0x1 << AD_SWP2));
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/* sunxi codec adc swap func */
+static const char * const sunxi_codec_adcswap_function[] = {
+				"Off", "On"};
+
+static const struct soc_enum sunxi_codec_adcswap_func_enum[] = {
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(sunxi_codec_adcswap_function),
+			sunxi_codec_adcswap_function),
+};
+#endif
+
+static int sunxi_codec_hpspeaker_event(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *k, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct codec_spk_config *spk_cfg = &(sunxi_codec->spk_config);
+	struct codec_hw_config *hw_cfg = &(sunxi_codec->hw_config);
+
+	switch (event) {
+	case	SND_SOC_DAPM_POST_PMU:
+#ifdef SUNXI_CODEC_DAP_ENABLE
+		if (hw_cfg->dacdrc_cfg & DAP_SPK_EN)
+			dacdrc_enable(component, 1);
+		else if (hw_cfg->dacdrc_cfg & DAP_HP_EN)
+			dacdrc_enable(component, 0);
+
+		if (hw_cfg->dachpf_cfg & DAP_SPK_EN)
+			dachpf_enable(component, 1);
+		else if (hw_cfg->dachpf_cfg & DAP_HP_EN)
+			dachpf_enable(component, 0);
+#endif
+		if (spk_cfg->used) {
+			gpio_direction_output(spk_cfg->spk_gpio, 1);
+			gpio_set_value(spk_cfg->spk_gpio, spk_cfg->pa_level);
+			/* time delay to wait spk pa work fine */
+			msleep(spk_cfg->pa_msleep);
+		}
+		break;
+	case	SND_SOC_DAPM_PRE_PMD:
+		if (spk_cfg->used)
+			gpio_set_value(spk_cfg->spk_gpio, !(spk_cfg->pa_level));
+#ifdef SUNXI_CODEC_DAP_ENABLE
+		if (hw_cfg->dacdrc_cfg & DAP_SPK_EN)
+			dacdrc_enable(component, 0);
+		if (hw_cfg->dacdrc_cfg & DAP_SPK_EN)
+			dachpf_enable(component, 0);
+#endif
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int sunxi_codec_headphone_event(struct snd_soc_dapm_widget *w,
+			struct snd_kcontrol *k,	int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct codec_hw_config *hw_cfg = &(sunxi_codec->hw_config);
+	unsigned int reg_val;
+
+	switch (event) {
+	case SND_SOC_DAPM_POST_PMU:
+	sunxi_codec->hpgain_now = 1;
+#ifdef SUNXI_CODEC_DAP_ENABLE
+	if (hw_cfg->dacdrc_cfg & DAP_HP_EN)
+		dacdrc_enable(component, 1);
+	if (hw_cfg->dachpf_cfg & DAP_HP_EN)
+		dachpf_enable(component, 1);
+#endif
+	/* In order to ensure that the hpout pop for B chip SOC,
+	 * the B chip SOC needs to disable RMC_EN and enable RD_EN
+	 * when up HPOUT (whether LINEOUT use).
+	 */
+	if (sunxi_get_soc_ver() & 0x7) {
+		snd_soc_component_update_bits(component, SUNXI_RAMP_REG,
+				(0x1 << RMC_EN), (0x0 << RMC_EN));
+		snd_soc_component_update_bits(component, SUNXI_RAMP_REG,
+				(0x1 << RD_EN), (0x1 << RD_EN));
+		msleep(100);
+	} else {
+		snd_soc_component_update_bits(component, SUNXI_HP2_REG,
+				(0x1 << HPFB_BUF_EN), (0x1 << HPFB_BUF_EN));
+		snd_soc_component_update_bits(component, SUNXI_HP2_REG,
+				(0x1 << HP_DRVEN), (0x1 << HP_DRVEN));
+		snd_soc_component_update_bits(component, SUNXI_HP2_REG,
+				(0x1 << HP_DRVOUTEN), (0x1 << HP_DRVOUTEN));
+		snd_soc_component_update_bits(component, SUNXI_HP2_REG,
+				(0x1 << RSWITCH), (0x1 << RSWITCH));
+		snd_soc_component_update_bits(component, SUNXI_HP2_REG,
+				(0x1 << HPFB_IN_EN), (0x1 << HPFB_IN_EN));
+		snd_soc_component_update_bits(component, SUNXI_HP2_REG,
+				(0x1 << RAMP_OUT_EN), (0x1 << RAMP_OUT_EN));
+		snd_soc_component_update_bits(component, SUNXI_POWER_REG,
+				(0x1 << HPLDO_EN), (0x1 << HPLDO_EN));
+	}
+		break;
+	case SND_SOC_DAPM_PRE_PMD:
+	sunxi_codec->hpgain_now = 0;
+
+	/* In order to ensure that the hpout pop for B chip SOC,
+	 * the B chip SOC needs to enable RMC_EN and disable RD_EN
+	 * when down HPOUT and LINEOUT useing.
+	 */
+	if (sunxi_get_soc_ver() & 0x7) {
+		/* if lineout playing, enable RMC_EN */
+		reg_val = snd_soc_component_read32(component, SUNXI_DAC_REG);
+		if ((reg_val & (0x1 << LINEOUTLEN)) || (reg_val & (0x1 << LINEOUTREN)))
+			snd_soc_component_update_bits(component, SUNXI_RAMP_REG,
+					(0x1 << RMC_EN), (0x1 << RMC_EN));
+
+		snd_soc_component_update_bits(component, SUNXI_RAMP_REG,
+				(0x1 << RD_EN), (0x0 << RD_EN));
+		msleep(100);
+	} else {
+		snd_soc_component_update_bits(component, SUNXI_POWER_REG,
+				(0x1 << HPLDO_EN), (0x0 << HPLDO_EN));
+		snd_soc_component_update_bits(component, SUNXI_HP2_REG,
+				(0x1 << HPFB_BUF_EN), (0x0 << HPFB_BUF_EN));
+		snd_soc_component_update_bits(component, SUNXI_HP2_REG,
+				(0x1 << HP_DRVEN), (0x0 << HP_DRVEN));
+		snd_soc_component_update_bits(component, SUNXI_HP2_REG,
+				(0x1 << HP_DRVOUTEN), (0x0 << HP_DRVOUTEN));
+		snd_soc_component_update_bits(component, SUNXI_HP2_REG,
+				(0x1 << RSWITCH), (0x0 << RSWITCH));
+		snd_soc_component_update_bits(component, SUNXI_HP2_REG,
+				(0x1 << HPFB_IN_EN), (0x0 << HPFB_IN_EN));
+		snd_soc_component_update_bits(component, SUNXI_HP2_REG,
+				(0x1 << RAMP_OUT_EN), (0x0 << RAMP_OUT_EN));
+	}
+#ifdef SUNXI_CODEC_DAP_ENABLE
+	if (hw_cfg->dacdrc_cfg & DAP_HP_EN)
+		dacdrc_enable(component, 0);
+	if (hw_cfg->dachpf_cfg & DAP_HP_EN)
+		dachpf_enable(component, 0);
+#endif
+		break;
+	}
+
+	return 0;
+}
+
+static int sunxi_codec_lineout_event(struct snd_soc_dapm_widget *w,
+				  struct snd_kcontrol *k, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct codec_spk_config *spk_cfg = &(sunxi_codec->spk_config);
+	struct codec_hw_config *hw_cfg = &(sunxi_codec->hw_config);
+	unsigned int reg_val;
+
+	switch (event) {
+	case	SND_SOC_DAPM_POST_PMU:
+#ifdef SUNXI_CODEC_DAP_ENABLE
+	if (hw_cfg->dacdrc_cfg & DAP_SPK_EN)
+		dacdrc_enable(component, 1);
+	if (hw_cfg->dachpf_cfg & DAP_SPK_EN)
+		dachpf_enable(component, 1);
+#endif
+
+	/* In order to ensure that the hpout pop for B chip SOC,
+	 * the B chip SOC needs to enable RMC_EN when RD_EN disable (HPOUT no useing).
+	 */
+	if (sunxi_get_soc_ver() & 0x7) {
+		reg_val = snd_soc_component_read32(component, SUNXI_RAMP_REG);
+		if (!(reg_val & (0x1 << RD_EN)))
+			snd_soc_component_update_bits(component, SUNXI_RAMP_REG,
+					(0x1 << RMC_EN), (0x1 << RMC_EN));
+	}
+
+	snd_soc_component_update_bits(component, SUNXI_DAC_REG,
+			(0x1 << LINEOUTLEN), (0x1 << LINEOUTLEN));
+	snd_soc_component_update_bits(component, SUNXI_DAC_REG,
+			(0x1 << LINEOUTREN), (0x1 << LINEOUTREN));
+
+	if (spk_cfg->used) {
+		gpio_direction_output(spk_cfg->spk_gpio, 1);
+		gpio_set_value(spk_cfg->spk_gpio, spk_cfg->pa_level);
+		/* time delay to wait spk pa work fine */
+		msleep(spk_cfg->pa_msleep);
+	}
+		break;
+	case	SND_SOC_DAPM_PRE_PMD:
+	if (spk_cfg->used)
+		gpio_set_value(spk_cfg->spk_gpio, !(spk_cfg->pa_level));
+
+	snd_soc_component_update_bits(component, SUNXI_DAC_REG,
+			(0x1 << LINEOUTLEN), (0x0 << LINEOUTLEN));
+	snd_soc_component_update_bits(component, SUNXI_DAC_REG,
+			(0x1 << LINEOUTREN), (0x0 << LINEOUTREN));
+
+	/* In order to ensure that the hpout pop for B chip SOC,
+	 * the B chip SOC needs to disable RMC_EN when RD_EN disable and disable lineout.
+	 */
+	if (sunxi_get_soc_ver() & 0x7) {
+		reg_val = snd_soc_component_read32(component, SUNXI_RAMP_REG);
+		if (!(reg_val & (0x1 << RD_EN)))
+			snd_soc_component_update_bits(component, SUNXI_RAMP_REG,
+					(0x1 << RMC_EN), (0x0 << RMC_EN));
+	}
+
+#ifdef SUNXI_CODEC_DAP_ENABLE
+	if (hw_cfg->dacdrc_cfg & DAP_SPK_EN)
+		dacdrc_enable(component, 0);
+	if (hw_cfg->dachpf_cfg & DAP_SPK_EN)
+		dachpf_enable(component, 0);
+#endif
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int sunxi_hp_gain_event(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *k, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	switch (event) {
+	case	SND_SOC_DAPM_PRE_PMU:
+		snd_soc_component_update_bits(component, SUNXI_HP2_REG,
+				0x7 << HEADPHONE_GAIN,
+				sunxi_codec->headphonegain << HEADPHONE_GAIN);
+		break;
+	case	SND_SOC_DAPM_POST_PMD:
+		snd_soc_component_update_bits(component, SUNXI_HP2_REG,
+				0x7 << HEADPHONE_GAIN,
+				0x0 << HEADPHONE_GAIN);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int sunxi_mic1_gain_event(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *k, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	switch (event) {
+	case	SND_SOC_DAPM_PRE_PMU:
+		snd_soc_component_update_bits(component, SUNXI_ADC1_REG,
+				(0x1F<<ADC1_PGA_GAIN_CTRL),
+				(sunxi_codec->mic1gain<<ADC1_PGA_GAIN_CTRL));
+		break;
+	case	SND_SOC_DAPM_POST_PMD:
+		snd_soc_component_update_bits(component, SUNXI_ADC1_REG,
+				(0x1F<<ADC1_PGA_GAIN_CTRL),
+				(0x0<<ADC1_PGA_GAIN_CTRL));
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int sunxi_mic2_gain_event(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *k, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	switch (event) {
+	case	SND_SOC_DAPM_PRE_PMU:
+		snd_soc_component_update_bits(component, SUNXI_ADC2_REG,
+				(0x1F<<ADC2_PGA_GAIN_CTRL),
+				(sunxi_codec->mic2gain<<ADC2_PGA_GAIN_CTRL));
+		break;
+	case	SND_SOC_DAPM_POST_PMD:
+		snd_soc_component_update_bits(component, SUNXI_ADC2_REG,
+				(0x1F<<ADC2_PGA_GAIN_CTRL),
+				(0x0<<ADC2_PGA_GAIN_CTRL));
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int sunxi_mic3_gain_event(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *k, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	switch (event) {
+	case	SND_SOC_DAPM_PRE_PMU:
+		snd_soc_component_update_bits(component, SUNXI_ADC3_REG,
+				(0x1F<<ADC3_PGA_GAIN_CTRL),
+				(sunxi_codec->mic3gain<<ADC3_PGA_GAIN_CTRL));
+		break;
+	case	SND_SOC_DAPM_POST_PMD:
+		snd_soc_component_update_bits(component, SUNXI_ADC3_REG,
+				(0x1F<<ADC3_PGA_GAIN_CTRL),
+				(0x0<<ADC3_PGA_GAIN_CTRL));
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int sunxi_codec_adc1_event(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *k, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	switch (event) {
+	case	SND_SOC_DAPM_POST_PMU:
+		//mdelay(80);
+		sunxi_codec->mic1gain_now = 1;
+		snd_soc_component_update_bits(component, SUNXI_ADC_DIG_CTRL,
+					      0x1 << ADC1_CHANNEL_EN,
+					      0x1 << ADC1_CHANNEL_EN);
+		snd_soc_component_update_bits(component, SUNXI_ADC1_REG,
+					      0x1 << ADC1_EN,
+					      0x1 << ADC1_EN);
+		snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+					      0x1 << EN_AD,
+					      0x1 << EN_AD);
+		break;
+	case	SND_SOC_DAPM_POST_PMD:
+		sunxi_codec->mic1gain_now = 0;
+		snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+					      0x1 << EN_AD,
+					      0x0 << EN_AD);
+		snd_soc_component_update_bits(component, SUNXI_ADC1_REG,
+					      0x1 << ADC1_EN,
+					      0x0 << ADC1_EN);
+		snd_soc_component_update_bits(component, SUNXI_ADC_DIG_CTRL,
+					      0x1 << ADC1_CHANNEL_EN,
+					      0x0 << ADC1_CHANNEL_EN);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int sunxi_codec_adc2_event(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *k, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	switch (event) {
+	case	SND_SOC_DAPM_POST_PMU:
+		//mdelay(80);
+		sunxi_codec->mic2gain_now = 1;
+		snd_soc_component_update_bits(component, SUNXI_ADC_DIG_CTRL,
+					      0x1 << ADC2_CHANNEL_EN,
+					      0x1 << ADC2_CHANNEL_EN);
+		snd_soc_component_update_bits(component, SUNXI_ADC2_REG,
+					      0x1 << ADC2_EN,
+					      0x1 << ADC2_EN);
+		snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+					      0x1 << EN_AD,
+					      0x1 << EN_AD);
+		break;
+	case	SND_SOC_DAPM_POST_PMD:
+		sunxi_codec->mic2gain_now = 0;
+		snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+					      0x1 << EN_AD,
+					      0x0 << EN_AD);
+		snd_soc_component_update_bits(component, SUNXI_ADC2_REG,
+					      0x1 << ADC2_EN,
+					      0x0 << ADC2_EN);
+		snd_soc_component_update_bits(component, SUNXI_ADC_DIG_CTRL,
+					      0x1 << ADC2_CHANNEL_EN,
+					      0x0 << ADC2_CHANNEL_EN);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int sunxi_codec_adc3_event(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *k, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	switch (event) {
+	case	SND_SOC_DAPM_POST_PMU:
+		//mdelay(80);
+		sunxi_codec->mic3gain_now = 1;
+		snd_soc_component_update_bits(component, SUNXI_ADC_DIG_CTRL,
+					      0x1 << ADC3_CHANNEL_EN,
+					      0x1 << ADC3_CHANNEL_EN);
+		snd_soc_component_update_bits(component, SUNXI_ADC3_REG,
+					      0x1 << ADC3_EN,
+					      0x1 << ADC3_EN);
+		snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+					      0x1 << EN_AD,
+					      0x1 << EN_AD);
+		break;
+	case	SND_SOC_DAPM_POST_PMD:
+		sunxi_codec->mic3gain_now = 0;
+		snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+					      0x1 << EN_AD,
+					      0x0 << EN_AD);
+		snd_soc_component_update_bits(component, SUNXI_ADC3_REG,
+					      0x1 << ADC3_EN,
+					      0x0 << ADC3_EN);
+		snd_soc_component_update_bits(component, SUNXI_ADC_DIG_CTRL,
+					      0x1 << ADC3_CHANNEL_EN,
+					      0x0 << ADC3_CHANNEL_EN);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int sunxi_codec_adc_mixer_event(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *k, int event)
+{
+#ifdef SUNXI_CODEC_DAP_ENABLE
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct codec_hw_config *hw_cfg = &(sunxi_codec->hw_config);
+	unsigned int adcctrl_val = 0;
+
+	switch (event) {
+	case SND_SOC_DAPM_POST_PMU:
+		if (hw_cfg->adcdrc_cfg & DAP_HP_EN) {
+			adcctrl_val = snd_soc_component_read32(component, SUNXI_ADC1_REG);
+			if ((adcctrl_val >> MIC1_PGA_EN) & 0x1)
+				adcdrc_enable(component, 1);
+		} else if (hw_cfg->adcdrc_cfg & DAP_SPK_EN) {
+			adcctrl_val = snd_soc_component_read32(component, SUNXI_ADC2_REG);
+			if ((adcctrl_val >> MIC2_PGA_EN) & 0x1)
+				adcdrc_enable(component, 1);
+		}
+		break;
+	case SND_SOC_DAPM_POST_PMD:
+		if ((hw_cfg->adcdrc_cfg & DAP_SPK_EN) ||
+			(hw_cfg->adcdrc_cfg & DAP_HP_EN))
+			adcdrc_enable(component, 0);
+		break;
+	default:
+		break;
+	}
+#endif
+
+	return 0;
+}
+
+static const struct snd_kcontrol_new sunxi_codec_controls[] = {
+#ifdef SUNXI_CODEC_HUB_ENABLE
+	SOC_ENUM_EXT("codec hub mode", sunxi_codec_hub_mode_enum[0],
+				sunxi_codec_get_hub_mode,
+				sunxi_codec_set_hub_mode),
+#endif
+#ifdef SUNXI_CODEC_ADCSWAP_ENABLE
+	SOC_ENUM_EXT("ADC1 ADC2 swap", sunxi_codec_adcswap_func_enum[0],
+		     sunxi_codec_get_adcswap1_mode,
+		     sunxi_codec_set_adcswap1_mode),
+	SOC_ENUM_EXT("ADC3 ADC4 swap", sunxi_codec_adcswap_func_enum[0],
+		     sunxi_codec_get_adcswap2_mode,
+		     sunxi_codec_set_adcswap2_mode),
+#endif
+	/* Digital Volume */
+	SOC_SINGLE_TLV("digital volume", SUNXI_DAC_DPC,
+		       DVOL, 0x3F, 1, digital_tlv),
+	/* DAC Volume */
+	SOC_DOUBLE_TLV("DAC volume", SUNXI_DAC_VOL_CTRL,
+		       DAC_VOL_L, DAC_VOL_R, 0xFF, 0, dac_vol_tlv),
+	/* ADC1 Volume */
+	SOC_SINGLE_TLV("ADC1 volume", SUNXI_ADC_VOL_CTRL,
+		       ADC1_VOL, 0xFF, 0, adc_vol_tlv),
+	/* ADC2 Volume */
+	SOC_SINGLE_TLV("ADC2 volume", SUNXI_ADC_VOL_CTRL,
+		       ADC2_VOL, 0xFF, 0, adc_vol_tlv),
+	/* ADC3 Volume */
+	SOC_SINGLE_TLV("ADC3 volume", SUNXI_ADC_VOL_CTRL,
+		       ADC3_VOL, 0xFF, 0, adc_vol_tlv),
+	/* MIC1 Gain */
+	SOC_SINGLE_EXT_TLV("MIC1 gain volume", SND_SOC_NOPM,
+			MIC1_GAIN_SHIFT, 0x1F, 0,
+			sunxi_get_gain_volsw,
+			sunxi_put_gain_volsw,
+			mic_gain_tlv),
+	/* MIC2 Gain */
+	SOC_SINGLE_EXT_TLV("MIC2 gain volume", SND_SOC_NOPM,
+			MIC2_GAIN_SHIFT, 0x1F, 0,
+			sunxi_get_gain_volsw,
+			sunxi_put_gain_volsw,
+			mic_gain_tlv),
+	/* MIC3 Gain */
+	SOC_SINGLE_EXT_TLV("MIC3 gain volume", SND_SOC_NOPM,
+			MIC3_GAIN_SHIFT, 0x1F, 0,
+			sunxi_get_gain_volsw,
+			sunxi_put_gain_volsw,
+			mic_gain_tlv),
+	/* FMIN_L Gain */
+	SOC_SINGLE_TLV("FMINL gain volume", SUNXI_ADC1_REG,
+		       FMINLG, 0x1, 0, fmin_gain_tlv),
+	/* FMIN_R Gain */
+	SOC_SINGLE_TLV("FMINR gain volume", SUNXI_ADC2_REG,
+		       FMINRG, 0x1, 0, fmin_gain_tlv),
+	/* LINEIN_L Gain */
+	SOC_SINGLE_TLV("LINEINL gain volume", SUNXI_ADC1_REG,
+		       LINEINLG, 0x1, 0, linein_gain_tlv),
+	/* LINEIN_R Gain */
+	SOC_SINGLE_TLV("LINEINR gain volume", SUNXI_ADC2_REG,
+		       LINEINRG, 0x1, 0, linein_gain_tlv),
+	/* LINEOUT Volume */
+	SOC_SINGLE_TLV("LINEOUT volume", SUNXI_DAC_REG,
+		       LINEOUT_VOL, 0x1F, 0, lineout_tlv),
+	/* Headphone Gain */
+	SOC_SINGLE_EXT_TLV("Headphone volume", SND_SOC_NOPM,
+			HP_GAIN_SHIFT, 0x07, 1,
+			sunxi_get_gain_volsw,
+			sunxi_put_gain_volsw,
+			headphone_gain_tlv),
+};
+
+/* lineout controls */
+static const char * const lineout_select_text[] = {
+	"DAC_SINGLE", "DAC_DIFFER",
+};
+/* micin controls */
+static const char * const micin_select_text[] = {
+	"MIC_DIFFER", "MIC_SINGLE",
+};
+
+static const struct soc_enum left_lineout_enum =
+	SOC_ENUM_SINGLE(SUNXI_DAC_REG, LINEOUTLDIFFEN,
+			ARRAY_SIZE(lineout_select_text), lineout_select_text);
+static const struct soc_enum right_lineout_enum =
+	SOC_ENUM_SINGLE(SUNXI_DAC_REG, LINEOUTRDIFFEN,
+			ARRAY_SIZE(lineout_select_text), lineout_select_text);
+
+static const struct soc_enum mic1_input_enum =
+	SOC_ENUM_SINGLE(SUNXI_ADC1_REG, MIC1_SIN_EN,
+			ARRAY_SIZE(micin_select_text), micin_select_text);
+static const struct soc_enum mic2_input_enum =
+	SOC_ENUM_SINGLE(SUNXI_ADC2_REG, MIC2_SIN_EN,
+			ARRAY_SIZE(micin_select_text), micin_select_text);
+static const struct soc_enum mic3_input_enum =
+	SOC_ENUM_SINGLE(SUNXI_ADC3_REG, MIC3_SIN_EN,
+			ARRAY_SIZE(micin_select_text), micin_select_text);
+
+static const struct snd_kcontrol_new left_lineout_mux =
+	SOC_DAPM_ENUM("LINEOUT Output Select", left_lineout_enum);
+static const struct snd_kcontrol_new right_lineout_mux =
+	SOC_DAPM_ENUM("LINEOUTR Output Select", right_lineout_enum);
+
+static const struct snd_kcontrol_new mic1_input_mux =
+	SOC_DAPM_ENUM("MIC1 Input Select", mic1_input_enum);
+static const struct snd_kcontrol_new mic2_input_mux =
+	SOC_DAPM_ENUM("MIC2 Input Select", mic2_input_enum);
+static const struct snd_kcontrol_new mic3_input_mux =
+	SOC_DAPM_ENUM("MIC3 Input Select", mic3_input_enum);
+
+static const struct snd_kcontrol_new adc1_input_mixer[] = {
+	SOC_DAPM_SINGLE("MIC1 Boost Switch", SUNXI_ADC1_REG, MIC1_PGA_EN, 1, 0),
+	SOC_DAPM_SINGLE("FMINL Switch", SUNXI_ADC1_REG, FMINLEN, 1, 0),
+	SOC_DAPM_SINGLE("LINEINL Switch", SUNXI_ADC1_REG, LINEINLEN, 1, 0),
+};
+
+static const struct snd_kcontrol_new adc2_input_mixer[] = {
+	SOC_DAPM_SINGLE("MIC2 Boost Switch", SUNXI_ADC2_REG, MIC2_PGA_EN, 1, 0),
+	SOC_DAPM_SINGLE("FMINR Switch", SUNXI_ADC2_REG, FMINREN, 1, 0),
+	SOC_DAPM_SINGLE("LINEINR Switch", SUNXI_ADC2_REG, LINEINREN, 1, 0),
+};
+
+static const struct snd_kcontrol_new adc3_input_mixer[] = {
+	SOC_DAPM_SINGLE("MIC3 Boost Switch", SUNXI_ADC3_REG, MIC3_PGA_EN, 1, 0),
+};
+
+/*audio dapm widget */
+static const struct snd_soc_dapm_widget sunxi_codec_dapm_widgets[] = {
+	SND_SOC_DAPM_AIF_IN_E("DACL", "Playback", 0, SUNXI_DAC_REG,
+				DACLEN, 0,
+				sunxi_codec_playback_event,
+				SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+
+	SND_SOC_DAPM_AIF_IN_E("DACR", "Playback", 0, SUNXI_DAC_REG,
+				DACREN, 0,
+				sunxi_codec_playback_event,
+				SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+
+	SND_SOC_DAPM_AIF_OUT_E("ADC1", "Capture", 0, SND_SOC_NOPM, 0, 0,
+			       sunxi_codec_adc1_event,
+			       SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_AIF_OUT_E("ADC2", "Capture", 0, SND_SOC_NOPM, 0, 0,
+			       sunxi_codec_adc2_event,
+			       SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_AIF_OUT_E("ADC3", "Capture", 0, SND_SOC_NOPM, 0, 0,
+			       sunxi_codec_adc3_event,
+			       SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
+
+	SND_SOC_DAPM_PGA_E("HP PGA", SND_SOC_NOPM, 0, 0, NULL, 0,
+			     sunxi_hp_gain_event,
+			     SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+
+	SND_SOC_DAPM_MUX("LINEOUTL Output Select", SND_SOC_NOPM, 0, 0,
+			 &left_lineout_mux),
+	SND_SOC_DAPM_MUX("LINEOUTR Output Select", SND_SOC_NOPM, 0, 0,
+			 &right_lineout_mux),
+
+	SND_SOC_DAPM_MUX("MIC1 Input Select", SND_SOC_NOPM, 0, 0,
+			 &mic1_input_mux),
+	SND_SOC_DAPM_MUX("MIC2 Input Select", SND_SOC_NOPM, 0, 0,
+			 &mic2_input_mux),
+	SND_SOC_DAPM_MUX("MIC3 Input Select", SND_SOC_NOPM, 0, 0,
+			 &mic3_input_mux),
+
+	SND_SOC_DAPM_PGA_E("MIC1 PGA", SND_SOC_NOPM, 0, 0, NULL, 0,
+			     sunxi_mic1_gain_event,
+			     SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_PGA_E("MIC2 PGA", SND_SOC_NOPM, 0, 0, NULL, 0,
+			     sunxi_mic2_gain_event,
+			     SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_PGA_E("MIC3 PGA", SND_SOC_NOPM, 0, 0, NULL, 0,
+			     sunxi_mic3_gain_event,
+			     SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+
+	SND_SOC_DAPM_MIXER_E("ADC1 Input", SND_SOC_NOPM, 0, 0,
+			     adc1_input_mixer, ARRAY_SIZE(adc1_input_mixer),
+			     sunxi_codec_adc_mixer_event,
+			     SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_MIXER_E("ADC2 Input", SND_SOC_NOPM, 0, 0,
+			     adc2_input_mixer, ARRAY_SIZE(adc2_input_mixer),
+			     sunxi_codec_adc_mixer_event,
+			     SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_MIXER_E("ADC3 Input", SND_SOC_NOPM, 0, 0,
+			     adc3_input_mixer, ARRAY_SIZE(adc3_input_mixer),
+			     sunxi_codec_adc_mixer_event,
+			     SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
+
+	SND_SOC_DAPM_MICBIAS("MainMic Bias", SUNXI_MICBIAS_REG, MMICBIASEN, 0),
+
+	SND_SOC_DAPM_INPUT("MIC1"),
+	SND_SOC_DAPM_INPUT("MIC2"),
+	SND_SOC_DAPM_INPUT("MIC3"),
+	SND_SOC_DAPM_INPUT("FMINL"),
+	SND_SOC_DAPM_INPUT("FMINR"),
+	SND_SOC_DAPM_INPUT("LINEINL"),
+	SND_SOC_DAPM_INPUT("LINEINR"),
+
+	SND_SOC_DAPM_OUTPUT("HPOUTL"),
+	SND_SOC_DAPM_OUTPUT("HPOUTR"),
+	SND_SOC_DAPM_OUTPUT("LINEOUTL"),
+	SND_SOC_DAPM_OUTPUT("LINEOUTR"),
+
+	SND_SOC_DAPM_HP("Headphone", sunxi_codec_headphone_event),
+	SND_SOC_DAPM_LINE("LINEOUT", sunxi_codec_lineout_event),
+	SND_SOC_DAPM_SPK("HpSpeaker", sunxi_codec_hpspeaker_event),
+};
+
+static const struct snd_soc_dapm_route sunxi_codec_dapm_routes[] = {
+	/* input route */
+	{"MIC1 Input Select", "MIC_SINGLE", "MIC1"},
+	{"MIC1 Input Select", "MIC_DIFFER", "MIC1"},
+	{"MIC2 Input Select", "MIC_SINGLE", "MIC2"},
+	{"MIC2 Input Select", "MIC_DIFFER", "MIC2"},
+	{"MIC3 Input Select", "MIC_SINGLE", "MIC3"},
+	{"MIC3 Input Select", "MIC_DIFFER", "MIC3"},
+
+	{"MIC1 PGA", NULL, "MIC1 Input Select"},
+	{"MIC2 PGA", NULL, "MIC2 Input Select"},
+	{"MIC3 PGA", NULL, "MIC3 Input Select"},
+
+	{"ADC1 Input", "MIC1 Boost Switch", "MIC1 PGA"},
+	{"ADC1 Input", "FMINL Switch", "FMINL"},
+	{"ADC1 Input", "LINEINL Switch", "LINEINL"},
+
+	{"ADC2 Input", "MIC2 Boost Switch", "MIC2 PGA"},
+	{"ADC2 Input", "FMINR Switch", "FMINR"},
+	{"ADC2 Input", "LINEINR Switch", "LINEINR"},
+
+	{"ADC3 Input", "MIC3 Boost Switch", "MIC3 PGA"},
+
+	{"ADC1", NULL, "ADC1 Input"},
+	{"ADC2", NULL, "ADC2 Input"},
+	{"ADC3", NULL, "ADC3 Input"},
+
+	/* Output route */
+	{"LINEOUTL Output Select", "DAC_SINGLE", "DACL"},
+	{"LINEOUTL Output Select", "DAC_DIFFER", "DACL"},
+
+	{"LINEOUTR Output Select", "DAC_SINGLE", "DACR"},
+	{"LINEOUTR Output Select", "DAC_DIFFER", "DACR"},
+
+	{"HPOUTL", NULL, "DACL"},
+	{"HPOUTR", NULL, "DACR"},
+
+	{"LINEOUTL", NULL, "LINEOUTL Output Select"},
+	{"LINEOUTR", NULL, "LINEOUTR Output Select"},
+
+	{"LINEOUT", NULL, "LINEOUTL"},
+	{"LINEOUT", NULL, "LINEOUTR"},
+
+	{"HP PGA", NULL, "HPOUTL"},
+	{"HP PGA", NULL, "HPOUTR"},
+
+	{"Headphone", NULL, "HP PGA"},
+	{"HpSpeaker", NULL, "HP PGA"},
+};
+
+static void sunxi_codec_init(struct snd_soc_component *component)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	/* In order to ensure that the ADC sampling is normal,
+	 * the A chip SOC needs to always open HPLDO and RMC_EN
+	 */
+	if (sunxi_get_soc_ver() & 0x7) {
+		snd_soc_component_update_bits(component, SUNXI_RAMP_REG,
+				(0x1 << RMC_EN), (0x0 << RMC_EN));
+	} else {
+		snd_soc_component_update_bits(component, SUNXI_POWER_REG,
+				(0x1 << HPLDO_EN), (0x1 << HPLDO_EN));
+		snd_soc_component_update_bits(component, SUNXI_RAMP_REG,
+				(0x1 << RMC_EN), (0x1 << RMC_EN));
+	}
+
+	/* DAC_VOL_SEL default disabled */
+	snd_soc_component_update_bits(component, SUNXI_DAC_VOL_CTRL,
+			(0x1 << DAC_VOL_SEL), (0x1 << DAC_VOL_SEL));
+
+	if (sunxi_codec->rx_sync_en) {
+		/* disabled ADCFDT */
+		snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+				(0x1 << ADCDFEN), (0x0 << ADCDFEN));
+		snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+				(0x3 << ADCFDT), (0x2 << ADCFDT));
+		/* Enable RX_SYNC_EN */
+		snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+				(0x1 << RX_SYNC_EN), (0x1 << RX_SYNC_EN));
+	} else {
+		/* Enable ADCFDT to overcome niose at the beginning */
+		snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+				(0x1 << ADCDFEN), (0x1 << ADCDFEN));
+		snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+				(0x3 << ADCFDT), (0x2 << ADCFDT));
+	}
+
+	/* Digital VOL defeult setting */
+	snd_soc_component_update_bits(component, SUNXI_DAC_DPC,
+			0x3F << DVOL,
+			sunxi_codec->digital_vol << DVOL);
+
+	/* LINEOUT VOL defeult setting */
+	snd_soc_component_update_bits(component, SUNXI_DAC_REG,
+			0x1F << LINEOUT_VOL,
+			sunxi_codec->lineout_vol << LINEOUT_VOL);
+
+	/* Headphone Gain defeult setting */
+	snd_soc_component_update_bits(component, SUNXI_HP2_REG,
+			0x7 << HEADPHONE_GAIN,
+			0x0 << HEADPHONE_GAIN);
+
+	/* ADCL MIC1 gain defeult setting */
+	snd_soc_component_update_bits(component, SUNXI_ADC1_REG,
+			0x1F << ADC1_PGA_GAIN_CTRL,
+			0x0 << ADC1_PGA_GAIN_CTRL);
+	/* ADCR MIC2 gain defeult setting */
+	snd_soc_component_update_bits(component, SUNXI_ADC2_REG,
+			0x1F << ADC2_PGA_GAIN_CTRL,
+			0x0 << ADC2_PGA_GAIN_CTRL);
+	/* ADCR MIC3 gain defeult setting */
+	snd_soc_component_update_bits(component, SUNXI_ADC3_REG,
+			0x1F << ADC3_PGA_GAIN_CTRL,
+			0x0 << ADC3_PGA_GAIN_CTRL);
+
+	/* ADC IOP params default setting */
+	snd_soc_component_update_bits(component, SUNXI_ADC1_REG,
+			0xFF << ADC1_IOPMIC, 0x55 << ADC1_IOPMIC);
+	snd_soc_component_update_bits(component, SUNXI_ADC2_REG,
+			0xFF << ADC2_IOPMIC, 0x55 << ADC2_IOPMIC);
+	snd_soc_component_update_bits(component, SUNXI_ADC3_REG,
+			0xFF << ADC3_IOPMIC, 0x55 << ADC3_IOPMIC);
+
+	snd_soc_component_update_bits(component, SUNXI_DAC_REG,
+			0x01 << LINEOUTLDIFFEN, 0x01 << LINEOUTLDIFFEN);
+	snd_soc_component_update_bits(component, SUNXI_DAC_REG,
+			0x01 << LINEOUTRDIFFEN, 0x01 << LINEOUTRDIFFEN);
+	snd_soc_component_update_bits(component, SUNXI_ADC1_REG,
+			0x01 << MIC1_SIN_EN, 0x00 << MIC1_SIN_EN);
+	snd_soc_component_update_bits(component, SUNXI_ADC2_REG,
+			0x01 << MIC2_SIN_EN, 0x00 << MIC2_SIN_EN);
+	snd_soc_component_update_bits(component, SUNXI_ADC3_REG,
+			0x01 << MIC3_SIN_EN, 0x00 << MIC3_SIN_EN);
+#ifdef SUNXI_CODEC_DAP_ENABLE
+	if (sunxi_codec->hw_config.adcdrc_cfg)
+		adcdrc_config(component);
+	if (sunxi_codec->hw_config.adchpf_cfg)
+		adchpf_config(component);
+
+	if (sunxi_codec->hw_config.dacdrc_cfg)
+		dacdrc_config(component);
+	if (sunxi_codec->hw_config.dachpf_cfg)
+		dachpf_config(component);
+#endif
+}
+
+static void sunxi_codec_rx_enable(void *data, bool enable)
+{
+	struct snd_soc_component *component = data;
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	if (enable)
+		regmap_update_bits(sunxi_codec->regmap, SUNXI_ADC_FIFOC,
+			(1 << RX_SYNC_EN_STA), (1 << RX_SYNC_EN_STA));
+	else
+		regmap_update_bits(sunxi_codec->regmap, SUNXI_ADC_FIFOC,
+			(1 << RX_SYNC_EN_STA), (0 << RX_SYNC_EN_STA));
+
+}
+
+static int sunxi_codec_startup(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+#ifdef SUNXI_CODEC_DAP_ENABLE
+	struct snd_soc_component *component = dai->component;
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		if (sunxi_codec->hw_config.adchpf_cfg)
+			adchpf_enable(component, 1);
+	}
+#endif
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE &&
+		sunxi_codec->rx_sync_en) {
+		sunxi_rx_sync_startup((void *)dai->component,
+			sunxi_codec->rx_sync_domain, sunxi_codec->rx_sync_id,
+			sunxi_codec_rx_enable);
+	}
+
+	return 0;
+}
+
+static int sunxi_codec_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct snd_soc_component *component = dai->component;
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	int i = 0;
+
+	switch (params_format(params)) {
+	case	SNDRV_PCM_FORMAT_S16_LE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			snd_soc_component_update_bits(component, SUNXI_DAC_FIFOC,
+				(3 << FIFO_MODE), (3 << FIFO_MODE));
+			snd_soc_component_update_bits(component, SUNXI_DAC_FIFOC,
+				(1 << TX_SAMPLE_BITS), (0 << TX_SAMPLE_BITS));
+		} else {
+			snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+				(1 << RX_FIFO_MODE), (1 << RX_FIFO_MODE));
+			snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+				(1 << RX_SAMPLE_BITS), (0 << RX_SAMPLE_BITS));
+		}
+		break;
+	case	SNDRV_PCM_FORMAT_S24_LE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			snd_soc_component_update_bits(component, SUNXI_DAC_FIFOC,
+				(3 << FIFO_MODE), (0 << FIFO_MODE));
+			snd_soc_component_update_bits(component, SUNXI_DAC_FIFOC,
+				(1 << TX_SAMPLE_BITS), (1 << TX_SAMPLE_BITS));
+		} else {
+			snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+				(1 << RX_FIFO_MODE), (0 << RX_FIFO_MODE));
+			snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+				(1 << RX_SAMPLE_BITS), (1 << RX_SAMPLE_BITS));
+		}
+		break;
+	default:
+		break;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(sample_rate_conv); i++) {
+		if (sample_rate_conv[i].samplerate == params_rate(params)) {
+			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+				snd_soc_component_update_bits(component, SUNXI_DAC_FIFOC,
+					(0x7 << DAC_FS),
+					(sample_rate_conv[i].rate_bit << DAC_FS));
+			} else {
+				if (sample_rate_conv[i].samplerate > 48000)
+					return -EINVAL;
+				snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+					(0x7 << ADC_FS),
+					(sample_rate_conv[i].rate_bit<<ADC_FS));
+			}
+		}
+	}
+
+	/* reset the adchpf func setting for different sampling */
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		if (sunxi_codec->hw_config.adchpf_cfg) {
+			if (params_rate(params) == 16000) {
+				snd_soc_component_write(component, SUNXI_ADC_DRC_HHPFC,
+						(0x00F623A5 >> 16) & 0xFFFF);
+
+				snd_soc_component_write(component, SUNXI_ADC_DRC_LHPFC,
+							0x00F623A5 & 0xFFFF);
+
+			} else if (params_rate(params) == 44100) {
+				snd_soc_component_write(component, SUNXI_ADC_DRC_HHPFC,
+						(0x00FC60DB >> 16) & 0xFFFF);
+
+				snd_soc_component_write(component, SUNXI_ADC_DRC_LHPFC,
+							0x00FC60DB & 0xFFFF);
+			} else {
+				snd_soc_component_write(component, SUNXI_ADC_DRC_HHPFC,
+						(0x00FCABB3 >> 16) & 0xFFFF);
+
+				snd_soc_component_write(component, SUNXI_ADC_DRC_LHPFC,
+							0x00FCABB3 & 0xFFFF);
+			}
+		}
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		switch (params_channels(params)) {
+		case 1:
+			/* DACL & DACR send same data */
+			snd_soc_component_update_bits(component, SUNXI_DAC_FIFOC,
+				(0x1 << DAC_MONO_EN), 0x1 << DAC_MONO_EN);
+			break;
+		case 2:
+			snd_soc_component_update_bits(component, SUNXI_DAC_FIFOC,
+				(0x1 << DAC_MONO_EN), 0x0 << DAC_MONO_EN);
+			break;
+		default:
+			LOG_WARN("not support channels:%u", params_channels(params));
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+static int sunxi_codec_set_sysclk(struct snd_soc_dai *dai,
+			int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_component *component = dai->component;
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	switch (clk_id) {
+	case	0:
+		/* set clk source [22.5792MHz * n] to surpport playback */
+		if (clk_set_parent(sunxi_codec->dacclk, sunxi_codec->pllaudio0)) {
+			LOG_ERR("set parent of dacclk to pllaudio0 failed");
+			return -EINVAL;
+		}
+
+		if (clk_set_rate(sunxi_codec->dacclk, freq)) {
+			LOG_ERR("codec set dac clk rate failed");
+			return -EINVAL;
+		}
+		break;
+	case	1:
+		/* set clk source [22.5792MHz * n] to surpport capture */
+		if (clk_set_parent(sunxi_codec->adcclk, sunxi_codec->pllaudio0)) {
+			LOG_ERR("set parent of adcclk to pllaudio0 failed");
+			return -EINVAL;
+		}
+
+		if (clk_set_rate(sunxi_codec->adcclk, freq)) {
+			LOG_ERR("codec set adc clk rate failed");
+			return -EINVAL;
+		}
+		break;
+	case	2:
+		/* set clk source [24.576MHz * n] to surpport playback */
+		if (clk_set_parent(sunxi_codec->dacclk, sunxi_codec->pllaudio1_div5)) {
+			LOG_ERR("set parent of dacclk to pllaudio1_div5 failed");
+			return -EINVAL;
+		}
+
+		if (clk_set_rate(sunxi_codec->dacclk, freq)) {
+			LOG_ERR("codec set dac clk rate failed");
+			return -EINVAL;
+		}
+		break;
+	case	3:
+		/* set clk source [24.576MHz * n] to surpport capture */
+		if (clk_set_parent(sunxi_codec->adcclk, sunxi_codec->pllaudio1_div5)) {
+			LOG_ERR("set parent of adcclk to pllaudio1_div5 failed");
+			return -EINVAL;
+		}
+
+		if (clk_set_rate(sunxi_codec->adcclk, freq)) {
+			LOG_ERR("codec set adc clk rate failed");
+			return -EINVAL;
+		}
+		break;
+	default:
+		LOG_ERR("Bad clk params input!");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void sunxi_codec_shutdown(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+#ifdef SUNXI_CODEC_DAP_ENABLE
+	struct snd_soc_component *component = dai->component;
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		if (sunxi_codec->hw_config.adchpf_cfg)
+			adchpf_enable(component, 0);
+	}
+#endif
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE &&
+		sunxi_codec->rx_sync_en) {
+		sunxi_rx_sync_shutdown(sunxi_codec->rx_sync_domain,
+				sunxi_codec->rx_sync_id);
+	}
+}
+
+static int sunxi_codec_prepare(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	struct snd_soc_component *component = dai->component;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		snd_soc_component_update_bits(component, SUNXI_DAC_FIFOC,
+			(1 << FIFO_FLUSH), (1 << FIFO_FLUSH));
+		snd_soc_component_write(component, SUNXI_DAC_FIFOS,
+			(1 << DAC_TXE_INT | 1 << DAC_TXU_INT | 1 << DAC_TXO_INT));
+		snd_soc_component_write(component, SUNXI_DAC_CNT, 0);
+	} else {
+		snd_soc_component_update_bits(component, SUNXI_ADC_FIFOC,
+				(1 << ADC_FIFO_FLUSH), (1 << ADC_FIFO_FLUSH));
+		snd_soc_component_write(component, SUNXI_ADC_FIFOS,
+				(1 << ADC_RXA_INT | 1 << ADC_RXO_INT));
+		snd_soc_component_write(component, SUNXI_ADC_CNT, 0);
+	}
+
+	return 0;
+}
+
+static int sunxi_codec_trigger(struct snd_pcm_substream *substream,
+				int cmd, struct snd_soc_dai *dai)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(dai->component);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			regmap_update_bits(sunxi_codec->regmap, SUNXI_DAC_FIFOC,
+				(1 << DAC_DRQ_EN), (1 << DAC_DRQ_EN));
+		} else {
+			regmap_update_bits(sunxi_codec->regmap, SUNXI_ADC_FIFOC,
+				(1 << ADC_DRQ_EN), (1 << ADC_DRQ_EN));
+			if (sunxi_codec->rx_sync_en)
+				sunxi_rx_sync_control(sunxi_codec->rx_sync_domain,
+						sunxi_codec->rx_sync_id, 1);
+		}
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			regmap_update_bits(sunxi_codec->regmap, SUNXI_DAC_FIFOC,
+				(1 << DAC_DRQ_EN), (0 << DAC_DRQ_EN));
+		} else {
+			regmap_update_bits(sunxi_codec->regmap, SUNXI_ADC_FIFOC,
+				(1 << ADC_DRQ_EN), (0 << ADC_DRQ_EN));
+			if (sunxi_codec->rx_sync_en)
+				sunxi_rx_sync_control(sunxi_codec->rx_sync_domain,
+						sunxi_codec->rx_sync_id, 0);
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops sunxi_codec_dai_ops = {
+	.startup	= sunxi_codec_startup,
+	.hw_params	= sunxi_codec_hw_params,
+	.shutdown	= sunxi_codec_shutdown,
+	.set_sysclk	= sunxi_codec_set_sysclk,
+	.trigger	= sunxi_codec_trigger,
+	.prepare	= sunxi_codec_prepare,
+};
+
+static struct snd_soc_dai_driver sunxi_codec_dai[] = {
+	{
+		.name	= "sun8iw20codec",
+		.playback = {
+			.stream_name = "Playback",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates	= SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE,
+		},
+		.capture = {
+			.stream_name = "Capture",
+			.channels_min = 1,
+			.channels_max = 3,
+			.rates = SNDRV_PCM_RATE_8000_48000
+				| SNDRV_PCM_RATE_KNOT,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE,
+		},
+		.ops = &sunxi_codec_dai_ops,
+	},
+};
+
+static int sunxi_codec_probe(struct snd_soc_component *component)
+{
+	int ret;
+	struct snd_soc_dapm_context *dapm = &component->dapm;
+
+	ret = snd_soc_add_component_controls(component, sunxi_codec_controls,
+					ARRAY_SIZE(sunxi_codec_controls));
+	if (ret)
+		LOG_ERR("failed to register codec controls");
+
+	snd_soc_dapm_new_controls(dapm, sunxi_codec_dapm_widgets,
+				ARRAY_SIZE(sunxi_codec_dapm_widgets));
+	snd_soc_dapm_add_routes(dapm, sunxi_codec_dapm_routes,
+				ARRAY_SIZE(sunxi_codec_dapm_routes));
+
+	sunxi_codec_init(component);
+
+	return 0;
+}
+
+static void sunxi_codec_remove(struct snd_soc_component *component)
+{
+
+}
+
+static int save_audio_reg(struct sunxi_codec_info *sunxi_codec)
+{
+	int i = 0;
+
+	while (reg_labels[i].name != NULL) {
+		regmap_read(sunxi_codec->regmap, reg_labels[i].address,
+			&reg_labels[i].value);
+		i++;
+	}
+
+	return i;
+}
+
+static int echo_audio_reg(struct sunxi_codec_info *sunxi_codec)
+{
+	int i = 0;
+
+	while (reg_labels[i].name != NULL) {
+		regmap_write(sunxi_codec->regmap, reg_labels[i].address,
+					reg_labels[i].value);
+		i++;
+	}
+
+	return i;
+}
+
+static int sunxi_codec_suspend(struct snd_soc_component *component)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct codec_spk_config *spk_cfg = &(sunxi_codec->spk_config);
+
+	pr_debug("Enter %s\n", __func__);
+	save_audio_reg(sunxi_codec);
+
+	if (spk_cfg->used)
+		gpio_set_value(spk_cfg->spk_gpio, !(spk_cfg->pa_level));
+
+	if (sunxi_codec->vol_supply.avcc)
+		regulator_disable(sunxi_codec->vol_supply.avcc);
+
+	if (sunxi_codec->vol_supply.hpvcc)
+		regulator_disable(sunxi_codec->vol_supply.hpvcc);
+
+	clk_disable_unprepare(sunxi_codec->dacclk);
+	clk_disable_unprepare(sunxi_codec->adcclk);
+	clk_disable_unprepare(sunxi_codec->pllaudio0);
+	clk_disable_unprepare(sunxi_codec->pllaudio1_div5);
+	clk_disable_unprepare(sunxi_codec->codec_clk_bus);
+	reset_control_assert(sunxi_codec->codec_clk_rst);
+
+	pr_debug("End %s\n", __func__);
+
+	return 0;
+}
+
+static int sunxi_codec_resume(struct snd_soc_component *component)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct codec_spk_config *spk_cfg = &(sunxi_codec->spk_config);
+	unsigned int ret;
+
+	pr_debug("Enter %s\n", __func__);
+
+	if (sunxi_codec->vol_supply.avcc) {
+		ret = regulator_enable(sunxi_codec->vol_supply.avcc);
+		if (ret)
+			LOG_ERR("resume avcc enable failed");
+	}
+
+	if (sunxi_codec->vol_supply.hpvcc) {
+		ret = regulator_enable(sunxi_codec->vol_supply.hpvcc);
+		if (ret)
+			LOG_ERR("resume hpvcc enable failed");
+	}
+
+	/* 22579200 * n */
+	if (clk_set_rate(sunxi_codec->pllaudio0, 22579200)) {
+		LOG_ERR("resume codec source set pllaudio0 rate failed");
+		return -EBUSY;
+	}
+
+	/* 24576000 * 25 */
+	if (clk_set_rate(sunxi_codec->pllaudio1_div5, 614400000)) {
+		LOG_ERR("resume codec source set pllaudio1_div5 rate failed");
+		return -EBUSY;
+	}
+
+	if (reset_control_deassert(sunxi_codec->codec_clk_rst)) {
+		LOG_ERR("resume deassert the codec reset failed");
+		return -EBUSY;
+	}
+
+	if (clk_prepare_enable(sunxi_codec->codec_clk_bus)) {
+		LOG_ERR("enable codec bus clk failed, resume exit");
+		return -EBUSY;
+	}
+
+	if (clk_prepare_enable(sunxi_codec->pllaudio0)) {
+		LOG_ERR("enable pllaudio0 failed, resume exit");
+		return -EBUSY;
+	}
+
+	if (clk_prepare_enable(sunxi_codec->pllaudio1_div5)) {
+		LOG_ERR("enable pllaudio1_div5 failed, resume exit");
+		return -EBUSY;
+	}
+
+	if (clk_prepare_enable(sunxi_codec->dacclk)) {
+		LOG_ERR("enable dacclk failed, resume exit");
+		return -EBUSY;
+	}
+
+	if (clk_prepare_enable(sunxi_codec->adcclk)) {
+		LOG_ERR("enable  adcclk failed, resume exit");
+		clk_disable_unprepare(sunxi_codec->adcclk);
+		return -EBUSY;
+	}
+
+	if (spk_cfg->used) {
+		gpio_direction_output(spk_cfg->spk_gpio, 1);
+		gpio_set_value(spk_cfg->spk_gpio, !(spk_cfg->pa_level));
+	}
+
+	sunxi_codec_init(component);
+	echo_audio_reg(sunxi_codec);
+
+	pr_debug("End %s\n", __func__);
+
+	return 0;
+}
+
+static unsigned int sunxi_codec_read(struct snd_soc_component *component,
+					unsigned int reg)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	unsigned int reg_val;
+
+	regmap_read(sunxi_codec->regmap, reg, &reg_val);
+
+	return reg_val;
+}
+
+static int sunxi_codec_write(struct snd_soc_component *component,
+				unsigned int reg, unsigned int val)
+{
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+
+	regmap_write(sunxi_codec->regmap, reg, val);
+
+	return 0;
+};
+
+static struct snd_soc_component_driver soc_codec_dev_sunxi = {
+	.probe = sunxi_codec_probe,
+	.remove = sunxi_codec_remove,
+	.suspend = sunxi_codec_suspend,
+	.resume = sunxi_codec_resume,
+	.read = sunxi_codec_read,
+	.write = sunxi_codec_write,
+};
+
+/* audiocodec reg dump about */
+static ssize_t show_audio_reg(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct sunxi_codec_info *sunxi_codec = dev_get_drvdata(dev);
+	int cnt = 0, i = 0, j = 0;
+	unsigned int reg_val, reg_val_tmp;
+	unsigned int size = ARRAY_SIZE(reg_labels);
+	char *reg_name_play = "REG NAME";
+	char *reg_offset_play = "OFFSET";
+	char *reg_val_play = "VALUE";
+
+	cnt += sprintf(buf + cnt,
+		       "%-30s|%-6s|%-10s"
+		       "|31-28|27-24|23-20|19-16|15-12|11-08|07-04|03-00|"
+		       "save_value\n",
+		       reg_name_play, reg_offset_play, reg_val_play);
+
+	while ((i < size) && (reg_labels[i].name != NULL)) {
+		regmap_read(sunxi_codec->regmap,
+			    reg_labels[i].address, &reg_val);
+
+		cnt += sprintf(buf + cnt,
+			       "%-30s|0x%4x|0x%8x",
+			       reg_labels[i].name,
+			       reg_labels[i].address,
+			       reg_val);
+		for (j = 7; j >= 0; j--) {
+			reg_val_tmp = reg_val >> (j * 4);
+			cnt += sprintf(buf + cnt,
+				       "|%c%c%c%c ",
+				       (((reg_val_tmp) & 0x08ull) ? '1' : '0'),
+				       (((reg_val_tmp) & 0x04ull) ? '1' : '0'),
+				       (((reg_val_tmp) & 0x02ull) ? '1' : '0'),
+				       (((reg_val_tmp) & 0x01ull) ? '1' : '0')
+				       );
+		}
+		cnt += sprintf(buf + cnt, "|0x%8x\n", reg_labels[i].value);
+
+		i++;
+	}
+
+	return cnt;
+}
+
+/* ex:
+ * param 1: 0 read;1 write
+ * param 2: reg value;
+ * param 3: write value;
+	read:
+		echo 0,0x00> audio_reg
+	write:
+		echo 1,0x00,0xa > audio_reg
+*/
+static ssize_t store_audio_reg(struct device *dev, struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	int ret;
+	int rw_flag;
+	int input_reg_val = 0;
+	int input_reg_offset = 0;
+	struct sunxi_codec_info *sunxi_codec = dev_get_drvdata(dev);
+
+	ret = sscanf(buf, "%d,0x%x,0x%x", &rw_flag,
+			&input_reg_offset, &input_reg_val);
+	LOG_INFO("ret:%d, reg_offset:%d, reg_val:0x%x",
+		 ret, input_reg_offset, input_reg_val);
+
+	if (!(rw_flag == 1 || rw_flag == 0)) {
+		LOG_ERR("not rw_flag");
+		ret = count;
+		goto out;
+	}
+
+	if (input_reg_offset > SUNXI_BIAS_REG) {
+		LOG_ERR("the reg offset[0x%03x] > SUNXI_BIAS_REG[0x%03x]",
+			input_reg_offset, SUNXI_BIAS_REG);
+		ret = count;
+		goto out;
+	}
+
+	if (rw_flag) {
+		regmap_write(sunxi_codec->regmap,
+				input_reg_offset, input_reg_val);
+	} else {
+		regmap_read(sunxi_codec->regmap,
+				input_reg_offset, &input_reg_val);
+		LOG_INFO("\n\n Reg[0x%x] : 0x%08x\n\n",
+				input_reg_offset, input_reg_val);
+	}
+	ret = count;
+out:
+	return ret;
+}
+
+static DEVICE_ATTR(audio_reg, 0644, show_audio_reg, store_audio_reg);
+
+static struct attribute *audio_debug_attrs[] = {
+	&dev_attr_audio_reg.attr,
+	NULL,
+};
+
+static struct attribute_group audio_debug_attr_group = {
+	.name   = "audio_reg_debug",
+	.attrs  = audio_debug_attrs,
+};
+
+/* regmap configuration */
+static const struct regmap_config sunxi_codec_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = SUNXI_ADC_CUR_REG,
+	.cache_type = REGCACHE_NONE,
+};
+static const struct snd_pcm_hardware snd_rockchip_hardware = {
+	.info			= SNDRV_PCM_INFO_MMAP |
+				  SNDRV_PCM_INFO_MMAP_VALID |
+				  SNDRV_PCM_INFO_PAUSE |
+				  SNDRV_PCM_INFO_RESUME |
+				  SNDRV_PCM_INFO_INTERLEAVED,
+	.period_bytes_min	= 32,
+	.period_bytes_max	= 8192,
+	.periods_min		= 1,
+	.periods_max		= 52,
+	.buffer_bytes_max	= 64 * 1024,
+	.fifo_size		= 32,
+};
+
+/*
+static int sunxi_codec_regulator_init(struct platform_device *pdev,
+				struct sunxi_codec_info *sunxi_codec)
+{
+	int ret = -EFAULT;
+
+	sunxi_codec->vol_supply.avcc = regulator_get(&pdev->dev, "avcc");
+	if (IS_ERR(sunxi_codec->vol_supply.avcc)) {
+		LOG_ERR("get audio avcc failed");
+		goto err_regulator;
+	} else {
+		ret = regulator_set_voltage(sunxi_codec->vol_supply.avcc,
+							1800000, 1800000);
+		if (ret) {
+			LOG_ERR("avcc set vol failed");
+			goto err_regulator_avcc;
+		}
+
+		ret = regulator_enable(sunxi_codec->vol_supply.avcc);
+		if (ret) {
+			LOG_ERR("avcc enable failed");
+			goto err_regulator_avcc;
+		}
+	}
+
+	sunxi_codec->vol_supply.hpvcc = regulator_get(&pdev->dev, "hpvcc");
+	if (IS_ERR(sunxi_codec->vol_supply.hpvcc)) {
+		LOG_ERR("get audio hpvcc failed");
+		goto err_regulator_avcc;
+	} else {
+		ret = regulator_set_voltage(sunxi_codec->vol_supply.hpvcc,
+							1800000, 1800000);
+		if (ret) {
+			LOG_ERR("hpvcc set vol failed");
+			goto err_regulator_hpvcc;
+		}
+
+		ret = regulator_enable(sunxi_codec->vol_supply.hpvcc);
+		if (ret) {
+			LOG_ERR("hpvcc enable failed");
+			goto err_regulator_hpvcc;
+		}
+	}
+	return 0;
+
+err_regulator_hpvcc:
+	regulator_put(sunxi_codec->vol_supply.hpvcc);
+err_regulator_avcc:
+	regulator_put(sunxi_codec->vol_supply.avcc);
+err_regulator:
+	return ret;
+}
+*/
+
+static int sunxi_codec_clk_init(struct device_node *np,
+				struct platform_device *pdev,
+				struct sunxi_codec_info *sunxi_codec)
+{
+	int ret = -EBUSY;
+	/* get the parent clk and the module clk */
+	sunxi_codec->dacclk = of_clk_get_by_name(np, "audio_clk_dac");
+	if (IS_ERR(sunxi_codec->dacclk))
+		LOG_ERR("audio_clk_dac clk get failed");
+	sunxi_codec->adcclk = of_clk_get_by_name(np, "audio_clk_adc");
+	if (IS_ERR(sunxi_codec->adcclk))
+		LOG_ERR("audio_clk_adc clk get failed");
+	sunxi_codec->pllaudio0 = of_clk_get_by_name(np, "pll_audio0");
+	if (IS_ERR(sunxi_codec->pllaudio0))
+		LOG_ERR("pll_audio0 clk get failed");
+	sunxi_codec->pllaudio1_div5 = of_clk_get_by_name(np, "pll_audio1_div5");
+	if (IS_ERR(sunxi_codec->pllaudio1_div5))
+		LOG_ERR("pll_audio1_div5 clk get failed");
+	sunxi_codec->codec_clk_bus = of_clk_get_by_name(np, "audio_clk_bus");
+	if (IS_ERR(sunxi_codec->codec_clk_bus))
+		LOG_ERR("audio_clk_bus clk get failed");
+	sunxi_codec->codec_clk_rst = devm_reset_control_get(&pdev->dev, NULL);
+
+	if (reset_control_deassert(sunxi_codec->codec_clk_rst)) {
+		LOG_ERR("reset clk deassert failed");
+		goto err_devm_kfree;
+	}
+
+	if (clk_set_parent(sunxi_codec->dacclk, sunxi_codec->pllaudio0)) {
+		LOG_ERR("set parent of dacclk to pllaudio0 failed");
+		goto err_devm_kfree;
+	}
+
+	if (clk_set_parent(sunxi_codec->adcclk, sunxi_codec->pllaudio0)) {
+		LOG_ERR("set parent of adcclk to pllaudio0 failed");
+		goto err_devm_kfree;
+	}
+
+	/* 22579200 * n */
+	if (clk_set_rate(sunxi_codec->pllaudio0, 22579200)) {
+		LOG_ERR("pllaudio0 set rate failed");
+		goto err_devm_kfree;
+	}
+
+	/* 24576000 * n */
+	if (clk_set_rate(sunxi_codec->pllaudio1_div5, 614400000)) {
+		LOG_ERR("pllaudio1_div5 set rate failed");
+		goto err_devm_kfree;
+	}
+
+	if (clk_prepare_enable(sunxi_codec->codec_clk_bus)) {
+		LOG_ERR("codec clk bus enable failed");
+	}
+
+	if (clk_prepare_enable(sunxi_codec->pllaudio0)) {
+		LOG_ERR("pllaudio0 enable failed");
+		goto err_bus_kfree;
+	}
+
+	if (clk_prepare_enable(sunxi_codec->pllaudio1_div5)) {
+		LOG_ERR("pllaudio1_div5 enable failed");
+		goto err_pllaudio0_kfree;
+	}
+
+	if (clk_prepare_enable(sunxi_codec->dacclk)) {
+		LOG_ERR("dacclk enable failed");
+		goto err_pllaudio1_div5_kfree;
+	}
+
+	if (clk_prepare_enable(sunxi_codec->adcclk)) {
+		LOG_ERR("adcclk enable failed");
+		goto err_dacclk_kfree;
+	}
+	return 0;
+
+err_dacclk_kfree:
+	clk_disable_unprepare(sunxi_codec->dacclk);
+err_pllaudio1_div5_kfree:
+	clk_disable_unprepare(sunxi_codec->pllaudio1_div5);
+err_pllaudio0_kfree:
+	clk_disable_unprepare(sunxi_codec->pllaudio0);
+err_bus_kfree:
+	clk_disable_unprepare(sunxi_codec->codec_clk_bus);
+err_devm_kfree:
+	return ret;
+}
+
+static int sunxi_codec_parse_params(struct device_node *np,
+				struct platform_device *pdev,
+				struct sunxi_codec_info *sunxi_codec)
+{
+	int ret = 0;
+	unsigned int temp_val;
+
+	/* get the special property form the board.dts */
+	ret = of_property_read_u32(np, "digital_vol", &temp_val);
+	if (ret < 0) {
+		LOG_WARN("digital volume get failed, use default vol");
+		sunxi_codec->digital_vol = 0;
+	} else {
+		sunxi_codec->digital_vol = temp_val;
+	}
+
+	/* lineout volume */
+	ret = of_property_read_u32(np, "lineout_vol", &temp_val);
+	if (ret < 0) {
+		LOG_WARN("lineout volume get failed, use default vol");
+		sunxi_codec->lineout_vol = 0;
+	} else {
+		sunxi_codec->lineout_vol = temp_val;
+	}
+
+	/* headphone volume */
+	ret = of_property_read_u32(np, "headphonegain", &temp_val);
+	if (ret < 0) {
+		LOG_WARN("headphonegain volume get failed, use default vol");
+		sunxi_codec->headphonegain = 0;
+	} else {
+		sunxi_codec->headphonegain = temp_val;
+	}
+
+	/* mic gain for capturing */
+	ret = of_property_read_u32(np, "mic1gain", &temp_val);
+	if (ret < 0) {
+		LOG_WARN("mic1gain get failed, use default vol");
+		sunxi_codec->mic1gain = 31;
+	} else {
+		sunxi_codec->mic1gain = temp_val;
+	}
+	ret = of_property_read_u32(np, "mic2gain", &temp_val);
+	if (ret < 0) {
+		LOG_WARN("mic2gain get failed, use default vol");
+		sunxi_codec->mic2gain = 31;
+	} else {
+		sunxi_codec->mic2gain = temp_val;
+	}
+	ret = of_property_read_u32(np, "mic3gain", &temp_val);
+	if (ret < 0) {
+		sunxi_codec->mic3gain = 31;
+		LOG_WARN("mic3gain get failed, use default vol");
+	} else {
+		sunxi_codec->mic3gain = temp_val;
+	}
+
+	/* Pa's delay time(ms) to work fine */
+	ret = of_property_read_u32(np, "pa_msleep_time", &temp_val);
+	if (ret < 0) {
+		LOG_WARN("pa_msleep get failed, use default vol");
+		sunxi_codec->spk_config.pa_msleep = 160;
+	} else {
+		sunxi_codec->spk_config.pa_msleep = temp_val;
+	}
+
+	/* PA/SPK enable property */
+	ret = of_property_read_u32(np, "pa_level", &temp_val);
+	if (ret < 0) {
+		LOG_WARN("pa_level get failed, use default vol");
+		sunxi_codec->spk_config.pa_level = 1;
+	} else {
+		sunxi_codec->spk_config.pa_level = temp_val;
+	}
+	ret = of_property_read_u32(np, "pa_pwr_level", &temp_val);
+	if (ret < 0) {
+		LOG_WARN("pa_pwr_level get failed, use default vol");
+		sunxi_codec->spk_pwr_config.pa_level = 1;
+	} else {
+		sunxi_codec->spk_pwr_config.pa_level = temp_val;
+	}
+
+	LOG_INFO("digital_vol:%d, lineout_vol:%d, mic1gain:%d, mic2gain:%d"
+		 " pa_msleep:%d, pa_level:%d, pa_pwr_level:%d\n",
+		 sunxi_codec->digital_vol,
+		 sunxi_codec->lineout_vol,
+		 sunxi_codec->mic1gain,
+		 sunxi_codec->mic2gain,
+		 sunxi_codec->spk_config.pa_msleep,
+		 sunxi_codec->spk_config.pa_level,
+		 sunxi_codec->spk_pwr_config.pa_level);
+
+#ifdef SUNXI_CODEC_DAP_ENABLE
+	/* ADC/DAC DRC/HPF func enable property */
+	ret = of_property_read_u32(np, "adcdrc_cfg", &temp_val);
+	if (ret < 0) {
+		LOG_ERR("adcdrc_cfg configs missing or invalid");
+	} else {
+		sunxi_codec->hw_config.adcdrc_cfg = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "adchpf_cfg", &temp_val);
+	if (ret < 0) {
+		LOG_ERR("adchpf_cfg configs missing or invalid");
+	} else {
+		sunxi_codec->hw_config.adchpf_cfg = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "dacdrc_cfg", &temp_val);
+	if (ret < 0) {
+		LOG_ERR("dacdrc_cfg configs missing or invalid");
+	} else {
+		sunxi_codec->hw_config.dacdrc_cfg = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "dachpf_cfg", &temp_val);
+	if (ret < 0) {
+		LOG_ERR("dachpf_cfg configs missing or invalid");
+	} else {
+		sunxi_codec->hw_config.dachpf_cfg = temp_val;
+	}
+
+	LOG_INFO("adcdrc_cfg:%d, adchpf_cfg:%d, dacdrc_cfg:%d, dachpf:%d",
+		 sunxi_codec->hw_config.adcdrc_cfg,
+		 sunxi_codec->hw_config.adchpf_cfg,
+		 sunxi_codec->hw_config.dacdrc_cfg,
+		 sunxi_codec->hw_config.dachpf_cfg);
+#endif
+	/* get the gpio number to control external speaker */
+	ret = of_get_named_gpio(np, "gpio-spk", 0);
+	if (ret >= 0) {
+		sunxi_codec->spk_config.used = 1;
+		sunxi_codec->spk_config.spk_gpio = ret;
+		if (!gpio_is_valid(sunxi_codec->spk_config.spk_gpio)) {
+			sunxi_codec->spk_config.used = 0;
+			LOG_ERR("gpio-spk set failed, SPK not work!");
+		} else {
+			ret = devm_gpio_request(&pdev->dev,
+				sunxi_codec->spk_config.spk_gpio, "SPK");
+			if (ret) {
+				sunxi_codec->spk_config.used = 0;
+				LOG_ERR("gpio-spk set failed, SPK not work!");
+			}
+		}
+	} else {
+		sunxi_codec->spk_config.used = 0;
+	}
+
+	ret = of_get_named_gpio(np, "gpio-spk-pwr", 0);
+	if (ret >= 0) {
+		sunxi_codec->spk_pwr_config.used = 1;
+		sunxi_codec->spk_pwr_config.spk_gpio = ret;
+		if (!gpio_is_valid(sunxi_codec->spk_pwr_config.spk_gpio)) {
+			sunxi_codec->spk_pwr_config.used = 0;
+			LOG_ERR("gpio-spk-pwr set failed, SPK not work!");
+		} else {
+			ret = devm_gpio_request(&pdev->dev,
+				sunxi_codec->spk_pwr_config.spk_gpio, "SPK POWER");
+			if (ret) {
+				sunxi_codec->spk_pwr_config.used = 0;
+				LOG_ERR("gpio-spk-pwr set failed, SPK not work!");
+			} else {
+				gpio_direction_output(sunxi_codec->spk_pwr_config.spk_gpio, 1);
+				gpio_set_value(sunxi_codec->spk_pwr_config.spk_gpio,
+						sunxi_codec->spk_pwr_config.pa_level);
+			}
+		}
+	} else {
+		sunxi_codec->spk_pwr_config.used = 0;
+	}
+
+	ret = of_property_read_u32(np, "rx_sync_en", &temp_val);
+	if (ret < 0) {
+		LOG_ERR("rx_sync_en configs missing or invalid");
+		sunxi_codec->rx_sync_en = 0;
+	} else {
+		sunxi_codec->rx_sync_en = temp_val;
+	}
+
+	if (sunxi_codec->rx_sync_en) {
+		sunxi_codec->rx_sync_domain = RX_SYNC_SYS_DOMAIN;
+		sunxi_codec->rx_sync_id =
+			sunxi_rx_sync_probe(sunxi_codec->rx_sync_domain);
+		if (sunxi_codec->rx_sync_id < 0) {
+			LOG_ERR("sunxi_rx_sync_probe failed");
+			return -EINVAL;
+		}
+		LOG_INFO("sunxi_rx_sync_probe successful. domain=%d, id=%d",
+			sunxi_codec->rx_sync_domain,
+			sunxi_codec->rx_sync_id);
+	}
+
+	return 0;
+}
+
+static int sunxi_internal_codec_probe(struct platform_device *pdev)
+{
+	struct sunxi_codec_info *sunxi_codec;
+	struct resource res;
+	struct resource *memregion = NULL;
+	struct device_node *np = pdev->dev.of_node;
+	int ret;
+
+	if (IS_ERR_OR_NULL(np)) {
+		LOG_ERR("pdev->dev.of_node is err");
+		ret = -EFAULT;
+		goto err_node_put;
+	}
+
+	sunxi_codec = devm_kzalloc(&pdev->dev,
+				sizeof(struct sunxi_codec_info), GFP_KERNEL);
+	if (!sunxi_codec) {
+		LOG_ERR("Can't allocate sunxi codec memory");
+		ret = -ENOMEM;
+		goto err_node_put;
+	}
+	dev_set_drvdata(&pdev->dev, sunxi_codec);
+	sunxi_codec->dev = &pdev->dev;
+
+	/*
+	if (sunxi_codec_regulator_init(pdev, sunxi_codec) != 0) {
+		LOG_ERR("Failed to init sunxi audio regulator");
+		ret = -EFAULT;
+		goto err_devm_kfree;
+	}
+	*/
+
+	if (sunxi_codec_parse_params(np, pdev, sunxi_codec) != 0) {
+		LOG_ERR("Failed to parse sunxi audio params");
+		ret = -EFAULT;
+		goto err_devm_kfree;
+	}
+
+	if (sunxi_codec_clk_init(np, pdev, sunxi_codec) != 0) {
+		LOG_ERR("Failed to init sunxi audio clk");
+		ret = -EFAULT;
+		goto err_devm_kfree;
+	}
+
+	/* codec reg_base */
+	/* get the true codec addr form np0 to avoid the build warning */
+	ret = of_address_to_resource(np, 0, &res);
+	if (ret) {
+		LOG_ERR("Failed to get sunxi resource");
+		return -EINVAL;
+		goto err_moduleclk_disable;
+	}
+
+	memregion = devm_request_mem_region(&pdev->dev, res.start,
+				resource_size(&res), "sunxi-internal-codec");
+	if (!memregion) {
+		LOG_ERR("sunxi memory region already claimed");
+		ret = -EBUSY;
+		goto err_moduleclk_disable;
+	}
+
+	sunxi_codec->digital_base = devm_ioremap(&pdev->dev,
+					res.start, resource_size(&res));
+	if (!sunxi_codec->digital_base) {
+		LOG_ERR("sunxi digital_base ioremap failed");
+		ret = -EBUSY;
+		goto err_moduleclk_disable;
+	}
+
+	sunxi_codec->regmap = devm_regmap_init_mmio(&pdev->dev,
+				sunxi_codec->digital_base,
+				&sunxi_codec_regmap_config);
+	if (IS_ERR_OR_NULL(sunxi_codec->regmap)) {
+		LOG_ERR("regmap init failed");
+		ret = PTR_ERR(sunxi_codec->regmap);
+		goto err_moduleclk_disable;
+	}
+
+	/* CODEC DAI cfg and register */
+	ret = devm_snd_soc_register_component(&pdev->dev, &soc_codec_dev_sunxi,
+				sunxi_codec_dai, ARRAY_SIZE(sunxi_codec_dai));
+	if (ret < 0) {
+		LOG_ERR("register codec failed");
+		goto err_moduleclk_disable;
+	}
+
+	ret  = sysfs_create_group(&pdev->dev.kobj, &audio_debug_attr_group);
+	if (ret) {
+		LOG_WARN("failed to create attr group");
+		goto err_moduleclk_disable;
+	}
+
+	LOG_INFO("codec probe finished");
+
+	return 0;
+
+
+err_moduleclk_disable:
+	clk_disable_unprepare(sunxi_codec->dacclk);
+	clk_disable_unprepare(sunxi_codec->adcclk);
+	clk_disable_unprepare(sunxi_codec->pllaudio0);
+	clk_disable_unprepare(sunxi_codec->pllaudio1_div5);
+err_devm_kfree:
+	devm_kfree(&pdev->dev, sunxi_codec);
+err_node_put:
+	of_node_put(np);
+	return ret;
+}
+
+static int  __exit sunxi_internal_codec_remove(struct platform_device *pdev)
+{
+	struct sunxi_codec_info *sunxi_codec = dev_get_drvdata(&pdev->dev);
+	struct codec_spk_config *spk_cfg = &(sunxi_codec->spk_config);
+
+	if (sunxi_codec->rx_sync_en)
+		sunxi_rx_sync_remove(sunxi_codec->rx_sync_domain);
+
+	if (spk_cfg->used) {
+		devm_gpio_free(&pdev->dev,
+					sunxi_codec->spk_config.spk_gpio);
+	}
+
+	if (sunxi_codec->vol_supply.avcc) {
+		regulator_disable(sunxi_codec->vol_supply.avcc);
+		regulator_put(sunxi_codec->vol_supply.avcc);
+	}
+
+	if (sunxi_codec->vol_supply.hpvcc) {
+		regulator_disable(sunxi_codec->vol_supply.hpvcc);
+		regulator_put(sunxi_codec->vol_supply.hpvcc);
+	}
+
+	sysfs_remove_group(&pdev->dev.kobj, &audio_debug_attr_group);
+	snd_soc_unregister_component(&pdev->dev);
+
+	clk_disable_unprepare(sunxi_codec->dacclk);
+	clk_put(sunxi_codec->dacclk);
+	clk_disable_unprepare(sunxi_codec->adcclk);
+	clk_put(sunxi_codec->adcclk);
+	clk_disable_unprepare(sunxi_codec->pllaudio0);
+	clk_put(sunxi_codec->pllaudio0);
+	clk_disable_unprepare(sunxi_codec->pllaudio1_div5);
+	clk_put(sunxi_codec->pllaudio1_div5);
+	clk_disable_unprepare(sunxi_codec->codec_clk_bus);
+	clk_put(sunxi_codec->codec_clk_bus);
+	reset_control_assert(sunxi_codec->codec_clk_rst);
+
+	devm_iounmap(&pdev->dev, sunxi_codec->digital_base);
+	devm_kfree(&pdev->dev, sunxi_codec);
+	platform_set_drvdata(pdev, NULL);
+
+	LOG_INFO("codec remove finished");
+
+	return 0;
+}
+
+static const struct of_device_id sunxi_internal_codec_of_match[] = {
+	{ .compatible = "allwinner,sunxi-internal-codec", },
+	{},
+};
+
+static struct platform_driver sunxi_internal_codec_driver = {
+	.driver = {
+		.name = "sunxi-internal-codec",
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_internal_codec_of_match,
+	},
+	.probe = sunxi_internal_codec_probe,
+	.remove = __exit_p(sunxi_internal_codec_remove),
+};
+module_platform_driver(sunxi_internal_codec_driver);
+
+MODULE_DESCRIPTION("SUNXI Codec ASoC driver");
+MODULE_AUTHOR("Dby <Dby@allwinnertech.com>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:sunxi-internal-codec");
diff --git a/sound/soc/sunxi/sun8iw20-codec.h b/sound/soc/sunxi/sun8iw20-codec.h
new file mode 100644
index 000000000..043d1a922
--- /dev/null
+++ b/sound/soc/sunxi/sun8iw20-codec.h
@@ -0,0 +1,557 @@
+/*
+ * sound\soc\sunxi\sun8iw20-codec.h
+ * (C) Copyright 2021-2026
+ * allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * yumingfeng <yumingfeng@allwinnertech.com>
+ * luguofang <luguofang@allwinnertech.com>
+ * Dby <Dby@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+#ifndef _SUN8IW20_CODEC_H
+#define _SUN8IW20_CODEC_H
+
+#include "sunxi-pcm.h"
+
+#define SUNXI_DAC_DPC		0x00
+#define SUNXI_DAC_VOL_CTRL	0x04
+#define SUNXI_DAC_FIFOC		0x10
+#define SUNXI_DAC_FIFOS		0x14
+
+#define SUNXI_DAC_TXDATA	0X20
+#define SUNXI_DAC_CNT		0x24
+#define SUNXI_DAC_DG		0x28
+
+#define	SUNXI_ADC_FIFOC		0x30
+#define	SUNXI_ADC_VOL_CTRL	0x34
+#define SUNXI_ADC_FIFOS		0x38
+#define SUNXI_ADC_RXDATA	0x40
+#define SUNXI_ADC_CNT		0x44
+#define SUNXI_ADC_DG		0x4C
+#define SUNXI_ADC_DIG_CTRL	0x50
+#define SUNXI_VRA1SPEEDUP_DOWN_CTRL	0x54
+
+#define SUNXI_DAC_DAP_CTL	0xF0
+#define SUNXI_ADC_DAP_CTL	0xF8
+
+#define SUNXI_DAC_DRC_HHPFC	0x100
+#define SUNXI_DAC_DRC_LHPFC	0x104
+#define SUNXI_DAC_DRC_CTRL	0x108
+#define SUNXI_DAC_DRC_LPFHAT	0x10C
+#define SUNXI_DAC_DRC_LPFLAT	0x110
+#define SUNXI_DAC_DRC_RPFHAT	0x114
+#define SUNXI_DAC_DRC_RPFLAT	0x118
+#define SUNXI_DAC_DRC_LPFHRT	0x11C
+#define SUNXI_DAC_DRC_LPFLRT	0x120
+#define SUNXI_DAC_DRC_RPFHRT	0x124
+#define SUNXI_DAC_DRC_RPFLRT	0x128
+#define SUNXI_DAC_DRC_LRMSHAT	0x12C
+#define SUNXI_DAC_DRC_LRMSLAT	0x130
+#define SUNXI_DAC_DRC_RRMSHAT	0x134
+#define SUNXI_DAC_DRC_RRMSLAT	0x138
+#define SUNXI_DAC_DRC_HCT	0x13C
+#define SUNXI_DAC_DRC_LCT	0x140
+#define SUNXI_DAC_DRC_HKC	0x144
+#define SUNXI_DAC_DRC_LKC	0x148
+#define SUNXI_DAC_DRC_HOPC	0x14C
+#define SUNXI_DAC_DRC_LOPC	0x150
+#define SUNXI_DAC_DRC_HLT	0x154
+#define SUNXI_DAC_DRC_LLT	0x158
+#define SUNXI_DAC_DRC_HKI	0x15C
+#define SUNXI_DAC_DRC_LKI	0x160
+#define SUNXI_DAC_DRC_HOPL	0x164
+#define SUNXI_DAC_DRC_LOPL	0x168
+#define SUNXI_DAC_DRC_HET	0x16C
+#define SUNXI_DAC_DRC_LET	0x170
+#define SUNXI_DAC_DRC_HKE	0x174
+#define SUNXI_DAC_DRC_LKE	0x178
+#define SUNXI_DAC_DRC_HOPE	0x17C
+#define SUNXI_DAC_DRC_LOPE	0x180
+#define SUNXI_DAC_DRC_HKN	0x184
+#define SUNXI_DAC_DRC_LKN	0x188
+#define SUNXI_DAC_DRC_SFHAT	0x18C
+#define SUNXI_DAC_DRC_SFLAT	0x190
+#define SUNXI_DAC_DRC_SFHRT	0x194
+#define SUNXI_DAC_DRC_SFLRT	0x198
+#define SUNXI_DAC_DRC_MXGHS	0x19C
+#define SUNXI_DAC_DRC_MXGLS	0x1A0
+#define SUNXI_DAC_DRC_MNGHS	0x1A4
+#define SUNXI_DAC_DRC_MNGLS	0x1A8
+#define SUNXI_DAC_DRC_EPSHC	0x1AC
+#define SUNXI_DAC_DRC_EPSLC	0x1B0
+#define SUNXI_DAC_DRC_OPT	0x1B4
+#define SUNXI_DAC_DRC_HPFHGAIN	0x1B8
+#define SUNXI_DAC_DRC_HPFLGAIN	0x1BC
+
+#define SUNXI_ADC_DRC_HHPFC	0x200
+#define SUNXI_ADC_DRC_LHPFC	0x204
+#define SUNXI_ADC_DRC_CTRL	0x208
+#define SUNXI_ADC_DRC_LPFHAT	0x20C
+#define SUNXI_ADC_DRC_LPFLAT	0x210
+#define SUNXI_ADC_DRC_RPFHAT	0x214
+#define SUNXI_ADC_DRC_RPFLAT	0x218
+#define SUNXI_ADC_DRC_LPFHRT	0x21C
+#define SUNXI_ADC_DRC_LPFLRT	0x220
+#define SUNXI_ADC_DRC_RPFHRT	0x224
+#define SUNXI_ADC_DRC_RPFLRT	0x228
+#define SUNXI_ADC_DRC_LRMSHAT	0x22C
+#define SUNXI_ADC_DRC_LRMSLAT	0x230
+#define SUNXI_ADC_DRC_RRMSHAT	0x234
+#define SUNXI_ADC_DRC_RRMSLAT	0x238
+#define SUNXI_ADC_DRC_HCT	0x23C
+#define SUNXI_ADC_DRC_LCT	0x240
+#define SUNXI_ADC_DRC_HKC	0x244
+#define SUNXI_ADC_DRC_LKC	0x248
+#define SUNXI_ADC_DRC_HOPC	0x24C
+#define SUNXI_ADC_DRC_LOPC	0x250
+#define SUNXI_ADC_DRC_HLT	0x254
+#define SUNXI_ADC_DRC_LLT	0x258
+#define SUNXI_ADC_DRC_HKI	0x25C
+#define SUNXI_ADC_DRC_LKI	0x260
+#define SUNXI_ADC_DRC_HOPL	0x264
+#define SUNXI_ADC_DRC_LOPL	0x268
+#define SUNXI_ADC_DRC_HET	0x26C
+#define SUNXI_ADC_DRC_LET	0x270
+#define SUNXI_ADC_DRC_HKE	0x274
+#define SUNXI_ADC_DRC_LKE	0x278
+#define SUNXI_ADC_DRC_HOPE	0x27C
+#define SUNXI_ADC_DRC_LOPE	0x280
+#define SUNXI_ADC_DRC_HKN	0x284
+#define SUNXI_ADC_DRC_LKN	0x288
+#define SUNXI_ADC_DRC_SFHAT	0x28C
+#define SUNXI_ADC_DRC_SFLAT	0x290
+#define SUNXI_ADC_DRC_SFHRT	0x294
+#define SUNXI_ADC_DRC_SFLRT	0x298
+#define SUNXI_ADC_DRC_MXGHS	0x29C
+#define SUNXI_ADC_DRC_MXGLS	0x2A0
+#define SUNXI_ADC_DRC_MNGHS	0x2A4
+#define SUNXI_ADC_DRC_MNGLS	0x2A8
+#define SUNXI_ADC_DRC_EPSHC	0x2AC
+#define SUNXI_ADC_DRC_EPSLC	0x2B0
+#define SUNXI_ADC_DRC_OPT	0x2B4
+#define SUNXI_ADC_DRC_HPFHGAIN	0x2B8
+#define SUNXI_ADC_DRC_HPFLGAIN	0x2BC
+
+#define SUNXI_AC_VERSION	0x2C0
+
+/* Analog register */
+#define SUNXI_ADC1_REG		0x300
+#define SUNXI_ADC2_REG		0x304
+#define SUNXI_ADC3_REG		0x308
+#define SUNXI_DAC_REG		0x310
+#define SUNXI_MICBIAS_REG	0x318
+#define SUNXI_RAMP_REG		0x31C
+#define SUNXI_BIAS_REG		0x320
+#define SUNXI_HMIC_CTRL		0x328
+#define SUNXI_HMIC_STS		0x32C
+#define SUNXI_HP2_REG		0x340
+#define SUNXI_POWER_REG		0x348
+#define SUNXI_ADC_CUR_REG	0x34C
+
+/* SUNXI_DAC_DPC:0x00 */
+#define EN_DAC			31
+#define MODQU			25
+#define DWA_EN			24
+#define HPF_EN			18
+#define DVOL			12
+#define DAC_HUB_EN		0
+
+/* SUNXI_DAC_VOL_CTRL:0x04 */
+#define DAC_VOL_SEL		16
+#define DAC_VOL_L		8
+#define DAC_VOL_R		0
+
+/* SUNXI_DAC_FIFOC:0x10 */
+#define DAC_FS			29
+#define FIR_VER			28
+#define SEND_LASAT		26
+#define FIFO_MODE		24
+#define DAC_DRQ_CLR_CNT		21
+#define TX_TRIG_LEVEL		8
+#define DAC_MONO_EN		6
+#define TX_SAMPLE_BITS		5
+#define DAC_DRQ_EN		4
+#define DAC_IRQ_EN		3
+#define FIFO_UNDERRUN_IRQ_EN	2
+#define FIFO_OVERRUN_IRQ_EN	1
+#define FIFO_FLUSH		0
+
+/* SUNXI_DAC_FIFOS:0x14 */
+#define	TX_EMPTY		23
+#define	DAC_TXE_CNT		8
+#define	DAC_TXE_INT		3
+#define	DAC_TXU_INT		2
+#define	DAC_TXO_INT		1
+
+/* SUNXI_DAC_DG:0x28 */
+#define	DAC_MODU_SEL		11
+#define	DAC_PATTERN_SEL		9
+#define	DAC_CODEC_CLK_SEL	8
+#define	DAC_SWP			6
+#define	ADDA_LOOP_MODE		0
+
+/* SUNXI_ADC_FIFOC:0x30 */
+#define ADC_FS			29
+#define EN_AD			28
+#define ADCFDT			26
+#define ADCDFEN			25
+#define RX_FIFO_MODE		24
+#define RX_SYNC_EN_STA		21
+#define RX_SYNC_EN		20
+#define RX_SAMPLE_BITS		16
+#define RX_FIFO_TRG_LEVEL	4
+#define ADC_DRQ_EN		3
+#define ADC_IRQ_EN		2
+#define ADC_OVERRUN_IRQ_EN	1
+#define ADC_FIFO_FLUSH		0
+
+/* SUNXI_ADC_VOL_CTRL:0x34 */
+#define ADC3_VOL		16
+#define ADC2_VOL		8
+#define ADC1_VOL		0
+
+/* SUNXI_ADC_FIFOS:0x38 */
+#define	RXA			23
+#define	ADC_RXA_CNT		8
+#define	ADC_RXA_INT		3
+#define	ADC_RXO_INT		1
+
+/* SUNXI_ADC_DG:0x4C */
+#define	AD_SWP2			25
+#define	AD_SWP1			24
+
+/* SUNXI_ADC_DIG_CTRL:0x50 */
+#define	ADC3_VOL_EN		17
+#define	ADC1_2_VOL_EN		16
+#define	ADC3_CHANNEL_EN		2
+#define	ADC2_CHANNEL_EN		1
+#define	ADC1_CHANNEL_EN		0
+#define	ADC_CHANNEL_EN		0
+
+/* SUNXI_VRA1SPEEDUP_DOWN_CTRL:0x54 */
+#define	VRA1SPEEDUP_DOWN_STATE		4
+#define	VRA1SPEEDUP_DOWN_CTRL		1
+#define	VRA1SPEEDUP_DOWN_RST_CTRL	0
+
+/* SUNXI_DAC_DAP_CTL:0xf0 */
+#define	DDAP_EN			31
+#define	DDAP_DRC_EN		29
+#define	DDAP_HPF_EN		28
+
+/* SUNXI_ADC_DAP_CTL:0xf8 */
+#define	ADC_DAP0_EN		31
+#define	ADC_DRC0_EN		29
+#define	ADC_HPF0_EN		28
+#define	ADC_DAP1_EN		27
+#define	ADC_DRC1_EN		25
+#define	ADC_HPF1_EN		24
+
+/* SUNXI_DAC_DRC_HHPFC : 0x100*/
+#define DAC_HHPF_CONF		0
+
+/* SUNXI_DAC_DRC_LHPFC : 0x104*/
+#define DAC_LHPF_CONF		0
+
+/* SUNXI_DAC_DRC_CTRL : 0x108*/
+#define DAC_DRC_DELAY_OUT_STATE		15
+#define DAC_DRC_SIGNAL_DELAY		8
+#define DAC_DRC_DELAY_BUF_EN		7
+#define DAC_DRC_GAIN_MAX_EN		6
+#define DAC_DRC_GAIN_MIN_EN		5
+#define DAC_DRC_NOISE_DET_EN		4
+#define DAC_DRC_SIGNAL_SEL		3
+#define DAC_DRC_DELAY_EN		2
+#define DAC_DRC_LT_EN			1
+#define DAC_DRC_ET_EN			0
+
+/* SUNXI_ADC_DRC_HHPFC : 0x200*/
+#define ADC_HHPF_CONF		0
+
+/* SUNXI_ADC_DRC_LHPFC : 0x204*/
+#define ADC_LHPF_CONF		0
+
+/* SUNXI_ADC_DRC_CTRL : 0x208*/
+#define ADC_DRC_DELAY_OUT_STATE		15
+#define ADC_DRC_SIGNAL_DELAY		8
+#define ADC_DRC_DELAY_BUF_EN		7
+#define ADC_DRC_GAIN_MAX_EN		6
+#define ADC_DRC_GAIN_MIN_EN		5
+#define ADC_DRC_NOISE_DET_EN		4
+#define ADC_DRC_SIGNAL_SEL		3
+#define ADC_DRC_DELAY_EN		2
+#define ADC_DRC_LT_EN			1
+#define ADC_DRC_ET_EN			0
+
+/* SUNXI_ADC1_REG : 0x300 */
+#define ADC1_EN			31
+#define MIC1_PGA_EN		30
+#define ADC1_DITHER_CTRL	29
+#define MIC1_SIN_EN		28
+#define FMINLEN			27
+#define FMINLG			26
+#define ADC1_DSM_DITHER_LVL	24
+#define LINEINLEN		23
+#define LINEINLG		22
+#define ADC1_IOPBUFFER		20
+#define ADC1_PGA_CTRL_RCM	18
+#define ADC1_PGA_IN_VCM_CTRL	16
+#define IOPADC			14
+#define ADC1_PGA_GAIN_CTRL	8
+#define ADC1_IOPAAF		6
+#define ADC1_IOPSDM1		4
+#define ADC1_IOPSDM2		2
+#define ADC1_IOPMIC		0
+
+/* SUNXI_ADC2_REG : 0x304 */
+#define ADC2_EN			31
+#define MIC2_PGA_EN		30
+#define ADC2_DITHER_CTRL	29
+#define MIC2_SIN_EN		28
+#define FMINREN			27
+#define FMINRG			26
+#define ADC2_DSM_DITHER_LVL	24
+#define LINEINREN		23
+#define LINEINRG		22
+#define ADC2_IOPBUFFER		20
+#define ADC2_PGA_CTRL_RCM	18
+#define ADC2_PGA_IN_VCM_CTRL	16
+#define ADC2_PGA_GAIN_CTRL	8
+#define ADC2_IOPAAF		6
+#define ADC2_IOPSDM1		4
+#define ADC2_IOPSDM2		2
+#define ADC2_IOPMIC		0
+
+/* SUNXI_ADC3_REG : 0x308 */
+#define ADC3_EN			31
+#define MIC3_PGA_EN		30
+#define ADC3_DITHER_CTRL	29
+#define MIC3_SIN_EN		28
+#define ADC3_DSM_DITHER_LVL	24
+#define ADC3_IOPBUFFER		20
+#define ADC3_PGA_CTRL_RCM	18
+#define ADC3_PGA_IN_VCM_CTRL	16
+#define ADC3_PGA_GAIN_CTRL	8
+#define ADC3_IOPAAF		6
+#define ADC3_IOPSDM1		4
+#define ADC3_IOPSDM2		2
+#define ADC3_IOPMIC		0
+
+/* SUNXI_DAC_REG : 0x310 */
+#define CURRENT_TEST_SELECT	23
+#define	VRA2_IOPVRS		20
+#define	ILINEOUTAMPS		18
+#define IOPDACS			16
+#define DACLEN			15
+#define DACREN			14
+#define LINEOUTLEN		13
+#define DACLMUTE		12
+#define LINEOUTREN		11
+#define DACRMUTE		10
+#define LINEOUTLDIFFEN		6
+#define LINEOUTRDIFFEN		5
+#define LINEOUT_VOL		0
+
+/* SUNXI_MICBIAS_REG : 0x318 */
+#define SELDETADCFS		28
+#define SELDETADCDB		26
+#define SELDETADCBF		24
+#define JACKDETEN		23
+#define SELDETADCDY		21
+#define MICADCEN		20
+#define POPFREE			19
+#define DETMODE			18
+#define AUTOPLEN		17
+#define MICDETPL		16
+#define HMICBIASEN		15
+#define HBIASSEL		13
+#define	HMICBIAS_CHOP_EN	12
+#define HMICBIAS_CHOP_CLK_SEL	10
+#define MMICBIASEN		7
+#define	MBIASSEL		5
+#define	MMICBIAS_CHOP_EN	4
+#define MMICBIAS_CHOP_CLK_SEL	2
+
+/* SUNXI_RAMP_REG : 0x31C */
+#define RAMP_RISE_INT_EN	31
+#define RAMP_RISE_INT		30
+#define RAMP_FALL_INT_EN	29
+#define RAMP_FALL_INT		28
+#define RAMP_SRST		24
+#define RAMP_CLK_DIV_M		16
+#define HP_PULL_OUT_EN		15
+#define RAMP_HOLD_STEP		12
+#define GAP_STEP		8
+#define RAMP_STEP		4
+#define RMD_EN			3
+#define RMU_EN			2
+#define RMC_EN			1
+#define RD_EN			0
+
+/* SUNXI_BIAS_REG : 0x320 */
+#define AC_BIASDATA		0
+
+/* SUNXI_HMIC_CTRL : 0x328 */
+#define HMIC_SAMPLE_SEL		21
+#define MDATA_THRESHOLD		16
+#define HMIC_SF			14
+#define HMIC_M			10
+#define HMIC_N			6
+#define MDATA_THRESHOLD_DB	3
+#define JACK_OUT_IRQ_EN		2
+#define JACK_IN_IRQ_EN		1
+#define MIC_DET_IRQ_EN		0
+
+/* SUNXI_HMIC_STS : 0x32C */
+#define MDATA_DISCARD		13
+#define	HMIC_DATA		8
+#define JACK_DET_OUT_ST		4
+#define JACK_DET_OIRQ		4
+#define JACK_DET_IIN_ST 	3
+#define JACK_DET_IIRQ		3
+#define MIC_DET_ST		0
+
+/* SUNXI_HP2_REG	:0x340 */
+#define HPFB_BUF_EN		31
+#define HEADPHONE_GAIN		28
+#define HPFB_RES		26
+#define OPDRV_CUR		24
+#define IOPHP			22
+#define HP_DRVEN		21
+#define HP_DRVOUTEN		20
+#define RSWITCH			19
+#define RAMPEN			18
+#define HPFB_IN_EN		17
+#define RAMP_FINAL_CTRL		16
+#define RAMP_OUT_EN		15
+#define RAMP_FINAL_STATE_RES	13
+#define FB_BUF_OUTPUT_CURRENT	8
+
+/* SUNXI_POWER_REG      :0x348 */
+#define ALDO_EN			31
+#define HPLDO_EN		30
+#define VAR1SPEEDUP_DOWN_FURTHER_CTRL	29
+#define AVCCPOR			16
+#define ALDO_OUTPUT_VOLTAGE	12
+#define HPLDO_OUTPUT_VOLTAGE	8
+#define BG_TRIM			0
+
+/* SUNXI_ADC_CUR_REG    :0x34C */
+#define ADC3_IOPMIC2		20
+#define ADC3_OP_MIC1_CUR	18
+#define ADC3_OP_MIC2_CUR	16
+#define ADC2_IOPMIC2		12
+#define ADC2_OP_MIC1_CUR	10
+#define ADC2_OP_MIC2_CUR	8
+#define ADC1_IOPMIC2		4
+#define ADC1_OP_MIC1_CUR	2
+#define ADC1_OP_MIC2_CUR	0
+
+#define CODEC_TX_FIFO_SIZE	128
+#define CODEC_RX_FIFO_SIZE	256
+
+/* gain select */
+#define MIC1_GAIN_SHIFT		1
+#define MIC2_GAIN_SHIFT		2
+#define MIC3_GAIN_SHIFT		3
+
+#define HP_GAIN_SHIFT		4
+
+/*125ms * (HP_DEBOUCE_TIME+1)*/
+#define HP_DEBOUCE_TIME	0x3
+
+#define REG_LABEL(constant)	{#constant, constant, 0}
+#define REG_LABEL_END           {NULL, 0, 0}
+
+/* SUNXI_CODEC_DAP_ENABLE: Whether to use the adc/dac drc/hpf function */
+#define SUNXI_CODEC_DAP_ENABLE
+
+/* SUNXI_CODEC_HUB_ENABLE: Whether to use the hub mode */
+#define SUNXI_CODEC_HUB_ENABLE
+
+/* SUNXI_CODEC_ADCSWAP_ENABLE: Whether to open the adc swap func controls */
+#define SUNXI_CODEC_ADCSWAP_ENABLE
+
+struct reg_label {
+	const char *name;
+	const unsigned int address;
+	unsigned int value;
+};
+
+struct codec_hw_config {
+	u32 adcdrc_cfg:8;
+	u32 dacdrc_cfg:8;
+	u32 adchpf_cfg:8;
+	u32 dachpf_cfg:8;
+};
+
+struct codec_spk_config {
+	u32 spk_gpio;
+	u32 pa_msleep;
+	bool used;
+	bool pa_level;
+};
+
+struct sample_rate {
+	unsigned int samplerate;
+	unsigned int rate_bit;
+};
+
+struct voltage_supply {
+	struct regulator *avcc;
+	struct regulator *hpvcc;
+};
+
+struct codec_dap {
+	int drc_enable;
+	int hpf_enable;
+};
+
+struct sunxi_codec_info {
+	struct device *dev;
+	struct regmap *regmap;
+	void __iomem *digital_base;
+	struct clk *pllaudio0;
+	struct clk *pllaudio1_div5;
+	struct clk *dacclk;
+	struct clk *adcclk;
+	struct clk *codec_clk_bus;
+	struct reset_control *codec_clk_rst;
+
+	/* regulator about */
+	struct voltage_supply vol_supply;
+
+	/* for dap function */
+	struct codec_dap dac_dap;
+	struct codec_dap adc_dap;
+	int dac_dap_enable;
+	int adc_dap_enable;
+
+	/* self user config params */
+	u32 digital_vol;
+	u32 lineout_vol;
+	u32 dac_digital_vol;
+
+	bool mic1gain_now;
+	bool mic2gain_now;
+	bool mic3gain_now;
+	bool hpgain_now;
+	u32 mic1gain;
+	u32 mic2gain;
+	u32 mic3gain;
+	u32 headphonegain;
+
+	u32 rx_sync_en;
+	int rx_sync_id;
+	rx_sync_domain_t rx_sync_domain;
+
+	struct codec_spk_config spk_config;
+	struct codec_spk_config spk_pwr_config;
+	struct codec_hw_config hw_config;
+};
+
+#endif
diff --git a/sound/soc/sunxi/sun8iw20-sndcodec.c b/sound/soc/sunxi/sun8iw20-sndcodec.c
new file mode 100644
index 000000000..266f48f38
--- /dev/null
+++ b/sound/soc/sunxi/sun8iw20-sndcodec.c
@@ -0,0 +1,900 @@
+/*
+ * sound\soc\sunxi\sun8iw20-sndcodec.c
+ * (C) Copyright 2021-2026
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * huangxin <huangxin@Reuuimllatech.com>
+ * liushaohua <liushaohua@allwinnertech.com>
+ * yumingfengng <yumingfeng@allwinnertech.com>
+ * luguofang <luguofang@allwinnertech.com>
+ * Dby <Dby@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+#include <linux/gpio.h>
+#include <linux/io.h>
+#include <linux/input.h>
+#include <linux/of.h>
+#include <linux/delay.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/jack.h>
+#include <sound/pcm_params.h>
+#include <sound/soc-dapm.h>
+
+#include "sun8iw20-codec.h"
+
+#define LOG_ERR(fmt, arg...)	pr_err("[SNDCODEC][%s][%d]:" fmt "\n", __func__, __LINE__, ##arg)
+#define LOG_WARN(fmt, arg...)	pr_warn("[SNDCODEC][%s][%d]:" fmt "\n", __func__, __LINE__, ##arg)
+#define LOG_INFO(fmt, arg...)	pr_info("[SNDCODEC][%s][%d]:" fmt "\n", __func__, __LINE__, ##arg)
+
+static int mdata_threshold = 0x10;
+module_param(mdata_threshold, int, 0644);
+MODULE_PARM_DESC(mdata_threshold,
+		"SUNXI hmic data threshold");
+
+typedef enum {
+	RESUME_IRQ  = 0x0,
+	SYSINIT_IRQ = 0x1,
+	OTHER_IRQ   = 0x2,
+} _jack_irq_times;
+
+enum HPDETECTWAY {
+	HP_DETECT_LOW = 0x0,
+	HP_DETECT_HIGH = 0x1,
+};
+
+enum dectect_jack {
+	PLUG_OUT = 0x0,
+	PLUG_IN  = 0x1,
+};
+
+enum JACK_FUNCTION {
+	JACK_ENABLE = 0x1,
+	JACK_DISABLE = 0x0,
+};
+
+static bool is_irq;
+static int switch_state;
+
+struct sunxi_card_priv {
+	struct snd_soc_card *card;
+	struct snd_soc_component *component;
+	struct delayed_work hs_init_work;
+	struct delayed_work hs_detect_work;
+	struct delayed_work hs_button_work;
+	struct delayed_work hs_checkplug_work;
+	struct mutex jack_mlock;
+	struct snd_soc_jack jack;
+	struct timespec64 tv_headset_plugin;	/*4*/
+	_jack_irq_times jack_irq_times;
+	u32 detect_state;
+	u32 jackirq;				/*switch irq*/
+	u32 HEADSET_DATA;			/*threshod for switch insert*/
+	u32 headset_basedata;
+	u32 switch_status;
+	u32 key_volup;
+	u32 key_voldown;
+	u32 key_hook;
+	u32 key_voiceassist;
+	u32 hp_detect_case;
+	u32 jack_func;
+};
+
+/*
+ * Identify the jack type as Headset/Headphone/None
+ */
+static int sunxi_check_jack_type(struct snd_soc_jack *jack)
+{
+	u32 reg_val = 0;
+	u32 jack_type = 0, tempdata = 0;
+	struct sunxi_card_priv *priv = container_of(jack,
+						    struct sunxi_card_priv,
+						    jack);
+
+	reg_val = snd_soc_component_read32(priv->component, SUNXI_HMIC_STS);
+	tempdata = (reg_val >> HMIC_DATA) & 0x1f;
+	priv->headset_basedata = tempdata;
+
+	if (tempdata >= priv->HEADSET_DATA) {
+		/* headset:4 */
+		jack_type = SND_JACK_HEADSET;
+	} else {
+		/* headphone:3, disable hbias and adc */
+		snd_soc_component_update_bits(priv->component,
+				SUNXI_MICBIAS_REG,
+				(0x1 << HMICBIASEN),
+				(0x0 << HMICBIASEN));
+		snd_soc_component_update_bits(priv->component,
+				SUNXI_MICBIAS_REG,
+				(0x1 << MICADCEN),
+				(0x0 << MICADCEN));
+		jack_type = SND_JACK_HEADPHONE;
+	}
+
+	return jack_type;
+}
+
+/* Checks hs insertion by mdet */
+static void sunxi_check_hs_plug(struct work_struct *work)
+{
+	struct sunxi_card_priv *priv = container_of(work,
+						    struct sunxi_card_priv,
+						    hs_checkplug_work.work);
+
+	mutex_lock(&priv->jack_mlock);
+	if (priv->detect_state != PLUG_IN) {
+		/* Enable MDET */
+		snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+				(0x1 << MIC_DET_IRQ_EN),
+				(0x1 << MIC_DET_IRQ_EN));
+		snd_soc_component_update_bits(priv->component, SUNXI_MICBIAS_REG,
+				(0x1 << MICADCEN),
+				(0x1 << MICADCEN));
+		/* Enable PA */
+		/*
+		snd_soc_component_update_bits(priv->component, SUNXI_HEADPHONE_REG,
+				(0x1 << HPPA_EN),
+				(0x1 << HPPA_EN));
+		*/
+	} else {
+		/*
+		 * Enable HPPA_EN
+		 * FIXME:When the Audio HAL is not at the do_output_standby,
+		 * apk not play the music at the same time, we can insert
+		 * headset now and click to play music immediately in the apk,
+		 * the Audio HAL will write data to the card and not update
+		 * the stream routing. Because we also set mute when
+		 * the mdet come into force, so that the dapm will not update
+		 * and it makes the mute.
+		 */
+		/*
+		snd_soc_component_update_bits(priv->component, SUNXI_HEADPHONE_REG,
+				(0x1 << HPPA_EN),
+				(0x1 << HPPA_EN));
+		*/
+	}
+	mutex_unlock(&priv->jack_mlock);
+}
+
+/* Checks jack insertion and identifies the jack type.*/
+static void sunxi_check_hs_detect_status(struct work_struct *work)
+{
+	int jack_type = 0, reg_val = 0;
+	struct sunxi_card_priv *priv = container_of(work,
+						    struct sunxi_card_priv,
+						    hs_detect_work.work);
+
+	mutex_lock(&priv->jack_mlock);
+	if (priv->detect_state == PLUG_IN) {
+		/* enable hbias and adc */
+		snd_soc_component_update_bits(priv->component,
+				SUNXI_MICBIAS_REG,
+				(0x1 << HMICBIASEN),
+				(0x1 << HMICBIASEN));
+		snd_soc_component_update_bits(priv->component,
+				SUNXI_MICBIAS_REG,
+				(0x1 << MICADCEN),
+				(0x1 << MICADCEN));
+		msleep(100);
+		jack_type = sunxi_check_jack_type(&priv->jack);
+		if (jack_type != priv->switch_status) {
+			priv->switch_status = jack_type;
+			snd_jack_report(priv->jack.jack, jack_type);
+			LOG_INFO("plugin --> switch:%d", jack_type);
+			switch_state = jack_type;
+		}
+
+		/* if SND_JACK_HEADSET,enable mic detect irq */
+		if (jack_type == SND_JACK_HEADSET) {
+			reg_val = snd_soc_component_read32(priv->component, SUNXI_HMIC_STS);
+			priv->headset_basedata = (reg_val >> HMIC_DATA) & 0x1f;
+			if (priv->headset_basedata > 3)
+				priv->headset_basedata -= 3;
+
+			usleep_range(1000, 2000);
+			snd_soc_component_update_bits(priv->component,
+				SUNXI_HMIC_CTRL,
+				(0x1f << MDATA_THRESHOLD),
+				(priv->headset_basedata << MDATA_THRESHOLD));
+			snd_soc_component_update_bits(priv->component,
+				SUNXI_HMIC_CTRL,
+				(0x1 << MIC_DET_IRQ_EN),
+				(0x1 << MIC_DET_IRQ_EN));
+		} else if (jack_type == SND_JACK_HEADPHONE) {
+			/* if is HEADPHONE 3, close mic detect irq */
+			snd_soc_component_update_bits(priv->component,
+				SUNXI_HMIC_CTRL,
+				(0x1 << MIC_DET_IRQ_EN),
+				(0x0 << MIC_DET_IRQ_EN));
+		}
+	} else {
+		priv->switch_status = 0;
+		snd_jack_report(priv->jack.jack, priv->switch_status);
+		switch_state = priv->switch_status;
+		LOG_INFO("plugout --> switch:%d", priv->switch_status);
+		snd_soc_component_update_bits(priv->component,
+				SUNXI_MICBIAS_REG,
+				(0x1 << HMICBIASEN),
+				(0x0 << HMICBIASEN));
+		snd_soc_component_update_bits(priv->component,
+				SUNXI_MICBIAS_REG,
+				(0x1 << MICADCEN),
+				(0x0 << MICADCEN));
+		snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+				(0x1f << MDATA_THRESHOLD),
+				(mdata_threshold << MDATA_THRESHOLD));
+		snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+				(0x1 << MIC_DET_IRQ_EN),
+				(0x0 << MIC_DET_IRQ_EN));
+	}
+	mutex_unlock(&priv->jack_mlock);
+}
+
+static void sunxi_hs_init_work(struct work_struct *work)
+{
+	struct sunxi_card_priv *priv = container_of(work,
+						    struct sunxi_card_priv,
+						    hs_init_work.work);
+
+	mutex_lock(&priv->jack_mlock);
+	if (is_irq == true) {
+		is_irq = false;
+	} else {
+		if ((priv->hp_detect_case == HP_DETECT_LOW) ||
+		    (priv->jack_irq_times == RESUME_IRQ)) {
+			/*
+			 * It should be report after resume.
+			 * If the headset plugout after suspend, the system
+			 * can not know the state, so we should reset here
+			 * when resume.
+			 */
+			LOG_INFO("resume-->report switch");
+			priv->switch_status = 0;
+			snd_jack_report(priv->jack.jack, priv->switch_status);
+			switch_state = 0;
+		}
+	}
+	priv->jack_irq_times = OTHER_IRQ;
+	mutex_unlock(&priv->jack_mlock);
+}
+
+/* Check for hook release */
+static void sunxi_check_hs_button_status(struct work_struct *work)
+{
+	u32 i = 0;
+	struct sunxi_card_priv *priv = container_of(work,
+						    struct sunxi_card_priv,
+						    hs_button_work.work);
+
+	mutex_lock(&priv->jack_mlock);
+	for (i = 0; i < 1; i++) {
+		if (priv->key_hook == 0) {
+			LOG_INFO("Hook (2)!!");
+			priv->switch_status &= ~SND_JACK_BTN_0;
+			snd_jack_report(priv->jack.jack, priv->switch_status);
+			break;
+		}
+		/* may msleep 8 */
+		msleep(20);
+	}
+	mutex_unlock(&priv->jack_mlock);
+}
+
+static irqreturn_t jack_interrupt(int irq, void *dev_id)
+{
+	struct sunxi_card_priv *priv = dev_id;
+	struct timespec64 tv;
+	u32 tempdata = 0, regval = 0;
+	int jack_state = 0;
+
+	if (priv->jack_irq_times == RESUME_IRQ ||
+	    priv->jack_irq_times == SYSINIT_IRQ) {
+		LOG_INFO("is_irq is ture");
+		is_irq = true;
+		priv->jack_irq_times = OTHER_IRQ;
+	}
+
+	jack_state = snd_soc_component_read32(priv->component, SUNXI_HMIC_STS);
+
+	/*
+	if (priv->detect_state != PLUG_IN) {
+		//when headphone half-insertion, MIC_DET IRQ will be trigger.
+		if (jack_state & (1 << MIC_DET_ST)) {
+			regval = snd_soc_component_read32(priv->component, SUNXI_HMIC_CTRL);
+			regval &= ~(0x1 << MIC_DET_IRQ_EN);
+			snd_soc_component_write(priv->component, SUNXI_HMIC_CTRL, regval);
+
+			regval = snd_soc_component_read32(priv->component, SUNXI_MICBIAS_REG);
+			regval &= ~(0x1 << MICADCEN);
+			snd_soc_component_write(priv->component, SUNXI_MICBIAS_REG, regval);
+
+			//clear mic detect status
+			regval = snd_soc_component_read32(priv->component, SUNXI_HMIC_STS);
+			regval &= ~(0x1 << JACK_DET_IIN_ST);
+			regval &= ~(0x1 << JACK_DET_OUT_ST);
+			regval |= 0x1 << MIC_DET_ST;
+			snd_soc_component_write(priv->component, SUNXI_HMIC_STS, regval);
+
+			//prevent mic detect false trigger
+			schedule_delayed_work(&priv->hs_checkplug_work,
+				msecs_to_jiffies(700));
+		}
+	}
+	*/
+
+	/* headphone plugin */
+	if (jack_state & (1 << JACK_DET_IIN_ST)) {
+		regval = jack_state;
+		regval &= ~(0x1 << JACK_DET_OUT_ST);
+		snd_soc_component_write(priv->component, SUNXI_HMIC_STS, regval);
+		priv->detect_state = PLUG_IN;
+		/* get jack insert time to set mic det dead time */
+		ktime_get_real_ts64(&priv->tv_headset_plugin);
+		schedule_delayed_work(&priv->hs_detect_work,
+				      msecs_to_jiffies(10));
+	}
+
+	/* headphone plugout */
+	if (jack_state & (1 << JACK_DET_OUT_ST)) {
+		regval = jack_state;
+		regval &= ~(0x1 << JACK_DET_IIN_ST);
+		snd_soc_component_write(priv->component, SUNXI_HMIC_STS, regval);
+		priv->detect_state = PLUG_OUT;
+		schedule_delayed_work(&priv->hs_detect_work,
+				      msecs_to_jiffies(10));
+	}
+
+	/* headphone btn event */
+	if ((priv->detect_state == PLUG_IN) &&
+	    (jack_state & (1 << MIC_DET_ST))) {
+		regval = jack_state;
+		regval &= ~(0x1 << JACK_DET_IIN_ST);
+		regval &= ~(0x1 << JACK_DET_OUT_ST);
+		snd_soc_component_write(priv->component, SUNXI_HMIC_STS, regval);
+
+		/* plugin less 1s, not operate */
+		ktime_get_real_ts64(&tv);
+		if (abs(tv.tv_sec - priv->tv_headset_plugin.tv_sec) < 1)
+			return IRQ_HANDLED;
+
+		tempdata = snd_soc_component_read32(priv->component, SUNXI_HMIC_STS);
+		tempdata = (tempdata & 0x1f00) >> 8;
+		LOG_ERR("KEY tempdata: %d", tempdata);
+
+		if (tempdata == 2) {
+			priv->key_hook = 0;
+			priv->key_voldown = 0;
+			priv->key_voiceassist = 0;
+			priv->key_volup++;
+			if (priv->key_volup == 1) {
+				LOG_INFO("Volume ++");
+				priv->key_volup = 0;
+				priv->switch_status |= SND_JACK_BTN_1;
+				snd_jack_report(priv->jack.jack,
+						priv->switch_status);
+				priv->switch_status &= ~SND_JACK_BTN_1;
+				snd_jack_report(priv->jack.jack,
+						priv->switch_status);
+			}
+		} else if ((tempdata == 5) || tempdata == 4) {
+			priv->key_volup = 0;
+			priv->key_hook = 0;
+			priv->key_voiceassist = 0;
+			priv->key_voldown++;
+			if (priv->key_voldown == 1) {
+				LOG_INFO("Volume --");
+				priv->key_voldown = 0;
+				priv->switch_status |= SND_JACK_BTN_2;
+				snd_jack_report(priv->jack.jack,
+						priv->switch_status);
+				priv->switch_status &= ~SND_JACK_BTN_2;
+				snd_jack_report(priv->jack.jack,
+						priv->switch_status);
+			}
+		} else if (tempdata == 1) {
+			priv->key_volup = 0;
+			priv->key_hook = 0;
+			priv->key_voldown = 0;
+			priv->key_voiceassist++;
+			if (priv->key_voiceassist == 1) {
+				LOG_INFO("Voice Assistant Open");
+				priv->key_voiceassist = 0;
+				priv->switch_status |= SND_JACK_BTN_3;
+				snd_jack_report(priv->jack.jack,
+						priv->switch_status);
+				priv->switch_status &= ~SND_JACK_BTN_3;
+				snd_jack_report(priv->jack.jack,
+						priv->switch_status);
+			}
+		} else if (tempdata == 0x0) {
+			priv->key_volup = 0;
+			priv->key_voldown = 0;
+			priv->key_voiceassist = 0;
+			priv->key_hook++;
+			if (priv->key_hook >= 1) {
+				priv->key_hook = 0;
+				if ((priv->switch_status & SND_JACK_BTN_0)
+				    == 0) {
+					priv->switch_status |= SND_JACK_BTN_0;
+					snd_jack_report(priv->jack.jack,
+							priv->switch_status);
+					LOG_INFO("Hook (1)");
+				}
+				schedule_delayed_work(&priv->hs_button_work,
+						      msecs_to_jiffies(180));
+			}
+		} else {
+			LOG_ERR("tempdata:0x%x,Key data err:",
+				 tempdata);
+			priv->key_volup = 0;
+			priv->key_voldown = 0;
+			priv->key_hook = 0;
+			priv->key_voiceassist = 0;
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+static const struct snd_kcontrol_new sunxi_card_controls[] = {
+	SOC_DAPM_PIN_SWITCH("Headphone"),
+	SOC_DAPM_PIN_SWITCH("HpSpeaker"),
+	SOC_DAPM_PIN_SWITCH("LINEOUT"),
+};
+
+static const struct snd_soc_dapm_widget sunxi_card_dapm_widgets[] = {
+	SND_SOC_DAPM_MIC("HeadphoneMic", NULL),
+	SND_SOC_DAPM_MIC("Main Mic", NULL),
+};
+
+static const struct snd_soc_dapm_route sunxi_card_routes[] = {
+	{"MainMic Bias", NULL, "Main Mic"},
+	{"MIC1", NULL, "MainMic Bias"},
+	/*{"MIC2", NULL, "HeadphoneMic"},*/
+	{"MIC2", NULL, "MainMic Bias"},
+	{"MIC3", NULL, "MainMic Bias"},
+};
+
+static void sunxi_hs_reg_init(struct sunxi_card_priv *priv)
+{
+	/*
+	snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+			(0xffff << 0),
+			(0x0 << 0));
+	*/
+	snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+			(0x1f << MDATA_THRESHOLD),
+			(0x17 << MDATA_THRESHOLD));
+	/*
+	snd_soc_component_update_bits(priv->component, SUNXI_HMIC_STS,
+			(0xffff << 0),
+			(0x6000 << 0));
+	*/
+	/*
+	snd_soc_component_update_bits(priv->component, SUNXI_MICBIAS_REG,
+			(0x7f << SELDETADCBF),
+			(0x40 << SELDETADCBF));
+	*/
+	if (priv->hp_detect_case == HP_DETECT_LOW) {
+		snd_soc_component_update_bits(priv->component,
+				SUNXI_MICBIAS_REG,
+				(0x1 << AUTOPLEN),
+				(0x1 << AUTOPLEN));
+		snd_soc_component_update_bits(priv->component,
+				SUNXI_MICBIAS_REG,
+				(0x1 << DETMODE),
+				(0x0 << DETMODE));
+	} else {
+		snd_soc_component_update_bits(priv->component,
+				SUNXI_MICBIAS_REG,
+				(0x1 << AUTOPLEN),
+				(0x0 << AUTOPLEN));
+		snd_soc_component_update_bits(priv->component,
+				SUNXI_MICBIAS_REG,
+				(0x1 << DETMODE),
+				(0x1 << DETMODE));
+	}
+	snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+			(0xf << HMIC_N),
+			(HP_DEBOUCE_TIME << HMIC_N));
+	snd_soc_component_update_bits(priv->component, SUNXI_MICBIAS_REG,
+			(0x1 << JACKDETEN),
+			(0x1 << JACKDETEN));
+	snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+			(0x1 << JACK_IN_IRQ_EN),
+			(0x1 << JACK_IN_IRQ_EN));
+	snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+			(0x1 << JACK_OUT_IRQ_EN),
+			(0x1 << JACK_OUT_IRQ_EN));
+
+	/*
+	snd_soc_component_update_bits(priv->component, SUNXI_MICBIAS_REG,
+			    (0x1 << HMICBIASEN), (0x1 << HMICBIASEN));
+	snd_soc_component_update_bits(priv->component, SUNXI_MICBIAS_REG,
+			    (0x1 << MICADCEN), (0x1 << MICADCEN));
+	*/
+
+	/*
+	snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+			(0x1 << MIC_DET_IRQ_EN),
+			(0x1 << MIC_DET_IRQ_EN));
+	*/
+
+	schedule_delayed_work(&priv->hs_init_work, msecs_to_jiffies(10));
+}
+
+static void snd_sunxi_unregister_jack(struct sunxi_card_priv *priv)
+{
+	/*
+	 * Set process button events to false so that the button
+	 * delayed work will not be scheduled.
+	 */
+	cancel_delayed_work_sync(&priv->hs_detect_work);
+	cancel_delayed_work_sync(&priv->hs_button_work);
+	cancel_delayed_work_sync(&priv->hs_init_work);
+	free_irq(priv->jackirq, priv);
+}
+
+/*
+ * Card initialization
+ */
+static int sunxi_card_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_component *component = rtd->codec_dai->component;
+	struct snd_soc_dapm_context *dapm = &component->dapm;
+
+	struct sunxi_card_priv *priv = snd_soc_card_get_drvdata(rtd->card);
+	int ret;
+
+	priv->component = rtd->codec_dai->component;
+
+	ret = snd_soc_card_jack_new(rtd->card, "sunxi Audio Jack",
+			       SND_JACK_HEADSET | SND_JACK_HEADPHONE |
+				   SND_JACK_BTN_0 | SND_JACK_BTN_1 |
+				   SND_JACK_BTN_2 | SND_JACK_BTN_3,
+			       &priv->jack, NULL, 0);
+	if (ret) {
+		LOG_ERR("jack creation failed");
+		return ret;
+	}
+
+	snd_jack_set_key(priv->jack.jack, SND_JACK_BTN_0, KEY_MEDIA);
+	snd_jack_set_key(priv->jack.jack, SND_JACK_BTN_1, KEY_VOLUMEUP);
+	snd_jack_set_key(priv->jack.jack, SND_JACK_BTN_2, KEY_VOLUMEDOWN);
+	snd_jack_set_key(priv->jack.jack, SND_JACK_BTN_3, KEY_VOICECOMMAND);
+
+	snd_soc_dapm_disable_pin(dapm, "HPOUTR");
+	snd_soc_dapm_disable_pin(dapm, "HPOUTL");
+
+	snd_soc_dapm_disable_pin(dapm, "LINEOUT");
+	snd_soc_dapm_disable_pin(dapm, "HpSpeaker");
+	snd_soc_dapm_disable_pin(dapm, "Headphone");
+
+	snd_soc_dapm_sync(dapm);
+
+	LOG_WARN("card init finished");
+	return 0;
+}
+
+static int sunxi_card_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	/* struct snd_soc_card *card = rtd->card; */
+	unsigned int freq;
+	int ret;
+	int stream_flag;
+
+	switch (params_rate(params)) {
+	case	8000:
+	case	12000:
+	case	16000:
+	case	24000:
+	case	32000:
+	case	48000:
+	case	96000:
+	case	192000:
+		freq = 24576000;
+		break;
+	case	11025:
+	case	22050:
+	case	44100:
+		freq = 22579200;
+		break;
+	default:
+		LOG_ERR("invalid rate setting");
+		return -EINVAL;
+	}
+
+	/* the substream type: 0->playback, 1->capture */
+	stream_flag = substream->stream;
+	LOG_INFO("stream_flag: %d", stream_flag);
+
+	/* To surpport playback and capture func in different freq point */
+	if (freq == 22579200) {
+		if (stream_flag == 0) {
+			ret = snd_soc_dai_set_sysclk(codec_dai, 0, freq, 0);
+			if (ret < 0) {
+				LOG_ERR("set codec dai sysclk faided, freq:%d", freq);
+				return ret;
+			}
+		}
+	}
+
+	if (freq == 22579200) {
+		if (stream_flag == 1) {
+			ret = snd_soc_dai_set_sysclk(codec_dai, 1, freq, 0);
+			if (ret < 0) {
+				LOG_ERR("set codec dai sysclk faided, freq:%d", freq);
+				return ret;
+			}
+		}
+	}
+
+	if (freq == 24576000) {
+		if (stream_flag == 0) {
+			ret = snd_soc_dai_set_sysclk(codec_dai, 2, freq, 0);
+			if (ret < 0) {
+				LOG_ERR("set codec dai sysclk faided, freq:%d", freq);
+				return ret;
+			}
+		}
+	}
+
+	if (freq == 24576000) {
+			if (stream_flag == 1) {
+			ret = snd_soc_dai_set_sysclk(codec_dai, 3, freq, 0);
+			if (ret < 0) {
+				LOG_ERR("set codec dai sysclk faided, freq:%d", freq);
+				return ret;
+			}
+		}
+	}
+
+	return 0;
+}
+
+static struct snd_soc_ops sunxi_card_ops = {
+	.hw_params = sunxi_card_hw_params,
+};
+
+SND_SOC_DAILINK_DEFS(sun8iw20p1_dai_link,
+	DAILINK_COMP_ARRAY(COMP_CPU("sunxi-dummy-cpudai")),
+	DAILINK_COMP_ARRAY(COMP_CODEC("sunxi-internal-codec", "sun8iw20codec")),
+	DAILINK_COMP_ARRAY(COMP_PLATFORM("sunxi-dummy-cpudai")));
+
+static struct snd_soc_dai_link sunxi_card_dai_link[] = {
+	{
+		.name		= "audiocodec",
+		.stream_name	= "SUNXI-CODEC",
+		.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF
+				| SND_SOC_DAIFMT_CBM_CFM,
+		.init		= sunxi_card_init,
+		.ops		= &sunxi_card_ops,
+		SND_SOC_DAILINK_REG(sun8iw20p1_dai_link),
+	},
+};
+
+static int sunxi_card_suspend(struct snd_soc_card *card)
+{
+	struct sunxi_card_priv *priv = snd_soc_card_get_drvdata(card);
+
+	if (priv->jack_func == JACK_DISABLE)
+		return 0;
+	disable_irq(priv->jackirq);
+
+	snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+			    (0x1 << MIC_DET_IRQ_EN), (0x0 << MIC_DET_IRQ_EN));
+	snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+			    (0x1 << JACK_IN_IRQ_EN), (0x0 << JACK_IN_IRQ_EN));
+	snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+			    (0x1 << JACK_OUT_IRQ_EN), (0x0 << JACK_OUT_IRQ_EN));
+	snd_soc_component_update_bits(priv->component, SUNXI_MICBIAS_REG, (0x1 << JACKDETEN),
+			    (0x0 << JACKDETEN));
+	LOG_INFO("suspend");
+
+	return 0;
+}
+
+static int sunxi_card_resume(struct snd_soc_card *card)
+{
+	struct sunxi_card_priv *priv = snd_soc_card_get_drvdata(card);
+
+	if (priv->jack_func == JACK_DISABLE)
+		return 0;
+	enable_irq(priv->jackirq);
+	priv->jack_irq_times = RESUME_IRQ;
+	priv->detect_state = PLUG_OUT;/*todo..?*/
+	sunxi_hs_reg_init(priv);
+	LOG_INFO("resume");
+
+	return 0;
+}
+
+static struct snd_soc_card snd_soc_sunxi_card = {
+	.name			= "audiocodec",
+	.owner			= THIS_MODULE,
+	.dai_link		= sunxi_card_dai_link,
+	.num_links		= ARRAY_SIZE(sunxi_card_dai_link),
+	.suspend_post		= sunxi_card_suspend,
+	.resume_post		= sunxi_card_resume,
+
+};
+
+static int sunxi_card_dev_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	u32 temp_val;
+	struct sunxi_card_priv *priv = NULL;
+	struct device_node *np = pdev->dev.of_node;
+	struct snd_soc_card *card = &snd_soc_sunxi_card;
+	struct snd_soc_dapm_context *dapm = &card->dapm;
+
+	if (!np) {
+		LOG_ERR("can not get dt node for this device");
+		return -EINVAL;
+	}
+
+	/* dai link */
+	sunxi_card_dai_link[0].cpus->dai_name = NULL;
+	sunxi_card_dai_link[0].cpus->of_node = of_parse_phandle(np,
+					"sunxi,cpudai-controller", 0);
+	if (!sunxi_card_dai_link[0].cpus->of_node) {
+		LOG_ERR("Property 'sunxi,cpudai-controller' missing or invalid");
+		ret = -EINVAL;
+		goto err_devm_kfree;
+	} else {
+		sunxi_card_dai_link[0].platforms->name = NULL;
+		sunxi_card_dai_link[0].platforms->of_node =
+				sunxi_card_dai_link[0].cpus->of_node;
+	}
+	sunxi_card_dai_link[0].codecs->name = NULL;
+	sunxi_card_dai_link[0].codecs->of_node = of_parse_phandle(np,
+						"sunxi,audio-codec", 0);
+	if (!sunxi_card_dai_link[0].codecs->of_node) {
+		LOG_ERR("Property 'sunxi,audio-codec' missing or invalid");
+		ret = -EINVAL;
+		goto err_devm_kfree;
+	}
+
+	/* register the soc card */
+	card->dev = &pdev->dev;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(struct sunxi_card_priv),
+			    GFP_KERNEL);
+	if (!priv) {
+		LOG_ERR("devm_kzalloc failed %d", ret);
+		return -ENOMEM;
+	}
+	priv->card = card;
+
+	snd_soc_card_set_drvdata(card, priv);
+
+	ret = snd_soc_register_card(card);
+	if (ret) {
+		LOG_ERR("snd_soc_register_card failed %d", ret);
+		goto err_devm_kfree;
+	}
+
+	ret = snd_soc_add_card_controls(card, sunxi_card_controls,
+					ARRAY_SIZE(sunxi_card_controls));
+	if (ret)
+		LOG_ERR("failed to register codec controls");
+
+	snd_soc_dapm_new_controls(dapm, sunxi_card_dapm_widgets,
+				  ARRAY_SIZE(sunxi_card_dapm_widgets));
+	snd_soc_dapm_add_routes(dapm, sunxi_card_routes,
+				ARRAY_SIZE(sunxi_card_routes));
+
+	ret = of_property_read_u32(np, "jack_enable", &temp_val);
+	if (ret < 0) {
+		LOG_ERR("jack_enable missing, use default enable jack");
+		priv->jack_func = JACK_ENABLE;
+	} else {
+		priv->jack_func = temp_val;
+	}
+	if (priv->jack_func == JACK_DISABLE)
+		return 0;
+
+	ret = of_property_read_u32(np, "hp_detect_case", &temp_val);
+	if (ret < 0) {
+		LOG_ERR("hp_detect_case missing, use default hp_detect_low");
+		priv->hp_detect_case = HP_DETECT_LOW;
+	} else {
+		priv->hp_detect_case = temp_val;
+	}
+
+	/* initial the parameters for judge switch state */
+	priv->jack_irq_times = SYSINIT_IRQ;
+	priv->HEADSET_DATA = 0xA;
+	priv->detect_state = PLUG_OUT;
+	mutex_init(&priv->jack_mlock);
+	INIT_DELAYED_WORK(&priv->hs_detect_work, sunxi_check_hs_detect_status);
+	INIT_DELAYED_WORK(&priv->hs_button_work, sunxi_check_hs_button_status);
+	INIT_DELAYED_WORK(&priv->hs_init_work, sunxi_hs_init_work);
+	INIT_DELAYED_WORK(&priv->hs_checkplug_work, sunxi_check_hs_plug);
+
+	priv->jackirq = platform_get_irq(pdev, 0);
+	if (priv->jackirq < 0) {
+		LOG_ERR("irq get failed");
+		ret = -ENODEV;
+	}
+	ret = request_irq(priv->jackirq, jack_interrupt, 0, "audio jack irq",
+			  priv);
+
+	sunxi_hs_reg_init(priv);
+
+	LOG_INFO("register card finished");
+	return 0;
+
+err_devm_kfree:
+	devm_kfree(&pdev->dev, priv);
+	return ret;
+}
+
+static int __exit sunxi_card_dev_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+	struct sunxi_card_priv *priv = snd_soc_card_get_drvdata(card);
+
+	snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+			    (0x1 << JACK_IN_IRQ_EN), (0x0 << JACK_IN_IRQ_EN));
+	snd_soc_component_update_bits(priv->component, SUNXI_HMIC_CTRL,
+			    (0x1 << JACK_OUT_IRQ_EN), (0x0 << JACK_OUT_IRQ_EN));
+	snd_soc_component_update_bits(priv->component, SUNXI_MICBIAS_REG, (0x1 << JACKDETEN),
+			    (0x0 << JACKDETEN));
+	snd_soc_component_update_bits(priv->component, SUNXI_MICBIAS_REG,
+				(0x1 << HMICBIASEN), (0x0 << HMICBIASEN));
+	snd_sunxi_unregister_jack(priv);
+
+	snd_soc_unregister_card(card);
+	devm_kfree(&pdev->dev, priv);
+
+	LOG_WARN("unregister card finished");
+
+	return 0;
+}
+
+static const struct of_device_id sunxi_card_of_match[] = {
+	{ .compatible = "allwinner,sunxi-codec-machine", },
+	{},
+};
+
+static struct platform_driver sunxi_machine_driver = {
+	.driver = {
+		.name = "sunxi-codec-machine",
+		.owner = THIS_MODULE,
+		.pm = &snd_soc_pm_ops,
+		.of_match_table = sunxi_card_of_match,
+	},
+	.probe = sunxi_card_dev_probe,
+	.remove = __exit_p(sunxi_card_dev_remove),
+};
+
+static int __init sunxi_machine_driver_init(void)
+{
+	return platform_driver_register(&sunxi_machine_driver);
+}
+module_init(sunxi_machine_driver_init);
+
+static void __exit sunxi_machine_driver_exit(void)
+{
+	platform_driver_unregister(&sunxi_machine_driver);
+}
+module_exit(sunxi_machine_driver_exit);
+
+module_param_named(switch_state, switch_state, int, S_IRUGO | S_IWUSR);
+
+MODULE_DESCRIPTION("SUNXI Codec Machine ASoC driver");
+MODULE_AUTHOR("Dby <Dby@allwinnertech.com>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:sunxi-codec-machine");
diff --git a/sound/soc/sunxi/sunxi-daudio.c b/sound/soc/sunxi/sunxi-daudio.c
new file mode 100644
index 000000000..ecd852776
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-daudio.c
@@ -0,0 +1,2281 @@
+/* sound\soc\sunxi\sunxi-daudio.c
+ * (C) Copyright 2019-2025
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * yumingfeng <yumingfeng@allwinnertech.com>
+ * luguofang <luguofang@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/clk.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/regmap.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/regulator/consumer.h>
+#include <linux/delay.h>
+#include <linux/debugfs.h>
+#include <linux/reset.h>
+#include <asm/dma.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+#include <sound/soc-dai.h>
+#include <sound/simple_card.h>
+
+#include "sunxi-daudio.h"
+
+#define	DRV_NAME	"sunxi-daudio"
+
+#ifdef SUNXI_DAUDIO_DEBUG
+static struct daudio_reg_label reg_labels[] = {
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_CTL),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_FMT0),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_FMT1),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_INTSTA),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_FIFOCTL),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_FIFOSTA),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_INTCTL),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_CLKDIV),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_TXCNT),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_RXCNT),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_CHCFG),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_TX0CHSEL),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_TX1CHSEL),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_TX2CHSEL),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_TX3CHSEL),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_TX0CHMAP0),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_TX0CHMAP1),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_TX1CHMAP0),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_TX1CHMAP1),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_TX2CHMAP0),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_TX2CHMAP1),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_TX3CHMAP0),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_TX3CHMAP1),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_RXCHSEL),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_RXCHMAP0),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_RXCHMAP1),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_RXCHMAP2),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_RXCHMAP3),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_DEBUG),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_REV),
+#if IS_ENABLED(CONFIG_SND_SUNXI_SOC_DAUDIO_ASRC)
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_ASRC_MCLKCFG),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_ASRC_FSOUTCFG),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_ASRC_FSIN_EXTCFG),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_ASRC_ASRCEN),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_ASRC_MANCFG),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_ASRC_RATIOSTAT),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_ASRC_FIFOSTAT),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_ASRC_MBISTCFG),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_ASRC_MBISTSTA),
+#endif
+	DAUDIO_REG_LABEL_END,
+};
+
+static ssize_t show_daudio_reg(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct sunxi_daudio_info *sunxi_daudio = dev_get_drvdata(dev);
+	int cnt = 0, i = 0, j = 0;
+	unsigned int reg_val, reg_val_tmp;
+	unsigned int size = ARRAY_SIZE(reg_labels);
+	char *reg_name_play = "REG NAME";
+	char *reg_offset_play = "OFFSET";
+	char *reg_val_play = "VALUE";
+
+	cnt += sprintf(buf + cnt,
+		       "%-30s|%-6s|%-10s"
+		       "|31-28|27-24|23-20|19-16|15-12|11-08|07-04|03-00|"
+		       "save_value\n",
+		       reg_name_play, reg_offset_play, reg_val_play);
+
+	while ((i < size) && (reg_labels[i].name != NULL)) {
+		regmap_read(sunxi_daudio->mem_info.regmap,
+			    reg_labels[i].address, &reg_val);
+
+		cnt += sprintf(buf + cnt,
+			       "%-30s|0x%4x|0x%8x",
+			       reg_labels[i].name,
+			       reg_labels[i].address,
+			       reg_val);
+		for (j = 7; j >= 0; j--) {
+			reg_val_tmp = reg_val >> (j * 4);
+			cnt += sprintf(buf + cnt,
+				       "|%c%c%c%c ",
+				       (((reg_val_tmp) & 0x08ull) ? '1' : '0'),
+				       (((reg_val_tmp) & 0x04ull) ? '1' : '0'),
+				       (((reg_val_tmp) & 0x02ull) ? '1' : '0'),
+				       (((reg_val_tmp) & 0x01ull) ? '1' : '0')
+				       );
+		}
+		cnt += sprintf(buf + cnt, "|0x%8x\n", reg_labels[i].value);
+
+		i++;
+	}
+
+	return cnt;
+}
+
+/* ex:
+ *param 1: 0 read;1 write
+ *param 2: reg value;
+ *param 3: write value;
+	read:
+		echo 0,0x0 > daudio_reg
+	write:
+		echo 1,0x00,0xa > daudio_reg
+*/
+static ssize_t store_daudio_reg(struct device *dev, struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	int ret;
+	int rw_flag;
+	int reg_val_read;
+	unsigned int input_reg_val = 0;
+	unsigned int input_reg_offset = 0;
+	struct sunxi_daudio_info *sunxi_daudio = dev_get_drvdata(dev);
+	struct sunxi_daudio_mem_info *mem_info = NULL;
+	unsigned int res_size = 0;
+
+	if (IS_ERR_OR_NULL(sunxi_daudio)) {
+		dev_err(dev, "sunxi_daudio is NULL!\n");
+		return count;
+	}
+	mem_info = &sunxi_daudio->mem_info;
+	res_size = resource_size(&mem_info->res),
+
+	ret = sscanf(buf, "%d,0x%x,0x%x", &rw_flag, &input_reg_offset,
+			&input_reg_val);
+
+	if (ret == 3 || ret == 2) {
+		if (!(rw_flag == 1 || rw_flag == 0)) {
+			dev_err(dev, "rw_flag should be 0(read) or 1(write).\n");
+			return count;
+		}
+		if (input_reg_offset > res_size) {
+			dev_err(dev, "the reg offset is invalid! [0x0 - 0x%x]\n",
+				res_size);
+			return count;
+		}
+		if (rw_flag) {
+			regmap_write(mem_info->regmap, input_reg_offset,
+					input_reg_val);
+		}
+		regmap_read(mem_info->regmap, input_reg_offset, &reg_val_read);
+		pr_err("Reg[0x%x] : 0x%x\n", input_reg_offset, reg_val_read);
+	} else {
+		pr_err("ret:%d, The num of params invalid!\n", ret);
+		pr_err("\nExample(reg range: 0x0 - 0x%x):\n", res_size);
+		pr_err("\nRead reg[0x04]:\n");
+		pr_err("      echo 0,0x04 > daudio_reg\n");
+		pr_err("Write reg[0x04]=0x10\n");
+		pr_err("      echo 1,0x04,0x10 > daudio_reg\n");
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(daudio_reg, 0644, show_daudio_reg, store_daudio_reg);
+
+static struct attribute *audio_debug_attrs[] = {
+	&dev_attr_daudio_reg.attr,
+	NULL,
+};
+
+static struct attribute_group daudio_debug_attr_group = {
+	.name	= "daudio_debug",
+	.attrs	= audio_debug_attrs,
+};
+#endif
+
+static void sunxi_daudio_global_lock_irqsave(struct sunxi_daudio_info *sunxi_daudio)
+{
+	local_irq_save(sunxi_daudio->global_spinlock.flags);
+	spin_lock(&sunxi_daudio->global_spinlock.lock);
+}
+
+static void sunxi_daudio_global_unlock_irqrestore(struct sunxi_daudio_info *sunxi_daudio)
+{
+	spin_unlock(&sunxi_daudio->global_spinlock.lock);
+	local_irq_restore(sunxi_daudio->global_spinlock.flags);
+}
+
+static int sunxi_daudio_get_hub_mode(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sunxi_daudio_info *sunxi_daudio =
+					snd_soc_component_get_drvdata(component);
+	struct sunxi_daudio_mem_info *mem_info = &sunxi_daudio->mem_info;
+	unsigned int reg_val;
+
+	regmap_read(mem_info->regmap, SUNXI_DAUDIO_FIFOCTL, &reg_val);
+	ucontrol->value.integer.value[0] = ((reg_val & (1 << HUB_EN)) ? 1 : 0);
+
+	return 0;
+}
+
+static int sunxi_daudio_set_hub_mode(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sunxi_daudio_info *sunxi_daudio =
+					snd_soc_component_get_drvdata(component);
+	struct sunxi_daudio_mem_info *mem_info = &sunxi_daudio->mem_info;
+
+	switch (ucontrol->value.integer.value[0]) {
+	case	0:
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_FIFOCTL,
+				(1 << HUB_EN), (0 << HUB_EN));
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_CTL,
+				(1 << CTL_TXEN), (0 << CTL_TXEN));
+		sunxi_daudio->hub_mode = 0;
+		break;
+	case	1:
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_FIFOCTL,
+				(1 << HUB_EN), (1 << HUB_EN));
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_CTL,
+				(1 << CTL_TXEN), (1 << CTL_TXEN));
+		sunxi_daudio->hub_mode = 1;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const char *daudio_format_function[] = {"Disable", "Enable"};
+
+static const struct soc_enum daudio_format_enum[] = {
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(daudio_format_function),
+			daudio_format_function),
+};
+
+#if IS_ENABLED(CONFIG_SND_SUNXI_SOC_DAUDIO_ASRC)
+static int sunxi_daudio_get_asrc_function(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sunxi_daudio_info *sunxi_daudio =
+					snd_soc_component_get_drvdata(component);
+
+	ucontrol->value.integer.value[0] = sunxi_daudio->asrc_function_en;
+
+	return 0;
+}
+
+static int sunxi_daudio_set_asrc_function(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sunxi_daudio_info *sunxi_daudio =
+					snd_soc_component_get_drvdata(component);
+
+	sunxi_daudio->asrc_function_en = ucontrol->value.integer.value[0];
+
+	return 0;
+}
+
+static const char * const daudio_asrc_function[] = {"Disable", "Enable"};
+
+static const struct soc_enum daudio_asrc_function_enum[] = {
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(daudio_asrc_function),
+			daudio_asrc_function),
+};
+#endif
+
+/* dts pcm Audio Mode Select */
+static const struct snd_kcontrol_new sunxi_daudio_controls[] = {
+	SOC_ENUM_EXT("sunxi daudio audio hub mode", daudio_format_enum[0],
+		sunxi_daudio_get_hub_mode, sunxi_daudio_set_hub_mode),
+	SOC_SINGLE("sunxi daudio loopback debug", SUNXI_DAUDIO_CTL,
+		LOOP_EN, 1, 0),
+#if IS_ENABLED(CONFIG_SND_SUNXI_SOC_DAUDIO_ASRC)
+	SOC_ENUM_EXT("sunxi daudio asrc function", daudio_asrc_function_enum[0],
+		sunxi_daudio_get_asrc_function, sunxi_daudio_set_asrc_function),
+#endif
+};
+
+static void sunxi_daudio_txctrl_enable(struct sunxi_daudio_info *sunxi_daudio,
+					bool enable)
+{
+	struct sunxi_daudio_mem_info *mem_info = &sunxi_daudio->mem_info;
+	struct sunxi_daudio_dts_info *dts_info = &sunxi_daudio->dts_info;
+	struct sunxi_daudio_platform_data_info *pdata_info = &dts_info->pdata_info;
+	unsigned int DAUDIO_SDO_MASK = 0;
+	unsigned int reg_val;
+	unsigned int i = 0;
+
+	for (i = 0; i < pdata_info->tx_num; i++)
+		DAUDIO_SDO_MASK |= 0x1 << i;
+
+	if (enable) {
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_INTCTL,
+				(1 << TXDRQEN), (1 << TXDRQEN));
+
+		/* HDMI audio Transmit Clock just enable at startup */
+		if (pdata_info->daudio_type != SUNXI_DAUDIO_HDMIAUDIO_TYPE) {
+			regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_CTL,
+					(DAUDIO_SDO_MASK << SDO0_EN),
+					(DAUDIO_SDO_MASK << SDO0_EN));
+
+			regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_CTL,
+					(1 << CTL_TXEN), (1 << CTL_TXEN));
+		}
+	} else {
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_INTCTL,
+					(1 << TXDRQEN), (0 << TXDRQEN));
+
+		if (pdata_info->daudio_type != SUNXI_DAUDIO_HDMIAUDIO_TYPE) {
+			/* add this to avoid the i2s pop */
+			while (1) {
+				regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_FIFOCTL,
+					(1 << FIFO_CTL_FTX), (1 << FIFO_CTL_FTX));
+				regmap_write(mem_info->regmap,
+						SUNXI_DAUDIO_TXCNT, 0);
+
+				regmap_read(mem_info->regmap,
+						SUNXI_DAUDIO_FIFOSTA, &reg_val);
+				reg_val = ((reg_val & 0xFF0000) >> 16);
+				if (reg_val == 0x80) {
+					break;
+				}
+			}
+			udelay(250);
+
+			regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_CTL,
+					(1 << CTL_TXEN), (0 << CTL_TXEN));
+
+			regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_CTL,
+					(DAUDIO_SDO_MASK << SDO0_EN),
+					(0 << SDO0_EN));
+		}
+	}
+}
+
+static void sunxi_daudio_rxctrl_enable(struct sunxi_daudio_info *sunxi_daudio,
+					bool enable)
+{
+	struct sunxi_daudio_mem_info *mem_info = NULL;
+	struct sunxi_daudio_dts_info *dts_info = NULL;
+	struct sunxi_daudio_platform_data_info *pdata_info = NULL;
+
+	if (IS_ERR_OR_NULL(sunxi_daudio)) {
+		pr_err("[%s] sunxi_daudio is null.\n", __func__);
+		return;
+	}
+	mem_info = &sunxi_daudio->mem_info;
+	dts_info = &sunxi_daudio->dts_info;
+	pdata_info = &dts_info->pdata_info;
+
+	if (enable) {
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_CTL,
+				(1 << CTL_RXEN), (1 << CTL_RXEN));
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_INTCTL,
+				(1 << RXDRQEN), (1 << RXDRQEN));
+	} else {
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_INTCTL,
+				(1 << RXDRQEN), (0 << RXDRQEN));
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_CTL,
+				(1 << CTL_RXEN), (0 << CTL_RXEN));
+	}
+}
+
+static int sunxi_daudio_global_enable(struct sunxi_daudio_info *sunxi_daudio,
+					bool enable)
+{
+	struct sunxi_daudio_mem_info *mem_info = NULL;
+
+	if (IS_ERR_OR_NULL(sunxi_daudio)) {
+		pr_err("[%s] sunxi_daudio is null.\n", __func__);
+		return -ENOMEM;
+	}
+	mem_info = &sunxi_daudio->mem_info;
+
+	sunxi_daudio_global_lock_irqsave(sunxi_daudio);
+	if (enable) {
+		if (sunxi_daudio->global_enable++ == 0)
+			regmap_update_bits(mem_info->regmap,
+				SUNXI_DAUDIO_CTL,
+				(1 << GLOBAL_EN), (1 << GLOBAL_EN));
+	} else {
+		if (--sunxi_daudio->global_enable <= 0) {
+			sunxi_daudio->global_enable = 0;
+			regmap_update_bits(mem_info->regmap,
+				SUNXI_DAUDIO_CTL,
+				(1 << GLOBAL_EN), (0 << GLOBAL_EN));
+		}
+	}
+	sunxi_daudio_global_unlock_irqrestore(sunxi_daudio);
+
+	return 0;
+}
+
+static int sunxi_daudio_mclk_setting(struct sunxi_daudio_info *sunxi_daudio)
+{
+	struct sunxi_daudio_mem_info *mem_info = &sunxi_daudio->mem_info;
+	struct sunxi_daudio_dts_info *dts_info = &sunxi_daudio->dts_info;
+	struct sunxi_daudio_platform_data_info *pdata_info = &dts_info->pdata_info;
+	unsigned int mclk_div;
+
+	if (pdata_info->mclk_div) {
+		switch (pdata_info->mclk_div) {
+		case	1:
+			mclk_div = SUNXI_DAUDIO_MCLK_DIV_1;
+			break;
+		case	2:
+			mclk_div = SUNXI_DAUDIO_MCLK_DIV_2;
+			break;
+		case	4:
+			mclk_div = SUNXI_DAUDIO_MCLK_DIV_3;
+			break;
+		case	6:
+			mclk_div = SUNXI_DAUDIO_MCLK_DIV_4;
+			break;
+		case	8:
+			mclk_div = SUNXI_DAUDIO_MCLK_DIV_5;
+			break;
+		case	12:
+			mclk_div = SUNXI_DAUDIO_MCLK_DIV_6;
+			break;
+		case	16:
+			mclk_div = SUNXI_DAUDIO_MCLK_DIV_7;
+			break;
+		case	24:
+			mclk_div = SUNXI_DAUDIO_MCLK_DIV_8;
+			break;
+		case	32:
+			mclk_div = SUNXI_DAUDIO_MCLK_DIV_9;
+			break;
+		case	48:
+			mclk_div = SUNXI_DAUDIO_MCLK_DIV_10;
+			break;
+		case	64:
+			mclk_div = SUNXI_DAUDIO_MCLK_DIV_11;
+			break;
+		case	96:
+			mclk_div = SUNXI_DAUDIO_MCLK_DIV_12;
+			break;
+		case	128:
+			mclk_div = SUNXI_DAUDIO_MCLK_DIV_13;
+			break;
+		case	176:
+			mclk_div = SUNXI_DAUDIO_MCLK_DIV_14;
+			break;
+		case	192:
+			mclk_div = SUNXI_DAUDIO_MCLK_DIV_15;
+			break;
+		default:
+			dev_err(sunxi_daudio->dev, "unsupport  mclk_div\n");
+			return -EINVAL;
+		}
+
+		/* setting Mclk output as external codec input clk */
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_CLKDIV,
+			(SUNXI_DAUDIO_MCLK_DIV_MASK << MCLK_DIV),
+			(mclk_div << MCLK_DIV));
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_CLKDIV,
+				(1 << MCLKOUT_EN), (1 << MCLKOUT_EN));
+	} else {
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_CLKDIV,
+				(1 << MCLKOUT_EN), (0 << MCLKOUT_EN));
+	}
+
+	return 0;
+}
+
+static int sunxi_daudio_init_fmt(struct sunxi_daudio_info *sunxi_daudio,
+				unsigned int fmt)
+{
+	struct sunxi_daudio_mem_info *mem_info = NULL;
+	unsigned int offset, mode;
+	unsigned int lrck_polarity, brck_polarity;
+
+	if (IS_ERR_OR_NULL(sunxi_daudio)) {
+		pr_err("[%s] sunxi_daudio is null.\n", __func__);
+		return -ENOMEM;
+	}
+	mem_info = &sunxi_daudio->mem_info;
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case	SND_SOC_DAIFMT_CBM_CFM:
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_CTL,
+				(SUNXI_DAUDIO_LRCK_OUT_MASK<<LRCK_OUT),
+				(SUNXI_DAUDIO_LRCK_OUT_DISABLE<<LRCK_OUT));
+		break;
+	case	SND_SOC_DAIFMT_CBS_CFS:
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_CTL,
+				(SUNXI_DAUDIO_LRCK_OUT_MASK<<LRCK_OUT),
+				(SUNXI_DAUDIO_LRCK_OUT_ENABLE<<LRCK_OUT));
+		break;
+	default:
+		dev_err(sunxi_daudio->dev, "unknown maser/slave format\n");
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case	SND_SOC_DAIFMT_I2S:
+		offset = SUNXI_DAUDIO_TX_OFFSET_1;
+		mode = SUNXI_DAUDIO_MODE_CTL_I2S;
+		break;
+	case	SND_SOC_DAIFMT_RIGHT_J:
+		offset = SUNXI_DAUDIO_TX_OFFSET_0;
+		mode = SUNXI_DAUDIO_MODE_CTL_RIGHT;
+		break;
+	case	SND_SOC_DAIFMT_LEFT_J:
+		offset = SUNXI_DAUDIO_TX_OFFSET_0;
+		mode = SUNXI_DAUDIO_MODE_CTL_LEFT;
+		break;
+	case	SND_SOC_DAIFMT_DSP_A:
+		offset = SUNXI_DAUDIO_TX_OFFSET_1;
+		mode = SUNXI_DAUDIO_MODE_CTL_PCM;
+		break;
+	case	SND_SOC_DAIFMT_DSP_B:
+		offset = SUNXI_DAUDIO_TX_OFFSET_0;
+		mode = SUNXI_DAUDIO_MODE_CTL_PCM;
+		break;
+	default:
+		dev_err(sunxi_daudio->dev, "format setting failed\n");
+		return -EINVAL;
+	}
+
+	regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_CTL,
+			(SUNXI_DAUDIO_MODE_CTL_MASK<<MODE_SEL),
+			(mode<<MODE_SEL));
+
+	regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_TX0CHSEL,
+			(SUNXI_DAUDIO_TX_OFFSET_MASK<<TX_OFFSET),
+			(offset<<TX_OFFSET));
+
+	if (sunxi_daudio->hdmi_en) {
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_TX1CHSEL,
+				(SUNXI_DAUDIO_TX_OFFSET_MASK<<TX_OFFSET),
+				(offset<<TX_OFFSET));
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_TX2CHSEL,
+				(SUNXI_DAUDIO_TX_OFFSET_MASK<<TX_OFFSET),
+				(offset<<TX_OFFSET));
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_TX3CHSEL,
+				(SUNXI_DAUDIO_TX_OFFSET_MASK<<TX_OFFSET),
+				(offset<<TX_OFFSET));
+	}
+
+	regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_RXCHSEL,
+			(SUNXI_DAUDIO_RX_OFFSET_MASK<<RX_OFFSET),
+			(offset<<RX_OFFSET));
+
+	/* linux-4.9 kernel: SND_SOC_DAIFMT_NB_NF: 1 */
+	/* linux-5.4 kernel: SND_SOC_DAIFMT_NB_NF: 0 */
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case	SND_SOC_DAIFMT_NB_NF:
+		lrck_polarity = SUNXI_DAUDIO_LRCK_POLARITY_NOR;
+		brck_polarity = SUNXI_DAUDIO_BCLK_POLARITY_NOR;
+		break;
+	case	SND_SOC_DAIFMT_NB_IF:
+		lrck_polarity = SUNXI_DAUDIO_LRCK_POLARITY_INV;
+		brck_polarity = SUNXI_DAUDIO_BCLK_POLARITY_NOR;
+		break;
+	case	SND_SOC_DAIFMT_IB_NF:
+		lrck_polarity = SUNXI_DAUDIO_LRCK_POLARITY_NOR;
+		brck_polarity = SUNXI_DAUDIO_BCLK_POLARITY_INV;
+		break;
+	case	SND_SOC_DAIFMT_IB_IF:
+		lrck_polarity = SUNXI_DAUDIO_LRCK_POLARITY_INV;
+		brck_polarity = SUNXI_DAUDIO_BCLK_POLARITY_INV;
+		break;
+	default:
+		dev_err(sunxi_daudio->dev, "invert clk setting failed!\n");
+		return -EINVAL;
+	}
+
+	if (((fmt & SND_SOC_DAIFMT_FORMAT_MASK) == SND_SOC_DAIFMT_DSP_A) ||
+		((fmt & SND_SOC_DAIFMT_FORMAT_MASK) == SND_SOC_DAIFMT_DSP_B))
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_FMT0,
+				(1<<LRCK_POLARITY), ((lrck_polarity^1)<<LRCK_POLARITY));
+	else
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_FMT0,
+				(1<<LRCK_POLARITY), (lrck_polarity<<LRCK_POLARITY));
+	regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_FMT0,
+			(1<<BRCK_POLARITY), (brck_polarity<<BRCK_POLARITY));
+
+	return 0;
+}
+
+static int sunxi_daudio_init(struct sunxi_daudio_info *sunxi_daudio)
+{
+	struct sunxi_daudio_mem_info *mem_info = &sunxi_daudio->mem_info;
+	struct sunxi_daudio_dts_info *dts_info = &sunxi_daudio->dts_info;
+	struct sunxi_daudio_platform_data_info *pdata_info = &dts_info->pdata_info;
+
+	regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_FMT0,
+			(1 << LRCK_WIDTH),
+			(pdata_info->frame_type << LRCK_WIDTH));
+	regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_FMT0,
+			(SUNXI_DAUDIO_LRCK_PERIOD_MASK) << LRCK_PERIOD,
+			((pdata_info->pcm_lrck_period - 1) << LRCK_PERIOD));
+	regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_FMT0,
+			(SUNXI_DAUDIO_SLOT_WIDTH_MASK << SLOT_WIDTH),
+			(((pdata_info->slot_width_select >> 2) - 1) << SLOT_WIDTH));
+
+	/*
+	 * MSB on the transmit format, always be first.
+	 * default using Linear-PCM, without no companding.
+	 * A-law<Eourpean standard> or U-law<US-Japan> not working ok.
+	 */
+	regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_FMT1,
+			(0x1 <<  TX_MLS),
+			(pdata_info->msb_lsb_first << TX_MLS));
+	regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_FMT1,
+			(0x1 <<  RX_MLS),
+			(pdata_info->msb_lsb_first << RX_MLS));
+	regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_FMT1,
+			(0x3 <<  SEXT),
+			(pdata_info->sign_extend << SEXT));
+	regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_FMT1,
+			(0x3 <<  TX_PDM),
+			(pdata_info->tx_data_mode << TX_PDM));
+	regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_FMT1,
+			(0x3 <<  RX_PDM),
+			(pdata_info->rx_data_mode << RX_PDM));
+
+	if (sunxi_daudio->rx_sync_en) {
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_CTL,
+				(0x1 <<  RX_EN_MUX), (0x1 << RX_PDM));
+	}
+
+	return sunxi_daudio_mclk_setting(sunxi_daudio);
+}
+
+static int sunxi_daudio_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct sunxi_daudio_info *sunxi_daudio = snd_soc_dai_get_drvdata(dai);
+	struct sunxi_daudio_mem_info *mem_info = NULL;
+	struct sunxi_daudio_dts_info *dts_info = NULL;
+	struct sunxi_daudio_platform_data_info *pdata_info = NULL;
+	struct asoc_simple_priv *sndhdmi_priv =
+				snd_soc_card_get_drvdata(dai->component->card);
+
+	if (IS_ERR_OR_NULL(sunxi_daudio)) {
+		dev_err(dai->dev, "[%s] sunxi_daudio is null.\n", __func__);
+		return -ENOMEM;
+	}
+	mem_info = &sunxi_daudio->mem_info;
+	dts_info = &sunxi_daudio->dts_info;
+	pdata_info = &dts_info->pdata_info;
+
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		/*
+		 * Special processing for hdmi, HDMI card name is
+		 * "sndhdmi" or sndhdmiraw. if card not HDMI,
+		 * strstr func just return NULL, jump to right section.
+		 * Not HDMI card, sunxi_hdmi maybe a NULL pointer.
+		 */
+		if (pdata_info->daudio_type == SUNXI_DAUDIO_HDMIAUDIO_TYPE &&
+					(sndhdmi_priv->hdmi_format > 1)) {
+			regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_FMT0,
+				(SUNXI_DAUDIO_SR_MASK<<DAUDIO_SAMPLE_RESOLUTION),
+				(SUNXI_DAUDIO_SR_24BIT<<DAUDIO_SAMPLE_RESOLUTION));
+			regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_FIFOCTL,
+				(SUNXI_DAUDIO_TXIM_MASK<<TXIM),
+				(SUNXI_DAUDIO_TXIM_VALID_MSB<<TXIM));
+		} else {
+			regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_FMT0,
+				(SUNXI_DAUDIO_SR_MASK << DAUDIO_SAMPLE_RESOLUTION),
+				(SUNXI_DAUDIO_SR_16BIT << DAUDIO_SAMPLE_RESOLUTION));
+			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+				regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_FIFOCTL,
+					(SUNXI_DAUDIO_TXIM_MASK << TXIM),
+					(SUNXI_DAUDIO_TXIM_VALID_LSB << TXIM));
+			} else {
+				regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_FIFOCTL,
+					(SUNXI_DAUDIO_RXOM_MASK << RXOM),
+					(SUNXI_DAUDIO_RXOM_EXPH << RXOM));
+			}
+		}
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+	case SNDRV_PCM_FORMAT_S24_LE:
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_FMT0,
+			(SUNXI_DAUDIO_SR_MASK << DAUDIO_SAMPLE_RESOLUTION),
+			(SUNXI_DAUDIO_SR_24BIT << DAUDIO_SAMPLE_RESOLUTION));
+
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_FIFOCTL,
+					(SUNXI_DAUDIO_TXIM_MASK << TXIM),
+					(SUNXI_DAUDIO_TXIM_VALID_LSB << TXIM));
+		} else {
+			regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_FIFOCTL,
+					(SUNXI_DAUDIO_RXOM_MASK << RXOM),
+					(SUNXI_DAUDIO_RXOM_EXPH << RXOM));
+		}
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_FMT0,
+			(SUNXI_DAUDIO_SR_MASK << DAUDIO_SAMPLE_RESOLUTION),
+			(SUNXI_DAUDIO_SR_32BIT << DAUDIO_SAMPLE_RESOLUTION));
+
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_FIFOCTL,
+					(SUNXI_DAUDIO_TXIM_MASK << TXIM),
+					(SUNXI_DAUDIO_TXIM_VALID_LSB << TXIM));
+		} else {
+			regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_FIFOCTL,
+					(SUNXI_DAUDIO_RXOM_MASK << RXOM),
+					(SUNXI_DAUDIO_RXOM_EXPH << RXOM));
+		}
+		break;
+	default:
+		dev_err(sunxi_daudio->dev, "unrecognized format\n");
+		return -EINVAL;
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		unsigned int SUNXI_DAUDIO_TXCHMAP0 = 0;
+		unsigned int SUNXI_DAUDIO_TXCHMAP1 = 0;
+		unsigned int SUNXI_DAUDIO_TXCHSEL = 0;
+		int index = 0;
+
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_CHCFG,
+				(SUNXI_DAUDIO_TX_SLOT_MASK << TX_SLOT_NUM),
+				((params_channels(params)-1) << TX_SLOT_NUM));
+
+		if (sunxi_daudio->hdmi_en == 0) {
+
+		for (index = 0; index < pdata_info->tx_num; index++) {
+			switch (index) {
+			case 0:
+				SUNXI_DAUDIO_TXCHMAP0 = SUNXI_DAUDIO_TX0CHMAP0;
+				SUNXI_DAUDIO_TXCHMAP1 = SUNXI_DAUDIO_TX0CHMAP1;
+				SUNXI_DAUDIO_TXCHSEL = SUNXI_DAUDIO_TX0CHSEL;
+			break;
+			case 1:
+				SUNXI_DAUDIO_TXCHMAP0 = SUNXI_DAUDIO_TX1CHMAP0;
+				SUNXI_DAUDIO_TXCHMAP1 = SUNXI_DAUDIO_TX1CHMAP1;
+				SUNXI_DAUDIO_TXCHSEL = SUNXI_DAUDIO_TX1CHSEL;
+			break;
+			case 2:
+				SUNXI_DAUDIO_TXCHMAP0 = SUNXI_DAUDIO_TX2CHMAP0;
+				SUNXI_DAUDIO_TXCHMAP1 = SUNXI_DAUDIO_TX2CHMAP1;
+				SUNXI_DAUDIO_TXCHSEL = SUNXI_DAUDIO_TX2CHSEL;
+			break;
+			case 3:
+				SUNXI_DAUDIO_TXCHMAP0 = SUNXI_DAUDIO_TX3CHMAP0;
+				SUNXI_DAUDIO_TXCHMAP1 = SUNXI_DAUDIO_TX3CHMAP1;
+				SUNXI_DAUDIO_TXCHSEL = SUNXI_DAUDIO_TX3CHSEL;
+			break;
+			default:
+				dev_err(sunxi_daudio->dev, "tx_num %d error.\n",
+						pdata_info->tx_num);
+			break;
+			}
+			regmap_write(mem_info->regmap,
+				SUNXI_DAUDIO_TXCHMAP0, pdata_info->tx_chmap0);
+			regmap_write(mem_info->regmap,
+				SUNXI_DAUDIO_TXCHMAP1, pdata_info->tx_chmap1);
+			regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_TXCHSEL,
+				(SUNXI_DAUDIO_TX_CHSEL_MASK << TX_CHSEL),
+				((params_channels(params)-1) << TX_CHSEL));
+			regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_TXCHSEL,
+				(SUNXI_DAUDIO_TX_CHEN_MASK << TX_CHEN),
+				((1<<params_channels(params))-1) << TX_CHEN);
+		}
+
+		} else {
+		/* HDMI multi-channel processing */
+			regmap_write(mem_info->regmap,
+					SUNXI_DAUDIO_TX0CHMAP1, 0x10);
+			if (sndhdmi_priv->hdmi_format > 1) {
+				regmap_write(mem_info->regmap,
+						SUNXI_DAUDIO_TX1CHMAP1, 0x32);
+				regmap_write(mem_info->regmap,
+						SUNXI_DAUDIO_TX2CHMAP1, 0x54);
+				regmap_write(mem_info->regmap,
+						SUNXI_DAUDIO_TX3CHMAP1, 0x76);
+			} else {
+				if (params_channels(params) > 2)
+					regmap_write(mem_info->regmap,
+						SUNXI_DAUDIO_TX1CHMAP1, 0x23);
+				if (params_channels(params) > 4) {
+					if (params_channels(params) == 6)
+						regmap_write(
+							mem_info->regmap,
+							SUNXI_DAUDIO_TX2CHMAP1,
+							0x54);
+					else
+						regmap_write(
+							mem_info->regmap,
+							SUNXI_DAUDIO_TX2CHMAP1,
+							0x76);
+				}
+				if (params_channels(params) > 6)
+					regmap_write(mem_info->regmap,
+							SUNXI_DAUDIO_TX3CHMAP1,
+							0x54);
+			}
+
+			regmap_update_bits(mem_info->regmap,
+					SUNXI_DAUDIO_TX0CHSEL,
+					0x01 << TX_CHSEL, 0x01 << TX_CHSEL);
+			regmap_update_bits(mem_info->regmap,
+					SUNXI_DAUDIO_TX0CHSEL,
+					0x03 << TX_CHEN, 0x03 << TX_CHEN);
+			regmap_update_bits(mem_info->regmap,
+					SUNXI_DAUDIO_TX1CHSEL,
+					0x01 << TX_CHSEL, 0x01 << TX_CHSEL);
+			regmap_update_bits(mem_info->regmap,
+					SUNXI_DAUDIO_TX1CHSEL,
+					(0x03)<<TX_CHEN, 0x03 << TX_CHEN);
+			regmap_update_bits(mem_info->regmap,
+					SUNXI_DAUDIO_TX2CHSEL,
+					0x01 << TX_CHSEL, 0x01 << TX_CHSEL);
+			regmap_update_bits(mem_info->regmap,
+					SUNXI_DAUDIO_TX2CHSEL,
+					(0x03)<<TX_CHEN, 0x03 << TX_CHEN);
+			regmap_update_bits(mem_info->regmap,
+					SUNXI_DAUDIO_TX3CHSEL,
+					0x01 << TX_CHSEL, 0x01 << TX_CHSEL);
+			regmap_update_bits(mem_info->regmap,
+					SUNXI_DAUDIO_TX3CHSEL,
+					(0x03)<<TX_CHEN, 0x03 << TX_CHEN);
+/* HDMI */
+		}
+	} else {
+		unsigned int SUNXI_DAUDIO_RXCHMAPX = 0;
+		unsigned int SUNXI_DAUDIO_RXCHMAP_VAL = 0;
+		int index = 0;
+
+		for (index = 0; index < pdata_info->rx_num; index++) {
+			switch (index) {
+			case 0:
+				SUNXI_DAUDIO_RXCHMAPX = SUNXI_DAUDIO_RXCHMAP0;
+				SUNXI_DAUDIO_RXCHMAP_VAL = pdata_info->rx_chmap0;
+			break;
+			case 1:
+				SUNXI_DAUDIO_RXCHMAPX = SUNXI_DAUDIO_RXCHMAP1;
+				SUNXI_DAUDIO_RXCHMAP_VAL = pdata_info->rx_chmap1;
+			break;
+			case 2:
+				SUNXI_DAUDIO_RXCHMAPX = SUNXI_DAUDIO_RXCHMAP2;
+				SUNXI_DAUDIO_RXCHMAP_VAL = pdata_info->rx_chmap2;
+			break;
+			case 3:
+				SUNXI_DAUDIO_RXCHMAPX = SUNXI_DAUDIO_RXCHMAP3;
+				SUNXI_DAUDIO_RXCHMAP_VAL = pdata_info->rx_chmap3;
+			break;
+			default:
+				dev_err(sunxi_daudio->dev, "rx_num %d error.\n",
+						pdata_info->rx_num);
+			break;
+			}
+			regmap_write(mem_info->regmap, SUNXI_DAUDIO_RXCHMAPX,
+					SUNXI_DAUDIO_RXCHMAP_VAL);
+		}
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_CHCFG,
+				(SUNXI_DAUDIO_RX_SLOT_MASK << RX_SLOT_NUM),
+				((params_channels(params)-1) << RX_SLOT_NUM));
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_RXCHSEL,
+				(SUNXI_DAUDIO_RX_CHSEL_MASK << RX_CHSEL),
+				((params_channels(params)-1) << RX_CHSEL));
+	}
+
+	/* Special processing for HDMI hub playback to enable hdmi module */
+	if (pdata_info->daudio_type == SUNXI_DAUDIO_HDMIAUDIO_TYPE) {
+		if (sunxi_daudio->hub_mode) {
+			sunxi_hdmi_codec_hw_params(substream, params, NULL);
+			sunxi_hdmi_codec_prepare(substream, NULL);
+		}
+	}
+
+#if IS_ENABLED(CONFIG_SND_SUNXI_SOC_DAUDIO_ASRC)
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		if (sunxi_daudio->asrc_function_en) {
+		pr_warn("set asrc params\n");
+		/* 0x80 */
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_ASRC_MCLKCFG,
+					(0x1 << DAUDIO_ASRC_MCLK_GATE),
+					(0x1 << DAUDIO_ASRC_MCLK_GATE));
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_ASRC_MCLKCFG,
+					(0xFFFF << DAUDIO_ASRC_MCLK_RATIO),
+					(0x1 << DAUDIO_ASRC_MCLK_RATIO));
+		/* 0x84 */
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_ASRC_FSOUTCFG,
+					(0x1 << DAUDIO_ASRC_FSOUT_GATE),
+					(0x1 << DAUDIO_ASRC_FSOUT_GATE));
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_ASRC_FSOUTCFG,
+					(0xF << DAUDIO_ASRC_FSOUT_CLKSRC),
+					(0x0 << DAUDIO_ASRC_FSOUT_CLKSRC));
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_ASRC_FSOUTCFG,
+					(0xF << DAUDIO_ASRC_FSOUT_CLKDIV1),
+//					(0xD << DAUDIO_ASRC_FSOUT_CLKDIV1));
+					(0xF << DAUDIO_ASRC_FSOUT_CLKDIV1));
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_ASRC_FSOUTCFG,
+					(0xF << DAUDIO_ASRC_FSOUT_CLKDIV2),
+					(0xA << DAUDIO_ASRC_FSOUT_CLKDIV2));
+		/* 0x88 */
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_ASRC_FSIN_EXTCFG,
+			(0x1 << DAUDIO_ASRC_FSIN_EXTEN),
+			(0x1 << DAUDIO_ASRC_FSIN_EXTEN));
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_ASRC_FSIN_EXTCFG,
+			(0xFF << DAUDIO_ASRC_FSIN_EXTCYCLE),
+			(0xA << DAUDIO_ASRC_FSIN_EXTCYCLE));
+		/* 0x90 */
+		regmap_write(mem_info->regmap, SUNXI_DAUDIO_ASRC_MANCFG, 0);
+#if 0
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_ASRC_MANCFG,
+			(0x1 << DAUDIO_ASRC_MANRATIOEN),
+			(0x0 << DAUDIO_ASRC_MANRATIOEN));
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_ASRC_MANCFG,
+			(0x3FFFFFF << DAUDIO_ASRC_MAN_RATIO),
+			(0x155555 << DAUDIO_ASRC_MAN_RATIO));
+#endif
+		/* 0x8C */
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_ASRC_ASRCEN,
+			(0x1 << DAUDIO_ASRC_ASRCEN),
+			(0x1 << DAUDIO_ASRC_ASRCEN));
+		} else {
+		/* 0x8C */
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_ASRC_ASRCEN,
+			(0x1 << DAUDIO_ASRC_ASRCEN),
+			(0x0 << DAUDIO_ASRC_ASRCEN));
+		}
+	}
+#endif
+
+	return 0;
+}
+
+static int sunxi_daudio_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+{
+	struct sunxi_daudio_info *sunxi_daudio = snd_soc_dai_get_drvdata(dai);
+
+	sunxi_daudio_init_fmt(sunxi_daudio, fmt);
+
+	return 0;
+}
+
+static int sunxi_daudio_set_sysclk(struct snd_soc_dai *dai,
+			int clk_id, unsigned int freq, int dir)
+{
+	struct sunxi_daudio_info *sunxi_daudio = snd_soc_dai_get_drvdata(dai);
+	struct sunxi_daudio_clk_info *clk_info = NULL;
+
+	if (IS_ERR_OR_NULL(sunxi_daudio)) {
+		dev_err(dai->dev, "[%s] sunxi_daudio is null.\n", __func__);
+		return -ENOMEM;
+	}
+	clk_info = &sunxi_daudio->clk_info;
+
+	switch (clk_info->clk_parent) {
+	case DAUDIO_CLK_PLL_AUDIO_X1:
+		if (clk_set_rate(clk_info->clk_pll, freq)) {
+			dev_err(sunxi_daudio->dev, "Freq : %u not support\n", freq);
+			return -EINVAL;
+		}
+		break;
+	default:
+	case DAUDIO_CLK_PLL_AUDIO_X4:
+		if (clk_set_rate(clk_info->clk_pll, freq * 4)) {
+			dev_err(sunxi_daudio->dev, "Freq : %u not support\n", freq * 4);
+			return -EINVAL;
+		}
+		break;
+	}
+
+	if (clk_set_rate(clk_info->clk_module, freq)) {
+		dev_err(sunxi_daudio->dev, "Freq : %u not support\n", freq);
+		return -EINVAL;
+	}
+
+#if IS_ENABLED(CONFIG_SND_SUNXI_SOC_DAUDIO_ASRC)
+	/* set the asrc clk to 98MHz */
+	if (clk_set_rate(clk_info->clk_asrc, 98304000)) {
+		dev_err(sunxi_daudio->dev, "asrc clk set the freq: %d failed!\n", freq);
+		return -EINVAL;
+	}
+#endif
+
+	return 0;
+}
+
+static int sunxi_daudio_set_clkdiv(struct snd_soc_dai *dai,
+				int clk_id, int clk_div)
+{
+	struct sunxi_daudio_info *sunxi_daudio = snd_soc_dai_get_drvdata(dai);
+	struct sunxi_daudio_mem_info *mem_info = NULL;
+	struct sunxi_daudio_dts_info *dts_info = NULL;
+	struct sunxi_daudio_platform_data_info *pdata_info = NULL;
+	unsigned int bclk_div, div_ratio;
+
+	if (IS_ERR_OR_NULL(sunxi_daudio)) {
+		dev_err(dai->dev, "[%s] sunxi_daudio is null.\n", __func__);
+		return -ENOMEM;
+	}
+	mem_info = &sunxi_daudio->mem_info;
+	dts_info = &sunxi_daudio->dts_info;
+	pdata_info = &dts_info->pdata_info;
+
+	if (pdata_info->tdm_config)
+		/* I2S/TDM two channel mode */
+		div_ratio = clk_div/(2 * pdata_info->pcm_lrck_period);
+	else
+		/* PCM mode */
+		div_ratio = clk_div / pdata_info->pcm_lrck_period;
+
+	switch (div_ratio) {
+	case	1:
+		bclk_div = SUNXI_DAUDIO_BCLK_DIV_1;
+		break;
+	case	2:
+		bclk_div = SUNXI_DAUDIO_BCLK_DIV_2;
+		break;
+	case	4:
+		bclk_div = SUNXI_DAUDIO_BCLK_DIV_3;
+		break;
+	case	6:
+		bclk_div = SUNXI_DAUDIO_BCLK_DIV_4;
+		break;
+	case	8:
+		bclk_div = SUNXI_DAUDIO_BCLK_DIV_5;
+		break;
+	case	12:
+		bclk_div = SUNXI_DAUDIO_BCLK_DIV_6;
+		break;
+	case	16:
+		bclk_div = SUNXI_DAUDIO_BCLK_DIV_7;
+		break;
+	case	24:
+		bclk_div = SUNXI_DAUDIO_BCLK_DIV_8;
+		break;
+	case	32:
+		bclk_div = SUNXI_DAUDIO_BCLK_DIV_9;
+		break;
+	case	48:
+		bclk_div = SUNXI_DAUDIO_BCLK_DIV_10;
+		break;
+	case	64:
+		bclk_div = SUNXI_DAUDIO_BCLK_DIV_11;
+		break;
+	case	96:
+		bclk_div = SUNXI_DAUDIO_BCLK_DIV_12;
+		break;
+	case	128:
+		bclk_div = SUNXI_DAUDIO_BCLK_DIV_13;
+		break;
+	case	176:
+		bclk_div = SUNXI_DAUDIO_BCLK_DIV_14;
+		break;
+	case	192:
+		bclk_div = SUNXI_DAUDIO_BCLK_DIV_15;
+		break;
+	default:
+		dev_err(sunxi_daudio->dev, "unsupport clk_div\n");
+		return -EINVAL;
+	}
+	/* setting bclk to driver external codec bit clk */
+	regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_CLKDIV,
+			(SUNXI_DAUDIO_BCLK_DIV_MASK << BCLK_DIV),
+			(bclk_div << BCLK_DIV));
+
+	return 0;
+}
+
+static void sunxi_rx_sync_daudio_rx_enable(void *data, bool enable)
+{
+	struct snd_soc_dai *dai = data;
+	struct sunxi_daudio_info *sunxi_daudio = snd_soc_dai_get_drvdata(dai);
+	struct sunxi_daudio_mem_info *mem_info = NULL;
+
+	mem_info = &sunxi_daudio->mem_info;
+	if (enable)
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_CTL,
+			(0x1 << RX_SYNC_EN), (0x1 << RX_SYNC_EN));
+	else
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_CTL,
+			(0x1 << RX_SYNC_EN), (0x0 << RX_SYNC_EN));
+
+}
+
+static int sunxi_daudio_dai_startup(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	struct sunxi_daudio_info *sunxi_daudio = snd_soc_dai_get_drvdata(dai);
+	struct sunxi_daudio_mem_info *mem_info = NULL;
+	struct sunxi_daudio_dts_info *dts_info = NULL;
+	struct sunxi_daudio_platform_data_info *pdata_info = NULL;
+
+	if (IS_ERR_OR_NULL(sunxi_daudio)) {
+		dev_err(dai->dev, "[%s] sunxi_daudio is NULL!\n", __func__);
+		return -ENOMEM;
+	}
+	mem_info = &sunxi_daudio->mem_info;
+	dts_info = &sunxi_daudio->dts_info;
+	pdata_info = &dts_info->pdata_info;
+
+	/* FIXME: As HDMI module to play audio, it need at least 1100ms to sync.
+	 * if we not wait we lost audio data to playback, or we wait for 1100ms
+	 * to playback, user experience worst than you can imagine. So we need
+	 * to cutdown that sync time by keeping clock signal on. we just enable
+	 * it at startup and resume, cutdown it at remove and suspend time.
+	 */
+	if (pdata_info->daudio_type == SUNXI_DAUDIO_HDMIAUDIO_TYPE) {
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_CTL,
+				(1<<CTL_TXEN), (1<<CTL_TXEN));
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		snd_soc_dai_set_dma_data(dai, substream,
+					&sunxi_daudio->playback_dma_param);
+	} else {
+		snd_soc_dai_set_dma_data(dai, substream,
+					&sunxi_daudio->capture_dma_param);
+		if (sunxi_daudio->rx_sync_en) {
+			sunxi_rx_sync_startup((void *)dai,
+					sunxi_daudio->rx_sync_domain,
+					sunxi_daudio->rx_sync_id,
+					sunxi_rx_sync_daudio_rx_enable);
+		}
+	}
+
+	return 0;
+}
+
+static int sunxi_daudio_trigger(struct snd_pcm_substream *substream,
+				int cmd, struct snd_soc_dai *dai)
+{
+	struct sunxi_daudio_info *sunxi_daudio = snd_soc_dai_get_drvdata(dai);
+	struct sunxi_daudio_dts_info *dts_info = &sunxi_daudio->dts_info;
+	struct sunxi_daudio_platform_data_info *pdata_info = &dts_info->pdata_info;
+
+	switch (cmd) {
+	case	SNDRV_PCM_TRIGGER_START:
+	case	SNDRV_PCM_TRIGGER_RESUME:
+	case	SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			/* Global enable I2S/TDM module */
+			if ((pdata_info->daudio_type != SUNXI_DAUDIO_HDMIAUDIO_TYPE)
+					&& (!sunxi_daudio->playback_en)) {
+				sunxi_daudio_global_enable(sunxi_daudio, true);
+				sunxi_daudio->playback_en = 1;
+			}
+			sunxi_daudio_txctrl_enable(sunxi_daudio, true);
+		} else {
+			if (pdata_info->daudio_type != SUNXI_DAUDIO_HDMIAUDIO_TYPE)
+				sunxi_daudio_global_enable(sunxi_daudio, true);
+			sunxi_daudio_rxctrl_enable(sunxi_daudio, true);
+			if (sunxi_daudio->rx_sync_en) {
+				sunxi_rx_sync_control(sunxi_daudio->rx_sync_domain,
+					sunxi_daudio->rx_sync_id, true);
+			}
+		}
+		break;
+	case	SNDRV_PCM_TRIGGER_STOP:
+	case	SNDRV_PCM_TRIGGER_SUSPEND:
+	case	SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			/* Global enable I2S/TDM module */
+			if ((pdata_info->daudio_type != SUNXI_DAUDIO_HDMIAUDIO_TYPE)
+					&& (sunxi_daudio->playback_en)) {
+				sunxi_daudio_global_enable(sunxi_daudio, false);
+				sunxi_daudio->playback_en = 0;
+			}
+			sunxi_daudio_txctrl_enable(sunxi_daudio, false);
+		} else {
+			if (pdata_info->daudio_type != SUNXI_DAUDIO_HDMIAUDIO_TYPE) {
+				sunxi_daudio_global_enable(sunxi_daudio, false);
+				sunxi_daudio_rxctrl_enable(sunxi_daudio, false);
+			} else {
+				sunxi_daudio_rxctrl_enable(sunxi_daudio, false);
+			}
+			if (sunxi_daudio->rx_sync_en) {
+				sunxi_rx_sync_control(sunxi_daudio->rx_sync_domain,
+					sunxi_daudio->rx_sync_id, false);
+			}
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sunxi_daudio_prepare(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	unsigned int i;
+	struct sunxi_daudio_info *sunxi_daudio = snd_soc_dai_get_drvdata(dai);
+	struct sunxi_daudio_mem_info *mem_info = NULL;
+	struct sunxi_daudio_dts_info *dts_info = NULL;
+	struct sunxi_daudio_platform_data_info *pdata_info = NULL;
+
+	if (IS_ERR_OR_NULL(sunxi_daudio)) {
+		dev_err(dai->dev, "[%s] sunxi_daudio is null.\n", __func__);
+		return -ENOMEM;
+	}
+	mem_info = &sunxi_daudio->mem_info;
+	dts_info = &sunxi_daudio->dts_info;
+	pdata_info = &dts_info->pdata_info;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		for (i = 0 ; i < SUNXI_DAUDIO_FTX_TIMES ; i++) {
+			regmap_update_bits(mem_info->regmap,
+				SUNXI_DAUDIO_FIFOCTL,
+				(1<<FIFO_CTL_FTX), (1<<FIFO_CTL_FTX));
+			mdelay(1);
+		}
+		regmap_write(mem_info->regmap, SUNXI_DAUDIO_TXCNT, 0);
+
+		if (sunxi_daudio->hub_mode &&
+			(pdata_info->daudio_type != SUNXI_DAUDIO_HDMIAUDIO_TYPE)) {
+			unsigned int DAUDIO_SDO_MASK = 0;
+			for (i = 0; i < pdata_info->tx_num; i++)
+				DAUDIO_SDO_MASK |= 0x1 << i;
+			regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_CTL,
+					(DAUDIO_SDO_MASK << SDO0_EN),
+					(DAUDIO_SDO_MASK << SDO0_EN));
+			regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_CTL,
+					(1 << CTL_TXEN), (1 << CTL_TXEN));
+			sunxi_daudio_global_enable(sunxi_daudio, true);
+			sunxi_daudio->playback_en = 1;
+		}
+	} else {
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_FIFOCTL,
+				(1<<FIFO_CTL_FRX), (1<<FIFO_CTL_FRX));
+		regmap_write(mem_info->regmap, SUNXI_DAUDIO_RXCNT, 0);
+	}
+
+	return 0;
+}
+
+static int sunxi_daudio_probe(struct snd_soc_dai *dai)
+{
+	struct sunxi_daudio_info *sunxi_daudio = snd_soc_dai_get_drvdata(dai);
+
+	/* pcm_new will using the dma_param about the cma and fifo params. */
+	snd_soc_dai_init_dma_data(dai, &sunxi_daudio->playback_dma_param,
+				&sunxi_daudio->capture_dma_param);
+
+	sunxi_daudio_init(sunxi_daudio);
+
+	return 0;
+}
+
+static void sunxi_daudio_shutdown(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	struct sunxi_daudio_info *sunxi_daudio = snd_soc_dai_get_drvdata(dai);
+	struct sunxi_daudio_mem_info *mem_info = &sunxi_daudio->mem_info;
+	struct sunxi_daudio_dts_info *dts_info = &sunxi_daudio->dts_info;
+	struct sunxi_daudio_platform_data_info *pdata_info = &dts_info->pdata_info;
+
+	/* Special processing for HDMI hub playback to shutdown hdmi module */
+	if (pdata_info->daudio_type == SUNXI_DAUDIO_HDMIAUDIO_TYPE) {
+		if (sunxi_daudio->hub_mode) {
+			sunxi_hdmi_codec_shutdown(substream, NULL);
+		}
+	} else if ((substream->stream == SNDRV_PCM_STREAM_PLAYBACK) &&
+		(sunxi_daudio->hub_mode)) {
+		unsigned int i = 0;
+		unsigned int DAUDIO_SDO_MASK = 0;
+		for (i = 0; i < pdata_info->tx_num; i++)
+			DAUDIO_SDO_MASK |= 0x1 << i;
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_CTL,
+				(DAUDIO_SDO_MASK << SDO0_EN) | (1 << CTL_TXEN),
+				(0 << SDO0_EN) | (0 << CTL_TXEN));
+		if (sunxi_daudio->playback_en) {
+			sunxi_daudio_global_enable(sunxi_daudio, false);
+			sunxi_daudio->playback_en = 0;
+		}
+
+		return;
+	}
+
+	if ((substream->stream == SNDRV_PCM_STREAM_CAPTURE) &&
+			(sunxi_daudio->rx_sync_en)) {
+		sunxi_rx_sync_shutdown(sunxi_daudio->rx_sync_domain,
+				sunxi_daudio->rx_sync_id);
+	}
+}
+
+static int sunxi_daudio_remove(struct snd_soc_dai *dai)
+{
+	struct sunxi_daudio_info *sunxi_daudio = snd_soc_dai_get_drvdata(dai);
+	struct sunxi_daudio_mem_info *mem_info = &sunxi_daudio->mem_info;
+	struct sunxi_daudio_dts_info *dts_info = &sunxi_daudio->dts_info;
+	struct sunxi_daudio_platform_data_info *pdata_info = &dts_info->pdata_info;
+
+	if (pdata_info->daudio_type == SUNXI_DAUDIO_HDMIAUDIO_TYPE)
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_CTL,
+				(1<<CTL_TXEN), (0<<CTL_TXEN));
+
+	return 0;
+}
+
+static int sunxi_daudio_suspend(struct snd_soc_dai *dai)
+{
+	struct sunxi_daudio_info *sunxi_daudio = snd_soc_dai_get_drvdata(dai);
+	struct sunxi_daudio_mem_info *mem_info = &sunxi_daudio->mem_info;
+	struct sunxi_daudio_clk_info *clk_info = &sunxi_daudio->clk_info;
+	struct sunxi_daudio_pinctl_info *pin_info = &sunxi_daudio->pin_info;
+	struct sunxi_daudio_dts_info *dts_info = &sunxi_daudio->dts_info;
+	struct sunxi_daudio_platform_data_info *pdata_info = &dts_info->pdata_info;
+	struct sunxi_daudio_regulator_info *regulator_info = &sunxi_daudio->regulator_info;
+	unsigned int res_size = 0;
+	int i = 0;
+
+	pr_debug("[daudio] suspend .%s start\n", dev_name(sunxi_daudio->dev));
+	if (pdata_info->daudio_type == SUNXI_DAUDIO_HDMIAUDIO_TYPE) {
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_CTL,
+				(1<<SDO0_EN), (0<<SDO0_EN));
+		if (sunxi_daudio->hdmi_en) {
+			regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_CTL,
+					(1<<SDO1_EN), (0<<SDO1_EN));
+			regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_CTL,
+					(1<<SDO2_EN), (0<<SDO2_EN));
+			regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_CTL,
+					(1<<SDO3_EN), (0<<SDO3_EN));
+		}
+		/* Global enable I2S/TDM module */
+		sunxi_daudio_global_enable(sunxi_daudio, false);
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_CTL,
+				(1<<CTL_TXEN), (0<<CTL_TXEN));
+	}
+
+	res_size = resource_size(&mem_info->res);
+	sunxi_daudio->reg_label =
+		kzalloc(sizeof(struct daudio_label) * res_size, GFP_KERNEL);
+	if (!IS_ERR_OR_NULL(sunxi_daudio->reg_label)) {
+		/* for save daudio reg */
+		for (i = 0; i <= res_size; i++) {
+			regmap_read(mem_info->regmap, i << 2,
+					&((sunxi_daudio->reg_label+i)->value));
+		}
+	}
+
+	clk_disable_unprepare(clk_info->clk_module);
+	clk_disable_unprepare(clk_info->clk_pll);
+	clk_disable_unprepare(clk_info->clk_bus);
+	reset_control_assert(clk_info->clk_rst);
+
+	if (pin_info->pinctrl_used) {
+		pinctrl_select_state(pin_info->pinctrl, pin_info->pinstate_sleep);
+	}
+
+	if (!IS_ERR_OR_NULL(regulator_info->daudio_regulator))
+		regulator_disable(regulator_info->daudio_regulator);
+
+	pr_debug("[daudio] suspend .%s end \n", dev_name(sunxi_daudio->dev));
+
+	return 0;
+}
+
+static int sunxi_daudio_resume(struct snd_soc_dai *dai)
+{
+	struct sunxi_daudio_info *sunxi_daudio = snd_soc_dai_get_drvdata(dai);
+	struct sunxi_daudio_mem_info *mem_info = &sunxi_daudio->mem_info;
+	struct sunxi_daudio_clk_info *clk_info = &sunxi_daudio->clk_info;
+	struct sunxi_daudio_pinctl_info *pin_info = &sunxi_daudio->pin_info;
+	struct sunxi_daudio_dts_info *dts_info = &sunxi_daudio->dts_info;
+	struct sunxi_daudio_platform_data_info *pdata_info = &dts_info->pdata_info;
+	struct sunxi_daudio_regulator_info *regulator_info = &sunxi_daudio->regulator_info;
+	unsigned int res_size = 0;
+	int ret;
+	int i = 0;
+
+	pr_debug("[%s] resume .%s start\n", __func__,
+			dev_name(sunxi_daudio->dev));
+
+	if (!IS_ERR_OR_NULL(regulator_info->daudio_regulator)) {
+		ret = regulator_enable(regulator_info->daudio_regulator);
+		if (ret < 0) {
+			dev_err(sunxi_daudio->dev,
+				"resume enable duaido vcc-pin failed\n");
+				goto err_resume_regulator_enable;
+		}
+	}
+
+	if (reset_control_deassert(clk_info->clk_rst)) {
+		pr_err("daudio: resume deassert the daudio reset failed\n");
+		return -EINVAL;
+	}
+	ret = clk_prepare_enable(clk_info->clk_bus);
+	if (ret < 0) {
+		dev_err(sunxi_daudio->dev, "enable daudio bus clk failed, resume exit\n");
+		goto err_resume_clk_enable_bus;
+	}
+	ret = clk_prepare_enable(clk_info->clk_pll);
+	if (ret < 0) {
+		dev_err(sunxi_daudio->dev, "pllclk resume failed\n");
+		ret = -EBUSY;
+		goto err_resume_clk_pll_enable;
+	}
+	ret = clk_prepare_enable(clk_info->clk_module);
+	if (ret < 0) {
+		dev_err(sunxi_daudio->dev, "moduleclk resume failed\n");
+		ret = -EBUSY;
+		goto err_resume_clk_module_enable;
+	}
+
+	if (pin_info->pinctrl_used) {
+		ret = pinctrl_select_state(pin_info->pinctrl,
+					pin_info->pinstate);
+		if (ret < 0) {
+			dev_warn(sunxi_daudio->dev,
+				"daudio set pinctrl default state fail\n");
+			goto err_resume_pin_select_default;
+		}
+	}
+
+	sunxi_daudio_init(sunxi_daudio);
+
+	res_size = resource_size(&mem_info->res);
+	if (!IS_ERR_OR_NULL(sunxi_daudio->reg_label)) {
+		/* for echo the save reg */
+		for (i = 0; i <= res_size; i++) {
+			regmap_write(mem_info->regmap, i << 2,
+					(sunxi_daudio->reg_label+i)->value);
+		}
+		kfree(sunxi_daudio->reg_label);
+	}
+
+	/* for clear fifo */
+	for (i = 0 ; i < SUNXI_DAUDIO_FTX_TIMES ; i++) {
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_FIFOCTL,
+				(1 << FIFO_CTL_FTX), (1 << FIFO_CTL_FTX));
+		mdelay(1);
+	}
+
+	regmap_write(mem_info->regmap, SUNXI_DAUDIO_TXCNT, 0);
+	regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_FIFOCTL,
+				(1 << FIFO_CTL_FRX), (1 << FIFO_CTL_FRX));
+	regmap_write(mem_info->regmap, SUNXI_DAUDIO_RXCNT, 0);
+
+	if (pdata_info->daudio_type == SUNXI_DAUDIO_HDMIAUDIO_TYPE) {
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_CTL,
+				(1<<SDO0_EN), (1<<SDO0_EN));
+		if (sunxi_daudio->hdmi_en) {
+			regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_CTL,
+					(1<<SDO1_EN), (1<<SDO1_EN));
+			regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_CTL,
+					(1<<SDO2_EN), (1<<SDO2_EN));
+			regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_CTL,
+					(1<<SDO3_EN), (1<<SDO3_EN));
+		}
+		/* Global enable I2S/TDM module */
+		sunxi_daudio_global_enable(sunxi_daudio, true);
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_CTL,
+				(1<<CTL_TXEN), (1<<CTL_TXEN));
+	}
+	pr_debug("[%s] resume .%s end\n", __func__,
+			dev_name(sunxi_daudio->dev));
+
+	return 0;
+
+err_resume_pin_select_default:
+		clk_disable_unprepare(clk_info->clk_module);
+err_resume_clk_module_enable:
+		clk_disable_unprepare(clk_info->clk_pll);
+err_resume_clk_pll_enable:
+		clk_disable_unprepare(clk_info->clk_bus);
+err_resume_clk_enable_bus:
+		reset_control_assert(clk_info->clk_rst);
+err_resume_regulator_enable:
+	if (!IS_ERR_OR_NULL(regulator_info->daudio_regulator))
+		regulator_disable(regulator_info->daudio_regulator);
+	return ret;
+}
+
+static struct snd_soc_dai_ops sunxi_daudio_dai_ops = {
+	.startup = sunxi_daudio_dai_startup,
+	.set_sysclk = sunxi_daudio_set_sysclk,
+	.set_clkdiv = sunxi_daudio_set_clkdiv,
+	.set_fmt = sunxi_daudio_set_fmt,
+	.hw_params = sunxi_daudio_hw_params,
+	.prepare = sunxi_daudio_prepare,
+	.trigger = sunxi_daudio_trigger,
+	.shutdown = sunxi_daudio_shutdown,
+};
+
+static struct snd_soc_dai_driver sunxi_daudio_dai = {
+	.probe = sunxi_daudio_probe,
+	.suspend = sunxi_daudio_suspend,
+	.resume = sunxi_daudio_resume,
+	.remove = sunxi_daudio_remove,
+	.playback = {
+		.channels_min = 1,
+		.channels_max = 8,
+		.rates = SUNXI_DAUDIO_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE
+			| SNDRV_PCM_FMTBIT_S20_3LE
+			| SNDRV_PCM_FMTBIT_S24_LE
+			| SNDRV_PCM_FMTBIT_S32_LE,
+	},
+	.capture = {
+		.channels_min = 1,
+		.channels_max = 8,
+		.rates = SUNXI_DAUDIO_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE
+			| SNDRV_PCM_FMTBIT_S20_3LE
+			| SNDRV_PCM_FMTBIT_S24_LE
+			| SNDRV_PCM_FMTBIT_S32_LE,
+	},
+	.ops = &sunxi_daudio_dai_ops,
+};
+
+static const struct snd_soc_component_driver sunxi_daudio_component = {
+	.name		= DRV_NAME,
+	.controls	= sunxi_daudio_controls,
+	.num_controls	= ARRAY_SIZE(sunxi_daudio_controls),
+};
+
+static const struct of_device_id sunxi_daudio_of_match[] = {
+	{
+		.compatible = "allwinner,sunxi-daudio",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, sunxi_daudio_of_match);
+
+static struct regmap_config sunxi_daudio_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = SUNXI_DAUDIO_REG_MAX,
+	.cache_type = REGCACHE_NONE,
+};
+
+static int sunxi_daudio_mem_init(struct platform_device *pdev,
+		struct device_node *np, struct sunxi_daudio_info *sunxi_daudio)
+{
+	struct sunxi_daudio_mem_info *mem_info = &sunxi_daudio->mem_info;
+	int ret = 0;
+
+	ret = of_address_to_resource(np, 0, &(mem_info->res));
+	if (ret) {
+		dev_err(&pdev->dev, "parse device node resource failed\n");
+		ret = -EINVAL;
+		goto err_of_addr_to_resource;
+	}
+
+	mem_info->memregion = devm_request_mem_region(&pdev->dev,
+					mem_info->res.start,
+					resource_size(&mem_info->res),
+					DRV_NAME);
+	if (IS_ERR_OR_NULL(mem_info->memregion)) {
+		dev_err(&pdev->dev, "Memory region already claimed\n");
+		ret = -EBUSY;
+		goto err_devm_request_region;
+	}
+
+	mem_info->membase = devm_ioremap(&pdev->dev,
+					mem_info->memregion->start,
+					resource_size(mem_info->memregion));
+	if (IS_ERR_OR_NULL(mem_info->membase)) {
+		dev_err(&pdev->dev, "ioremap failed\n");
+		ret = -EBUSY;
+		goto err_devm_ioremap;
+	}
+
+	sunxi_daudio_regmap_config.max_register = resource_size(&mem_info->res);
+	mem_info->regmap = devm_regmap_init_mmio(&pdev->dev,
+					mem_info->membase,
+					&sunxi_daudio_regmap_config);
+	if (IS_ERR_OR_NULL(mem_info->regmap)) {
+		dev_err(&pdev->dev, "regmap init failed\n");
+		ret = -EINVAL;
+		goto err_devm_regmap_init;
+	}
+
+	return 0;
+
+err_devm_regmap_init:
+	devm_iounmap(&pdev->dev, mem_info->membase);
+err_devm_ioremap:
+	devm_release_mem_region(&pdev->dev, mem_info->memregion->start,
+				resource_size(mem_info->memregion));
+err_devm_request_region:
+err_of_addr_to_resource:
+	devm_kfree(&pdev->dev, sunxi_daudio);
+	return ret;
+};
+
+static int sunxi_daudio_clk_init(struct platform_device *pdev,
+		struct device_node *np, struct sunxi_daudio_info *sunxi_daudio)
+{
+	struct sunxi_daudio_clk_info *clk_info = &sunxi_daudio->clk_info;
+	int ret = 0;
+
+	ret = of_property_read_u32(np, "clk_parent", (u32 *)&clk_info->clk_parent);
+	if (ret != 0) {
+		dev_warn(&pdev->dev, "clk_parent config missing or invalid.\n");
+		clk_info->clk_parent = DAUDIO_CLK_PLL_AUDIO_X1;
+	}
+
+	clk_info->clk_pll = of_clk_get(np, 0);
+	clk_info->clk_module = of_clk_get(np, 1);
+	clk_info->clk_bus = of_clk_get(np, 2);
+#if IS_ENABLED(CONFIG_SND_SUNXI_SOC_DAUDIO_ASRC)
+	clk_info->clk_pll1 = of_clk_get(np, 3);
+	clk_info->clk_asrc = of_clk_get(np, 4);
+#endif
+	clk_info->clk_rst = devm_reset_control_get(&pdev->dev, NULL);
+
+	if (clk_set_parent(clk_info->clk_module, clk_info->clk_pll)) {
+		dev_err(&pdev->dev,
+			"set parent of clk_module to clk_pll failed!\n");
+		ret = -EINVAL;
+		goto err_clk_set_parent;
+	}
+#if IS_ENABLED(CONFIG_SND_SUNXI_SOC_DAUDIO_ASRC)
+	if (clk_set_parent(clk_info->clk_asrc, clk_info->clk_pll1)) {
+		dev_err(&pdev->dev,
+			"set parent of clk_module to clk_pll1 failed!\n");
+		ret = -EINVAL;
+		goto err_clk_set_parent;
+	}
+#endif
+
+	if (reset_control_deassert(clk_info->clk_rst)) {
+		pr_err("daudio: deassert the daudio reset failed\n");
+		return -EINVAL;
+	}
+	if (clk_prepare_enable(clk_info->clk_bus)) {
+		dev_err(&pdev->dev, "daudio clk bus enable failed\n");
+		ret = -EBUSY;
+		goto err_clk_enable_bus;
+	}
+	if (clk_prepare_enable(clk_info->clk_pll)) {
+		dev_err(&pdev->dev, "clk_pll enable failed\n");
+		ret = -EBUSY;
+		goto err_clk_enable_pll;
+	}
+	if (clk_prepare_enable(clk_info->clk_module)) {
+		dev_err(&pdev->dev, "clk_module enable failed\n");
+		ret = -EBUSY;
+		goto err_clk_enable_module;
+	}
+#if IS_ENABLED(CONFIG_SND_SUNXI_SOC_DAUDIO_ASRC)
+	if (clk_prepare_enable(clk_info->clk_pll1)) {
+		dev_err(&pdev->dev, "clk_pll1 enable failed\n");
+		ret = -EBUSY;
+		goto err_clk_enable_pll;
+	}
+	if (clk_prepare_enable(clk_info->clk_asrc)) {
+		dev_err(&pdev->dev, "clk_asrc enable failed\n");
+		ret = -EBUSY;
+		goto err_clk_enable_module;
+	}
+#endif
+
+	return 0;
+
+err_clk_enable_module:
+	clk_disable_unprepare(clk_info->clk_pll);
+err_clk_enable_pll:
+err_clk_set_parent:
+	clk_put(clk_info->clk_bus);
+err_clk_enable_bus:
+	reset_control_assert(clk_info->clk_rst);
+	return ret;
+};
+
+static int sunxi_daudio_pinctrl_init(struct platform_device *pdev,
+		struct device_node *np, struct sunxi_daudio_info *sunxi_daudio)
+{
+	struct sunxi_daudio_pinctl_info *pin_info = &sunxi_daudio->pin_info;
+//	struct sunxi_daudio_dts_info *dts_info = &sunxi_daudio->dts_info;
+//	struct sunxi_daudio_platform_data_info *pdata_info = &dts_info->pdata_info;
+	int ret = 0;
+	int temp_val;
+
+	ret = of_property_read_u32(np, "pinctrl_used", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "pinctrl_used config missing\n");
+		pin_info->pinctrl_used = 1;
+	} else {
+		pin_info->pinctrl_used = temp_val?1:0;
+	}
+
+	if (pin_info->pinctrl_used) {
+		pin_info->pinctrl = devm_pinctrl_get(&pdev->dev);
+		if (IS_ERR_OR_NULL(pin_info->pinctrl)) {
+			dev_err(&pdev->dev, "pinctrl get failed\n");
+			ret = -EINVAL;
+			return ret;
+		}
+		pin_info->pinstate = pinctrl_lookup_state(
+				pin_info->pinctrl, PINCTRL_STATE_DEFAULT);
+		if (IS_ERR_OR_NULL(pin_info->pinstate)) {
+			dev_err(&pdev->dev, "pinctrl default state get fail\n");
+			ret = -EINVAL;
+			goto err_loopup_pinstate;
+		}
+		pin_info->pinstate_sleep = pinctrl_lookup_state(
+				pin_info->pinctrl, PINCTRL_STATE_SLEEP);
+		if (IS_ERR_OR_NULL(pin_info->pinstate_sleep)) {
+			dev_err(&pdev->dev, "pinctrl sleep state get failed\n");
+			ret = -EINVAL;
+			goto err_loopup_pin_sleep;
+		}
+
+		ret = pinctrl_select_state(pin_info->pinctrl,
+					pin_info->pinstate);
+		if (ret < 0) {
+			dev_err(sunxi_daudio->dev,
+				"daudio set pinctrl default state fail\n");
+			ret = -EBUSY;
+			goto err_pinctrl_select_default;
+		}
+	}
+
+	return 0;
+
+err_pinctrl_select_default:
+err_loopup_pin_sleep:
+err_loopup_pinstate:
+	if (pin_info->pinctrl_used)
+		devm_pinctrl_put(pin_info->pinctrl);
+	return ret;
+};
+
+static int sunxi_daudio_dts_params_init(struct platform_device *pdev,
+		struct device_node *np, struct sunxi_daudio_info *sunxi_daudio)
+{
+	struct sunxi_daudio_dts_info *dts_info = &sunxi_daudio->dts_info;
+	struct sunxi_daudio_platform_data_info *pdata_info = &dts_info->pdata_info;
+	unsigned int temp_val = 0;
+	int ret = 0;
+
+	ret = of_property_read_u32(np, "playback_cma", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "playback cma kbytes config missing or invalid.\n");
+		dts_info->playback_cma = SUNXI_AUDIO_CMA_MAX_KBYTES;
+	} else {
+		if (temp_val > SUNXI_AUDIO_CMA_MAX_KBYTES)
+			temp_val = SUNXI_AUDIO_CMA_MAX_KBYTES;
+		else if (temp_val < SUNXI_AUDIO_CMA_MIN_KBYTES)
+			temp_val = SUNXI_AUDIO_CMA_MIN_KBYTES;
+		dts_info->playback_cma = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "capture_cma", &temp_val);
+	if (ret != 0) {
+		dev_warn(&pdev->dev, "capture cma kbytes config missing or invalid.\n");
+		dts_info->capture_cma = SUNXI_AUDIO_CMA_MAX_KBYTES;
+	} else {
+		if (temp_val > SUNXI_AUDIO_CMA_MAX_KBYTES)
+			temp_val = SUNXI_AUDIO_CMA_MAX_KBYTES;
+		else if (temp_val < SUNXI_AUDIO_CMA_MIN_KBYTES)
+			temp_val = SUNXI_AUDIO_CMA_MIN_KBYTES;
+		dts_info->capture_cma = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "tdm_num", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "tdm configuration missing\n");
+		/*
+		 * warnning just continue,
+		 * making tdm_num as default setting
+		 */
+		pdata_info->tdm_num = 0;
+	} else {
+		/*
+		 * FIXME, for channel number mess,
+		 * so just not check channel overflow
+		 */
+		pdata_info->tdm_num = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "pcm_lrck_period", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "pcm_lrck_period config missing or invalid\n");
+		pdata_info->pcm_lrck_period = 0;
+	} else {
+		pdata_info->pcm_lrck_period = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "msb_lsb_first", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "msb_lsb_first config missing or invalid\n");
+		pdata_info->msb_lsb_first = 0;
+	} else {
+		pdata_info->msb_lsb_first = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "slot_width_select", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "slot_width_select config missing or invalid\n");
+		pdata_info->slot_width_select = 0;
+	} else {
+		pdata_info->slot_width_select = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "frametype", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "frametype config missing or invalid\n");
+		pdata_info->frame_type = 0;
+	} else {
+		pdata_info->frame_type = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "sign_extend", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "sign_extend config missing or invalid\n");
+		pdata_info->sign_extend = 0;
+	} else {
+		pdata_info->sign_extend = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "tx_data_mode", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "tx_data_mode config missing or invalid\n");
+		pdata_info->tx_data_mode = 0;
+	} else {
+		pdata_info->tx_data_mode = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "rx_data_mode", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "rx_data_mode config missing or invalid\n");
+		pdata_info->rx_data_mode = 0;
+	} else {
+		pdata_info->rx_data_mode = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "tdm_config", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "tdm_config config missing or invalid\n");
+		pdata_info->tdm_config = 1;
+	} else {
+		pdata_info->tdm_config = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "mclk_div", &temp_val);
+	if (ret < 0) {
+		pdata_info->mclk_div = 0;
+	} else {
+		pdata_info->mclk_div = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "tx_num", &temp_val);
+	if (ret < 0) {
+		pdata_info->tx_num = SUNXI_DAUDIO_TXCH_NUM;
+	} else {
+		if ((temp_val < SUNXI_DAUDIO_TXCH_NUM) && (temp_val != 0))
+			pdata_info->tx_num = temp_val;
+		else
+			pdata_info->tx_num = SUNXI_DAUDIO_TXCH_NUM;
+	}
+
+	ret = of_property_read_u32(np, "tx_chmap0", &temp_val);
+	if (ret < 0) {
+		pdata_info->tx_chmap0 = SUNXI_DEFAULT_TXCHMAP0;
+	} else {
+		pdata_info->tx_chmap0 = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "tx_chmap1", &temp_val);
+	if (ret < 0) {
+		pdata_info->tx_chmap1 = SUNXI_DEFAULT_TXCHMAP1;
+	} else {
+		pdata_info->tx_chmap1 = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "rx_num", &temp_val);
+	if (ret < 0) {
+		pdata_info->rx_num = SUNXI_DAUDIO_RXCH_NUM;
+	} else {
+		if ((temp_val < SUNXI_DAUDIO_RXCH_NUM) && (temp_val != 0))
+			pdata_info->rx_num = temp_val;
+		else
+			pdata_info->rx_num = SUNXI_DAUDIO_RXCH_NUM;
+	}
+
+	ret = of_property_read_u32(np, "rx_chmap0", &temp_val);
+	if (ret < 0) {
+		if (pdata_info->rx_num == 1)
+			pdata_info->rx_chmap0 = SUNXI_DEFAULT_RXCHMAP;
+		else
+			pdata_info->rx_chmap0 = SUNXI_DEFAULT_RXCHMAP0;
+	} else {
+		pdata_info->rx_chmap0 = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "rx_chmap1", &temp_val);
+	if (ret < 0) {
+		pdata_info->rx_chmap1 = SUNXI_DEFAULT_RXCHMAP1;
+	} else {
+		pdata_info->rx_chmap1 = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "rx_chmap2", &temp_val);
+	if (ret < 0) {
+		pdata_info->rx_chmap2 = SUNXI_DEFAULT_RXCHMAP3;
+	} else {
+		pdata_info->rx_chmap2 = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "rx_chmap3", &temp_val);
+	if (ret < 0) {
+		pdata_info->rx_chmap3 = SUNXI_DEFAULT_RXCHMAP3;
+	} else {
+		pdata_info->rx_chmap3 = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "daudio_type", &temp_val);
+	if (ret < 0) {
+		pdata_info->daudio_type = SUNXI_DAUDIO_EXTERNAL_TYPE;
+	} else {
+		pdata_info->daudio_type = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "rx_sync_en", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "rx_sync_en config missing or invalid.\n");
+		sunxi_daudio->rx_sync_en = 0;
+	} else {
+		sunxi_daudio->rx_sync_en = temp_val;
+	}
+	if (sunxi_daudio->rx_sync_en) {
+		sunxi_daudio->rx_sync_domain = RX_SYNC_SYS_DOMAIN;
+		sunxi_daudio->rx_sync_id =
+			sunxi_rx_sync_probe(sunxi_daudio->rx_sync_domain);
+		if (sunxi_daudio->rx_sync_id < 0) {
+			dev_err(&pdev->dev, "sunxi_rx_sync_probe failed\n");
+			return -EINVAL;
+		}
+		dev_info(&pdev->dev, "sunxi_rx_sync_probe successful. "
+					"domain=%d, id=%d\n",
+					sunxi_daudio->rx_sync_domain,
+					sunxi_daudio->rx_sync_id);
+	}
+
+#if IS_ENABLED(CONFIG_SND_SUNXI_SOC_DAUDIO_ASRC)
+	ret = of_property_read_u32(np, "asrc_function_en", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "asrc_function_en config missing and set 0\n");
+		sunxi_daudio->asrc_function_en = 0;
+	} else {
+		sunxi_daudio->asrc_function_en = temp_val;
+	}
+#endif
+	return 0;
+};
+
+static int sunxi_daudio_regulator_init(struct platform_device *pdev,
+		struct device_node *np, struct sunxi_daudio_info *sunxi_daudio)
+{
+	struct sunxi_daudio_regulator_info *regulator_info
+					= &sunxi_daudio->regulator_info;
+	struct sunxi_daudio_dts_info *dts_info = &sunxi_daudio->dts_info;
+	struct sunxi_daudio_platform_data_info *pdata_info = &dts_info->pdata_info;
+	int ret = 0;
+
+	regulator_info->regulator_name = NULL;
+	ret = of_property_read_string(np, "daudio_regulator",
+			&regulator_info->regulator_name);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "regulator missing or invalid\n");
+		regulator_info->daudio_regulator = NULL;
+	} else {
+		regulator_info->daudio_regulator =
+			regulator_get(NULL, regulator_info->regulator_name);
+		if (IS_ERR_OR_NULL(regulator_info->daudio_regulator)) {
+			dev_err(&pdev->dev, "get duaido[%d] vcc-pin failed\n",
+				pdata_info->tdm_num);
+			ret = -EFAULT;
+			goto err_regulator_get;
+		}
+		ret = regulator_set_voltage(regulator_info->daudio_regulator,
+					3300000, 3300000);
+		if (ret < 0) {
+			dev_err(&pdev->dev, "set duaido[%d] voltage failed\n",
+					pdata_info->tdm_num);
+			ret = -EFAULT;
+			goto err_regulator_set_vol;
+		}
+		ret = regulator_enable(regulator_info->daudio_regulator);
+		if (ret < 0) {
+			dev_err(&pdev->dev, "enable duaido[%d] vcc-pin failed\n",
+					pdata_info->tdm_num);
+			ret = -EFAULT;
+			goto err_regulator_enable;
+		}
+	}
+
+	return 0;
+
+err_regulator_enable:
+err_regulator_set_vol:
+	if (regulator_info->daudio_regulator)
+		regulator_put(regulator_info->daudio_regulator);
+err_regulator_get:
+	return ret;
+};
+
+static void sunxi_daudio_dma_params_init(struct resource res,
+					struct sunxi_daudio_info *sunxi_daudio)
+{
+	struct sunxi_daudio_dts_info *dts_info = &sunxi_daudio->dts_info;
+	struct sunxi_daudio_platform_data_info *pdata_info = &dts_info->pdata_info;
+
+	switch (pdata_info->daudio_type) {
+	case	SUNXI_DAUDIO_EXTERNAL_TYPE:
+		sunxi_daudio->playback_dma_param.src_maxburst = 4;
+		sunxi_daudio->playback_dma_param.dst_maxburst = 4;
+		sunxi_daudio->playback_dma_param.dma_addr = res.start + SUNXI_DAUDIO_TXFIFO;
+		sunxi_daudio->playback_dma_param.cma_kbytes = dts_info->playback_cma;
+		sunxi_daudio->playback_dma_param.fifo_size = DAUDIO_TX_FIFO_SIZE;
+
+		sunxi_daudio->capture_dma_param.dma_addr = res.start + SUNXI_DAUDIO_RXFIFO;
+		sunxi_daudio->capture_dma_param.src_maxburst = 4;
+		sunxi_daudio->capture_dma_param.dst_maxburst = 4;
+		sunxi_daudio->capture_dma_param.cma_kbytes = dts_info->capture_cma;
+		sunxi_daudio->capture_dma_param.fifo_size = DAUDIO_RX_FIFO_SIZE;
+		break;
+	case	SUNXI_DAUDIO_HDMIAUDIO_TYPE:
+		sunxi_daudio->playback_dma_param.src_maxburst = 8;
+		sunxi_daudio->playback_dma_param.dst_maxburst = 8;
+		sunxi_daudio->playback_dma_param.dma_addr = res.start + SUNXI_DAUDIO_TXFIFO;
+		sunxi_daudio->playback_dma_param.cma_kbytes = dts_info->playback_cma;
+		sunxi_daudio->playback_dma_param.fifo_size = DAUDIO_TX_FIFO_SIZE;
+		sunxi_daudio->hdmi_en = 1;
+
+		sunxi_daudio->capture_dma_param.src_maxburst = 8;
+		sunxi_daudio->capture_dma_param.dst_maxburst = 8;
+		sunxi_daudio->capture_dma_param.dma_addr = res.start + SUNXI_DAUDIO_RXFIFO;
+		sunxi_daudio->capture_dma_param.cma_kbytes = dts_info->capture_cma;
+		sunxi_daudio->capture_dma_param.fifo_size = DAUDIO_RX_FIFO_SIZE;
+		break;
+	default:
+		pr_err("[%s] missing digital audio type\n", __func__);
+	}
+};
+
+static int sunxi_daudio_dev_probe(struct platform_device *pdev)
+{
+	const struct of_device_id *match = NULL;
+	struct sunxi_daudio_info *sunxi_daudio = NULL;
+	struct sunxi_daudio_mem_info *mem_info = NULL;
+	struct sunxi_daudio_clk_info *clk_info = NULL;
+	struct sunxi_daudio_pinctl_info *pin_info = NULL;
+	struct sunxi_daudio_dts_info *dts_info = NULL;
+	struct sunxi_daudio_regulator_info *regulator_info = NULL;
+	struct sunxi_daudio_platform_data_info *pdata_info = NULL;
+	struct device_node *np = pdev->dev.of_node;
+	int ret;
+
+	match = of_match_device(sunxi_daudio_of_match, &pdev->dev);
+	if (match) {
+		sunxi_daudio = devm_kzalloc(&pdev->dev,
+					sizeof(struct sunxi_daudio_info),
+					GFP_KERNEL);
+		if (IS_ERR_OR_NULL(sunxi_daudio)) {
+			dev_err(&pdev->dev, "alloc sunxi_daudio failed\n");
+			ret = -ENOMEM;
+			goto err_devm_malloc_sunxi_daudio;
+		}
+		dev_set_drvdata(&pdev->dev, sunxi_daudio);
+
+		sunxi_daudio->dev = &pdev->dev;
+		mem_info = &sunxi_daudio->mem_info;
+		clk_info = &sunxi_daudio->clk_info;
+		pin_info = &sunxi_daudio->pin_info;
+		dts_info = &sunxi_daudio->dts_info;
+		pdata_info = &dts_info->pdata_info;
+		regulator_info = &sunxi_daudio->regulator_info;
+	} else {
+		dev_err(&pdev->dev, "node match failed\n");
+		return -EINVAL;
+	}
+
+	/* init some params */
+	sunxi_daudio->hub_mode = 0;
+	sunxi_daudio->playback_en = 0;
+	sunxi_daudio->capture_en = 0;
+
+	/* mem init about */
+	ret = sunxi_daudio_mem_init(pdev, np, sunxi_daudio);
+	if (ret) {
+		dev_err(&pdev->dev, "[%s] failed\n", __func__);
+		ret = -EINVAL;
+		return ret;
+	}
+
+	/* clk init about */
+	ret = sunxi_daudio_clk_init(pdev, np, sunxi_daudio);
+	if (ret) {
+		dev_err(&pdev->dev, "[%s] failed\n", __func__);
+		ret = -EINVAL;
+		return ret;
+	}
+
+	/* pinctrl init about */
+	ret = sunxi_daudio_pinctrl_init(pdev, np, sunxi_daudio);
+	if (ret) {
+		dev_err(&pdev->dev, "[%s] failed\n", __func__);
+		ret = -EINVAL;
+		return ret;
+	}
+
+	/* regulator init about */
+	ret = sunxi_daudio_regulator_init(pdev, np, sunxi_daudio);
+	if (ret) {
+		dev_err(&pdev->dev, "[%s] failed\n", __func__);
+		ret = -EINVAL;
+		return ret;
+	}
+
+	/* dts params init about */
+	ret = sunxi_daudio_dts_params_init(pdev, np, sunxi_daudio);
+	if (ret) {
+		dev_err(&pdev->dev, "[%s] failed\n", __func__);
+		ret = -EINVAL;
+		return ret;
+	}
+
+	/* daudio dma params about */
+	sunxi_daudio_dma_params_init(sunxi_daudio->mem_info.res, sunxi_daudio);
+
+	/* sunxi daudio component about register */
+	ret = snd_soc_register_component(&pdev->dev, &sunxi_daudio_component,
+					&sunxi_daudio_dai, 1);
+	if (ret) {
+		dev_err(&pdev->dev, "component register failed\n");
+		ret = -ENOMEM;
+		goto err_register_component;
+	}
+
+	switch (pdata_info->daudio_type) {
+	case	SUNXI_DAUDIO_EXTERNAL_TYPE:
+		ret = asoc_dma_platform_register(&pdev->dev, 0);
+		if (ret) {
+			dev_err(&pdev->dev, "register ASoC platform failed\n");
+			ret = -ENOMEM;
+			goto err_asoc_dma_platform_register;
+		}
+		break;
+	case	SUNXI_DAUDIO_HDMIAUDIO_TYPE:
+		ret = asoc_dma_platform_register(&pdev->dev,
+						SND_DMAENGINE_PCM_FLAG_NO_DT);
+		if (ret) {
+			dev_err(&pdev->dev, "register ASoC platform failed\n");
+			ret = -ENOMEM;
+			goto err_asoc_dma_platform_register;
+		}
+		break;
+	default:
+		dev_err(&pdev->dev, "missing digital audio type\n");
+		ret = -EINVAL;
+		goto err_daudio_type_asoc_dma_register;
+	}
+
+#ifdef SUNXI_DAUDIO_DEBUG
+	ret  = sysfs_create_group(&pdev->dev.kobj, &daudio_debug_attr_group);
+	if (ret)
+		dev_err(&pdev->dev, "failed to create attr group\n");
+#endif
+
+	if (pdata_info->daudio_type == SUNXI_DAUDIO_HDMIAUDIO_TYPE) {
+		regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_CTL,
+				(1<<SDO0_EN), (1<<SDO0_EN));
+		if (sunxi_daudio->hdmi_en) {
+			regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_CTL,
+					(1<<SDO1_EN), (1<<SDO1_EN));
+			regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_CTL,
+					(1<<SDO2_EN), (1<<SDO2_EN));
+			regmap_update_bits(mem_info->regmap, SUNXI_DAUDIO_CTL,
+					(1<<SDO3_EN), (1<<SDO3_EN));
+		}
+		sunxi_daudio_global_enable(sunxi_daudio, true);
+	}
+
+	return 0;
+
+err_asoc_dma_platform_register:
+err_daudio_type_asoc_dma_register:
+	snd_soc_unregister_component(&pdev->dev);
+err_register_component:
+	devm_kfree(&pdev->dev, sunxi_daudio);
+err_devm_malloc_sunxi_daudio:
+	of_node_put(np);
+	return ret;
+}
+
+static int __exit sunxi_daudio_dev_remove(struct platform_device *pdev)
+{
+	struct sunxi_daudio_info *sunxi_daudio = dev_get_drvdata(&pdev->dev);
+	struct sunxi_daudio_mem_info *mem_info = &sunxi_daudio->mem_info;
+	struct sunxi_daudio_clk_info *clk_info = &sunxi_daudio->clk_info;
+	struct sunxi_daudio_pinctl_info *pin_info = &sunxi_daudio->pin_info;
+//	struct sunxi_daudio_dts_info *dts_info = &sunxi_daudio->dts_info;
+//	struct sunxi_daudio_platform_data_info *pdata_info = &dts_info->pdata_info;
+	struct sunxi_daudio_regulator_info *regulator_info = &sunxi_daudio->regulator_info;
+
+	if (sunxi_daudio->rx_sync_en)
+		sunxi_rx_sync_remove(sunxi_daudio->rx_sync_domain);
+
+#ifdef SUNXI_DAUDIO_DEBUG
+	sysfs_remove_group(&pdev->dev.kobj, &daudio_debug_attr_group);
+#endif
+
+	snd_soc_unregister_component(&pdev->dev);
+	devm_iounmap(&pdev->dev, mem_info->membase);
+	devm_release_mem_region(&pdev->dev, mem_info->memregion->start,
+				resource_size(mem_info->memregion));
+
+	if (regulator_info->daudio_regulator) {
+		if (!IS_ERR_OR_NULL(regulator_info->daudio_regulator)) {
+			regulator_disable(regulator_info->daudio_regulator);
+			regulator_put(regulator_info->daudio_regulator);
+		}
+		if (pin_info->pinctrl_used) {
+			devm_pinctrl_put(pin_info->pinctrl);
+		}
+	}
+
+	clk_disable_unprepare(clk_info->clk_module);
+	clk_put(clk_info->clk_module);
+	clk_disable_unprepare(clk_info->clk_pll);
+	clk_put(clk_info->clk_pll);
+	clk_disable_unprepare(clk_info->clk_bus);
+	clk_put(clk_info->clk_bus);
+	reset_control_assert(clk_info->clk_rst);
+
+	devm_kfree(&pdev->dev, sunxi_daudio);
+
+	return 0;
+}
+
+static struct platform_driver sunxi_daudio_driver = {
+	.probe = sunxi_daudio_dev_probe,
+	.remove = __exit_p(sunxi_daudio_dev_remove),
+	.driver = {
+		.name = DRV_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_daudio_of_match,
+	},
+};
+
+module_platform_driver(sunxi_daudio_driver);
+MODULE_AUTHOR("yumingfeng <yumingfeng@allwinnertech.com>");
+MODULE_DESCRIPTION("SUNXI DAI AUDIO ASoC Interface");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:sunxi-daudio");
diff --git a/sound/soc/sunxi/sunxi-daudio.h b/sound/soc/sunxi/sunxi-daudio.h
new file mode 100644
index 000000000..c2cdeae2c
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-daudio.h
@@ -0,0 +1,496 @@
+/*
+ * sound\soc\sunxi\sunxi-daudio.h
+ * (C) Copyright 2019-2025
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * yumingfeng <yumingfeng@allwinertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef	__SUNXI_DAUDIO_H_
+#define	__SUNXI_DAUDIO_H_
+
+#include "sunxi-pcm.h"
+
+/*
+ * Platform    I2S_count   HDMI_seq(index is 0 to i)     MODE
+ * sun50iw10      4           NONE                        B(TDM:16-channels)
+ * sun8iw20	  3	      NONE			  B(TDM:16-channels)
+ */
+
+/* DAUDIO register definition */
+#define	SUNXI_DAUDIO_CTL		0x00
+#define	SUNXI_DAUDIO_FMT0		0x04
+#define	SUNXI_DAUDIO_FMT1		0x08
+#define	SUNXI_DAUDIO_INTSTA		0x0C
+#define	SUNXI_DAUDIO_RXFIFO		0x10
+#define	SUNXI_DAUDIO_FIFOCTL		0x14
+#define	SUNXI_DAUDIO_FIFOSTA		0x18
+#define	SUNXI_DAUDIO_INTCTL		0x1C
+#define	SUNXI_DAUDIO_TXFIFO		0x20
+#define	SUNXI_DAUDIO_CLKDIV		0x24
+#define	SUNXI_DAUDIO_TXCNT		0x28
+#define	SUNXI_DAUDIO_RXCNT		0x2C
+#define	SUNXI_DAUDIO_CHCFG		0x30
+#define	SUNXI_DAUDIO_TX0CHSEL		0x34
+#define	SUNXI_DAUDIO_TX1CHSEL		0x38
+#define	SUNXI_DAUDIO_TX2CHSEL		0x3C
+#define	SUNXI_DAUDIO_TX3CHSEL		0x40
+
+#define	SUNXI_DAUDIO_TX0CHMAP0		0x44
+#define	SUNXI_DAUDIO_TX0CHMAP1		0x48
+#define	SUNXI_DAUDIO_TX1CHMAP0		0x4C
+#define	SUNXI_DAUDIO_TX1CHMAP1		0x50
+#define	SUNXI_DAUDIO_TX2CHMAP0		0x54
+#define	SUNXI_DAUDIO_TX2CHMAP1		0x58
+#define	SUNXI_DAUDIO_TX3CHMAP0		0x5C
+#define	SUNXI_DAUDIO_TX3CHMAP1		0x60
+
+#define	SUNXI_DAUDIO_RXCHSEL		0x64
+#define	SUNXI_DAUDIO_RXCHMAP0		0x68
+#define	SUNXI_DAUDIO_RXCHMAP1		0x6C
+#define	SUNXI_DAUDIO_RXCHMAP2		0x70
+#define	SUNXI_DAUDIO_RXCHMAP3		0x74
+
+#define	SUNXI_DAUDIO_DEBUG		0x78
+#define	SUNXI_DAUDIO_REV		0x7C
+
+/* SUNXI DAUDIO ASRC FUNC */
+#if IS_ENABLED(CONFIG_SND_SUNXI_SOC_DAUDIO_ASRC)
+#define SUNXI_DAUDIO_ASRC_MCLKCFG	0x80
+#define SUNXI_DAUDIO_ASRC_FSOUTCFG	0x84
+#define SUNXI_DAUDIO_ASRC_FSIN_EXTCFG	0x88
+#define SUNXI_DAUDIO_ASRC_ASRCEN	0x8C
+#define SUNXI_DAUDIO_ASRC_MANCFG	0x90
+#define SUNXI_DAUDIO_ASRC_RATIOSTAT	0x94
+#define SUNXI_DAUDIO_ASRC_FIFOSTAT	0x98
+#define SUNXI_DAUDIO_ASRC_MBISTCFG	0x9C
+#define SUNXI_DAUDIO_ASRC_MBISTSTA	0xA0
+#endif
+
+/* about platform define */
+#if IS_ENABLED(CONFIG_SND_SUNXI_SOC_DAUDIO_ASRC)
+#define SUNXI_DAUDIO_REG_MAX SUNXI_DAUDIO_ASRC_MBISTSTA
+#else
+#define SUNXI_DAUDIO_REG_MAX SUNXI_DAUDIO_REV
+#endif
+
+/* SUNXI_DAUDIO_CTL:0x00 */
+#define RX_SYNC_EN			21
+#define RX_EN_MUX			20
+#define	BCLK_OUT			18
+#define	LRCK_OUT			17
+#define	LRCKR_CTL			16
+#define	SDO3_EN				11
+#define	SDO2_EN				10
+#define	SDO1_EN				9
+#define	SDO0_EN				8
+#define	MUTE_CTL			6
+#define	MODE_SEL			4
+#define	LOOP_EN				3
+#define	CTL_TXEN			2
+#define	CTL_RXEN			1
+#define	GLOBAL_EN			0
+
+/* SUNXI_DAUDIO_FMT0:0x04 */
+#define	SDI_SYNC_SEL			31
+#define	LRCK_WIDTH			30
+#define	LRCKR_PERIOD			20
+#define	LRCK_POLARITY			19
+#define	LRCK_PERIOD			8
+#define	BRCK_POLARITY			7
+#define	DAUDIO_SAMPLE_RESOLUTION	4
+#define	EDGE_TRANSFER			3
+#define	SLOT_WIDTH			0
+
+/* SUNXI_DAUDIO_FMT1:0x08 */
+#define	RX_MLS				7
+#define	TX_MLS				6
+#define	SEXT				4
+#define	RX_PDM				2
+#define	TX_PDM				0
+
+/* SUNXI_DAUDIO_INTSTA:0x0C */
+#define	TXU_INT				6
+#define	TXO_INT				5
+#define	TXE_INT				4
+#define	RXU_INT				2
+#define RXO_INT				1
+#define	RXA_INT				0
+
+/* SUNXI_DAUDIO_FIFOCTL:0x14 */
+#define	HUB_EN				31
+#define	FIFO_CTL_FTX			25
+#define	FIFO_CTL_FRX			24
+#define	TXTL				12
+#define	RXTL				4
+#define	TXIM				2
+#define	RXOM				0
+
+/* SUNXI_DAUDIO_FIFOSTA:0x18 */
+#define	FIFO_TXE			28
+#define	FIFO_TX_CNT			16
+#define	FIFO_RXA			8
+#define	FIFO_RX_CNT			0
+
+/* SUNXI_DAUDIO_INTCTL:0x1C */
+#define	TXDRQEN				7
+#define	TXUI_EN				6
+#define	TXOI_EN				5
+#define	TXEI_EN				4
+#define	RXDRQEN				3
+#define	RXUIEN				2
+#define	RXOIEN				1
+#define	RXAIEN				0
+
+/* SUNXI_DAUDIO_CLKDIV:0x24 */
+#define	MCLKOUT_EN			8
+#define	BCLK_DIV			4
+#define	MCLK_DIV			0
+
+/* SUNXI_DAUDIO_CHCFG:0x30 */
+#define	TX_SLOT_HIZ			9
+#define	TX_STATE			8
+#define	RX_SLOT_NUM			4
+#define	TX_SLOT_NUM			0
+
+/* SUNXI_DAUDIO_TXnCHSEL:0X34+n*0x04 */
+#define	TX_OFFSET			20
+#define	TX_CHSEL			16
+#define	TX_CHEN				0
+
+/* SUNXI_DAUDIO_RXCHSEL */
+#define	RX_OFFSET			20
+#define	RX_CHSEL			16
+
+/* CHMAP default setting */
+#define SUNXI_DAUDIO_TXCH_NUM		0x4
+#define	SUNXI_DEFAULT_TXCHMAP0		0xFEDCBA98
+#define	SUNXI_DEFAULT_TXCHMAP1		0x76543210
+
+/* RXCHMAP default setting */
+#define SUNXI_DAUDIO_RXCH_NUM		0x4
+#define	SUNXI_DEFAULT_RXCHMAP		0x76543210
+
+#define	SUNXI_DEFAULT_RXCHMAP3		0x03020100
+#define	SUNXI_DEFAULT_RXCHMAP2		0x07060504
+#define	SUNXI_DEFAULT_RXCHMAP1		0x0B0A0908
+#define	SUNXI_DEFAULT_RXCHMAP0		0x0F0E0D0C
+
+/* Shift & Mask define */
+
+/* SUNXI_DAUDIO_CTL:0x00 */
+#define	SUNXI_DAUDIO_MODE_CTL_MASK		3
+#define	SUNXI_DAUDIO_MODE_CTL_PCM		0
+#define	SUNXI_DAUDIO_MODE_CTL_I2S		1
+#define	SUNXI_DAUDIO_MODE_CTL_LEFT		1
+#define	SUNXI_DAUDIO_MODE_CTL_RIGHT		2
+#define	SUNXI_DAUDIO_MODE_CTL_REVD		3
+/* combine LRCK_CLK & BCLK setting */
+#define	SUNXI_DAUDIO_LRCK_OUT_MASK		3
+#define	SUNXI_DAUDIO_LRCK_OUT_DISABLE		0
+#define	SUNXI_DAUDIO_LRCK_OUT_ENABLE		3
+
+/* SUNXI_DAUDIO_FMT0 */
+#define	SUNXI_DAUDIO_LRCK_PERIOD_MASK		0x3FF
+#define	SUNXI_DAUDIO_SLOT_WIDTH_MASK		7
+/* Left Blank */
+#define	SUNXI_DAUDIO_SR_MASK			7
+#define	SUNXI_DAUDIO_SR_16BIT			3
+#define	SUNXI_DAUDIO_SR_24BIT			5
+#define	SUNXI_DAUDIO_SR_32BIT			7
+
+#define	SUNXI_DAUDIO_LRCK_POLARITY_NOR		0
+#define	SUNXI_DAUDIO_LRCK_POLARITY_INV		1
+#define	SUNXI_DAUDIO_BCLK_POLARITY_NOR		0
+#define	SUNXI_DAUDIO_BCLK_POLARITY_INV		1
+
+/* SUNXI_DAUDIO_FMT1 */
+#define	SUNXI_DAUDIO_FMT1_DEF			0x30
+
+/* SUNXI_DAUDIO_FIFOCTL */
+#define	SUNXI_DAUDIO_TXIM_MASK			1
+#define	SUNXI_DAUDIO_TXIM_VALID_MSB		0
+#define	SUNXI_DAUDIO_TXIM_VALID_LSB		1
+/* Left Blank */
+#define	SUNXI_DAUDIO_RXOM_MASK			3
+/* Expanding 0 at LSB of RX_FIFO */
+#define	SUNXI_DAUDIO_RXOM_EXP0			0
+/* Expanding sample bit at MSB of RX_FIFO */
+#define	SUNXI_DAUDIO_RXOM_EXPH			1
+/* Fill RX_FIFO low word be 0 */
+#define	SUNXI_DAUDIO_RXOM_TUNL			2
+/* Fill RX_FIFO high word be higher sample bit */
+#define	SUNXI_DAUDIO_RXOM_TUNH			3
+
+/* SUNXI_DAUDIO_CLKDIV */
+#define	SUNXI_DAUDIO_BCLK_DIV_MASK		0xF
+#define	SUNXI_DAUDIO_BCLK_DIV_1			1
+#define	SUNXI_DAUDIO_BCLK_DIV_2			2
+#define	SUNXI_DAUDIO_BCLK_DIV_3			3
+#define	SUNXI_DAUDIO_BCLK_DIV_4			4
+#define	SUNXI_DAUDIO_BCLK_DIV_5			5
+#define	SUNXI_DAUDIO_BCLK_DIV_6			6
+#define	SUNXI_DAUDIO_BCLK_DIV_7			7
+#define	SUNXI_DAUDIO_BCLK_DIV_8			8
+#define	SUNXI_DAUDIO_BCLK_DIV_9			9
+#define	SUNXI_DAUDIO_BCLK_DIV_10		10
+#define	SUNXI_DAUDIO_BCLK_DIV_11		11
+#define	SUNXI_DAUDIO_BCLK_DIV_12		12
+#define	SUNXI_DAUDIO_BCLK_DIV_13		13
+#define	SUNXI_DAUDIO_BCLK_DIV_14		14
+#define	SUNXI_DAUDIO_BCLK_DIV_15		15
+/* Left Blank */
+#define	SUNXI_DAUDIO_MCLK_DIV_MASK		0xF
+#define	SUNXI_DAUDIO_MCLK_DIV_1			1
+#define	SUNXI_DAUDIO_MCLK_DIV_2			2
+#define	SUNXI_DAUDIO_MCLK_DIV_3			3
+#define	SUNXI_DAUDIO_MCLK_DIV_4			4
+#define	SUNXI_DAUDIO_MCLK_DIV_5			5
+#define	SUNXI_DAUDIO_MCLK_DIV_6			6
+#define	SUNXI_DAUDIO_MCLK_DIV_7			7
+#define	SUNXI_DAUDIO_MCLK_DIV_8			8
+#define	SUNXI_DAUDIO_MCLK_DIV_9			9
+#define	SUNXI_DAUDIO_MCLK_DIV_10		10
+#define	SUNXI_DAUDIO_MCLK_DIV_11		11
+#define	SUNXI_DAUDIO_MCLK_DIV_12		12
+#define	SUNXI_DAUDIO_MCLK_DIV_13		13
+#define	SUNXI_DAUDIO_MCLK_DIV_14		14
+#define	SUNXI_DAUDIO_MCLK_DIV_15		15
+
+/* SUNXI_DAUDIO_CHCFG */
+#define	SUNXI_DAUDIO_TX_SLOT_MASK		0XF
+#define	SUNXI_DAUDIO_RX_SLOT_MASK		0XF
+/* SUNXI_DAUDIO_TX0CHSEL: */
+#define	SUNXI_DAUDIO_TX_OFFSET_MASK		3
+#define	SUNXI_DAUDIO_TX_OFFSET_0		0
+#define	SUNXI_DAUDIO_TX_OFFSET_1		1
+/* Left Blank */
+#define	SUNXI_DAUDIO_TX_CHEN_MASK		0xFFFF
+#define	SUNXI_DAUDIO_TX_CHSEL_MASK		0xF
+
+/* SUNXI_DAUDIO_RXCHSEL */
+#define SUNXI_DAUDIO_RX_OFFSET_MASK		3
+#define	SUNXI_DAUDIO_RX_CHSEL_MASK		0XF
+
+#define DAUDIO_RXCH_DEF_MAP(x) (x << ((x%4)<<3))
+#define DAUDIO_RXCHMAP(x) (0x1f << ((x%4)<<3))
+
+#if IS_ENABLED(CONFIG_SND_SUNXI_SOC_DAUDIO_ASRC)
+/* SUNXI_DAUDIO_ASRC_MCLKCFG:0x80 */
+#define DAUDIO_ASRC_MCLK_GATE		16
+#define DAUDIO_ASRC_MCLK_RATIO		0
+
+/* SUNXI_DAUDIO_ASRC_FSOUTCFG:0x84 */
+#define DAUDIO_ASRC_FSOUT_GATE		20
+#define DAUDIO_ASRC_FSOUT_CLKSRC	16
+#define DAUDIO_ASRC_FSOUT_CLKDIV1	4
+#define DAUDIO_ASRC_FSOUT_CLKDIV2	0
+
+/* SUNXI_DAUDIO_ASRC_FSIN_EXTCFG:0x88 */
+#define DAUDIO_ASRC_FSIN_EXTEN		16
+#define DAUDIO_ASRC_FSIN_EXTCYCLE	0
+
+/* SUNXI_DAUDIO_ASRC_ASRCEN:0x8C */
+#define DAUDIO_ASRC_ASRCEN		0
+
+/* SUNXI_DAUDIO_ASRC_MANCFG:0x90 */
+#define DAUDIO_ASRC_MANRATIOEN		31
+#define DAUDIO_ASRC_MAN_RATIO		0
+
+/* SUNXI_DAUDIO_ASRC_RATIOSTAT:0x94 */
+/* SUNXI_DAUDIO_ASRC_FIFOSTAT:0x98 */
+/* SUNXI_DAUDIO_ASRC_MBISTCFG:0x9C */
+/* SUNXI_DAUDIO_ASRC_MBISTSTA:0xA0 */
+#endif
+
+/*
+ * For other platform define.
+ */
+#ifndef DRQSRC_DAUDIO_2_RX
+#define DRQSRC_DAUDIO_2_RX		0
+#endif
+#ifndef DRQDST_DAUDIO_2_TX
+#define DRQDST_DAUDIO_2_TX		0
+#endif
+#ifndef DRQSRC_DAUDIO_3_RX
+#define DRQSRC_DAUDIO_3_RX		0
+#endif
+#ifndef DRQDST_DAUDIO_3_TX
+#define DRQDST_DAUDIO_3_TX		0
+#endif
+#ifndef DRQSRC_DAUDIO_4_RX
+#define DRQSRC_DAUDIO_4_RX		0
+#endif
+#ifndef DRQDST_DAUDIO_4_TX
+#define DRQDST_DAUDIO_4_TX		0
+#endif
+
+#define DAUDIO_NUM_MAX			5
+
+/* Basic Define */
+#define	SUNXI_DAUDIO_RATES	(SNDRV_PCM_RATE_8000_192000 \
+					| SNDRV_PCM_RATE_KNOT)
+
+#define	SUNXI_DAUDIO_EXTERNAL_TYPE	0
+#define	SUNXI_DAUDIO_HDMIAUDIO_TYPE	1
+
+/* Debug */
+#define DAUDIO_CLASS_DEBUG
+
+/* To clear FIFO */
+#define SUNXI_DAUDIO_FTX_TIMES		10
+
+#define DAUDIO_RX_FIFO_SIZE		64
+#define DAUDIO_TX_FIFO_SIZE		128
+
+#define DAUDIO_CLK_PLL_AUDIO_X1		0
+#define DAUDIO_CLK_PLL_AUDIO_X4		1
+
+#define DAUDIO_REG_LABEL(constant) {#constant, constant, 0}
+#define DAUDIO_REG_LABEL_END {NULL, -1, 0}
+
+struct daudio_label {
+	unsigned long address;
+	int value;
+};
+
+struct daudio_reg_label {
+	const char *name;
+	const unsigned int address;
+	int value;
+};
+
+struct sunxi_daudio_mem_info {
+	struct resource res;
+	void __iomem *membase;
+	struct resource *memregion;
+	struct regmap *regmap;
+};
+
+struct sunxi_daudio_clk_info {
+	struct clk *clk_pll;
+	struct clk *clk_module;
+	struct clk *clk_bus;
+#if IS_ENABLED(CONFIG_SND_SUNXI_SOC_DAUDIO_ASRC)
+	struct clk *clk_pll1;
+	struct clk *clk_asrc;
+#endif
+	struct reset_control *clk_rst;
+	unsigned int clk_parent;
+};
+
+struct sunxi_daudio_pinctl_info {
+	struct pinctrl *pinctrl;
+	struct pinctrl_state *pinstate;
+	struct pinctrl_state *pinstate_sleep;
+	unsigned int pinctrl_used;
+};
+
+struct sunxi_daudio_platform_data_info {
+	unsigned int daudio_type;
+//	unsigned int external_type;
+
+	unsigned int pcm_lrck_period;
+	unsigned int msb_lsb_first:1;
+	unsigned int sign_extend:2;
+	unsigned int tx_data_mode:2;
+	unsigned int rx_data_mode:2;
+	unsigned int slot_width_select;
+	unsigned int frame_type;
+	unsigned int tdm_config;
+	unsigned int tdm_num;
+	unsigned int mclk_div;
+	unsigned int tx_num;
+	unsigned int tx_chmap0;
+	unsigned int tx_chmap1;
+	unsigned int rx_num;
+	unsigned int rx_chmap0;
+	unsigned int rx_chmap1;
+	unsigned int rx_chmap2;
+	unsigned int rx_chmap3;
+};
+
+struct sunxi_daudio_regulator_info {
+	struct regulator *daudio_regulator;
+	const char *regulator_name;
+};
+
+struct sunxi_daudio_dts_info {
+	struct sunxi_daudio_platform_data_info pdata_info;
+
+	/* value must be (2^n)Kbyte */
+	size_t playback_cma;
+	size_t capture_cma;
+};
+
+struct sunxi_daudio_spinlock {
+	spinlock_t lock;
+	unsigned long flags;
+};
+
+struct sunxi_daudio_info {
+	struct device *dev;
+	struct sunxi_daudio_spinlock global_spinlock;
+
+	struct sunxi_daudio_mem_info mem_info;
+	struct sunxi_daudio_clk_info clk_info;
+	struct sunxi_daudio_pinctl_info pin_info;
+	struct sunxi_daudio_dts_info dts_info;
+	struct sunxi_daudio_regulator_info regulator_info;
+
+	struct sunxi_dma_params playback_dma_param;
+	struct sunxi_dma_params capture_dma_param;
+
+	unsigned int hub_mode;
+	bool playback_en;
+	bool capture_en;
+	int global_enable;
+	unsigned int hdmi_en;
+	struct snd_soc_dai *cpu_dai;
+	struct daudio_label *reg_label;
+
+	unsigned int rx_sync_en;
+	int rx_sync_id;
+	rx_sync_domain_t rx_sync_domain;
+
+#if IS_ENABLED(CONFIG_SND_SUNXI_SOC_DAUDIO_ASRC)
+	int asrc_function_en;
+#endif
+};
+
+#if IS_ENABLED(CONFIG_SND_SUNXI_SOC_SUNXI_HDMIAUDIO)
+extern int sunxi_hdmi_codec_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params, struct snd_soc_dai *dai);
+extern void sunxi_hdmi_codec_shutdown(struct snd_pcm_substream *substream,
+			struct snd_soc_dai *dai);
+extern int sunxi_hdmi_codec_prepare(struct snd_pcm_substream *substream,
+			struct snd_soc_dai *dai);
+#else
+static inline int sunxi_hdmi_codec_hw_params(
+		struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static inline int sunxi_hdmi_codec_prepare(struct snd_pcm_substream *substream,
+			struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static inline void sunxi_hdmi_codec_shutdown(
+		struct snd_pcm_substream *substream, struct snd_soc_dai *dai)
+{
+
+}
+#endif
+
+#endif	/* __SUNXI_DAUDIO_H_ */
diff --git a/sound/soc/sunxi/sunxi-dmic.c b/sound/soc/sunxi/sunxi-dmic.c
new file mode 100644
index 000000000..b6ff1bc29
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-dmic.c
@@ -0,0 +1,1074 @@
+/*
+ * sound\soc\sunxi\sunxi-dmic.c
+ * (C) Copyright 2019-2025
+ * AllWinner Technology Co., Ltd. <www.allwinnertech.com>
+ * yumingfeng <yumingfeng@allwinnertech.com>
+ * luguofang <luguofang@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/regmap.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/sunxi-gpio.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/regulator/consumer.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
+#include <linux/reset.h>
+#include <asm/dma.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/initval.h>
+
+#include "sunxi-dmic.h"
+#include "sunxi-pcm.h"
+
+#define	DRV_NAME	"sunxi-dmic"
+#define SUNXI_DMIC_DEBUG
+
+struct dmic_rate {
+	unsigned int samplerate;
+	unsigned int rate_bit;
+};
+
+static const struct dmic_rate dmic_rate_s[] = {
+	{44100, 0x0},
+	{48000, 0x0},
+	{22050, 0x2},
+	/* KNOT support */
+	{24000, 0x2},
+	{11025, 0x4},
+	{12000, 0x4},
+	{32000, 0x1},
+	{16000, 0x3},
+	{8000,  0x5},
+};
+
+#ifdef SUNXI_DMIC_DEBUG
+static struct sunxi_dmic_reg_label reg_labels[] = {
+	SUNXI_DMIC_REG_LABEL(SUNXI_DMIC_EN),
+	SUNXI_DMIC_REG_LABEL(SUNXI_DMIC_SR),
+	SUNXI_DMIC_REG_LABEL(SUNXI_DMIC_CTR),
+	SUNXI_DMIC_REG_LABEL(SUNXI_DMIC_INTC),
+	SUNXI_DMIC_REG_LABEL(SUNXI_DMIC_INTS),
+	SUNXI_DMIC_REG_LABEL(SUNXI_DMIC_FIFO_CTR),
+	SUNXI_DMIC_REG_LABEL(SUNXI_DMIC_FIFO_STA),
+	SUNXI_DMIC_REG_LABEL(SUNXI_DMIC_CH_NUM),
+	SUNXI_DMIC_REG_LABEL(SUNXI_DMIC_CH_MAP),
+	SUNXI_DMIC_REG_LABEL(SUNXI_DMIC_CNT),
+	SUNXI_DMIC_REG_LABEL(SUNXI_DMIC_DATA0_1_VOL),
+	SUNXI_DMIC_REG_LABEL(SUNXI_DMIC_DATA2_3_VOL),
+	SUNXI_DMIC_REG_LABEL(SUNXI_DMIC_HPF_CTRL),
+	SUNXI_DMIC_REG_LABEL(SUNXI_DMIC_HPF_COEF),
+	SUNXI_DMIC_REG_LABEL(SUNXI_DMIC_HPF_GAIN),
+	SUNXI_DMIC_REG_LABEL_END,
+};
+
+static ssize_t show_dmic_reg(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct sunxi_dmic_info *sunxi_dmic = dev_get_drvdata(dev);
+	struct sunxi_dmic_dts_info *dts_info = NULL;
+	struct sunxi_dmic_mem_info *mem_info = NULL;
+	int count = 0;
+	unsigned int reg_val;
+	int ret = 0;
+	int i = 0;
+
+	if (IS_ERR_OR_NULL(sunxi_dmic)) {
+		dev_err(dev, "sunxi_dmic is NULL!\n");
+		return count;
+	}
+	dts_info = &sunxi_dmic->dts_info;
+	mem_info = &sunxi_dmic->mem_info;
+
+	count = snprintf(buf, PAGE_SIZE, "Dump dmic reg:\n");
+	if (count > 0) {
+		ret += count;
+	} else {
+		dev_err(dev, "snprintf start error=%d.\n", count);
+		return 0;
+	}
+
+	while (reg_labels[i].name != NULL) {
+		regmap_read(mem_info->regmap, reg_labels[i].value, &reg_val);
+		count = snprintf(buf + ret, PAGE_SIZE - ret,
+			"%-23s[0x%02X]: 0x%08X\n",
+			reg_labels[i].name,
+			(reg_labels[i].value), reg_val);
+		if (count > 0) {
+			ret += count;
+		} else {
+			dev_err(dev, "snprintf [i=%d] error=%d.\n", i, count);
+			break;
+		}
+		if (ret > PAGE_SIZE) {
+			ret = PAGE_SIZE;
+			break;
+		}
+		i++;
+	}
+
+	return ret;
+}
+
+/* ex:
+ *param 1: 0 read;1 write
+ *param 2: reg value;
+ *param 3: write value;
+	read:
+		echo 0,0x0 > dmic_reg
+	write:
+		echo 1,0x00,0xa > dmic_reg
+*/
+static ssize_t store_dmic_reg(struct device *dev, struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	int ret;
+	int rw_flag;
+	int reg_val_read;
+	unsigned int input_reg_val = 0;
+	unsigned int input_reg_offset = 0;
+	struct sunxi_dmic_info *sunxi_dmic = dev_get_drvdata(dev);
+	struct sunxi_dmic_dts_info *dts_info = NULL;
+	struct sunxi_dmic_mem_info *mem_info = NULL;
+
+	if (IS_ERR_OR_NULL(sunxi_dmic)) {
+		dev_err(dev, "sunxi_dmic is NULL!\n");
+		return count;
+	}
+	dts_info = &sunxi_dmic->dts_info;
+	mem_info = &sunxi_dmic->mem_info;
+
+	ret = sscanf(buf, "%d,0x%x,0x%x", &rw_flag, &input_reg_offset,
+			&input_reg_val);
+
+	if (ret == 3 || ret == 2) {
+		if (!(rw_flag == 1 || rw_flag == 0)) {
+			dev_err(dev, "rw_flag should be 0(read) or 1(write).\n");
+			return count;
+		}
+		if (input_reg_offset > SUNXI_DMIC_REG_MAX) {
+			pr_err("the reg offset is invalid! [0x0 - 0x%x]\n",
+				SUNXI_DMIC_REG_MAX);
+			return count;
+		}
+		if (rw_flag) {
+			regmap_write(mem_info->regmap, input_reg_offset,
+					input_reg_val);
+		}
+		regmap_read(mem_info->regmap, input_reg_offset, &reg_val_read);
+		pr_err("\n\n Reg[0x%x] : 0x%x\n\n", input_reg_offset, reg_val_read);
+	} else {
+		pr_err("ret:%d, The num of params invalid!\n", ret);
+		pr_err("\nExample(reg range:0x0 - 0x%x):\n", SUNXI_DMIC_REG_MAX);
+		pr_err("\nRead reg[0x04]:\n");
+		pr_err("      echo 0,0x04 > dmic_reg\n");
+		pr_err("Write reg[0x04]=0x10\n");
+		pr_err("      echo 1,0x04,0x10 > dmic_reg\n");
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(dmic_reg, 0644, show_dmic_reg, store_dmic_reg);
+
+static struct attribute *audio_debug_attrs[] = {
+	&dev_attr_dmic_reg.attr,
+	NULL,
+};
+
+static struct attribute_group dmic_debug_attr_group = {
+	.name	= "dmic_debug",
+	.attrs	= audio_debug_attrs,
+};
+#endif
+
+/*
+ * Configure DMA , Chan enable & Global enable
+ */
+static void sunxi_dmic_enable(struct sunxi_dmic_info *sunxi_dmic, bool enable)
+{
+	struct sunxi_dmic_mem_info *mem_info = NULL;
+
+	if (IS_ERR_OR_NULL(sunxi_dmic)) {
+		pr_err("[%s] sunxi_dmic is NULL!\n", __func__);
+		return;
+	}
+	mem_info = &sunxi_dmic->mem_info;
+
+	if (enable) {
+		regmap_update_bits(mem_info->regmap, SUNXI_DMIC_INTC,
+				(0x1 << FIFO_DRQ_EN), (0x1 << FIFO_DRQ_EN));
+		regmap_update_bits(mem_info->regmap, SUNXI_DMIC_EN,
+				(0xFF << DATA_CH_EN),
+				(sunxi_dmic->chan_en << DATA_CH_EN));
+		regmap_update_bits(mem_info->regmap, SUNXI_DMIC_EN,
+				(0x1 << GLOBE_EN), (0x1 << GLOBE_EN));
+
+		if (sunxi_dmic->rx_sync_en) {
+			sunxi_rx_sync_control(sunxi_dmic->rx_sync_domain,
+					sunxi_dmic->rx_sync_id, 1);
+		}
+	} else {
+		regmap_update_bits(mem_info->regmap, SUNXI_DMIC_EN,
+				(0x1 << GLOBE_EN), (0x0 << GLOBE_EN));
+		regmap_update_bits(mem_info->regmap, SUNXI_DMIC_EN,
+				(0xFF << DATA_CH_EN),
+				(0x0 << DATA_CH_EN));
+		regmap_update_bits(mem_info->regmap, SUNXI_DMIC_INTC,
+				(0x1 << FIFO_DRQ_EN),
+				(0x0 << FIFO_DRQ_EN));
+
+		if (sunxi_dmic->rx_sync_en) {
+			sunxi_rx_sync_control(sunxi_dmic->rx_sync_domain,
+					sunxi_dmic->rx_sync_id, 0);
+		}
+	}
+}
+
+static void sunxi_dmic_init(struct sunxi_dmic_info *sunxi_dmic)
+{
+	struct sunxi_dmic_dts_info *dts_info = NULL;
+	struct sunxi_dmic_mem_info *mem_info = NULL;
+
+	if (IS_ERR_OR_NULL(sunxi_dmic)) {
+		pr_err("[%s] sunxi_dmic is NULL!\n", __func__);
+		return;
+	}
+	dts_info = &sunxi_dmic->dts_info;
+	mem_info = &sunxi_dmic->mem_info;
+
+	regmap_write(mem_info->regmap, SUNXI_DMIC_CH_MAP, dts_info->rx_chmap);
+
+	if (sunxi_dmic->rx_sync_en) {
+		regmap_update_bits(mem_info->regmap, SUNXI_DMIC_CTR,
+				(0x7 << DMICDFEN), (0x0 << DMICDFEN));
+		regmap_update_bits(mem_info->regmap, SUNXI_DMIC_EN,
+				(0x1 << DMIC_RX_EN_MUX), (0x1 << DMIC_RX_EN_MUX));
+	} else {
+		regmap_update_bits(mem_info->regmap, SUNXI_DMIC_CTR,
+				(0x7 << DMICDFEN), (0x7 << DMICDFEN));
+	}
+
+	/* set the vol */
+	regmap_update_bits(mem_info->regmap, SUNXI_DMIC_DATA0_1_VOL,
+			(0xFF << DATA0L_VOL) | (0xFF << DATA0R_VOL),
+			(dts_info->data_vol << DATA0L_VOL) |
+			(dts_info->data_vol << DATA0R_VOL));
+	regmap_update_bits(mem_info->regmap, SUNXI_DMIC_DATA0_1_VOL,
+			(0xFF << DATA1L_VOL) | (0xFF << DATA1R_VOL),
+			(dts_info->data_vol << DATA1L_VOL) |
+			(dts_info->data_vol << DATA1R_VOL));
+
+	regmap_update_bits(mem_info->regmap, SUNXI_DMIC_DATA2_3_VOL,
+			(0xFF << DATA2L_VOL) | (0xFF << DATA2R_VOL),
+			(dts_info->data_vol << DATA2L_VOL) |
+			(dts_info->data_vol << DATA2R_VOL));
+	regmap_update_bits(mem_info->regmap, SUNXI_DMIC_DATA2_3_VOL,
+			(0xFF << DATA3L_VOL) | (0xFF << DATA3R_VOL),
+			(dts_info->data_vol << DATA3L_VOL) |
+			(dts_info->data_vol << DATA3R_VOL));
+}
+
+static int sunxi_dmic_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct sunxi_dmic_info *sunxi_dmic = snd_soc_dai_get_drvdata(dai);
+	int i;
+	struct sunxi_dmic_dts_info *dts_info = NULL;
+	struct sunxi_dmic_mem_info *mem_info = NULL;
+
+	if (IS_ERR_OR_NULL(sunxi_dmic)) {
+		dev_err(dai->dev, "sunxi_dmic is NULL!\n");
+		return -ENOMEM;
+	}
+	dts_info = &sunxi_dmic->dts_info;
+	mem_info = &sunxi_dmic->mem_info;
+
+	/* sample resolution & sample fifo format */
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		regmap_update_bits(mem_info->regmap, SUNXI_DMIC_FIFO_CTR,
+				(0x1 << DMIC_SAMPLE_RESOLUTION),
+				(0x0 << DMIC_SAMPLE_RESOLUTION));
+		regmap_update_bits(mem_info->regmap, SUNXI_DMIC_FIFO_CTR,
+				(0x1 << DMIC_FIFO_MODE),
+				(0x1 << DMIC_FIFO_MODE));
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		regmap_update_bits(mem_info->regmap, SUNXI_DMIC_FIFO_CTR,
+				(0x1 << DMIC_SAMPLE_RESOLUTION),
+				(0x1 << DMIC_SAMPLE_RESOLUTION));
+		regmap_update_bits(mem_info->regmap, SUNXI_DMIC_FIFO_CTR,
+				(0x1 << DMIC_FIFO_MODE),
+				(0x0 << DMIC_FIFO_MODE));
+		break;
+	default:
+		dev_err(sunxi_dmic->dev, "Invalid format set\n");
+		return -EINVAL;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(dmic_rate_s); i++) {
+		if (dmic_rate_s[i].samplerate == params_rate(params)) {
+			regmap_update_bits(mem_info->regmap, SUNXI_DMIC_SR,
+			(0x7 << DMIC_SR),
+			(dmic_rate_s[i].rate_bit << DMIC_SR));
+			break;
+		}
+	}
+
+	/* oversamplerate adjust */
+	if (params_rate(params) >= 24000) {
+		regmap_update_bits(mem_info->regmap, SUNXI_DMIC_CTR,
+			(1 << DMIC_OVERSAMPLE_RATE),
+			(1 << DMIC_OVERSAMPLE_RATE));
+	} else {
+		regmap_update_bits(mem_info->regmap, SUNXI_DMIC_CTR,
+			(1 << DMIC_OVERSAMPLE_RATE),
+			(0 << DMIC_OVERSAMPLE_RATE));
+	}
+
+	sunxi_dmic->chan_en = (1 << params_channels(params)) - 1;
+	regmap_write(mem_info->regmap, SUNXI_DMIC_HPF_CTRL, sunxi_dmic->chan_en);
+
+	/* DMIC num is M+1 */
+	regmap_update_bits(mem_info->regmap, SUNXI_DMIC_CH_NUM,
+		(0x7 << DMIC_CH_NUM),
+		((params_channels(params) - 1) << DMIC_CH_NUM));
+
+	return 0;
+}
+
+static int sunxi_dmic_trigger(struct snd_pcm_substream *substream,
+				int cmd, struct snd_soc_dai *dai)
+{
+	int ret = 0;
+	struct sunxi_dmic_info *sunxi_dmic = snd_soc_dai_get_drvdata(dai);
+
+	if (IS_ERR_OR_NULL(sunxi_dmic)) {
+		dev_err(dai->dev, "sunxi_dmic is NULL!\n");
+		return -ENOMEM;
+	}
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		sunxi_dmic_enable(sunxi_dmic, true);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		sunxi_dmic_enable(sunxi_dmic, false);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+/*
+ * Reset & Flush FIFO
+ */
+static int sunxi_dmic_prepare(struct snd_pcm_substream *substream,
+			struct snd_soc_dai *dai)
+{
+	struct sunxi_dmic_info *sunxi_dmic = snd_soc_dai_get_drvdata(dai);
+	struct sunxi_dmic_dts_info *dts_info = NULL;
+	struct sunxi_dmic_mem_info *mem_info = NULL;
+	unsigned int i = 0;
+
+	if (IS_ERR_OR_NULL(sunxi_dmic)) {
+		dev_err(dai->dev, "sunxi_dmic is NULL!\n");
+		return -ENOMEM;
+	}
+	dts_info = &sunxi_dmic->dts_info;
+	mem_info = &sunxi_dmic->mem_info;
+
+	regmap_write(mem_info->regmap, SUNXI_DMIC_INTS,
+			(1 << FIFO_OVERRUN_IRQ_PENDING) |
+			(1 << FIFO_DATA_IRQ_PENDING));
+
+	for (i = 0; i < SUNXI_DMIC_FTX_TIMES; i++) {
+		regmap_update_bits(mem_info->regmap, SUNXI_DMIC_FIFO_CTR,
+			(1 << DMIC_FIFO_FLUSH), (1 << DMIC_FIFO_FLUSH));
+		regmap_write(mem_info->regmap, SUNXI_DMIC_CNT, 0x1);
+		mdelay(1);
+	}
+
+	return 0;
+}
+
+static void sunxi_dmic_rx_enable(void *data, bool enable)
+{
+	struct snd_soc_component *component = data;
+	struct sunxi_dmic_info *sunxi_dmic = snd_soc_component_get_drvdata(component);
+	struct sunxi_dmic_mem_info *mem_info = NULL;
+
+	mem_info = &sunxi_dmic->mem_info;
+	if (enable)
+		regmap_update_bits(mem_info->regmap, SUNXI_DMIC_EN,
+			(1 << DMIC_RX_SYNC_EN), (1 << DMIC_RX_SYNC_EN));
+	else
+		regmap_update_bits(mem_info->regmap, SUNXI_DMIC_EN,
+			(1 << DMIC_RX_SYNC_EN), (0 << DMIC_RX_SYNC_EN));
+
+}
+
+static int sunxi_dmic_startup(struct snd_pcm_substream *substream,
+			struct snd_soc_dai *dai)
+{
+	struct sunxi_dmic_info *sunxi_dmic = snd_soc_dai_get_drvdata(dai);
+
+	if (IS_ERR_OR_NULL(sunxi_dmic)) {
+		dev_err(dai->dev, "sunxi_dmic is NULL!\n");
+		return -ENOMEM;
+	}
+
+	snd_soc_dai_set_dma_data(dai, substream,
+				&sunxi_dmic->capture_dma_param);
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE &&
+		sunxi_dmic->rx_sync_en) {
+		sunxi_rx_sync_startup((void *)dai->component,
+			sunxi_dmic->rx_sync_domain, sunxi_dmic->rx_sync_id,
+			sunxi_dmic_rx_enable);
+	}
+
+	return 0;
+}
+
+static int sunxi_dmic_set_sysclk(struct snd_soc_dai *dai, int clk_id,
+						unsigned int freq, int dir)
+{
+
+	struct snd_soc_component *component = dai->component;
+	struct sunxi_dmic_info *sunxi_dmic = snd_soc_component_get_drvdata(component);
+	struct sunxi_dmic_dts_info *dts_info = NULL;
+	struct sunxi_dmic_clk_info *clk_info = NULL;
+
+	if (IS_ERR_OR_NULL(sunxi_dmic)) {
+		dev_err(dai->dev, "sunxi_dmic is NULL!\n");
+		return -ENOMEM;
+	}
+	dts_info = &sunxi_dmic->dts_info;
+	clk_info = &sunxi_dmic->clk_info;
+
+	sunxi_dmic_init(sunxi_dmic);
+
+	switch (clk_info->clk_parent) {
+	case DMIC_CLK_PLL_AUDIO_X1:
+		if (clk_set_rate(clk_info->clk_pll, freq)) {
+			dev_err(dai->dev, "Freq : %u not support\n", freq);
+			return -EINVAL;
+		}
+		break;
+	default:
+	case DMIC_CLK_PLL_AUDIO_X4:
+		if (clk_set_rate(clk_info->clk_pll, freq * 4)) {
+			dev_err(dai->dev, "Freq : %u not support\n", freq * 4);
+			return -EINVAL;
+		}
+		break;
+	}
+
+	if (clk_set_rate(clk_info->clk_pll, freq)) {
+		dev_err(dai->dev, "Freq : %u not support\n", freq);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/* Dmic module init status */
+static int sunxi_dmic_probe(struct snd_soc_dai *dai)
+{
+	struct sunxi_dmic_info *sunxi_dmic = snd_soc_dai_get_drvdata(dai);
+
+	if (IS_ERR_OR_NULL(sunxi_dmic)) {
+		dev_err(dai->dev, "sunxi_dmic is NULL!\n");
+		return -ENOMEM;
+	}
+
+	/* pcm_new will using the dma_param about the cma and fifo params. */
+	snd_soc_dai_init_dma_data(dai, NULL, &sunxi_dmic->capture_dma_param);
+
+	sunxi_dmic_init(sunxi_dmic);
+
+	return 0;
+}
+
+static int sunxi_dmic_suspend(struct snd_soc_dai *cpu_dai)
+{
+	struct sunxi_dmic_info *sunxi_dmic = snd_soc_dai_get_drvdata(cpu_dai);
+	struct sunxi_dmic_dts_info *dts_info = NULL;
+	struct sunxi_dmic_clk_info *clk_info = NULL;
+	struct sunxi_dmic_pinctl_info *pin_info = NULL;
+	u32 ret = 0;
+
+	pr_alert("[DMIC]Enter %s\n", __func__);
+
+	if (IS_ERR_OR_NULL(sunxi_dmic)) {
+		dev_err(cpu_dai->dev, "sunxi_dmic is NULL!\n");
+		return -ENOMEM;
+	}
+
+	dts_info = &sunxi_dmic->dts_info;
+	clk_info = &sunxi_dmic->clk_info;
+	pin_info = &sunxi_dmic->pin_info;
+
+	ret = pinctrl_select_state(pin_info->pinctrl, pin_info->pinstate_sleep);
+	if (ret != 0) {
+		dev_err(cpu_dai->dev, "[dmic] select pin sleep state failed\n");
+		goto err_suspend_pinctl_select;
+	}
+
+	clk_disable_unprepare(clk_info->clk_module);
+	clk_disable_unprepare(clk_info->clk_pll);
+	clk_disable_unprepare(clk_info->clk_bus);
+	reset_control_assert(clk_info->clk_rst);
+
+	pr_alert("[DMIC]End %s\n", __func__);
+
+	return 0;
+
+err_suspend_pinctl_select:
+	return ret;
+}
+
+static int sunxi_dmic_resume(struct snd_soc_dai *cpu_dai)
+{
+	struct sunxi_dmic_info *sunxi_dmic = snd_soc_dai_get_drvdata(cpu_dai);
+	struct sunxi_dmic_mem_info *mem_info = NULL;
+	struct sunxi_dmic_clk_info *clk_info = NULL;
+	struct sunxi_dmic_pinctl_info *pin_info = NULL;
+	s32 ret = 0;
+
+	pr_alert("[DMIC]Enter %s\n", __func__);
+
+	if (IS_ERR_OR_NULL(sunxi_dmic)) {
+		dev_err(cpu_dai->dev, "sunxi_dmic is NULL!\n");
+		return -ENOMEM;
+	}
+
+	mem_info = &sunxi_dmic->mem_info;
+	clk_info = &sunxi_dmic->clk_info;
+	pin_info = &sunxi_dmic->pin_info;
+
+	if (reset_control_deassert(clk_info->clk_rst)) {
+		pr_err("dmic: resume deassert the dmic reset failed\n");
+		return -EINVAL;
+	}
+	if (clk_prepare_enable(clk_info->clk_bus)) {
+		dev_err(sunxi_dmic->dev, "enable dmic bus clk failed, resume exit\n");
+		goto err_resume_clk_enable_bus;
+	}
+	if (clk_prepare_enable(clk_info->clk_pll)) {
+		pr_err("enable clk_info->clk_pll failed!\n");
+		ret = -EBUSY;
+		goto err_resume_clk_enable_pll;
+	}
+	if (clk_prepare_enable(clk_info->clk_module)) {
+		dev_err(cpu_dai->dev, "enable clk_info->clk_module failed!\n");
+		ret = -EBUSY;
+		goto err_resume_clk_enable_module;
+	}
+
+	ret = pinctrl_select_state(pin_info->pinctrl, pin_info->pinstate);
+	if (ret != 0) {
+		dev_err(cpu_dai->dev, "select pinstate failed!\n");
+		goto err_resume_pinctl_select;
+	}
+
+	sunxi_dmic_init(sunxi_dmic);
+
+	pr_debug("[DMIC]End %s\n", __func__);
+
+	return 0;
+
+err_resume_pinctl_select:
+	clk_disable_unprepare(clk_info->clk_module);
+err_resume_clk_enable_module:
+	clk_disable_unprepare(clk_info->clk_pll);
+err_resume_clk_enable_pll:
+	clk_disable_unprepare(clk_info->clk_bus);
+err_resume_clk_enable_bus:
+	reset_control_assert(clk_info->clk_rst);
+	return ret;
+}
+
+static void sunxi_dmic_shutdown(struct snd_pcm_substream *substream,
+			struct snd_soc_dai *dai)
+{
+	struct sunxi_dmic_info *sunxi_dmic = snd_soc_dai_get_drvdata(dai);
+	struct sunxi_dmic_clk_info *clk_info = NULL;
+
+	if (IS_ERR_OR_NULL(sunxi_dmic)) {
+		dev_err(dai->dev, "sunxi_dmic is NULL!\n");
+		return;
+	}
+	clk_info = &sunxi_dmic->clk_info;
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE &&
+		sunxi_dmic->rx_sync_en) {
+		sunxi_rx_sync_shutdown(sunxi_dmic->rx_sync_domain,
+			sunxi_dmic->rx_sync_id);
+	}
+}
+
+static struct snd_soc_dai_ops sunxi_dmic_dai_ops = {
+	.startup = sunxi_dmic_startup,
+	.set_sysclk = sunxi_dmic_set_sysclk,
+	.hw_params = sunxi_dmic_hw_params,
+	.prepare = sunxi_dmic_prepare,
+	.trigger = sunxi_dmic_trigger,
+	.shutdown = sunxi_dmic_shutdown,
+};
+
+static struct snd_soc_dai_driver sunxi_dmic_dai = {
+	.probe = sunxi_dmic_probe,
+	.suspend = sunxi_dmic_suspend,
+	.resume = sunxi_dmic_resume,
+	.capture = {
+		.channels_min = 1,
+		.channels_max = 8,
+		.rates = SUNXI_DMIC_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE,
+	},
+	.ops = &sunxi_dmic_dai_ops,
+};
+
+static const struct snd_soc_component_driver sunxi_dmic_component = {
+	.name = DRV_NAME,
+};
+
+/*****************************************************************************/
+static const struct regmap_config sunxi_dmic_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = SUNXI_DMIC_REG_MAX,
+	.cache_type = REGCACHE_NONE,
+};
+
+static int sunxi_dmic_mem_init(struct platform_device *pdev,
+		struct device_node *np, struct sunxi_dmic_info *sunxi_dmic)
+{
+	struct sunxi_dmic_mem_info *mem_info = &sunxi_dmic->mem_info;
+	int ret = 0;
+
+	ret = of_address_to_resource(np, 0, &mem_info->res);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "Failed to get sunxi dmic resource\n");
+		ret = -EINVAL;
+		goto err_np_get_addr_res;
+	}
+
+	/* for get mem info */
+	mem_info->memregion = devm_request_mem_region(&pdev->dev, mem_info->res.start,
+					    resource_size(&mem_info->res), DRV_NAME);
+	if (IS_ERR_OR_NULL(mem_info->memregion)) {
+		dev_err(&pdev->dev, "sunxi dmic memory region already claimed\n");
+		ret = -EBUSY;
+		goto err_devm_request_mem;
+	}
+
+	/* Managed ioremap().  Map is automatically unmapped on driver detach. */
+	mem_info->membase = devm_ioremap(&pdev->dev, mem_info->res.start,
+					resource_size(&mem_info->res));
+	if (IS_ERR_OR_NULL(mem_info->membase)) {
+		dev_err(&pdev->dev, "sunxi dmic ioremap failed\n");
+		ret = -ENOMEM;
+		goto err_devm_ioremap;
+	}
+	mem_info->regmap = devm_regmap_init_mmio(&pdev->dev,
+				mem_info->membase, &sunxi_dmic_regmap_config);
+	if (IS_ERR_OR_NULL(mem_info->regmap)) {
+		dev_err(&pdev->dev, "sunxi dmic registers regmap failed\n");
+		ret = -ENOMEM;
+		goto err_devm_regmap_init;
+	}
+
+	return 0;
+
+err_devm_regmap_init:
+err_devm_ioremap:
+	devm_release_mem_region(&pdev->dev, mem_info->memregion->start,
+				resource_size(mem_info->memregion));
+err_devm_request_mem:
+err_np_get_addr_res:
+	devm_kfree(&pdev->dev, sunxi_dmic);
+	return ret;
+};
+
+static int sunxi_dmic_clk_init(struct platform_device *pdev,
+		struct device_node *np, struct sunxi_dmic_info *sunxi_dmic)
+{
+	struct sunxi_dmic_clk_info *clk_info = &sunxi_dmic->clk_info;
+	unsigned int temp_val = 0;
+	int ret = 0;
+
+	ret = of_property_read_u32(np, "clk_parent", &temp_val);
+	if (ret != 0) {
+		dev_warn(&pdev->dev, "clk_parent config missing or invalid.\n");
+		clk_info->clk_parent = DMIC_CLK_PLL_AUDIO_X1;
+	} else {
+		clk_info->clk_parent = temp_val;
+	}
+
+	/* to get clk info */
+	clk_info->clk_pll = of_clk_get_by_name(np, "pll_audio");
+	clk_info->clk_module = of_clk_get_by_name(np, "dmic");
+	clk_info->clk_bus = of_clk_get_by_name(np, "dmic_bus");
+	clk_info->clk_rst = devm_reset_control_get(&pdev->dev, NULL);
+
+	if (clk_set_parent(clk_info->clk_module, clk_info->clk_pll)) {
+		dev_err(&pdev->dev,
+			"set parent of clk_module to clk_pll failed!\n");
+		ret = -EINVAL;
+		goto err_clk_set_parent;
+	}
+
+	if (reset_control_deassert(clk_info->clk_rst)) {
+		pr_err("dmic: deassert the dmic reset failed\n");
+		return -EINVAL;
+	}
+	if (clk_prepare_enable(clk_info->clk_bus)) {
+		dev_err(&pdev->dev, "dmic clk bus enable failed\n");
+		ret = -EBUSY;
+		goto err_clk_enable_bus;
+	}
+	if (clk_prepare_enable(clk_info->clk_pll)) {
+		dev_err(&pdev->dev, "clk_pll enable failed\n");
+		ret = -EBUSY;
+		goto err_clk_pll_enable;
+	}
+	if (clk_prepare_enable(clk_info->clk_module)) {
+		dev_err(&pdev->dev, "clk_module enable failed\n");
+		ret = -EBUSY;
+		goto err_clk_module_enable;
+	}
+
+	return 0;
+
+err_clk_module_enable:
+	clk_disable_unprepare(clk_info->clk_pll);
+err_clk_pll_enable:
+err_clk_set_parent:
+	clk_put(clk_info->clk_bus);
+err_clk_enable_bus:
+	reset_control_assert(clk_info->clk_rst);
+	return ret;
+};
+
+static int sunxi_dmic_pinctrl_init(struct platform_device *pdev,
+					struct sunxi_dmic_info *sunxi_dmic)
+{
+	struct sunxi_dmic_pinctl_info *pin_info = &sunxi_dmic->pin_info;
+	int ret = 0;
+
+	/* for get pin info */
+	pin_info->pinctrl = devm_pinctrl_get(&pdev->dev);
+	if (IS_ERR_OR_NULL(pin_info->pinctrl)) {
+		dev_err(&pdev->dev, "request pinctrl handle for audio failed\n");
+		ret =  -EINVAL;
+		goto err_devm_pin_get;
+	}
+	pin_info->pinstate = pinctrl_lookup_state(pin_info->pinctrl,
+						PINCTRL_STATE_DEFAULT);
+	if (IS_ERR_OR_NULL(pin_info->pinstate)) {
+		dev_err(&pdev->dev, "lookup pin default state failed\n");
+		ret = -EINVAL;
+		goto err_pinctrl_lookup_sate;
+	}
+	pin_info->pinstate_sleep = pinctrl_lookup_state(pin_info->pinctrl,
+						PINCTRL_STATE_SLEEP);
+	if (IS_ERR_OR_NULL(pin_info->pinstate_sleep)) {
+		dev_err(&pdev->dev, "lookup pin sleep state failed\n");
+		ret = -EINVAL;
+		goto err_pinctrl_lookup_sleep;
+	}
+	/*only until this step , can the pinctrl system find pin conlict*/
+	ret = pinctrl_select_state(pin_info->pinctrl, pin_info->pinstate);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "pin select state failed\n");
+		ret = -EINVAL;
+		goto err_pinctrl_select_state;
+	}
+
+	return 0;
+
+err_pinctrl_select_state:
+err_pinctrl_lookup_sleep:
+err_pinctrl_lookup_sate:
+err_devm_pin_get:
+	devm_pinctrl_put(pin_info->pinctrl);
+	return ret;
+};
+
+static int sunxi_dmic_dts_params_init(struct platform_device *pdev,
+		struct device_node *np, struct sunxi_dmic_info *sunxi_dmic)
+{
+	struct sunxi_dmic_dts_info *dts_info = &sunxi_dmic->dts_info;
+	unsigned int temp_val = 0;
+	int ret = 0;
+
+	/* for get other dts info */
+	ret = of_property_read_u32(np, "rx_chmap", &temp_val);
+	if (ret != 0) {
+		dev_warn(&pdev->dev, "rx_chmap config missing or invalid.\n");
+		dts_info->rx_chmap = DMIC_CHANMAP_DEFAULT;
+	} else {
+		dts_info->rx_chmap = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "data_vol", &temp_val);
+	if (ret != 0) {
+		dev_warn(&pdev->dev, "data_vol config missing or invalid.\n");
+		dts_info->data_vol = DMIC_DEFAULT_VOL;
+	} else {
+		dts_info->data_vol = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "capture_cma", &temp_val);
+	if (ret != 0) {
+		dev_warn(&pdev->dev, "capture cma kbytes config missing or invalid.\n");
+		dts_info->capture_cma = SUNXI_AUDIO_CMA_MAX_KBYTES;
+	} else {
+		if (temp_val > SUNXI_AUDIO_CMA_MAX_KBYTES)
+			temp_val = SUNXI_AUDIO_CMA_MAX_KBYTES;
+		else if (temp_val < SUNXI_AUDIO_CMA_MIN_KBYTES)
+			temp_val = SUNXI_AUDIO_CMA_MIN_KBYTES;
+		dts_info->capture_cma = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "rx_sync_en", &temp_val);
+	if (ret != 0) {
+		dev_warn(&pdev->dev, "rx_sync_en config missing or invalid.\n");
+		sunxi_dmic->rx_sync_en = 0;
+	} else {
+		sunxi_dmic->rx_sync_en = temp_val;
+	}
+
+	if (sunxi_dmic->rx_sync_en) {
+		sunxi_dmic->rx_sync_domain = RX_SYNC_SYS_DOMAIN;
+		sunxi_dmic->rx_sync_id =
+			sunxi_rx_sync_probe(sunxi_dmic->rx_sync_domain);
+		if (sunxi_dmic->rx_sync_id < 0) {
+			dev_err(&pdev->dev, "sunxi_rx_sync_probe failed\n");
+			return -EINVAL;
+		}
+		dev_info(&pdev->dev, "sunxi_rx_sync_probe successful. domain=%d, id=%d\n",
+			sunxi_dmic->rx_sync_domain,
+			sunxi_dmic->rx_sync_id);
+	}
+
+	return 0;
+};
+
+static void sunxi_dmic_dma_params_init(struct resource res,
+					struct sunxi_dmic_info *sunxi_dmic)
+{
+	struct sunxi_dmic_dts_info *dts_info = &sunxi_dmic->dts_info;
+
+	sunxi_dmic->capture_dma_param.dma_addr = res.start + SUNXI_DMIC_DATA;
+	sunxi_dmic->capture_dma_param.src_maxburst = 8;
+	sunxi_dmic->capture_dma_param.dst_maxburst = 8;
+	sunxi_dmic->capture_dma_param.cma_kbytes = dts_info->capture_cma;
+	sunxi_dmic->capture_dma_param.fifo_size = DMIC_RX_FIFO_SIZE;
+};
+
+static int sunxi_dmic_dev_probe(struct platform_device *pdev)
+{
+	struct sunxi_dmic_info *sunxi_dmic = NULL;
+	struct sunxi_dmic_mem_info *mem_info = NULL;
+	struct sunxi_dmic_clk_info *clk_info = NULL;
+	struct sunxi_dmic_dts_info *dts_info = NULL;
+	struct sunxi_dmic_pinctl_info *pin_info = NULL;
+	struct device_node *np = pdev->dev.of_node;
+	int ret;
+
+	sunxi_dmic = devm_kzalloc(&pdev->dev, sizeof(struct sunxi_dmic_info), GFP_KERNEL);
+	if (IS_ERR_OR_NULL(sunxi_dmic)) {
+		dev_err(&pdev->dev, "sunxi_dmic allocate failed\n");
+		return -ENOMEM;
+	}
+	dev_set_drvdata(&pdev->dev, sunxi_dmic);
+
+	sunxi_dmic->dev = &pdev->dev;
+	sunxi_dmic->dai = sunxi_dmic_dai;
+	sunxi_dmic->dai.name = dev_name(&pdev->dev);
+	mem_info = &sunxi_dmic->mem_info;
+	clk_info = &sunxi_dmic->clk_info;
+	dts_info = &sunxi_dmic->dts_info;
+	pin_info = &sunxi_dmic->pin_info;
+
+	/* mem init about */
+	ret = sunxi_dmic_mem_init(pdev, np, sunxi_dmic);
+	if (ret) {
+		dev_err(&pdev->dev, "[%s] failed\n", __func__);
+		ret = -EINVAL;
+		return ret;
+	}
+
+	/* clk init about */
+	ret = sunxi_dmic_clk_init(pdev, np, sunxi_dmic);
+	if (ret) {
+		dev_err(&pdev->dev, "[%s] failed\n", __func__);
+		ret = -EINVAL;
+		return ret;
+	}
+
+	/* pinctrl init about */
+	ret = sunxi_dmic_pinctrl_init(pdev, sunxi_dmic);
+	if (ret) {
+		dev_err(&pdev->dev, "[%s] failed\n", __func__);
+		ret = -EINVAL;
+		return ret;
+	}
+
+	/* dts params about */
+	ret = sunxi_dmic_dts_params_init(pdev, np, sunxi_dmic);
+	if (ret) {
+		dev_err(&pdev->dev, "[%s] failed\n", __func__);
+		ret = -EINVAL;
+		return ret;
+	}
+
+	/* dmic dma params about */
+	sunxi_dmic_dma_params_init(sunxi_dmic->mem_info.res, sunxi_dmic);
+
+	/*
+	 * Register a component with automatic unregistration when the device is
+	 * unregistered.
+	 */
+	ret = devm_snd_soc_register_component(&pdev->dev, &sunxi_dmic_component,
+				   &sunxi_dmic->dai, 1);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "Could not register DAI: %d\n", ret);
+		ret = -ENOMEM;
+		goto err_devm_register_component;
+	}
+
+	/*
+	 * Register a platform driver with automatic unregistration when the device is
+	 * unregistered.
+	 */
+	ret = asoc_dma_platform_register(&pdev->dev, 0);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "Could not register PCM: %d\n", ret);
+		ret = -ENOMEM;
+		goto err_platform_register;
+	}
+
+#ifdef SUNXI_DMIC_DEBUG
+	ret  = sysfs_create_group(&pdev->dev.kobj, &dmic_debug_attr_group);
+	if (ret)
+		dev_err(&pdev->dev, "failed to create attr group\n");
+#endif
+
+	return 0;
+
+err_platform_register:
+err_devm_register_component:
+	devm_kfree(&pdev->dev, sunxi_dmic);
+	return ret;
+}
+
+static int __exit sunxi_dmic_dev_remove(struct platform_device *pdev)
+{
+	struct sunxi_dmic_info *sunxi_dmic = NULL;
+	struct sunxi_dmic_mem_info *mem_info = NULL;
+	struct sunxi_dmic_clk_info *clk_info = NULL;
+	struct sunxi_dmic_pinctl_info *pin_info = NULL;
+
+	sunxi_dmic = platform_get_drvdata(pdev);
+	if (IS_ERR_OR_NULL(sunxi_dmic)) {
+		dev_err(&pdev->dev, "sunxi_dmic is NULL!\n");
+		return -ENOMEM;
+	}
+
+	mem_info = &sunxi_dmic->mem_info;
+	clk_info = &sunxi_dmic->clk_info;
+	pin_info = &sunxi_dmic->pin_info;
+
+	if (sunxi_dmic->rx_sync_en)
+		sunxi_rx_sync_remove(sunxi_dmic->rx_sync_domain);
+
+#ifdef SUNXI_DMIC_DEBUG
+	sysfs_remove_group(&pdev->dev.kobj, &dmic_debug_attr_group);
+#endif
+
+	clk_disable_unprepare(clk_info->clk_module);
+	clk_put(clk_info->clk_module);
+	clk_disable_unprepare(clk_info->clk_pll);
+	clk_put(clk_info->clk_pll);
+	clk_disable_unprepare(clk_info->clk_bus);
+	clk_put(clk_info->clk_bus);
+	reset_control_assert(clk_info->clk_rst);
+
+	snd_soc_unregister_component(&pdev->dev);
+
+	devm_pinctrl_put(pin_info->pinctrl);
+	devm_release_mem_region(&pdev->dev, mem_info->memregion->start,
+				resource_size(mem_info->memregion));
+
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+static const struct of_device_id sunxi_dmic_of_match[] = {
+	{ .compatible = "allwinner,sunxi-dmic", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, sunxi_dmic_of_match);
+
+static struct platform_driver sunxi_dmic_driver = {
+	.probe = sunxi_dmic_dev_probe,
+	.remove = __exit_p(sunxi_dmic_dev_remove),
+	.driver = {
+		.name = DRV_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_dmic_of_match,
+	},
+};
+
+static int __init sunxi_dmic_driver_init(void)
+{
+	return platform_driver_register(&sunxi_dmic_driver);
+}
+module_init(sunxi_dmic_driver_init);
+
+static void __exit sunxi_dmic_driver_exit(void)
+{
+	platform_driver_unregister(&sunxi_dmic_driver);
+}
+module_exit(sunxi_dmic_driver_exit);
+
+MODULE_AUTHOR("yumingfeng <yumingfeng@allwinnertech.com>");
+MODULE_DESCRIPTION("SUNXI DMIC dmic ASoC driver");
+MODULE_ALIAS("platform:sunxi-dmic");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/sunxi/sunxi-dmic.h b/sound/soc/sunxi/sunxi-dmic.h
new file mode 100644
index 000000000..82e6e9f39
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-dmic.h
@@ -0,0 +1,204 @@
+/*
+ * sound\soc\sunxi\sunxi_dmic.h
+ * (C) Copyright 2019-2025
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * yumingfeng <yumingfeng@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __SUNXI_DMIC_H
+#define __SUNXI_DMIC_H
+
+#include "sunxi-pcm.h"
+
+/*------------------DMIC register definition--------------------*/
+#define SUNXI_DMIC_EN			0x00
+#define SUNXI_DMIC_SR			0x04
+#define SUNXI_DMIC_CTR			0x08
+#define SUNXI_DMIC_DATA			0x10
+#define SUNXI_DMIC_INTC			0x14
+#define SUNXI_DMIC_INTS			0x18
+#define SUNXI_DMIC_FIFO_CTR		0x1c
+#define SUNXI_DMIC_FIFO_STA		0x20
+#define SUNXI_DMIC_CH_NUM		0x24
+#define SUNXI_DMIC_CH_MAP		0x28
+#define SUNXI_DMIC_CNT			0x2c
+#define SUNXI_DMIC_DATA0_1_VOL		0x30
+#define SUNXI_DMIC_DATA2_3_VOL		0x34
+#define	SUNXI_DMIC_HPF_CTRL		0x38
+#define	SUNXI_DMIC_HPF_COEF		0x3C
+#define	SUNXI_DMIC_HPF_GAIN		0x40
+#define SUNXI_DMIC_REV			0x50
+#define SUNXI_DMIC_REG_MAX			SUNXI_DMIC_REV
+
+/*0x00:SUNXI_DMIC_EN*/
+#define DMIC_RX_SYNC_EN			29
+#define DMIC_RX_EN_MUX			28
+#define GLOBE_EN			8
+#define DATA3_CHR_EN			7
+#define DATA3_CHL_EN			6
+#define DATA2_CHR_EN			5
+#define DATA2_CHL_EN			4
+#define DATA1_CHR_EN			3
+#define DATA1_CHL_EN			2
+#define DATA0_CHR_EN			1
+#define DATA0_CHL_EN			0
+#define DATA_CH_EN			0
+
+/*SUNXI_DMIC_SR:0x04*/
+#define DMIC_SR				0
+
+/*SUNXI_DMIC_CTR:0x08*/
+#define DMICFDT				9
+#define DMICDFEN			8
+#define DATA3_LR_SWEEP_EN		7
+#define DATA2_LR_SWEEP_EN		6
+#define DATA1_LR_SWEEP_EN		5
+#define DATA0_LR_SWEEP_EN		4
+#define DMIC_OVERSAMPLE_RATE		0
+
+/*SUNXI_DMIC_DATA:0x10*/
+#define DMIC_DATA			0
+
+/*SUNXI_DMIC_INTC:0x14*/
+#define FIFO_DRQ_EN			2
+#define FIFO_OVERRUN_IRQ_EN		1
+#define DATA_IRQ_EN			0
+
+/*SUNXI_DMIC_INTS:0x18*/
+#define FIFO_OVERRUN_IRQ_PENDING	1
+#define FIFO_DATA_IRQ_PENDING		0
+
+/*SUNXI_DMIC_FIFO_CTR:0x1c*/
+#define DMIC_FIFO_FLUSH			31
+#define DMIC_FIFO_MODE			9
+#define DMIC_SAMPLE_RESOLUTION		8
+#define FIFO_TRG_LEVEL			0
+
+/*SUNXI_DMIC_FIFO_STA:0x20*/
+#define DMIC_DATA_CNT			0
+
+/*SUNXI_DMIC_CH_NUM:0x24*/
+#define DMIC_CH_NUM			0
+
+/*SUNXI_DMIC_CH_MAP:0x28*/
+#define DMIC_CH7_MAP			28
+#define DMIC_CH6_MAP			24
+#define DMIC_CH5_MAP			20
+#define DMIC_CH4_MAP			16
+#define DMIC_CH3_MAP			12
+#define DMIC_CH2_MAP			8
+#define DMIC_CH1_MAP			4
+#define DMIC_CH0_MAP			0
+#define DMIC_CHANMAP_DEFAULT		(0x76543210)
+/*SUNXI_DMIC_CNT:0x2c*/
+#define DMIC_CNT			0
+
+/*SUNXI_DMIC_DATA0_1_VOL:0x30*/
+#define DATA1L_VOL			24
+#define DATA1R_VOL			16
+#define DATA0L_VOL			8
+#define DATA0R_VOL			0
+
+/*SUNXI_DMIC_DATA2_3_VOL:0x34*/
+#define DATA3L_VOL			24
+#define DATA3R_VOL			16
+#define DATA2L_VOL			8
+#define DATA2R_VOL			0
+#define	DMIC_DEFAULT_VOL		0xB0
+
+/*SUNXI_DMIC_HPF_EN_CTR:0x38*/
+#define HPF_DATA3_CHR_EN		7
+#define HPF_DATA3_CHL_EN		6
+#define HPF_DATA2_CHR_EN		5
+#define HPF_DATA2_CHL_EN		4
+#define HPF_DATA1_CHR_EN		3
+#define HPF_DATA1_CHL_EN		2
+#define HPF_DATA0_CHR_EN		1
+#define HPF_DATA0_CHL_EN		0
+
+/*SUNXI_DMIC_HPF_COEF:0x3C*/
+#define HPF_COEF			0
+
+/*SUNXI_DMIC_HPF_GAIN:0x40*/
+#define HPF_GAIN			0
+
+struct sunxi_dmic_reg_label {
+	const char *name;
+	int value;
+};
+
+#define SUNXI_DMIC_REG_LABEL(constant) \
+{ \
+	#constant, constant \
+}
+
+#define SUNXI_DMIC_REG_LABEL_END \
+{ \
+	NULL, -1 \
+}
+
+/*to clear FIFO*/
+#define SUNXI_DMIC_FTX_TIMES	3
+#define DMIC_RX_FIFO_SIZE	128
+
+#define DMIC_CLK_PLL_AUDIO_X1	0
+#define DMIC_CLK_PLL_AUDIO_X4	1
+
+#define	SUNXI_DMIC_RATES (SNDRV_PCM_RATE_8000_48000 | SNDRV_PCM_RATE_KNOT)
+
+struct sunxi_dmic_mem_info {
+	struct resource res;
+	void __iomem *membase;
+	struct resource *memregion;
+	struct regmap   *regmap;
+};
+
+struct sunxi_dmic_clk_info {
+	struct clk *clk_pll;
+	struct clk *clk_module;
+	struct clk *clk_bus;
+	struct reset_control *clk_rst;
+
+	unsigned int clk_parent;
+};
+
+struct sunxi_dmic_pinctl_info {
+	struct pinctrl *pinctrl;
+	struct pinctrl_state  *pinstate;
+	struct pinctrl_state  *pinstate_sleep;
+};
+
+struct sunxi_dmic_dts_info {
+	/* value must be (2^n)Kbyte */
+	size_t playback_cma;
+	size_t capture_cma;
+
+	unsigned int rx_chmap;
+	unsigned int data_vol;
+};
+
+struct sunxi_dmic_info {
+	struct device *dev;
+	struct snd_soc_dai_driver dai;
+
+	struct sunxi_dmic_dts_info dts_info;
+	struct sunxi_dmic_mem_info mem_info;
+	struct sunxi_dmic_clk_info clk_info;
+	struct sunxi_dmic_pinctl_info pin_info;
+
+	struct sunxi_dma_params capture_dma_param;
+	unsigned int chan_en;
+
+	unsigned int rx_sync_en;
+	int rx_sync_id;
+	rx_sync_domain_t rx_sync_domain;
+};
+#endif /* SUNXI_DMIC_H */
diff --git a/sound/soc/sunxi/sunxi-dummy-cpudai.c b/sound/soc/sunxi/sunxi-dummy-cpudai.c
new file mode 100644
index 000000000..1b2a39eec
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-dummy-cpudai.c
@@ -0,0 +1,250 @@
+/*
+ * sound\soc\sunxi\sunxi-cpudai.c
+ * (C) Copyright 2014-2018
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * wolfgang huang <huangjinhui@allwinnertech.com>
+ * yumingfeng <yumingfeng@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+
+#include "sunxi-pcm.h"
+
+#define DRV_NAME "sunxi-dummy-cpudai"
+
+struct sunxi_cpudai_info {
+	struct sunxi_dma_params playback_dma_param;
+	struct sunxi_dma_params capture_dma_param;
+};
+
+static int sunxi_cpudai_startup(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	struct sunxi_cpudai_info *sunxi_cpudai = snd_soc_dai_get_drvdata(dai);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		snd_soc_dai_set_dma_data(dai, substream,
+				&sunxi_cpudai->playback_dma_param);
+	else {
+		snd_soc_dai_set_dma_data(dai, substream,
+				&sunxi_cpudai->capture_dma_param);
+	}
+
+	return 0;
+}
+
+static int sunxi_cpudai_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static int sunxi_cpudai_suspend(struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static int sunxi_cpudai_resume(struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static void sunxi_cpudai_shutdown(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+}
+
+static struct snd_soc_dai_ops sunxi_cpudai_dai_ops = {
+	.startup = sunxi_cpudai_startup,
+	.hw_params = sunxi_cpudai_hw_params,
+	.shutdown = sunxi_cpudai_shutdown,
+};
+
+static int sunxi_cpudai_probe(struct snd_soc_dai *dai)
+{
+	struct sunxi_cpudai_info *sunxi_cpudai = snd_soc_dai_get_drvdata(dai);
+
+	/* pcm_new will using the dma_param about the cma and fifo params. */
+	snd_soc_dai_init_dma_data(dai, &sunxi_cpudai->playback_dma_param,
+				&sunxi_cpudai->capture_dma_param);
+	return 0;
+}
+
+static struct snd_soc_dai_driver sunxi_cpudai_dai = {
+	.probe = sunxi_cpudai_probe,
+	.suspend = sunxi_cpudai_suspend,
+	.resume = sunxi_cpudai_resume,
+	.playback = {
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_8000_192000 |
+			SNDRV_PCM_RATE_KNOT,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE |
+			SNDRV_PCM_FMTBIT_S24_LE |
+			SNDRV_PCM_FMTBIT_S32_LE,
+	},
+	.capture = {
+		.channels_min = 1,
+		.channels_max = 4,
+		.rates = SNDRV_PCM_RATE_8000_48000 |
+			SNDRV_PCM_RATE_KNOT,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE |
+			SNDRV_PCM_FMTBIT_S24_LE |
+			SNDRV_PCM_FMTBIT_S32_LE,
+	},
+	.ops		= &sunxi_cpudai_dai_ops,
+
+};
+
+static const struct snd_soc_component_driver sunxi_asoc_cpudai_component = {
+	.name = DRV_NAME,
+};
+static const struct of_device_id sunxi_asoc_cpudai_of_match[] = {
+	{ .compatible = "allwinner,sunxi-dummy-cpudai", },
+	{},
+};
+
+static int  sunxi_asoc_cpudai_dev_probe(struct platform_device *pdev)
+{
+	struct sunxi_cpudai_info *sunxi_cpudai;
+	struct device_node *np = pdev->dev.of_node;
+	unsigned int temp_val;
+	int ret;
+
+	sunxi_cpudai = devm_kzalloc(&pdev->dev,
+			sizeof(struct sunxi_cpudai_info), GFP_KERNEL);
+	if (!sunxi_cpudai) {
+		ret = -ENOMEM;
+		goto err_node_put;
+	}
+	dev_set_drvdata(&pdev->dev, sunxi_cpudai);
+
+	ret = of_property_read_u32(np, "playback_cma", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "playback cma kbytes config missing, using default value.\n");
+		sunxi_cpudai->playback_dma_param.cma_kbytes = SUNXI_AUDIO_CMA_MAX_KBYTES;
+	} else {
+		if (temp_val > SUNXI_AUDIO_CMA_MAX_KBYTES)
+			temp_val = SUNXI_AUDIO_CMA_MAX_KBYTES;
+		else if (temp_val < SUNXI_AUDIO_CMA_MIN_KBYTES)
+			temp_val = SUNXI_AUDIO_CMA_MIN_KBYTES;
+		sunxi_cpudai->playback_dma_param.cma_kbytes = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "capture_cma", &temp_val);
+	if (ret != 0) {
+		dev_warn(&pdev->dev, "capture cma kbytes config missing, using default value.\n");
+		sunxi_cpudai->capture_dma_param.cma_kbytes = SUNXI_AUDIO_CMA_MAX_KBYTES;
+	} else {
+		if (temp_val > SUNXI_AUDIO_CMA_MAX_KBYTES)
+			temp_val = SUNXI_AUDIO_CMA_MAX_KBYTES;
+		else if (temp_val < SUNXI_AUDIO_CMA_MIN_KBYTES)
+			temp_val = SUNXI_AUDIO_CMA_MIN_KBYTES;
+		sunxi_cpudai->capture_dma_param.cma_kbytes = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "tx_fifo_size", &temp_val);
+	if (ret != 0) {
+		dev_warn(&pdev->dev, "tx_fifo_size miss,using default value.\n");
+		sunxi_cpudai->playback_dma_param.fifo_size = 128;//CODEC_TX_FIFO_SIZE
+	} else {
+		sunxi_cpudai->playback_dma_param.fifo_size = temp_val;
+	}
+	ret = of_property_read_u32(np, "rx_fifo_size", &temp_val);
+	if (ret != 0) {
+		dev_warn(&pdev->dev, "rx_fifo_size miss,using default value.\n");
+		sunxi_cpudai->capture_dma_param.fifo_size = 256;//CODEC_RX_FIFO_SIZE
+	} else {
+		sunxi_cpudai->capture_dma_param.fifo_size = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "dac_txdata", &temp_val);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "dac_txdata miss,register dummy cpudai err.\n");
+		goto err_devm_kfree;
+	} else
+		sunxi_cpudai->playback_dma_param.dma_addr = temp_val;//SUNXI_DAC_TXDATA
+	sunxi_cpudai->playback_dma_param.dst_maxburst = 4;
+	sunxi_cpudai->playback_dma_param.src_maxburst = 4;
+
+	ret = of_property_read_u32(np, "adc_txdata", &temp_val);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "adc_txdata miss,register dummy cpudai err.\n");
+		goto err_devm_kfree;
+	} else
+		sunxi_cpudai->capture_dma_param.dma_addr = temp_val;//SUNXI_ADC_RXDATA
+	sunxi_cpudai->capture_dma_param.src_maxburst = 4;
+	sunxi_cpudai->capture_dma_param.dst_maxburst = 4;
+
+	ret = snd_soc_register_component(&pdev->dev, &sunxi_asoc_cpudai_component,
+			&sunxi_cpudai_dai, 1);
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register DAI: %d\n", ret);
+		ret = -EBUSY;
+		goto err_devm_kfree;
+	}
+
+	ret = asoc_dma_platform_register(&pdev->dev, 0);
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register PCM: %d\n", ret);
+		goto err_unregister_component;
+	}
+
+	return 0;
+
+err_unregister_component:
+	snd_soc_unregister_component(&pdev->dev);
+err_devm_kfree:
+	devm_kfree(&pdev->dev, sunxi_cpudai);
+err_node_put:
+	of_node_put(np);
+	return ret;
+}
+
+static int __exit sunxi_asoc_cpudai_dev_remove(struct platform_device *pdev)
+{
+	struct sunxi_cpudai_info *sunxi_cpudai = dev_get_drvdata(&pdev->dev);
+
+	asoc_dma_platform_unregister(&pdev->dev);
+	snd_soc_unregister_component(&pdev->dev);
+	devm_kfree(&pdev->dev, sunxi_cpudai);
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+static struct platform_driver sunxi_asoc_cpudai_driver = {
+	.driver = {
+		.name = DRV_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_asoc_cpudai_of_match,
+	},
+	.probe = sunxi_asoc_cpudai_dev_probe,
+	.remove = __exit_p(sunxi_asoc_cpudai_dev_remove),
+};
+
+module_platform_driver(sunxi_asoc_cpudai_driver);
+
+MODULE_AUTHOR("wolfgang huang <huangjinhui@allwinnertech.com>");
+MODULE_DESCRIPTION("SUNXI Internal cpudai ASoC Interface");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DRV_NAME);
+
diff --git a/sound/soc/sunxi/sunxi-hdmi.c b/sound/soc/sunxi/sunxi-hdmi.c
new file mode 100644
index 000000000..0b0668eda
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-hdmi.c
@@ -0,0 +1,359 @@
+/*
+ * sound\soc\sunxi\sunxi-hdmi.c
+ * (C) Copyright 2014-2020
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * yumingfeng <yumingfeng@allwinnertech.com>
+ * luguofang <luguofang@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <sound/simple_card.h>
+#include <linux/io.h>
+
+#include "sunxi-pcm.h"
+
+#include <video/drv_hdmi.h>
+
+static bool	hdmiaudio_reset_en;
+
+struct sunxi_hdmi_priv {
+	hdmi_audio_t hdmi_para;
+	bool update_param;
+};
+
+atomic_t			pcm_count_num;
+static __audio_hdmi_func	g_hdmi_func;
+static hdmi_audio_t		hdmi_para;
+
+module_param_named(hdmiaudio_reset_en, hdmiaudio_reset_en,
+		bool, S_IRUGO | S_IWUSR);
+
+void audio_set_hdmi_func(__audio_hdmi_func *hdmi_func)
+{
+	if (hdmi_func) {
+		g_hdmi_func.hdmi_audio_enable	= hdmi_func->hdmi_audio_enable;
+		g_hdmi_func.hdmi_set_audio_para	= hdmi_func->hdmi_set_audio_para;
+		g_hdmi_func.hdmi_is_playback	= hdmi_func->hdmi_is_playback;
+	} else {
+		pr_err("error:%s,line:%d\n", __func__, __LINE__);
+	}
+}
+EXPORT_SYMBOL(audio_set_hdmi_func);
+
+int sunxi_hdmi_codec_hw_params(struct snd_pcm_substream *substream,
+			       struct snd_pcm_hw_params *params,
+			       struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_card *card = rtd->card;
+	struct asoc_simple_priv *sndhdmi_priv = snd_soc_card_get_drvdata(card);
+	struct sunxi_hdmi_priv *sunxi_hdmi = snd_soc_component_get_drvdata(dai->component);
+
+	hdmi_para.sample_rate = params_rate(params);
+	hdmi_para.channel_num = params_channels(params);
+	hdmi_para.data_raw = sndhdmi_priv->hdmi_format;
+
+	if (sunxi_hdmi != NULL) {
+		if (sunxi_hdmi->hdmi_para.sample_rate != hdmi_para.sample_rate) {
+			sunxi_hdmi->hdmi_para.sample_rate = hdmi_para.sample_rate;
+			sunxi_hdmi->update_param = 1;
+		}
+		if (sunxi_hdmi->hdmi_para.channel_num != hdmi_para.channel_num) {
+			sunxi_hdmi->hdmi_para.channel_num = hdmi_para.channel_num;
+			sunxi_hdmi->update_param = 1;
+		}
+		if (sunxi_hdmi->hdmi_para.data_raw != hdmi_para.data_raw) {
+			sunxi_hdmi->hdmi_para.data_raw = hdmi_para.data_raw;
+			sunxi_hdmi->update_param = 1;
+		}
+	} else {
+		pr_warn("[%s] sunxi_hdmi is null.\n", __func__);
+	}
+
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		hdmi_para.sample_bit = 16;
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+		hdmi_para.sample_bit = 24;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		hdmi_para.sample_bit = 24;
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		hdmi_para.sample_bit = 24;
+		break;
+	default:
+		return -EINVAL;
+	}
+	/*
+	 * PCM = 1,
+	 * AC3 = 2,
+	 * MPEG1 = 3,
+	 * MP3 = 4,
+	 * MPEG2 = 5,
+	 * AAC = 6,
+	 * DTS = 7,
+	 * ATRAC = 8,
+	 * ONE_BIT_AUDIO = 9,
+	 * DOLBY_DIGITAL_PLUS = 10,
+	 * DTS_HD = 11,
+	 * MAT = 12,
+	 * DST = 13,
+	 * WMAPRO = 14.
+	 */
+	if (hdmi_para.data_raw > 1)
+		hdmi_para.sample_bit = 24;
+
+	if ((sunxi_hdmi != NULL) &&
+	    (sunxi_hdmi->hdmi_para.sample_bit != hdmi_para.sample_bit)) {
+		sunxi_hdmi->hdmi_para.sample_bit = hdmi_para.sample_bit;
+		sunxi_hdmi->update_param = 1;
+	}
+
+	if (hdmi_para.channel_num == 8)
+		hdmi_para.ca = 0x12;
+	else if (hdmi_para.channel_num == 6)
+		hdmi_para.ca = 0x0b;
+	else if ((hdmi_para.channel_num >= 3))
+		hdmi_para.ca = 0x1f;
+	else
+		hdmi_para.ca = 0x0;
+
+	if ((sunxi_hdmi != NULL) &&
+	    (sunxi_hdmi->hdmi_para.ca != hdmi_para.ca)) {
+		sunxi_hdmi->hdmi_para.ca = hdmi_para.ca;
+		sunxi_hdmi->update_param = 1;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(sunxi_hdmi_codec_hw_params);
+
+static int sunxi_hdmi_codec_set_dai_fmt(struct snd_soc_dai *codec_dai,
+			       unsigned int fmt)
+{
+	return 0;
+}
+
+int sunxi_hdmi_codec_prepare(struct snd_pcm_substream *substream,
+	struct snd_soc_dai *dai)
+{
+	struct sunxi_hdmi_priv *sunxi_hdmi = snd_soc_component_get_drvdata(dai->component);
+
+	if (hdmiaudio_reset_en == false) {
+		if ((sunxi_hdmi != NULL) && (sunxi_hdmi->update_param)) {
+			pr_warn("sunxi->update_param:%d\n", sunxi_hdmi->update_param);
+			atomic_set(&pcm_count_num, 0);
+			sunxi_hdmi->update_param = 0;
+		} else if (atomic_read(&pcm_count_num) == 0)
+			atomic_inc(&pcm_count_num);
+	} else if (hdmiaudio_reset_en == true)
+		atomic_set(&pcm_count_num, 0);
+
+	/*
+	 * set the first pcm param, need set the hdmi audio pcm param
+	 * set the data_raw param, need set the hdmi audio raw param
+	 */
+	if (!g_hdmi_func.hdmi_set_audio_para) {
+		pr_warn("hdmi video isn't insmod, hdmi interface is null\n");
+		return 0;
+	}
+
+	if (hdmiaudio_reset_en) {
+		pr_warn("[%s] raw:%d, sample_bit:%d, channel:%d, "
+			"sample_rate:%d, hdmiaudio_reset_en:%d\n", __func__,
+			hdmi_para.data_raw, hdmi_para.sample_bit,
+			hdmi_para.channel_num, hdmi_para.sample_rate,
+			hdmiaudio_reset_en);
+	}
+
+	if (atomic_read(&pcm_count_num) < 1) {
+		g_hdmi_func.hdmi_set_audio_para(&hdmi_para);
+		g_hdmi_func.hdmi_audio_enable(1, 1);
+		/*
+		 * When the params was be changed,
+		 * the hdmi clk should be shake hands again,
+		 * it needs some time to finishe.
+		 */
+		//msleep(1200);
+	}
+	return 0;
+}
+EXPORT_SYMBOL(sunxi_hdmi_codec_prepare);
+
+void sunxi_hdmi_codec_shutdown(struct snd_pcm_substream *substream,
+					struct snd_soc_dai *dai)
+{
+	struct sunxi_hdmi_priv *sunxi_hdmi = snd_soc_component_get_drvdata(dai->component);
+
+	if (sunxi_hdmi)
+		sunxi_hdmi->update_param = 0;
+
+	if (g_hdmi_func.hdmi_audio_enable)
+		g_hdmi_func.hdmi_audio_enable(0, 1);
+}
+EXPORT_SYMBOL(sunxi_hdmi_codec_shutdown);
+
+static int sunxi_hdmi_codec_trigger(struct snd_pcm_substream *substream,
+				int cmd, struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static int sunxi_hdmi_codec_suspend(struct snd_soc_component *dai)
+{
+	return 0;
+}
+
+static int sunxi_hdmi_codec_resume(struct snd_soc_component *dai)
+{
+	atomic_set(&pcm_count_num, 0);
+	return 0;
+}
+
+static struct snd_soc_dai_ops sunxi_hdmi_dai_ops = {
+	.hw_params	= sunxi_hdmi_codec_hw_params,
+	.set_fmt	= sunxi_hdmi_codec_set_dai_fmt,
+	.trigger	= sunxi_hdmi_codec_trigger,
+	.prepare	= sunxi_hdmi_codec_prepare,
+	.shutdown	= sunxi_hdmi_codec_shutdown,
+};
+
+static struct snd_soc_dai_driver sunxi_hdmi_codec_dai = {
+	.name		= "audiohdmi-dai",
+	.playback	= {
+		.stream_name	= "Playback",
+		.channels_min	= 1,
+		.channels_max	= 8,
+		.rates		= SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+		.formats	= SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE
+				| SNDRV_PCM_FMTBIT_S32_LE,
+	},
+	/* HDMI capture only for i2s loop(chan <= 2ch) debug */
+	.capture	= {
+		.stream_name	= "Capture",
+		.channels_min	= 1,
+		.channels_max	= 2,
+		.rates		= SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+		.formats	= SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE
+				| SNDRV_PCM_FMTBIT_S32_LE,
+	},
+	.ops			= &sunxi_hdmi_dai_ops,
+};
+
+static int sunxi_hdmi_codec_probe(struct snd_soc_component *component)
+{
+	struct sunxi_hdmi_priv *sunxi_hdmi = NULL;
+
+	atomic_set(&pcm_count_num, 0);
+
+	if (!component) {
+		pr_err("error:%s,line:%d\n", __func__, __LINE__);
+		return -EAGAIN;
+	}
+
+	sunxi_hdmi = kzalloc(sizeof(struct sunxi_hdmi_priv), GFP_KERNEL);
+	if (sunxi_hdmi == NULL) {
+		pr_err("[%s] cannot malloc sunxi_hdmi.\n", __func__);
+		return -ENOMEM;
+	}
+	snd_soc_component_set_drvdata(component, sunxi_hdmi);
+
+	return 0;
+}
+
+static void sunxi_hdmi_codec_remove(struct snd_soc_component *component)
+{
+	struct sunxi_hdmi_priv *sunxi_hdmi = NULL;
+
+
+	if (!component) {
+		pr_err("[%s] component is null !!!\n", __func__);
+	} else {
+		sunxi_hdmi = snd_soc_component_get_drvdata(component);
+		kfree(sunxi_hdmi);
+	}
+}
+
+static struct snd_soc_component_driver soc_codec_dev_sunxi_hdmi = {
+	.name		= "sunxi-hdmiaudio",
+	.probe		= sunxi_hdmi_codec_probe,
+	.remove		= sunxi_hdmi_codec_remove,
+	.suspend	= sunxi_hdmi_codec_suspend,
+	.resume		= sunxi_hdmi_codec_resume,
+};
+
+static int sunxi_hdmi_codec_dev_probe(struct platform_device *pdev)
+{
+	if (!pdev) {
+		pr_err("error:%s,line:%d\n", __func__, __LINE__);
+		return -EAGAIN;
+	}
+
+	return snd_soc_register_component(&pdev->dev, &soc_codec_dev_sunxi_hdmi,
+				&sunxi_hdmi_codec_dai, 1);
+}
+
+static int __exit sunxi_hdmi_codec_dev_remove(struct platform_device *pdev)
+{
+	if (!pdev) {
+		pr_err("error:%s,line:%d\n", __func__, __LINE__);
+		return -EAGAIN;
+	}
+
+	snd_soc_unregister_component(&pdev->dev);
+
+	return 0;
+}
+
+static const struct of_device_id sunxi_hdmi_codec_of_match[] = {
+	{ .compatible = "allwinner,sunxi-hdmiaudio", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, sunxi_hdmi_codec_of_match);
+
+static struct platform_driver sunxi_hdmi_codec_driver = {
+	.probe = sunxi_hdmi_codec_dev_probe,
+	.remove = __exit_p(sunxi_hdmi_codec_dev_remove),
+	.driver = {
+		.name	= "sunxi-hdmiaudio",
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_hdmi_codec_of_match,
+	},
+};
+
+static int __init sunxi_hdmi_codec_driver_init(void)
+{
+	return platform_driver_register(&sunxi_hdmi_codec_driver);
+}
+module_init(sunxi_hdmi_codec_driver_init);
+
+static void __exit sunxi_hdmi_codec_driver_exit(void)
+{
+	platform_driver_unregister(&sunxi_hdmi_codec_driver);
+}
+module_exit(sunxi_hdmi_codec_driver_exit);
+
+MODULE_AUTHOR("luguofang <luguofang@allwinnertech.com>");
+MODULE_DESCRIPTION("SUNXI HDMIAUDIO ASoC DRIVER");
+MODULE_ALIAS("platform:sunxi-hdmiaudio");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/sunxi/sunxi-pcm.c b/sound/soc/sunxi/sunxi-pcm.c
new file mode 100644
index 000000000..c0c46e927
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-pcm.c
@@ -0,0 +1,677 @@
+/*
+ * sound\soc\sunxi\sunxi-pcm.c
+ * (C) Copyright 2014-2018
+ * AllWinner Technology Co., Ltd. <www.allwinnertech.com>
+ * wolfgang huang <huangjinhui@allwinnertech.com>
+ * yumingfeng <yumingfeng@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/simple_card.h>
+#include <sound/dmaengine_pcm.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
+#include <asm/dma.h>
+#include "sunxi-pcm.h"
+
+static int raw_flag = 1;
+static dma_addr_t hdmiraw_dma_addr;
+static dma_addr_t hdmipcm_dma_addr;
+static unsigned char *hdmiraw_dma_area;	/* DMA area */
+static unsigned int channel_status[192];
+
+static u64 sunxi_pcm_mask = DMA_BIT_MASK(32);
+
+struct headbpcuv {
+	unsigned char other:3;
+	unsigned char V:1;
+	unsigned char U:1;
+	unsigned char C:1;
+	unsigned char P:1;
+	unsigned char B:1;
+};
+
+union head61937 {
+	struct headbpcuv head0;
+	unsigned char head1;
+} head;
+
+union word {
+	struct {
+		unsigned int bit0:1;
+		unsigned int bit1:1;
+		unsigned int bit2:1;
+		unsigned int bit3:1;
+		unsigned int bit4:1;
+		unsigned int bit5:1;
+		unsigned int bit6:1;
+		unsigned int bit7:1;
+		unsigned int bit8:1;
+		unsigned int bit9:1;
+		unsigned int bit10:1;
+		unsigned int bit11:1;
+		unsigned int bit12:1;
+		unsigned int bit13:1;
+		unsigned int bit14:1;
+		unsigned int bit15:1;
+		unsigned int rsvd:16;
+	} bits;
+	unsigned int wval;
+} wordformat;
+
+static struct snd_pcm_hardware sunxi_pcm_hardware = {
+	.info			= SNDRV_PCM_INFO_INTERLEAVED
+		| SNDRV_PCM_INFO_BLOCK_TRANSFER
+		| SNDRV_PCM_INFO_MMAP
+		| SNDRV_PCM_INFO_MMAP_VALID
+		| SNDRV_PCM_INFO_PAUSE
+		| SNDRV_PCM_INFO_RESUME,
+	.formats		= SNDRV_PCM_FMTBIT_S8
+		| SNDRV_PCM_FMTBIT_S16_LE
+		| SNDRV_PCM_FMTBIT_S20_3LE
+		| SNDRV_PCM_FMTBIT_S24_LE
+		| SNDRV_PCM_FMTBIT_S32_LE,
+	.rates			= SNDRV_PCM_RATE_8000_192000
+		| SNDRV_PCM_RATE_KNOT,
+	.rate_min		= 8000,
+	.rate_max		= 192000,
+	.channels_min		= 1,
+	.channels_max		= 8,
+	/* value must be (2^n)Kbyte */
+	.buffer_bytes_max	= SUNXI_AUDIO_CMA_MAX_BYTES_MAX,
+	.period_bytes_min	= 256,
+	.period_bytes_max	= SUNXI_AUDIO_CMA_MAX_BYTES_MAX / 2,
+	.periods_min		= 1,
+	.periods_max		= 8,
+	.fifo_size		= 128,
+};
+
+int sunxi_get_rawflag(void)
+{
+	return raw_flag;
+}
+
+int hdmi_transfer_format_61937_to_60958(int *out, short *temp,
+					int samples, int rate)
+{
+	int ret = 0;
+	int i;
+	static int numtotal;
+	union word w1;
+
+	samples >>= 1;
+	head.head0.other = 0;
+	head.head0.B = 1;
+	head.head0.P = 0;
+	head.head0.C = 0;
+	head.head0.U = 0;
+	head.head0.V = 1;
+
+	for (i = 0; i < 192; i++)
+		channel_status[i] = 0;
+
+	channel_status[1] = 1;
+	/* sample rates */
+	if (rate == 32000) {
+		channel_status[24] = 1;
+		channel_status[25] = 1;
+		channel_status[26] = 0;
+		channel_status[27] = 0;
+	} else if (rate == 44100) {
+		channel_status[24] = 0;
+		channel_status[25] = 0;
+		channel_status[26] = 0;
+		channel_status[27] = 0;
+	} else if (rate == 48000) {
+		channel_status[24] = 0;
+		channel_status[25] = 1;
+		channel_status[26] = 0;
+		channel_status[27] = 0;
+	} else if (rate == (32000*4)) {
+		channel_status[24] = 1;
+		channel_status[25] = 0;
+		channel_status[26] = 0;
+		channel_status[27] = 0;
+	} else if (rate == (44100*4)) {
+		channel_status[24] = 0;
+		channel_status[25] = 0;
+		channel_status[26] = 1;
+		channel_status[27] = 1;
+	} else if (rate == (48000*4)) {
+		channel_status[24] = 0;
+		channel_status[25] = 1;
+		channel_status[26] = 1;
+		channel_status[27] = 1;
+		if (raw_flag == 12 || raw_flag == 11) {
+			channel_status[24] = 1;
+			channel_status[25] = 0;
+			channel_status[26] = 0;
+			channel_status[27] = 1;
+		}
+	} else {
+		channel_status[24] = 0;
+		channel_status[25] = 1;
+		channel_status[26] = 0;
+		channel_status[27] = 0;
+	}
+
+	for (i = 0; i < samples; i++, numtotal++) {
+		if ((numtotal % 384 == 0) || (numtotal % 384 == 1))
+			head.head0.B = 1;
+		else
+			head.head0.B = 0;
+
+		head.head0.C = channel_status[(numtotal % 384)/2];
+
+		if (numtotal % 384 == 0)
+			numtotal = 0;
+
+		w1.wval = (*temp) & (0xffff);
+
+		head.head0.P = w1.bits.bit15 ^ w1.bits.bit14 ^ w1.bits.bit13 ^
+			       w1.bits.bit12 ^ w1.bits.bit11 ^ w1.bits.bit10 ^
+			       w1.bits.bit9 ^ w1.bits.bit8 ^ w1.bits.bit7 ^
+			       w1.bits.bit6 ^ w1.bits.bit5 ^ w1.bits.bit4 ^
+			       w1.bits.bit3 ^ w1.bits.bit2 ^ w1.bits.bit1 ^
+			       w1.bits.bit0;
+
+		ret = (int)(head.head1) << 24;
+		/* 11 may can be replace by 8 or 12 */
+		ret |= (int)((w1.wval)&(0xffff)) << 11;
+		*out = ret;
+		out++;
+		temp++;
+	}
+
+	return 0;
+}
+
+static int sunxi_pcm_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params)
+{
+	struct sunxi_dma_params *dmap;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct device *dev = rtd->dev;
+	struct dma_chan *chan = snd_dmaengine_pcm_get_chan(substream);
+	struct dma_slave_config slave_config;
+	int ret;
+
+	dmap = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
+
+	ret = snd_hwparams_to_dma_slave_config(substream, params,
+			&slave_config);
+	if (ret) {
+		dev_err(dev, "hw params config failed with err %d\n", ret);
+		return ret;
+	}
+
+	slave_config.dst_maxburst = dmap->dst_maxburst;
+	slave_config.src_maxburst = dmap->src_maxburst;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		slave_config.dst_addr = dmap->dma_addr;
+		slave_config.src_addr_width = slave_config.dst_addr_width;
+	} else {
+		slave_config.src_addr =	dmap->dma_addr;
+		slave_config.dst_addr_width = slave_config.src_addr_width;
+	}
+
+	ret = dmaengine_slave_config(chan, &slave_config);
+	if (ret < 0) {
+		dev_err(dev, "dma slave config failed with err %d\n", ret);
+		return ret;
+	}
+
+	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+
+	return 0;
+}
+
+
+static int sunxi_pcm_hdmi_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params)
+{
+	struct sunxi_dma_params *dmap;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct device *dev = rtd->dev;
+	struct dma_chan *chan = snd_dmaengine_pcm_get_chan(substream);
+	struct dma_slave_config slave_config;
+	struct asoc_simple_priv *sndhdmi_priv = snd_soc_card_get_drvdata(rtd->card);
+	int ret;
+
+	//TODO:adapt hdmi mode
+	raw_flag = sndhdmi_priv->hdmi_format;
+	pr_info("raw_flag value is %u\n", raw_flag);
+	dmap = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
+
+	ret = snd_hwparams_to_dma_slave_config(substream, params,
+			&slave_config);
+	if (ret) {
+		dev_err(dev, "hw params config failed with err %d\n", ret);
+		return ret;
+	}
+
+	slave_config.dst_maxburst = dmap->dst_maxburst;
+	slave_config.src_maxburst = dmap->src_maxburst;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		slave_config.dst_addr =	dmap->dma_addr;
+		slave_config.src_addr_width = slave_config.dst_addr_width;
+	} else {
+		slave_config.src_addr =	dmap->dma_addr;
+		slave_config.dst_addr_width = slave_config.src_addr_width;
+	}
+
+	/*raw_flag>1. rawdata*/
+	if (raw_flag > 1) {
+		slave_config.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+		slave_config.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+
+		if (!dev->dma_mask)
+			dev->dma_mask = &sunxi_pcm_mask;
+		if (!dev->coherent_dma_mask)
+			dev->coherent_dma_mask = 0xffffffff;
+
+		/* note: change the follow function
+		 * sound/core/pcm_dmaengine.c -> dmaengine_pcm_prepare_and_submit()
+		 * snd_pcm_lib_buffer_bytes(substream) * 2 when rawflag > 1
+		 */
+		hdmiraw_dma_area = dma_alloc_coherent(dev,
+				(2 * params_buffer_bytes(params)),
+				&hdmiraw_dma_addr, GFP_KERNEL);
+		if (hdmiraw_dma_area == NULL) {
+			pr_err("hdmi:raw:get mem failed...\n");
+			return -ENOMEM;
+		}
+		hdmipcm_dma_addr = substream->dma_buffer.addr;
+		substream->dma_buffer.addr = (dma_addr_t)hdmiraw_dma_addr;
+	}
+
+	ret = dmaengine_slave_config(chan, &slave_config);
+	if (ret < 0) {
+		dev_err(dev, "dma slave config failed with err %d\n", ret);
+		return ret;
+	}
+
+	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+
+	return 0;
+}
+
+static int sunxi_pcm_hdmi_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct device *dev = rtd->dev;
+
+	if (snd_pcm_lib_buffer_bytes(substream) && (raw_flag > 1)) {
+		dma_free_coherent(dev,
+				(2 * snd_pcm_lib_buffer_bytes(substream)),
+				hdmiraw_dma_area, hdmiraw_dma_addr);
+		substream->dma_buffer.addr = hdmipcm_dma_addr;
+		hdmiraw_dma_area = NULL;
+	}
+	snd_pcm_set_runtime_buffer(substream, NULL);
+
+	return 0;
+}
+
+static int sunxi_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	snd_pcm_set_runtime_buffer(substream, NULL);
+
+	return 0;
+}
+
+static int sunxi_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		switch (cmd) {
+		case SNDRV_PCM_TRIGGER_START:
+		case SNDRV_PCM_TRIGGER_RESUME:
+		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+			snd_dmaengine_pcm_trigger(substream,
+					SNDRV_PCM_TRIGGER_START);
+			break;
+		case SNDRV_PCM_TRIGGER_SUSPEND:
+		case SNDRV_PCM_TRIGGER_STOP:
+		case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+			snd_dmaengine_pcm_trigger(substream,
+					SNDRV_PCM_TRIGGER_STOP);
+			break;
+		}
+	} else {
+		switch (cmd) {
+		case SNDRV_PCM_TRIGGER_START:
+		case SNDRV_PCM_TRIGGER_RESUME:
+		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+			snd_dmaengine_pcm_trigger(substream,
+					SNDRV_PCM_TRIGGER_START);
+			break;
+		case SNDRV_PCM_TRIGGER_SUSPEND:
+		case SNDRV_PCM_TRIGGER_STOP:
+		case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+			snd_dmaengine_pcm_trigger(substream,
+					SNDRV_PCM_TRIGGER_STOP);
+			break;
+		}
+	}
+	return 0;
+}
+
+static const char * const dmaengine_pcm_dma_channel_names[] = {
+	[SNDRV_PCM_STREAM_PLAYBACK] = "tx",
+	[SNDRV_PCM_STREAM_CAPTURE] = "rx",
+};
+
+static int sunxi_pcm_open(struct snd_pcm_substream *substream)
+{
+	int ret = 0;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_component *component =
+		snd_soc_rtdcom_lookup(rtd, SUNXI_DMAENGINE_PCM_DRV_NAME);
+	struct device *dev = component->dev;
+	struct sunxi_dma_params *dma_params = NULL;
+	struct dma_chan *chan;
+
+	dma_params = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
+	/* Set HW params now that initialization is complete */
+	sunxi_pcm_hardware.buffer_bytes_max = dma_params->cma_kbytes *
+		SUNXI_AUDIO_CMA_BLOCK_BYTES;
+	sunxi_pcm_hardware.period_bytes_max = sunxi_pcm_hardware.buffer_bytes_max / 2;
+	sunxi_pcm_hardware.fifo_size = dma_params->fifo_size;
+	snd_soc_set_runtime_hwparams(substream, &sunxi_pcm_hardware);
+	ret = snd_pcm_hw_constraint_integer(substream->runtime,
+			SNDRV_PCM_HW_PARAM_PERIODS);
+	if (ret < 0)
+		return ret;
+
+	chan = dma_request_chan(dev, dmaengine_pcm_dma_channel_names[substream->stream]);
+	if (IS_ERR(chan)) {
+		dev_err(dev, "DMA channels request %s failed.\n",
+				dmaengine_pcm_dma_channel_names[substream->stream]);
+		return -EINVAL;
+	}
+
+	ret = snd_dmaengine_pcm_open(substream, chan);
+	if (ret < 0) {
+		dev_err(dev, "dmaengine pcm open failed with err %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int sunxi_pcm_mmap(struct snd_pcm_substream *substream,
+		struct vm_area_struct *vma)
+{
+	struct snd_pcm_runtime *runtime = NULL;
+
+	if (substream->runtime != NULL) {
+		runtime = substream->runtime;
+
+		return dma_mmap_wc(substream->pcm->card->dev, vma,
+				runtime->dma_area,
+				runtime->dma_addr,
+				runtime->dma_bytes);
+	} else {
+		return -1;
+	}
+
+}
+
+static int sunxi_pcm_copy(struct snd_pcm_substream *substream, int channel,
+			  unsigned long hwoff, void __user *buf,
+			  unsigned long bytes)
+{
+	int ret = 0;
+	char *hwbuf;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		hwbuf = runtime->dma_area + hwoff;
+		if (copy_from_user(hwbuf, buf, bytes))
+			return -EFAULT;
+		if (raw_flag > 1) {
+			char *hdmihw_area = hdmiraw_dma_area + 2 * hwoff;
+			hdmi_transfer_format_61937_to_60958((int *)hdmihw_area,
+							    (short *)hwbuf,
+							    bytes,
+							    runtime->rate);
+		}
+	} else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		hwbuf = runtime->dma_area + hwoff;
+		if (copy_to_user(buf, hwbuf, bytes))
+			return -EFAULT;
+	}
+
+	return ret;
+}
+
+/* For passthrough mode: using no_residue */
+snd_pcm_uframes_t sunxi_dmaengine_pcm_pointer(struct snd_pcm_substream *substream)
+{
+	if (raw_flag > 1)
+		return snd_dmaengine_pcm_pointer_no_residue(substream);
+	else
+		return snd_dmaengine_pcm_pointer(substream);
+}
+
+static struct snd_pcm_ops sunxi_pcm_ops = {
+	.open		= sunxi_pcm_open,
+	.close		= snd_dmaengine_pcm_close_release_chan,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= sunxi_pcm_hw_params,
+	.hw_free	= sunxi_pcm_hw_free,
+	.trigger	= sunxi_pcm_trigger,
+	.pointer	= snd_dmaengine_pcm_pointer,
+	.mmap		= sunxi_pcm_mmap,
+};
+
+static struct snd_pcm_ops sunxi_pcm_ops_no_residue = {
+	.open		= sunxi_pcm_open,
+	.close		= snd_dmaengine_pcm_close_release_chan,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= sunxi_pcm_hdmi_hw_params,
+	.hw_free	= sunxi_pcm_hdmi_hw_free,
+	.trigger	= sunxi_pcm_trigger,
+	.pointer	= sunxi_dmaengine_pcm_pointer,
+	.mmap		= sunxi_pcm_mmap,
+	.copy_user	= sunxi_pcm_copy,
+};
+
+static int sunxi_pcm_preallocate_stream_dma_buffer(struct snd_pcm *pcm,
+		int stream, size_t buffer_bytes_max)
+{
+	struct snd_pcm_str *streams = NULL;
+	struct snd_pcm_substream *substream = NULL;
+	struct snd_dma_buffer *buf = NULL;
+
+	streams = &pcm->streams[stream];
+	if (IS_ERR_OR_NULL(streams)) {
+		pr_err("[%s] stream=%d streams is null!\n", __func__, stream);
+		return -EFAULT;
+	}
+	substream = pcm->streams[stream].substream;
+	if (IS_ERR_OR_NULL(substream)) {
+		pr_err("[%s] stream=%d substream is null!\n", __func__, stream);
+		return -EFAULT;
+	}
+	buf = &substream->dma_buffer;
+	buf->dev.type = SNDRV_DMA_TYPE_DEV;
+	buf->dev.dev = pcm->card->dev;
+	buf->private_data = NULL;
+	if (buffer_bytes_max > SUNXI_AUDIO_CMA_MAX_BYTES_MAX)
+		buffer_bytes_max = SUNXI_AUDIO_CMA_MAX_BYTES_MAX;
+	if (buffer_bytes_max < SUNXI_AUDIO_CMA_MAX_BYTES_MIN)
+		buffer_bytes_max = SUNXI_AUDIO_CMA_MAX_BYTES_MIN;
+
+	buf->area = dma_alloc_coherent(pcm->card->dev, buffer_bytes_max,
+			&buf->addr, GFP_KERNEL);
+	if (!buf->area) {
+		dev_err(pcm->card->dev, "dmaengine alloc coherent failed.\n");
+		return -ENOMEM;
+	}
+	buf->bytes = buffer_bytes_max;
+
+	return 0;
+}
+
+static void sunxi_pcm_free_stream_dma_buffer(struct snd_pcm *pcm, int stream)
+{
+	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_dma_buffer *buf;
+
+	if (IS_ERR_OR_NULL(substream)) {
+		pr_err("[%s] stream=%d substream is null!\n", __func__, stream);
+		return;
+	}
+
+	buf = &substream->dma_buffer;
+	if (!buf->area) {
+		pr_err("[%s] stream=%d buf->area is null!\n", __func__, stream);
+		return;
+	}
+
+	dma_free_coherent(pcm->card->dev, buf->bytes,
+			buf->area, buf->addr);
+	buf->area = NULL;
+}
+
+static void sunxi_pcm_free_dma_buffers(struct snd_pcm *pcm)
+{
+	struct snd_pcm_substream *substream;
+	struct snd_dma_buffer *buf;
+	int stream;
+
+	for (stream = 0; stream < 2; stream++) {
+		substream = pcm->streams[stream].substream;
+		if (!substream)
+			continue;
+
+		buf = &substream->dma_buffer;
+		if (!buf->area)
+			continue;
+
+		dma_free_coherent(pcm->card->dev, buf->bytes,
+				buf->area, buf->addr);
+		buf->area = NULL;
+	}
+}
+
+static int sunxi_pcm_new(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_card *card = rtd->card->snd_card;
+	struct snd_soc_dai_link *dai_link = rtd->dai_link;
+	struct snd_pcm *pcm = rtd->pcm;
+	struct device *dev = rtd->dev;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct sunxi_dma_params *playback_dma_data = cpu_dai->playback_dma_data;
+	struct sunxi_dma_params *capture_dma_data = cpu_dai->capture_dma_data;
+	size_t capture_cma_bytes = SUNXI_AUDIO_CMA_BLOCK_BYTES;
+	size_t playback_cma_bytes = SUNXI_AUDIO_CMA_BLOCK_BYTES;
+	int ret = 0;
+
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &sunxi_pcm_mask;
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = 0xffffffff;
+
+	if (!IS_ERR_OR_NULL(playback_dma_data))
+		playback_cma_bytes *= playback_dma_data->cma_kbytes;
+	if (!IS_ERR_OR_NULL(capture_dma_data))
+		capture_cma_bytes *= capture_dma_data->cma_kbytes;
+
+	if (dai_link->playback_only) {
+		ret = sunxi_pcm_preallocate_stream_dma_buffer(pcm,
+				SNDRV_PCM_STREAM_PLAYBACK, playback_cma_bytes);
+		if (ret) {
+			dev_err(dev, "pcm new playback failed with err=%d\n", ret);
+			return ret;
+		}
+	} else if (dai_link->capture_only) {
+		ret = sunxi_pcm_preallocate_stream_dma_buffer(pcm,
+				SNDRV_PCM_STREAM_CAPTURE, capture_cma_bytes);
+		if (ret) {
+			dev_err(dev, "pcm new capture failed with err=%d\n", ret);
+			return ret;
+		}
+	} else {
+		ret = sunxi_pcm_preallocate_stream_dma_buffer(pcm,
+				SNDRV_PCM_STREAM_PLAYBACK, playback_cma_bytes);
+		if (ret) {
+			dev_err(dev, "pcm new playback failed with err=%d\n", ret);
+			goto err_pcm_prealloc_playback_buffer;
+		}
+		ret = sunxi_pcm_preallocate_stream_dma_buffer(pcm,
+				SNDRV_PCM_STREAM_CAPTURE, capture_cma_bytes);
+		if (ret) {
+			dev_err(dev, "pcm new capture failed with err=%d\n", ret);
+			goto err_pcm_prealloc_capture_buffer;
+		}
+	}
+
+	return 0;
+
+err_pcm_prealloc_capture_buffer:
+	sunxi_pcm_free_stream_dma_buffer(pcm, SNDRV_PCM_STREAM_PLAYBACK);
+err_pcm_prealloc_playback_buffer:
+	return ret;
+}
+
+static struct snd_soc_component_driver sunxi_soc_platform = {
+	.name		= SUNXI_DMAENGINE_PCM_DRV_NAME,
+	.ops		= &sunxi_pcm_ops,
+	.pcm_new	= sunxi_pcm_new,
+	.pcm_free	= sunxi_pcm_free_dma_buffers,
+};
+
+static const struct snd_soc_component_driver sunxi_soc_platform_no_residue = {
+	.name		= SUNXI_DMAENGINE_PCM_DRV_NAME,
+	.ops		= &sunxi_pcm_ops_no_residue,
+	.pcm_new	= sunxi_pcm_new,
+	.pcm_free	= sunxi_pcm_free_dma_buffers,
+};
+
+int asoc_dma_platform_register(struct device *dev, unsigned int flags)
+{
+	/*
+	 * FIXME, Don't try to request the DMA channels through devicetree.
+	 * in sunxi famaily, using HDMI, will decodec rawdata, should be using
+	 * self defined copy function, so using this flag just mark diff with
+	 * normal audio platform copy function, no relation with devicetree
+	 */
+	if (flags & SND_DMAENGINE_PCM_FLAG_NO_DT)
+		return snd_soc_register_component(dev,
+				&sunxi_soc_platform_no_residue, NULL, 0);
+	else
+		return snd_soc_register_component(dev,
+				&sunxi_soc_platform, NULL, 0);
+}
+EXPORT_SYMBOL_GPL(asoc_dma_platform_register);
+
+void asoc_dma_platform_unregister(struct device *dev)
+{
+	snd_soc_unregister_component(dev);
+}
+EXPORT_SYMBOL_GPL(asoc_dma_platform_unregister);
+
+MODULE_AUTHOR("huangxin, liushaohua");
+MODULE_DESCRIPTION("sunxi ASoC DMA Driver");
+MODULE_LICENSE("GPL");
+
diff --git a/sound/soc/sunxi/sunxi-pcm.h b/sound/soc/sunxi/sunxi-pcm.h
new file mode 100644
index 000000000..86433c7e1
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-pcm.h
@@ -0,0 +1,43 @@
+/* sound\soc\sunxi\sunxi-pcm.h
+ * (C) Copyright 2019-2025
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * yumingfeng <yumingfeng@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#ifndef __SUNXI_PCM_H_
+#define __SUNXI_PCM_H_
+
+#include "sunxi-rx-sync.h"
+
+#define SUNXI_AUDIO_CMA_BLOCK_BYTES 1024
+#define SUNXI_AUDIO_CMA_MAX_KBYTES 1024
+#define SUNXI_AUDIO_CMA_MIN_KBYTES 64
+#define SUNXI_AUDIO_CMA_MAX_BYTES_MAX \
+	(SUNXI_AUDIO_CMA_BLOCK_BYTES * SUNXI_AUDIO_CMA_MAX_KBYTES)
+#define SUNXI_AUDIO_CMA_MAX_BYTES_MIN \
+	(SUNXI_AUDIO_CMA_BLOCK_BYTES * SUNXI_AUDIO_CMA_MIN_KBYTES)
+
+#define SUNXI_DMAENGINE_PCM_DRV_NAME "sunxi_dmaengine_pcm"
+struct sunxi_dma_params {
+	char *name;
+	dma_addr_t dma_addr;
+	u8 src_maxburst;
+	u8 dst_maxburst;
+	/* value must be (2^n)Kbyte */
+	size_t cma_kbytes;
+	size_t fifo_size;
+};
+
+extern int asoc_dma_platform_register(struct device *dev, unsigned int flags);
+extern void asoc_dma_platform_unregister(struct device *dev);
+extern int sunxi_get_rawflag(void);
+
+#endif /* __SUNXI_PCM_H_ */
+
diff --git a/sound/soc/sunxi/sunxi-rpaf/component/Kconfig b/sound/soc/sunxi/sunxi-rpaf/component/Kconfig
new file mode 100644
index 000000000..0dbad4ca3
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-rpaf/component/Kconfig
@@ -0,0 +1,9 @@
+#
+# Allwinner Built-in DSP Misc Driver.
+#
+config SND_SUNXI_MISC_HIFI_DSP
+	tristate "Allwinner HiFi Component Driver"
+	default n
+	help
+		allwinner built-in dsp component driver.
+
diff --git a/sound/soc/sunxi/sunxi-rpaf/component/Makefile b/sound/soc/sunxi/sunxi-rpaf/component/Makefile
new file mode 100644
index 000000000..d6f19fa8d
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-rpaf/component/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for built-in dsp control drivers
+#
+sunxi-hifi-dsp-objs += component-driver.o component-core.o
+obj-$(CONFIG_SND_SUNXI_MISC_HIFI_DSP) += sunxi-hifi-dsp.o
diff --git a/sound/soc/sunxi/sunxi-rpaf/component/component-core.c b/sound/soc/sunxi/sunxi-rpaf/component/component-core.c
new file mode 100644
index 000000000..dcd04855e
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-rpaf/component/component-core.c
@@ -0,0 +1,1658 @@
+/*
+ * sound\sunxi-rpaf\component\component-core.c
+ * (C) Copyright 2019-2025
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * yumingfeng <yumingfeng@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/printk.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/poll.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/etherdevice.h>
+#include <linux/crypto.h>
+#include <linux/miscdevice.h>
+#include <linux/capability.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <asm/cacheflush.h>
+
+#include <sound/aw_rpaf/component-core.h>
+#include <sound/aw_rpaf/rpmsg_hifi.h>
+
+//#define RPAF_MEM_DEBUG_LOG
+
+static unsigned int component_id[RPAF_COMPONENT_MAX_NUM] = {0};
+static DEFINE_MUTEX(comp_id_mutex);
+
+static DEFINE_SPINLOCK(comp_stream_lock);
+
+static LIST_HEAD(snd_soc_rpaf_info_list);
+static LIST_HEAD(snd_soc_dsp_component_list);
+
+static DEFINE_MUTEX(rpaf_sub_list_mutex);
+static DEFINE_MUTEX(rpaf_info_list_mutex);
+
+void snd_soc_rpaf_pcm_stream_component_lock(void)
+{
+	spin_lock(&comp_stream_lock);
+}
+EXPORT_SYMBOL_GPL(snd_soc_rpaf_pcm_stream_component_lock);
+
+void snd_soc_rpaf_pcm_stream_component_unlock(void)
+{
+	spin_unlock(&comp_stream_lock);
+}
+EXPORT_SYMBOL_GPL(snd_soc_rpaf_pcm_stream_component_unlock);
+
+void snd_soc_rpaf_pcm_stream_lock(struct snd_dsp_component *dsp_component)
+{
+	spin_lock(&dsp_component->lock);
+}
+EXPORT_SYMBOL_GPL(snd_soc_rpaf_pcm_stream_lock);
+
+void snd_soc_rpaf_pcm_stream_lock_irq(struct snd_dsp_component *dsp_component)
+{
+	local_irq_disable();
+	snd_soc_rpaf_pcm_stream_lock(dsp_component);
+}
+EXPORT_SYMBOL_GPL(snd_soc_rpaf_pcm_stream_lock_irq);
+
+unsigned long snd_soc_rpaf_pcm_stream_lock_irqsave(struct snd_dsp_component *dsp_component)
+{
+	unsigned long flags = 0;
+
+	local_irq_save(flags);
+	snd_soc_rpaf_pcm_stream_lock(dsp_component);
+	return flags;
+}
+EXPORT_SYMBOL_GPL(snd_soc_rpaf_pcm_stream_lock_irqsave);
+
+void snd_soc_rpaf_pcm_stream_unlock(struct snd_dsp_component *dsp_component)
+{
+	spin_unlock(&dsp_component->lock);
+}
+EXPORT_SYMBOL_GPL(snd_soc_rpaf_pcm_stream_unlock);
+
+void snd_soc_rpaf_pcm_stream_unlock_irq(struct snd_dsp_component *dsp_component)
+{
+	snd_soc_rpaf_pcm_stream_unlock(dsp_component);
+	local_irq_enable();
+}
+EXPORT_SYMBOL_GPL(snd_soc_rpaf_pcm_stream_unlock_irq);
+
+void snd_soc_rpaf_pcm_stream_unlock_irqrestore(struct snd_dsp_component *dsp_component,
+				      unsigned long flags)
+{
+	snd_soc_rpaf_pcm_stream_unlock(dsp_component);
+	local_irq_restore(flags);
+}
+EXPORT_SYMBOL_GPL(snd_soc_rpaf_pcm_stream_unlock_irqrestore);
+
+/* for snd_soc_dsp_component list operation api */
+void snd_soc_dsp_component_list_add_tail(struct snd_soc_dsp_component *component)
+{
+	mutex_lock(&rpaf_sub_list_mutex);
+	list_add_tail(&component->list, &snd_soc_dsp_component_list);
+	mutex_unlock(&rpaf_sub_list_mutex);
+}
+EXPORT_SYMBOL_GPL(snd_soc_dsp_component_list_add_tail);
+
+void snd_soc_dsp_component_list_del(struct snd_soc_dsp_component *component)
+{
+	mutex_lock(&rpaf_sub_list_mutex);
+	list_del(&component->list);
+	mutex_unlock(&rpaf_sub_list_mutex);
+}
+EXPORT_SYMBOL_GPL(snd_soc_dsp_component_list_del);
+
+struct snd_soc_dsp_component *snd_soc_dsp_component_get_from_list_by_pcmdev(
+			int card, int device, int stream)
+{
+	struct snd_soc_dsp_component *component = NULL;
+	struct snd_soc_dsp_pcm_params *pcm_params = NULL;
+
+	mutex_lock(&rpaf_sub_list_mutex);
+	list_for_each_entry(component, &snd_soc_dsp_component_list, list) {
+		pcm_params = &(component->params);
+
+		if (pcm_params->card == card &&
+			pcm_params->device == device &&
+			pcm_params->stream == stream) {
+			mutex_unlock(&rpaf_sub_list_mutex);
+			return component;
+		}
+	}
+	mutex_unlock(&rpaf_sub_list_mutex);
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dsp_component_get_from_list_by_pcmdev);
+
+/* for snd_soc_rpaf_info list operation api */
+void snd_soc_rpaf_info_list_add_tail(struct snd_soc_rpaf_info *rpaf_info)
+{
+	mutex_lock(&rpaf_info_list_mutex);
+	list_add_tail(&rpaf_info->list, &snd_soc_rpaf_info_list);
+	mutex_unlock(&rpaf_info_list_mutex);
+}
+EXPORT_SYMBOL_GPL(snd_soc_rpaf_info_list_add_tail);
+
+void snd_soc_rpaf_info_list_del(struct snd_soc_rpaf_info *rpaf_info)
+{
+	mutex_lock(&rpaf_info_list_mutex);
+	list_del(&rpaf_info->list);
+	mutex_unlock(&rpaf_info_list_mutex);
+}
+EXPORT_SYMBOL_GPL(snd_soc_rpaf_info_list_del);
+
+struct snd_soc_rpaf_info *snd_soc_rpaf_info_get_from_list_by_minor(int minor)
+{
+	struct snd_soc_rpaf_info *rpaf_info;
+
+	mutex_lock(&rpaf_info_list_mutex);
+	list_for_each_entry(rpaf_info, &snd_soc_rpaf_info_list, list) {
+		if (rpaf_info->misc_dev.minor == minor) {
+			mutex_unlock(&rpaf_info_list_mutex);
+			return rpaf_info;
+		}
+	}
+	mutex_unlock(&rpaf_info_list_mutex);
+
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(snd_soc_rpaf_info_get_from_list_by_minor);
+
+struct snd_soc_rpaf_info *snd_soc_rpaf_info_get_from_list_by_dspid(unsigned int id)
+{
+	struct snd_soc_rpaf_info *rpaf_info;
+
+	mutex_lock(&rpaf_info_list_mutex);
+	list_for_each_entry(rpaf_info, &snd_soc_rpaf_info_list, list) {
+		if (rpaf_info->dsp_id == id) {
+			mutex_unlock(&rpaf_info_list_mutex);
+			return rpaf_info;
+		}
+	}
+	mutex_unlock(&rpaf_info_list_mutex);
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(snd_soc_rpaf_info_get_from_list_by_dspid);
+
+struct snd_soc_rpaf_info *snd_soc_rpaf_info_get_from_list_by_miscdevice(
+				struct miscdevice *device)
+{
+	struct snd_soc_rpaf_info *rpaf_info;
+
+	mutex_lock(&rpaf_info_list_mutex);
+	list_for_each_entry(rpaf_info, &snd_soc_rpaf_info_list, list) {
+		if (&rpaf_info->misc_dev == device) {
+			mutex_unlock(&rpaf_info_list_mutex);
+			return rpaf_info;
+		}
+	}
+	mutex_unlock(&rpaf_info_list_mutex);
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(snd_soc_rpaf_info_get_from_list_by_miscdevice);
+
+static int snd_soc_rpaf_misc_open(struct inode *inode, struct file *file)
+{
+	struct snd_soc_rpaf_info *rpaf_info = NULL;
+	struct snd_dsp_component *dsp_component = NULL;
+	struct msg_component_package *msg_component = NULL;
+	int minor = iminor(inode);
+	int err = -ENODEV;
+
+	err = nonseekable_open(inode, file);
+	if (err < 0)
+		return err;
+
+	rpaf_info = snd_soc_rpaf_info_get_from_list_by_minor(minor);
+	if (IS_ERR_OR_NULL(rpaf_info))
+		return -EBADF;
+
+	dsp_component = kzalloc(sizeof(struct snd_dsp_component), GFP_KERNEL);
+	if (IS_ERR_OR_NULL(dsp_component)) {
+		dev_err(rpaf_info->dev, "%s cannot malloc for dsp_component.\n", __func__);
+		return -ENOMEM;
+	}
+	msg_component = &dsp_component->msg_component;
+	init_waitqueue_head(&msg_component->tsleep);
+	spin_lock_init(&msg_component->lock);
+
+	snd_soc_dsp_component_list_add_tail(&msg_component->soc_component);
+	dsp_component->rpaf_info = rpaf_info;
+	file->private_data = dsp_component;
+	dsp_component->state = SND_DSP_COMPONENT_STATE_OPEN;
+
+	mutex_init(&dsp_component->comp_rw_lock);
+	spin_lock_init(&dsp_component->lock);
+#ifdef RPAF_MEM_DEBUG_LOG
+	dev_info(rpaf_info->dev, "%s line:%d dsp_component:%p, pa:0x%x, __pa.component:0x%x\n",
+				__func__, __LINE__, dsp_component, __pa(dsp_component),
+				__pa(&msg_component->soc_component));
+#endif
+	return err;
+}
+
+static int snd_soc_rpaf_misc_common_stop(struct snd_dsp_component *dsp_component);
+static int snd_soc_rpaf_misc_common_remove(struct snd_dsp_component *dsp_component);
+static int snd_soc_rpaf_misc_release(struct inode *inode, struct file *file)
+{
+	struct snd_dsp_component *dsp_component = file->private_data;
+	struct msg_component_package *msg_component = &dsp_component->msg_component;
+	struct snd_soc_dsp_component *component = &msg_component->soc_component;
+	struct snd_soc_rpaf_info *rpaf_info = dsp_component->rpaf_info;
+	int i = 0;
+	int result;
+
+	/*  */
+	switch (dsp_component->state) {
+	case SND_DSP_COMPONENT_STATE_START:
+	case SND_DSP_COMPONENT_STATE_RUNNING:
+		result = snd_soc_rpaf_misc_common_stop(dsp_component);
+		if (result < 0)
+			return result;
+	case SND_DSP_COMPONENT_STATE_STOP:
+		result = snd_soc_rpaf_misc_common_remove(dsp_component);
+		if (result < 0)
+			return result;
+		break;
+	case SND_DSP_COMPONENT_STATE_CLOSE:
+	default:
+		return -EINVAL;
+	case SND_DSP_COMPONENT_STATE_OPEN:
+	case SND_DSP_COMPONENT_STATE_CREATE:
+	case SND_DSP_COMPONENT_STATE_REMOVE:
+		break;
+	}
+	dsp_component->state = SND_DSP_COMPONENT_STATE_CLOSE;
+
+	/* stream */
+	if (component->read_addr) {
+		dma_free_coherent(rpaf_info->dev, component->read_size,
+			dsp_component->read_area, component->read_addr);
+#ifdef RPAF_MEM_DEBUG_LOG
+		dev_err(rpaf_info->dev, "read_area:%p, read_addr:0x%x\n",
+			dsp_component->read_area, component->read_addr);
+#endif
+		component->read_addr = 0;
+		dsp_component->read_area = NULL;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(component->dump_addr); i++) {
+		if (!component->dump_addr[i])
+			continue;
+		dma_free_coherent(rpaf_info->dev, component->dump_size,
+			dsp_component->dump_area[i], component->dump_addr[i]);
+#ifdef RPAF_MEM_DEBUG_LOG
+		dev_err(rpaf_info->dev, "dump_area[%d]:%p, dump_addr:0x%x\n",
+			i, dsp_component->dump_area[i], component->dump_addr[i]);
+#endif
+		component->dump_addr[i] = 0;
+		dsp_component->dump_area[i] = NULL;
+	}
+
+	if (component->write_addr) {
+		dma_free_coherent(rpaf_info->dev, component->write_size,
+			dsp_component->write_area, component->write_addr);
+#ifdef RPAF_MEM_DEBUG_LOG
+		dev_err(rpaf_info->dev, "write_area:%p, write_addr:0x%x\n",
+			dsp_component->write_area, component->write_addr);
+#endif
+		component->write_addr = 0;
+		dsp_component->write_area = NULL;
+	}
+
+	snd_soc_dsp_component_list_del(component);
+
+	mutex_destroy(&dsp_component->comp_rw_lock);
+	kfree(dsp_component);
+
+	return 0;
+}
+
+#if 0
+/* lib_write,dump */
+static ssize_t snd_soc_rpaf_misc_read(struct file *file, char __user *buf,
+				size_t count, loff_t *offset)
+{
+	struct snd_dsp_component *dsp_component = file->private_data;
+	struct msg_component_package *msg_component = &dsp_component->msg_component;
+	struct snd_soc_dsp_component *component = &msg_component->soc_component;
+	unsigned int read_size = count;
+
+	if (count > component->read_size)
+		read_size = component->read_size;
+
+	/*  */
+	mutex_lock(&dsp_component->comp_rw_lock);
+
+	sunxi_rpaf_dma_flush_range(dsp_component->read_area, read_size);
+
+	/* dsplib_writedump */
+	if (copy_to_user(buf, dsp_component->read_area, read_size)) {
+		mutex_unlock(&dsp_component->comp_rw_lock);
+		return -EFAULT;
+	}
+	mutex_unlock(&dsp_component->comp_rw_lock);
+	return read_size;
+}
+#endif
+
+/* lib_write,dump */
+ssize_t snd_soc_rpaf_misc_component_lib_read(struct snd_dsp_component *dsp_component,
+				struct snd_rpaf_xferi *xferi)
+{
+	ssize_t size = xferi->dump_length;
+	ssize_t read_size = size;
+	char __user *buf = (char __user *)(xferi->dump_buf);
+	struct msg_component_package *msg_component = &dsp_component->msg_component;
+	struct snd_soc_dsp_component *component = &msg_component->soc_component;
+//	struct snd_soc_rpaf_info *rpaf_info = dsp_component->rpaf_info;
+//	struct snd_soc_dsp_pcm_params *pcm_params = &(component->params);
+
+	if (xferi->dump_type >= RPAF_COMPONENT_MAX_NUM)
+		return -EINVAL;
+
+	if (IS_ERR_OR_NULL(dsp_component->dump_area[xferi->dump_type]))
+		return -EFAULT;
+
+	/*  */
+	mutex_lock(&dsp_component->comp_rw_lock);
+
+	if (size > component->dump_size)
+		read_size = component->dump_size;
+	if (size > component->dump_length[xferi->dump_type])
+		read_size = component->dump_length[xferi->dump_type];
+
+	sunxi_rpaf_dma_flush_range(dsp_component->dump_area[xferi->dump_type], component->dump_size);
+
+	/* dsplib_writedump */
+	if (copy_to_user(buf, dsp_component->dump_area[xferi->dump_type], read_size)) {
+		mutex_unlock(&dsp_component->comp_rw_lock);
+		return -EFAULT;
+	}
+	xferi->dump_length = read_size;
+	mutex_unlock(&dsp_component->comp_rw_lock);
+
+	return read_size;
+}
+
+static int snd_soc_rpaf_pcm_wait_for_avail(struct snd_dsp_component *dsp_component,
+			      snd_pcm_uframes_t *availp)
+{
+	struct snd_soc_rpaf_pcm_runtime *runtime = &dsp_component->runtime;
+	wait_queue_entry_t wait;
+	int err = 0;
+	snd_pcm_uframes_t avail = 0;
+	long wait_time, tout;
+
+	init_waitqueue_entry(&wait, current);
+	set_current_state(TASK_INTERRUPTIBLE);
+	add_wait_queue(&runtime->tsleep, &wait);
+
+	wait_time = msecs_to_jiffies(5 * 1000);
+
+	for (;;) {
+		if (signal_pending(current)) {
+			err = -ERESTARTSYS;
+			break;
+		}
+
+		/*
+		 * We need to check if space became available already
+		 * (and thus the wakeup happened already) first to close
+		 * the race of space already having become available.
+		 * This check must happen after been added to the waitqueue
+		 * and having current state be INTERRUPTIBLE.
+		 */
+		avail = snd_soc_rpaf_pcm_capture_avail(runtime);
+		if (avail >= runtime->twake)
+			break;
+		snd_soc_rpaf_pcm_stream_unlock_irq(dsp_component);
+
+		tout = schedule_timeout(wait_time);
+
+		snd_soc_rpaf_pcm_stream_lock_irq(dsp_component);
+		set_current_state(TASK_INTERRUPTIBLE);
+		if (!tout) {
+			pr_alert("[%s] line:%d cannot get avail data.\n",
+				__func__, __LINE__);
+			err = -EIO;
+			break;
+		}
+	}
+
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&runtime->tsleep, &wait);
+	*availp = avail;
+	return err;
+}
+
+static int32_t snd_soc_rpaf_pcm_stream_lib_read_transfer(struct snd_dsp_component *dsp_component,
+				     unsigned int hwoff,
+				     unsigned long data, unsigned int off,
+				     snd_pcm_uframes_t frames)
+{
+	struct snd_soc_rpaf_pcm_runtime *runtime = &dsp_component->runtime;
+	char __user *buf = (char __user *) data +
+		snd_soc_rpaf_pcm_frames_to_bytes(runtime, off);
+	char *hwbuf = dsp_component->read_area +
+		snd_soc_rpaf_pcm_frames_to_bytes(runtime, hwoff);
+	ssize_t sizes = snd_soc_rpaf_pcm_frames_to_bytes(runtime, frames);
+
+	snd_soc_rpaf_pcm_stream_component_lock();
+
+	if (!dsp_component->private_data) {
+		awrpaf_err("pcm stream had been closed.\n");
+
+		snd_soc_rpaf_pcm_stream_component_unlock();
+
+		return -EFAULT;
+	}
+
+	if (copy_to_user(buf, hwbuf, sizes)) {
+
+		snd_soc_rpaf_pcm_stream_component_unlock();
+
+		return -EFAULT;
+	}
+
+	snd_soc_rpaf_pcm_stream_component_unlock();
+
+	return 0;
+}
+
+static int snd_soc_rpaf_pcm_update_hw_ptr(struct snd_dsp_component *dsp_component,
+					unsigned int in_interrupt)
+{
+	struct snd_soc_rpaf_pcm_runtime *runtime = &dsp_component->runtime;
+	struct msg_component_package *msg_component = &dsp_component->msg_component;
+	struct snd_soc_dsp_component *soc_component = &msg_component->soc_component;
+	struct snd_soc_dsp_pcm_params *pcm_params = &(soc_component->params);
+	snd_pcm_uframes_t avail;
+	snd_pcm_uframes_t pos;
+	snd_pcm_uframes_t old_hw_ptr, new_hw_ptr, hw_base;
+	snd_pcm_sframes_t delta;
+
+	old_hw_ptr = runtime->hw_ptr;
+
+	pos = snd_soc_rpaf_pcm_pointer(runtime);
+	if (pos >= runtime->buffer_size)
+		pos = 0;
+
+	hw_base = runtime->hw_ptr_base;
+	new_hw_ptr = hw_base + pos;
+
+	/*
+	 * new_hw_ptr might be lower than old_hw_ptr in case
+	 * when pointer cross the end of the ring buffer
+	 */
+	if (new_hw_ptr < old_hw_ptr) {
+		hw_base += runtime->buffer_size;
+		if (hw_base >= runtime->boundary) {
+			hw_base = 0;
+		}
+		new_hw_ptr = hw_base + pos;
+	}
+
+	delta = new_hw_ptr - old_hw_ptr;
+
+	/* it means cross the end of boundary */
+	if (delta < 0)
+		delta += runtime->boundary;
+
+	/* something must be really wrong */
+	if (delta >= runtime->buffer_size + runtime->period_size) {
+		pr_err("[%s] Unexpected hw_ptr, stream:%d, pos:%lu, new_hw_ptr:%lu, old_hw_ptr:%lu\n",
+				(in_interrupt) ? "Q" : "P",
+				pcm_params->stream, pos, new_hw_ptr, old_hw_ptr);
+		return 0;
+	}
+
+	if (delta > runtime->period_size + runtime->period_size / 2) {
+		pr_debug("[%s] Lost interrupts? stream:%d, pos:%lu, new_hw_ptr:%lu, old_hw_ptr:%lu\n",
+			(in_interrupt) ? "Q" : "P",
+			pcm_params->stream, pos, new_hw_ptr, old_hw_ptr);
+	}
+
+	if (runtime->hw_ptr == new_hw_ptr)
+		return 0;
+
+	runtime->hw_ptr_base = hw_base;
+	runtime->hw_ptr = new_hw_ptr;
+
+	/* update avail */
+	avail = snd_soc_rpaf_pcm_capture_avail(runtime);
+	if (avail > runtime->avail_max)
+		runtime->avail_max = avail;
+
+	if (avail >= runtime->buffer_size) {
+		return -EPIPE;
+	}
+
+	if (runtime->twake) {
+		if (avail >= runtime->twake)
+			wake_up(&runtime->tsleep);
+	}
+
+	return 0;
+}
+
+void snd_soc_rpaf_pcm_stream_update_complete(void *arg)
+{
+	struct snd_dsp_component *dsp_component = arg;
+	struct snd_soc_rpaf_pcm_runtime *runtime = &dsp_component->runtime;
+	unsigned long flags;
+
+	flags = snd_soc_rpaf_pcm_stream_lock_irqsave(dsp_component);
+
+	runtime->pos += snd_soc_rpaf_pcm_frames_to_bytes(runtime,
+					runtime->period_size);
+	if (runtime->pos >= snd_soc_rpaf_pcm_frames_to_bytes(runtime,
+					runtime->buffer_size))
+		runtime->pos = 0;
+
+	if (snd_soc_rpaf_pcm_update_hw_ptr(dsp_component, 1) < 0) {
+		goto _end;
+	}
+ _end:
+	snd_soc_rpaf_pcm_stream_unlock_irqrestore(dsp_component, flags);
+}
+EXPORT_SYMBOL(snd_soc_rpaf_pcm_stream_update_complete);
+
+static int snd_soc_rpaf_misc_common_start(struct snd_dsp_component *dsp_component);
+
+ssize_t snd_soc_rpaf_misc_stream_lib_read(struct snd_dsp_component *dsp_component,
+				struct snd_rpaf_xferi *xferi, transfer_f transfer)
+{
+	char __user *buf = (char __user *)(xferi->dump_buf);
+	struct snd_soc_rpaf_pcm_runtime *runtime = &dsp_component->runtime;
+	ssize_t size = xferi->dump_length;
+	snd_pcm_sframes_t xfer = 0;
+	snd_pcm_uframes_t offset = 0;
+	snd_pcm_uframes_t avail = 0;
+	ssize_t err = 0;
+
+	if (xferi->dump_type >= RPAF_COMPONENT_MAX_NUM)
+		return -EINVAL;
+
+	if (IS_ERR_OR_NULL(dsp_component->read_area))
+		return -EFAULT;
+
+	if (dsp_component->state != SND_DSP_COMPONENT_STATE_RUNNING) {
+		err = snd_soc_rpaf_misc_common_start(dsp_component);
+		if (err < 0) {
+			awrpaf_err("start failed.\n");
+			return err;
+		}
+	}
+
+	snd_soc_rpaf_pcm_stream_lock_irq(dsp_component);
+
+	if (!dsp_component->private_data) {
+		err = -EFAULT;
+		goto _end_unlock;
+	}
+
+	runtime->dump_type = xferi->dump_type;
+	runtime->dump_start = 1;
+
+	snd_soc_rpaf_pcm_update_hw_ptr(dsp_component, 0);
+	avail = snd_soc_rpaf_pcm_capture_avail(runtime);
+	while (size > 0) {
+		snd_pcm_uframes_t frames, appl_ptr, appl_ofs;
+		snd_pcm_uframes_t cont;
+		if (!avail) {
+			runtime->twake = 1;
+			err = snd_soc_rpaf_pcm_wait_for_avail(dsp_component, &avail);
+			if (err < 0)
+				goto _end_unlock;
+			if (!avail)
+				continue;
+		}
+		frames = size > avail ? avail : size;
+		cont = runtime->buffer_size - runtime->appl_ptr % runtime->buffer_size;
+		if (frames > cont)
+			frames = cont;
+		if (WARN_ON(!frames)) {
+			runtime->twake = 0;
+			snd_soc_rpaf_pcm_stream_unlock_irq(dsp_component);
+			return -EINVAL;
+		}
+		appl_ptr = runtime->appl_ptr;
+		appl_ofs = appl_ptr % runtime->buffer_size;
+
+		snd_soc_rpaf_pcm_stream_unlock_irq(dsp_component);
+		err = transfer(dsp_component, appl_ofs, (unsigned long)buf, offset, frames);
+		snd_soc_rpaf_pcm_stream_lock_irq(dsp_component);
+		if (err < 0)
+			goto _end_unlock;
+		appl_ptr += frames;
+		if (appl_ptr >= runtime->boundary)
+			appl_ptr -= runtime->boundary;
+		runtime->appl_ptr = appl_ptr;
+		offset += frames;
+		size -= frames;
+		xfer += frames;
+		avail -= frames;
+	}
+
+_end_unlock:
+	runtime->twake = 0;
+	snd_soc_rpaf_pcm_stream_unlock_irq(dsp_component);
+	return xfer > 0 ? xfer : err;
+}
+
+ssize_t snd_soc_rpaf_misc_lib_read(struct snd_dsp_component *dsp_component,
+				struct snd_rpaf_xferi *xferi)
+{
+	struct msg_component_package *msg_component = &dsp_component->msg_component;
+	struct snd_soc_dsp_component *component = &msg_component->soc_component;
+	ssize_t read_size;
+
+	switch (component->comp_mode) {
+	case SND_DSP_COMPONENT_MODE_INDEPENDENCE:
+		read_size = snd_soc_rpaf_misc_component_lib_read(dsp_component, xferi);
+		dsp_component->state = SND_DSP_COMPONENT_STATE_RUNNING;
+		break;
+	case SND_DSP_COMPONENT_MODE_STREAM:
+		read_size = snd_soc_rpaf_misc_stream_lib_read(dsp_component,
+				xferi, snd_soc_rpaf_pcm_stream_lib_read_transfer);
+		dsp_component->state = SND_DSP_COMPONENT_STATE_RUNNING;
+		break;
+	default:
+		read_size = -EINVAL;
+		break;
+	}
+	return read_size;
+}
+
+static ssize_t snd_soc_rpaf_write_to_user(struct snd_dsp_component *dsp_component,
+			void __user * const data, ssize_t *size)
+{
+	struct msg_component_package *msg_component = &dsp_component->msg_component;
+	struct snd_soc_dsp_component *component = &msg_component->soc_component;
+//	struct snd_soc_rpaf_info *rpaf_info = dsp_component->rpaf_info;
+	ssize_t write_size = *size;
+	char __user * const buf = (char __user * const)data;
+
+	sunxi_rpaf_dma_flush_range(component, sizeof(struct snd_soc_dsp_component));
+
+	if (*size > component->read_size)
+		write_size = component->read_size;
+	if (*size > component->read_length)
+		write_size = component->read_length;
+
+	sunxi_rpaf_dma_flush_range(dsp_component->read_area, component->read_size);
+
+	if (copy_to_user(buf, dsp_component->read_area, write_size)) {
+		*size = 0;
+		return -EFAULT;
+	}
+	*size = write_size;
+
+	return write_size;
+}
+
+static ssize_t snd_soc_rpaf_misc_write(struct file *file, const char __user *buf,
+					size_t count, loff_t *offset)
+{
+	struct snd_dsp_component *dsp_component = file->private_data;
+	struct msg_component_package *msg_component = &dsp_component->msg_component;
+	struct snd_soc_dsp_component *component = &msg_component->soc_component;
+	struct snd_soc_rpaf_info *rpaf_info = dsp_component->rpaf_info;
+	ssize_t read_size = count;
+	int ret;
+
+	if (count > component->read_size)
+		read_size = component->read_size;
+
+	mutex_lock(&dsp_component->comp_rw_lock);
+	if (copy_from_user(dsp_component->write_area, buf, read_size)) {
+		mutex_unlock(&dsp_component->comp_rw_lock);
+		return 0;
+	}
+	sunxi_rpaf_dma_flush_range(dsp_component->write_area, read_size);
+
+	component->cmd_val = SND_SOC_DSP_COMPONENT_WRITE;
+	/* msgbox to dsp */
+	ret = sunxi_hifi_component_block_send(rpaf_info->dsp_id, msg_component);
+	mutex_unlock(&dsp_component->comp_rw_lock);
+	if (ret < 0) {
+		pr_err("%s line:%d error:%d\n", __func__, __LINE__, ret);
+		return ret;
+	}
+
+	return read_size;
+}
+
+ssize_t snd_soc_rpaf_misc_lib_write(struct snd_dsp_component *dsp_component,
+			  const void __user *data, ssize_t size)
+{
+	struct snd_soc_rpaf_info *rpaf_info = dsp_component->rpaf_info;
+	struct msg_component_package *msg_component = &dsp_component->msg_component;
+	struct snd_soc_dsp_component *component = &msg_component->soc_component;
+	ssize_t read_size = size;
+	const char __user *buf = (const char __user *)data;
+	int ret;
+
+	if (IS_ERR_OR_NULL(dsp_component->write_area) ||
+		IS_ERR_OR_NULL(dsp_component->read_area))
+		return -EFAULT;
+
+	mutex_lock(&dsp_component->comp_rw_lock);
+	if (size > component->write_size)
+		read_size = component->write_size;
+	component->write_length = read_size;
+
+	if (copy_from_user(dsp_component->write_area, buf, read_size)) {
+		mutex_unlock(&dsp_component->comp_rw_lock);
+		return 0;
+	}
+
+	sunxi_rpaf_dma_flush_range(dsp_component->write_area, read_size);
+
+	component->cmd_val = SND_SOC_DSP_COMPONENT_WRITE;
+	/* msgbox to dsp */
+	ret = sunxi_hifi_component_block_send(rpaf_info->dsp_id, msg_component);
+	mutex_unlock(&dsp_component->comp_rw_lock);
+	if (ret < 0) {
+		pr_err("%s line:%d error:%d\n", __func__, __LINE__, ret);
+		return ret;
+	}
+
+	return read_size;
+}
+
+static int snd_soc_rpaf_misc_lib_pcm_params(struct snd_soc_dsp_component *component,
+			struct snd_soc_dsp_pcm_params *params)
+{
+	struct snd_soc_dsp_pcm_params *pcm_params = &(component->params);
+
+	pcm_params->channels = params->channels;
+	pcm_params->rate = params->rate;
+	pcm_params->card = params->card;
+	pcm_params->device = params->device;
+	pcm_params->format = params->format;
+	pcm_params->stream = params->stream;
+	pcm_params->resample_rate = params->resample_rate;
+	pcm_params->period_size = params->period_size;
+	pcm_params->periods = params->periods;
+	pcm_params->buffer_size = params->buffer_size;
+	pcm_params->pcm_frames = params->pcm_frames;
+	pcm_params->data_type = params->data_type;
+	/* mp3 - aac */
+	pcm_params->codec_type = params->codec_type;
+
+	pcm_params->hw_stream = params->hw_stream;
+	pcm_params->data_mode = params->data_mode;
+	strncpy(pcm_params->driver, params->driver, 31);
+
+	pcm_params->input_size = params->input_size;
+	pcm_params->output_size = params->output_size;
+	pcm_params->dump_size = params->dump_size;
+	memcpy(pcm_params->algo_params, params->algo_params, sizeof(params->algo_params));
+
+#if 1//def RPAF_MEM_DEBUG_LOG
+	awrpaf_info("==================================\n");
+	awrpaf_info("channels = %d\n", pcm_params->channels);
+	awrpaf_info("rate = %d\n", pcm_params->rate);
+	awrpaf_info("card = %d\n", pcm_params->card);
+	awrpaf_info("device = %d\n", pcm_params->device);
+	awrpaf_info("format = %d\n", pcm_params->format);
+	awrpaf_info("stream = %d\n", pcm_params->stream);
+	awrpaf_info("resample_rate = %d\n", pcm_params->resample_rate);
+	awrpaf_info("period_size = %u\n", pcm_params->period_size);
+	awrpaf_info("buffer_size = %u\n", pcm_params->buffer_size);
+	awrpaf_info("data_type = %d\n", pcm_params->periods);
+	awrpaf_info("codec_type = %d\n", pcm_params->codec_type);
+	awrpaf_info("hw_stream = %d\n", pcm_params->hw_stream);
+	awrpaf_info("driver = %s\n", pcm_params->driver);
+	awrpaf_info("==================================\n");
+#endif
+
+	return 0;
+}
+
+static void snd_soc_rpaf_runtime_pcm_params(struct snd_soc_rpaf_pcm_runtime *runtime,
+	struct snd_soc_dsp_pcm_params *pcm_params)
+{
+	int bits = 0;
+
+	/* -- HW params -- */
+	switch (pcm_params->format) {
+	case SNDRV_PCM_FORMAT_S16:
+	case SNDRV_PCM_FORMAT_U16:
+		bits = 16;
+		break;
+	case SNDRV_PCM_FORMAT_S24:
+	case SNDRV_PCM_FORMAT_U24:
+	case SNDRV_PCM_FORMAT_S32:
+	case SNDRV_PCM_FORMAT_U32:
+		bits = 32;
+		break;
+	}
+	runtime->frame_bits = pcm_params->channels * bits;
+
+	/* period size */
+	runtime->period_size = pcm_params->period_size;
+	/* buffer size */
+	runtime->buffer_size = pcm_params->buffer_size;
+	runtime->avail_max = runtime->buffer_size;
+
+	/* -- SW params -- */
+	/* Silence filling size */
+	runtime->silence_size = runtime->buffer_size;
+	/* pointers wrap point */
+	runtime->boundary = runtime->buffer_size;
+	while (runtime->boundary * 2 <= LONG_MAX - runtime->buffer_size)
+		runtime->boundary *= 2;
+
+	/* transfer sleep */
+	init_waitqueue_head(&runtime->tsleep);
+}
+
+static int snd_soc_rpaf_misc_set_component_config_from_user(
+		struct snd_dsp_component *dsp_component,
+		struct snd_soc_dsp_component_config __user *_component_config)
+{
+	struct snd_soc_rpaf_info *rpaf_info = dsp_component->rpaf_info;
+	struct snd_soc_rpaf_pcm_runtime *runtime = &dsp_component->runtime;
+	struct msg_component_package *msg_component = &dsp_component->msg_component;
+	struct snd_soc_dsp_component *component = &msg_component->soc_component;
+	struct snd_soc_dsp_pcm_params *params;
+	struct snd_soc_dsp_component_config *component_config;
+	struct msg_component_package *stream_msg_component = NULL;
+	struct snd_dsp_component *stream_dsp_component = NULL;
+	int i = 0;
+	int ret = 0;
+
+	component_config = memdup_user(_component_config, sizeof(*component_config));
+	if (IS_ERR(component_config))
+		return PTR_ERR(component_config);
+
+	params = &component_config->pcm_params;
+	component->comp_mode = component_config->comp_mode;
+	component->component_type = component_config->component_type;
+	component->transfer_type = component_config->transfer_type;
+	memcpy(component->component_sort, component_config->component_sort,
+			sizeof(component->component_sort));
+
+	if (params->pcm_frames == 0) {
+		kfree(component_config);
+		return -EFAULT;
+	}
+
+	ret = snd_soc_rpaf_misc_lib_pcm_params(component, params);
+	if (ret < 0)
+		goto err_set_misc_lib_pcm_params;
+
+	snd_soc_rpaf_runtime_pcm_params(&dsp_component->runtime, params);
+
+	switch (component_config->comp_mode) {
+	case SND_DSP_COMPONENT_MODE_INDEPENDENCE:
+		component->write_size =  params->input_size;
+		component->read_size =  params->output_size;
+		component->dump_size = params->dump_size;
+		break;
+	case SND_DSP_COMPONENT_MODE_STREAM:
+		component->write_size = 0;
+		component->dump_size = 0;
+		component->read_size = snd_soc_rpaf_pcm_frames_to_bytes(runtime,
+						runtime->buffer_size);
+		break;
+	default:
+		goto err_set_misc_lib_pcm_params;
+		return -EINVAL;
+	}
+
+	if ((component->write_size) && (!component->write_addr)) {
+		dma_addr_t write_addr;
+		dsp_component->write_area = dma_alloc_coherent(rpaf_info->dev,
+						component->write_size,
+						&write_addr, GFP_KERNEL);
+		if (IS_ERR_OR_NULL(dsp_component->write_area)) {
+			ret = -ENOMEM;
+			goto err_malloc_write_addr;
+		}
+		component->write_addr = write_addr;
+	}
+
+	if ((component->read_size) && (!component->read_addr)) {
+		dma_addr_t read_addr;
+		dsp_component->read_area = dma_alloc_coherent(rpaf_info->dev,
+							component->read_size,
+							&read_addr, GFP_KERNEL);
+		if (IS_ERR_OR_NULL(dsp_component->read_area)) {
+			ret = -ENOMEM;
+			goto err_malloc_read_addr;
+		}
+		component->read_addr = read_addr;
+	}
+
+	dsp_component->state = SND_DSP_COMPONENT_STATE_SETUP;
+
+	if (component_config->comp_mode == SND_DSP_COMPONENT_MODE_STREAM)
+		goto _wait_msg_component_stream;
+	if (!component->dump_size)
+		goto _ignore_dump_area;
+
+	for (i = 0; i < ARRAY_SIZE(component->dump_addr); i++) {
+		dma_addr_t dump_addr;
+		if (component->dump_addr[i])
+			continue;
+		if ((component->component_type >> i) & 0x1) {
+			dsp_component->dump_area[i] = dma_alloc_coherent(rpaf_info->dev,
+							component->dump_size,
+							&dump_addr, GFP_KERNEL);
+			if (IS_ERR_OR_NULL(dsp_component->dump_area[i])) {
+				ret = -ENOMEM;
+				goto err_malloc_dump_addr;
+			}
+			component->dump_addr[i] = dump_addr;
+		}
+	}
+_ignore_dump_area:
+	kfree(component_config);
+	return ret;
+
+_wait_msg_component_stream:
+
+	/* 10? */
+	do {
+		static int i = 1;
+
+		stream_msg_component = sunxi_hifi_list_msg_component_find_item(msg_component);
+		if (i++ >= 100) {
+			i = 0;
+			awrpaf_err("cannot find running msg_component.\n");
+			ret = -EFAULT;
+			goto err_find_msg_component;
+		}
+		msleep(100);
+	} while (!stream_msg_component);
+	stream_dsp_component = container_of(stream_msg_component, struct snd_dsp_component,
+							msg_component);
+	/* pcm stream */
+	snd_soc_rpaf_pcm_stream_component_lock();
+
+	stream_dsp_component->private_data = dsp_component;
+	dsp_component->private_data = stream_dsp_component;
+
+	snd_soc_rpaf_pcm_stream_component_unlock();
+
+	kfree(component_config);
+	return ret;
+
+err_find_msg_component:
+err_malloc_dump_addr:
+	dma_free_coherent(rpaf_info->dev, component->read_size,
+				dsp_component->read_area, component->read_addr);
+	component->read_addr = 0;
+	dsp_component->read_area = NULL;
+	for (i = 0; i < ARRAY_SIZE(component->dump_addr); i++) {
+		if (!component->dump_addr[i])
+			continue;
+		dma_free_coherent(rpaf_info->dev, component->dump_size,
+				dsp_component->dump_area[i], component->dump_addr[i]);
+		component->dump_addr[i] = 0;
+		dsp_component->dump_area[i] = NULL;
+	}
+err_malloc_read_addr:
+	dma_free_coherent(rpaf_info->dev, component->write_size,
+				dsp_component->write_area, component->write_addr);
+	component->write_addr = 0;
+	dsp_component->write_area = NULL;
+err_malloc_write_addr:
+err_set_misc_lib_pcm_params:
+	kfree(component_config);
+	return ret;
+}
+
+static int snd_soc_rpaf_misc_set_pcm_params_to_user(struct snd_dsp_component *dsp_component,
+				struct snd_soc_dsp_pcm_params __user *_params)
+{
+	struct snd_soc_rpaf_info *rpaf_info = dsp_component->rpaf_info;
+
+	dev_err(rpaf_info->dev, "%s line:%d\n", __func__, __LINE__);
+	return 0;
+}
+
+static int snd_soc_rpaf_misc_common_set_algo(struct snd_dsp_component *dsp_component,
+					void __user *arg)
+{
+	struct snd_soc_rpaf_info *rpaf_info = dsp_component->rpaf_info;
+	struct msg_component_package *msg_component = &dsp_component->msg_component;
+	struct snd_soc_dsp_component *soc_component = &msg_component->soc_component;
+	struct snd_soc_dsp_component_config __user *_component_config = arg;
+	struct snd_soc_dsp_component_config component_config;
+	int ret;
+
+	if (copy_from_user(&component_config, _component_config,
+		sizeof(struct snd_soc_dsp_component_config))) {
+		dev_err(rpaf_info->dev, "cannot copy component_config.\n");
+		return -EFAULT;
+	}
+
+	soc_component->comp_mode = component_config.comp_mode;
+	soc_component->component_type = component_config.component_type;
+	strcpy(soc_component->params.driver, component_config.pcm_params.driver);
+	soc_component->transfer_type = component_config.transfer_type;
+	soc_component->sort_index = component_config.sort_index;
+	soc_component->used = component_config.component_used;
+	soc_component->params.stream = component_config.pcm_params.stream;
+
+	dev_dbg(rpaf_info->dev, "%s:Line:%d, driver:%s\n"
+		"component_config.comp_mode:%d, soc_component->comp_mode:%d\n"
+		"component_config.component_type:%d, soc_component->component_type:%d\n"
+		"component_config.sort_index:%d, soc_componen->sort_index:%d\n"
+		"component_config.pcm_params.stream:%d, soc_component->params.stream:%d\n"
+		"component_config.component_used:%d, soc_component->used:%d.\n",
+		__func__, __LINE__, soc_component->params.driver,
+		component_config.comp_mode, soc_component->comp_mode,
+		component_config.component_type, soc_component->component_type,
+		component_config.sort_index, soc_component->sort_index,
+		component_config.pcm_params.stream, soc_component->params.stream,
+		component_config.component_used, soc_component->used);
+
+	soc_component->cmd_val = SND_SOC_DSP_COMPONENT_ALGO_SET;
+	/* msgbox to dsp */
+	ret = sunxi_hifi_component_block_send(rpaf_info->dsp_id, msg_component);
+	if (ret < 0) {
+		pr_err("%s line:%d error:%d\n", __func__, __LINE__, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int snd_soc_rpaf_misc_common_get_algo(struct snd_dsp_component *dsp_component,
+					void __user *arg)
+{
+	struct snd_soc_rpaf_info *rpaf_info = dsp_component->rpaf_info;
+	struct msg_component_package *msg_component = &dsp_component->msg_component;
+	struct snd_soc_dsp_component *soc_component = &msg_component->soc_component;
+	struct snd_soc_dsp_component_config __user *_component_config = arg;
+	struct snd_soc_dsp_component_config component_config;
+	int ret;
+
+	if (copy_from_user(&component_config, _component_config,
+		sizeof(struct snd_soc_dsp_component_config))) {
+		dev_err(rpaf_info->dev, "cannot copy component_config.\n");
+		return -EFAULT;
+	}
+
+	soc_component->cmd_val = SND_SOC_DSP_COMPONENT_ALGO_GET;
+	soc_component->comp_mode = SND_DSP_COMPONENT_MODE_ALGO;
+	soc_component->component_type = component_config.component_type;
+	strcpy(soc_component->params.driver, component_config.pcm_params.driver);
+	soc_component->transfer_type = component_config.transfer_type;
+	soc_component->sort_index = component_config.sort_index;
+	soc_component->used = component_config.component_used;
+	soc_component->params.stream = component_config.pcm_params.stream;
+
+	/* msgbox to dsp */
+	ret = sunxi_hifi_component_block_send(rpaf_info->dsp_id, msg_component);
+	if (ret < 0) {
+		pr_err("%s line:%d error:%d\n", __func__, __LINE__, ret);
+		return ret;
+	}
+
+	dev_dbg(rpaf_info->dev, "%s:Line:%d, driver:%s\n"
+		"component_config.comp_mode:%d, soc_component->comp_mode:%d\n"
+		"component_config.component_type:%d, soc_component->component_type:%d\n"
+		"component_config.sort_index:%d, soc_componen->sort_index:%d\n"
+		"component_config.pcm_params.stream:%d, soc_component->params.stream:%d\n"
+		"component_config.component_used:%d, soc_component->used:%d.\n",
+		__func__, __LINE__, soc_component->params.driver,
+		component_config.comp_mode, soc_component->comp_mode,
+		component_config.component_type, soc_component->component_type,
+		component_config.sort_index, soc_component->sort_index,
+		component_config.pcm_params.stream, soc_component->params.stream,
+		component_config.component_used, soc_component->used);
+
+	component_config.pcm_params.stream = soc_component->params.stream;
+	component_config.comp_mode = soc_component->comp_mode;
+	component_config.component_type = soc_component->component_type;
+	component_config.sort_index = soc_component->sort_index;
+	strcpy(component_config.pcm_params.driver, soc_component->params.driver);
+
+	if (copy_to_user(_component_config, &component_config,
+		sizeof(struct snd_soc_dsp_component_config))) {
+		dev_err(rpaf_info->dev, "cannot copy component_config.\n");
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+static int snd_soc_rpaf_misc_common_create(struct snd_dsp_component *dsp_component,
+					void __user *arg)
+{
+	struct snd_soc_rpaf_info *rpaf_info = dsp_component->rpaf_info;
+	struct msg_component_package *msg_component = &dsp_component->msg_component;
+	struct snd_soc_dsp_component *soc_component = &msg_component->soc_component;
+	int i = 0;
+	int result = 0;
+
+	/*  */
+	switch (dsp_component->state) {
+	case SND_DSP_COMPONENT_STATE_CREATE:
+	case SND_DSP_COMPONENT_STATE_SETUP:
+	case SND_DSP_COMPONENT_STATE_START:
+	case SND_DSP_COMPONENT_STATE_RUNNING:
+	case SND_DSP_COMPONENT_STATE_STOP:
+	case SND_DSP_COMPONENT_STATE_REMOVE:
+	case SND_DSP_COMPONENT_STATE_CLOSE:
+	default:
+		return -EINVAL;
+	case SND_DSP_COMPONENT_STATE_OPEN:
+		break;
+	}
+
+	/* ID */
+	mutex_lock(&comp_id_mutex);
+	for (i = 0; i < RPAF_COMPONENT_MAX_NUM; i++) {
+		if (!component_id[i]) {
+			soc_component->id = i;
+			component_id[i] = 1;
+			break;
+		}
+	}
+	mutex_unlock(&comp_id_mutex);
+
+	if (soc_component->id != i) {
+		awrpaf_err("component id num [%d] set id:%u failed!\n", i, soc_component->id);
+		return -EINVAL;
+	}
+
+	/*  */
+	dsp_component->state = SND_DSP_COMPONENT_STATE_CREATE;
+
+	/* SETUP */
+	result = snd_soc_rpaf_misc_set_component_config_from_user(dsp_component, arg);
+	if (result < 0) {
+		awrpaf_err("component[%u] setting pcm_params failed!\n", soc_component->id);
+		return result;
+	}
+
+	mutex_lock(&comp_id_mutex);
+	component_id[soc_component->id] = 1;
+	mutex_unlock(&comp_id_mutex);
+
+	if (soc_component->comp_mode == SND_DSP_COMPONENT_MODE_STREAM) {
+		return result;
+	}
+
+	soc_component->cmd_val = SND_SOC_DSP_COMPONENT_CREATE;
+	/* msgbox to dsp */
+
+	result = sunxi_hifi_component_block_send(rpaf_info->dsp_id, msg_component);
+	if (result < 0) {
+		pr_err("%s line:%d error:%d\n", __func__, __LINE__, result);
+		return result;
+	}
+
+	return result;
+}
+
+static int snd_soc_rpaf_misc_common_remove(struct snd_dsp_component *dsp_component)
+{
+	struct snd_soc_rpaf_info *rpaf_info = dsp_component->rpaf_info;
+	struct msg_component_package *msg_component = &dsp_component->msg_component;
+	struct snd_soc_dsp_component *soc_component = &msg_component->soc_component;
+	struct snd_dsp_component *stream_dsp_component = NULL;
+	int ret;
+
+	/*  */
+	switch (dsp_component->state) {
+	case SND_DSP_COMPONENT_STATE_CREATE:
+	case SND_DSP_COMPONENT_STATE_START:
+	case SND_DSP_COMPONENT_STATE_RUNNING:
+	case SND_DSP_COMPONENT_STATE_REMOVE:
+	case SND_DSP_COMPONENT_STATE_CLOSE:
+	default:
+		return -EINVAL;
+	case SND_DSP_COMPONENT_STATE_OPEN:
+	case SND_DSP_COMPONENT_STATE_SETUP:
+	case SND_DSP_COMPONENT_STATE_STOP:
+		break;
+	}
+
+	mutex_lock(&comp_id_mutex);
+	component_id[soc_component->id] = 0;
+	mutex_unlock(&comp_id_mutex);
+
+	if (soc_component->comp_mode == SND_DSP_COMPONENT_MODE_STREAM) {
+
+		snd_soc_rpaf_pcm_stream_component_lock();
+
+		stream_dsp_component = dsp_component->private_data;
+		if (stream_dsp_component && stream_dsp_component->private_data) {
+			stream_dsp_component->private_data = NULL;
+			dsp_component->private_data = NULL;
+		}
+
+		snd_soc_rpaf_pcm_stream_component_unlock();
+
+		dsp_component->state = SND_DSP_COMPONENT_STATE_REMOVE;
+		return 0;
+	}
+
+	soc_component->cmd_val = SND_SOC_DSP_COMPONENT_REMOVE;
+	/* msgbox to dsp */
+	ret = sunxi_hifi_component_block_send(rpaf_info->dsp_id, msg_component);
+	if (ret < 0) {
+		pr_err("%s line:%d error:%d\n", __func__, __LINE__, ret);
+		return ret;
+	}
+	/*  */
+	dsp_component->state = SND_DSP_COMPONENT_STATE_REMOVE;
+	return 0;
+}
+
+static int snd_soc_rpaf_misc_common_status(struct snd_dsp_component *dsp_component)
+{
+	struct snd_soc_rpaf_info *rpaf_info = dsp_component->rpaf_info;
+
+	dev_err(rpaf_info->dev, "%s line:%d\n", __func__, __LINE__);
+	/* /msgbox to dsp */
+	return 0;
+}
+
+static void snd_soc_rpaf_runtime_prepare(struct snd_soc_rpaf_pcm_runtime *runtime)
+{
+	runtime->pos = 0;
+	runtime->hw_ptr = 0;
+	runtime->appl_ptr = 0;
+
+	/* Position at buffer restart */
+	runtime->hw_ptr_base = 0;
+	/* Position at interrupt time */
+	runtime->hw_ptr_interrupt = 0;
+	/* offset for hw_ptr due to boundary wrap-around */
+	runtime->hw_ptr_wrap = 0;
+}
+
+static int snd_soc_rpaf_misc_common_start(struct snd_dsp_component *dsp_component)
+{
+	struct snd_soc_rpaf_info *rpaf_info = dsp_component->rpaf_info;
+	struct msg_component_package *msg_component = &dsp_component->msg_component;
+	struct snd_soc_dsp_component *soc_component = &msg_component->soc_component;
+	struct snd_soc_rpaf_pcm_runtime *runtime = &dsp_component->runtime;
+	int ret;
+
+	/*  */
+	switch (dsp_component->state) {
+	case SND_DSP_COMPONENT_STATE_OPEN:
+	case SND_DSP_COMPONENT_STATE_CREATE:
+	case SND_DSP_COMPONENT_STATE_START:
+	case SND_DSP_COMPONENT_STATE_RUNNING:
+	case SND_DSP_COMPONENT_STATE_REMOVE:
+	case SND_DSP_COMPONENT_STATE_CLOSE:
+	default:
+		return -EINVAL;
+	case SND_DSP_COMPONENT_STATE_SETUP:
+	case SND_DSP_COMPONENT_STATE_STOP:
+		break;
+	}
+
+	if (soc_component->comp_mode == SND_DSP_COMPONENT_MODE_STREAM) {
+		snd_soc_rpaf_pcm_stream_lock_irq(dsp_component);
+		/*  */
+		snd_soc_rpaf_runtime_prepare(runtime);
+		snd_soc_rpaf_pcm_stream_unlock_irq(dsp_component);
+	}
+
+	soc_component->cmd_val = SND_SOC_DSP_COMPONENT_START;
+	/* msgbox to dsp */
+	ret = sunxi_hifi_component_block_send(rpaf_info->dsp_id, msg_component);
+	if (ret < 0) {
+		pr_err("%s line:%d error:%d\n", __func__, __LINE__, ret);
+		return ret;
+	}
+	/*  */
+	dsp_component->state = SND_DSP_COMPONENT_STATE_START;
+	return 0;
+}
+
+static int snd_soc_rpaf_misc_common_stop(struct snd_dsp_component *dsp_component)
+{
+	struct snd_soc_rpaf_info *rpaf_info = dsp_component->rpaf_info;
+	struct msg_component_package *msg_component = &dsp_component->msg_component;
+	struct snd_soc_dsp_component *soc_component = &msg_component->soc_component;
+	struct snd_soc_rpaf_pcm_runtime *runtime = &dsp_component->runtime;
+	int ret;
+
+	/*  */
+	switch (dsp_component->state) {
+	case SND_DSP_COMPONENT_STATE_OPEN:
+	case SND_DSP_COMPONENT_STATE_CREATE:
+	case SND_DSP_COMPONENT_STATE_SETUP:
+	case SND_DSP_COMPONENT_STATE_STOP:
+	case SND_DSP_COMPONENT_STATE_REMOVE:
+	case SND_DSP_COMPONENT_STATE_CLOSE:
+	default:
+		return -EINVAL;
+	case SND_DSP_COMPONENT_STATE_START:
+	case SND_DSP_COMPONENT_STATE_RUNNING:
+		break;
+	}
+
+	runtime->dump_start = 0;
+
+	soc_component->cmd_val = SND_SOC_DSP_COMPONENT_STOP;
+	/* msgbox to dsp */
+	ret = sunxi_hifi_component_block_send(rpaf_info->dsp_id, msg_component);
+	if (ret < 0) {
+		pr_err("%s line:%d error:%d\n", __func__, __LINE__, ret);
+		return ret;
+	}
+	/*  */
+	dsp_component->state = SND_DSP_COMPONENT_STATE_STOP;
+	return 0;
+}
+
+static long snd_soc_rpaf_misc_common_ioctl(struct file *file,
+				      struct snd_dsp_component *dsp_component,
+				      unsigned int cmd,
+				      void __user *arg)
+{
+	int result;
+	struct snd_soc_rpaf_info *rpaf_info;
+
+	if (IS_ERR_OR_NULL(dsp_component))
+		return -ENXIO;
+
+	rpaf_info = dsp_component->rpaf_info;
+
+	switch (cmd) {
+	case SND_SOC_DSP_COMPONENT_IOCTL_ALGO_SET:
+		result = snd_soc_rpaf_misc_common_set_algo(dsp_component, arg);
+		break;
+	case SND_SOC_DSP_COMPONENT_IOCTL_ALGO_GET:
+		result = snd_soc_rpaf_misc_common_get_algo(dsp_component, arg);
+		break;
+	case SND_SOC_DSP_COMPONENT_IOCTL_CREATE:
+		result = snd_soc_rpaf_misc_common_create(dsp_component, arg);
+		break;
+	case SND_SOC_DSP_COMPONENT_IOCTL_REMOVE:
+		result = snd_soc_rpaf_misc_common_remove(dsp_component);
+		put_user(result, (int __user *)arg);
+		break;
+	case SND_SOC_DSP_COMPONENT_IOCTL_STATUS:
+		result = snd_soc_rpaf_misc_common_status(dsp_component);
+		put_user(result, (int __user *)arg);
+		break;
+	case SND_SOC_DSP_COMPONENT_IOCTL_SW_PARAMS:
+		result = snd_soc_rpaf_misc_set_pcm_params_to_user(dsp_component, arg);
+		break;
+	case SND_SOC_DSP_COMPONENT_IOCTL_START:
+		result = snd_soc_rpaf_misc_common_start(dsp_component);
+		put_user(result, (int __user *)arg);
+		break;
+	case SND_SOC_DSP_COMPONENT_IOCTL_STOP:
+		result = snd_soc_rpaf_misc_common_stop(dsp_component);
+		put_user(result, (int __user *)arg);
+		break;
+	/* dump */
+	case SND_SOC_DSP_COMPONENT_IOCTL_READ:
+	{
+		struct snd_rpaf_xferi xferi;
+		struct snd_rpaf_xferi __user *_xferi = arg;
+
+		if (put_user(0, &_xferi->result))
+			return -EFAULT;
+
+		if (copy_from_user(&xferi, _xferi, sizeof(struct snd_rpaf_xferi)))
+			return -EFAULT;
+
+		result = snd_soc_rpaf_misc_lib_read(dsp_component, &xferi);
+		if (copy_to_user(_xferi, &xferi, sizeof(*_xferi)))
+			return -EFAULT;
+		__put_user(result, &_xferi->result);
+		return result < 0 ? result : 0;
+	}
+	case SND_SOC_DSP_COMPONENT_IOCTL_WRITE:
+	{
+		struct snd_rpaf_xferi xferi;
+		struct snd_rpaf_xferi __user *_xferi = arg;
+		struct msg_component_package *msg_component = &dsp_component->msg_component;
+		struct snd_soc_dsp_component *component = &msg_component->soc_component;
+		int result;
+
+		if (put_user(0, &_xferi->result))
+			return -EFAULT;
+		if (copy_from_user(&xferi, _xferi, sizeof(*_xferi)))
+			return -EFAULT;
+
+		dsp_component->state = SND_DSP_COMPONENT_STATE_RUNNING;
+
+		component->write_length = xferi.input_length;
+		component->read_length = xferi.output_length;
+		result = snd_soc_rpaf_misc_lib_write(dsp_component, xferi.input_buf,
+						xferi.input_length);
+		if (result < 0) {
+			__put_user(result, &_xferi->result);
+			return result < 0 ? result : 0;
+		}
+		/*  */
+		result = snd_soc_rpaf_write_to_user(dsp_component, xferi.output_buf,
+						&xferi.output_length);
+		if (copy_to_user(_xferi, &xferi, sizeof(*_xferi)))
+			return -EFAULT;
+		__put_user(result, &_xferi->result);
+		return result < 0 ? result : 0;
+	}
+#ifdef CONFIG_COMPAT
+	case SND_SOC_DSP_COMPONENT_IOCTL_WRITE32:
+	{
+		struct snd_rpaf_xferi xferi;
+		struct snd_rpaf_xferi32 __user *_xferi32 = arg;
+		struct msg_component_package *msg_component = &dsp_component->msg_component;
+		struct snd_soc_dsp_component *component = &msg_component->soc_component;
+		int result;
+		compat_caddr_t buf;
+
+		get_user(xferi.result, &_xferi32->result);
+		get_user(buf, &_xferi32->input_buf);
+		xferi.input_buf = compat_ptr(buf);
+		get_user(xferi.input_length, &_xferi32->input_length);
+		get_user(buf, &_xferi32->output_buf);
+		xferi.output_buf = compat_ptr(buf);
+		get_user(xferi.output_length, &_xferi32->output_length);
+		get_user(buf, &_xferi32->dump_buf);
+		xferi.dump_buf = compat_ptr(buf);
+		get_user(xferi.dump_length, &_xferi32->dump_length);
+		get_user(xferi.dump_type, &_xferi32->dump_type);
+
+		dsp_component->state = SND_DSP_COMPONENT_STATE_RUNNING;
+
+		component->write_length = xferi.input_length;
+		component->read_length = xferi.output_length;
+		result = snd_soc_rpaf_misc_lib_write(dsp_component, xferi.input_buf,
+						xferi.input_length);
+		if (result < 0) {
+			__put_user(result, &_xferi32->result);
+			return result < 0 ? result : 0;
+		}
+		/*  */
+		result = snd_soc_rpaf_write_to_user(dsp_component, xferi.output_buf,
+						&xferi.output_length);
+		__put_user(result, &_xferi32->result);
+		__put_user(xferi.output_length, &_xferi32->output_length);
+
+		return result < 0 ? result : 0;
+	}
+#endif
+	default:
+		dev_err(rpaf_info->dev, "%s cmd:%d not exist.\n", __func__, cmd);
+		return -EINVAL;
+	}
+
+	return result;
+}
+
+#ifdef CONFIG_COMPAT
+static long snd_soc_rpaf_misc_compat_ioctl(struct file *file,
+					  unsigned int cmd,
+					  unsigned long arg)
+{
+	struct snd_dsp_component *dsp_component = file->private_data;
+	void __user *argp = compat_ptr(arg);
+
+	if (((cmd >> 8) & 0xFF) != 'C')
+		return -ENOTTY;
+
+	return snd_soc_rpaf_misc_common_ioctl(file, dsp_component, cmd, argp);
+}
+#endif
+
+static long snd_soc_rpaf_misc_unlocked_ioctl(struct file *file,
+					  unsigned int cmd,
+					  unsigned long arg)
+{
+	struct snd_dsp_component *dsp_component = file->private_data;
+
+	if (((cmd >> 8) & 0xFF) != 'C')
+		return -ENOTTY;
+
+	return snd_soc_rpaf_misc_common_ioctl(file, dsp_component, cmd,
+					(void __user *)arg);
+}
+
+static const struct file_operations snd_soc_rpaf_misc_f_ops = {
+	.owner = THIS_MODULE,
+	.open = snd_soc_rpaf_misc_open,
+	.unlocked_ioctl = snd_soc_rpaf_misc_unlocked_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = snd_soc_rpaf_misc_compat_ioctl,
+#endif
+//	.read = snd_soc_rpaf_misc_read,
+	.write = snd_soc_rpaf_misc_write,
+	.llseek = no_llseek,
+	.release = snd_soc_rpaf_misc_release,
+};
+
+static struct miscdevice snd_soc_rpaf_misc_dev = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name  = "sunxi-rpaf-dsp",
+	.fops = &snd_soc_rpaf_misc_f_ops,
+};
+
+int snd_soc_rpaf_misc_register_device(struct device *dev, unsigned int dsp_id)
+{
+	char *str_name = NULL;
+	struct snd_soc_rpaf_info *rpaf_info = NULL;
+	int ret = 0;
+
+	if (IS_ERR_OR_NULL(dev)) {
+		pr_alert("[%s] dev id:%u is null.\n", __func__, dsp_id);
+		return -EFAULT;
+	}
+
+	if (snd_soc_rpaf_info_get_from_list_by_dspid(dsp_id) != NULL) {
+		dev_err(dev, "the dsp_id had been register!\n");
+		return -EINVAL;
+	}
+
+	rpaf_info = devm_kzalloc(dev, sizeof(struct snd_soc_rpaf_info),
+				GFP_KERNEL);
+	if (IS_ERR_OR_NULL(rpaf_info)) {
+		dev_err(dev, "kzalloc for snd_soc_rpaf_info failed.\n");
+		return -ENOMEM;
+	}
+	rpaf_info->dev = dev;
+	rpaf_info->dsp_id = dsp_id;
+	memset(rpaf_info->name, 0, sizeof(rpaf_info->name));
+	snprintf(rpaf_info->name, sizeof(rpaf_info->name),
+		 "rpaf_misc%d", rpaf_info->dsp_id);
+
+	snd_soc_rpaf_info_set_drvdata(rpaf_info, dev_get_drvdata(rpaf_info->dev));
+
+	memcpy(&rpaf_info->misc_dev, &snd_soc_rpaf_misc_dev,
+		sizeof(struct miscdevice));
+	str_name = devm_kzalloc(dev, SUNXI_RPAF_INFO_NAME_LEN, GFP_KERNEL);
+	if (IS_ERR_OR_NULL(str_name)) {
+		dev_err(dev, "failed to kzalloc attr group name!\n");
+		ret = -ENOMEM;
+		goto err_kzalloc_misc_dev_name;
+	}
+	memset(str_name, 0, SUNXI_RPAF_INFO_NAME_LEN);
+	snprintf(str_name, SUNXI_RPAF_INFO_NAME_LEN,
+		 "rpaf-dsp%d", rpaf_info->dsp_id);
+	rpaf_info->misc_dev.name = str_name;
+
+	ret = misc_register(&rpaf_info->misc_dev);
+	if (ret < 0) {
+		dev_err(dev, "sunxi-rpaf register driver as misc device error!\n");
+		goto err_misc_register;
+	}
+
+	snd_soc_rpaf_info_list_add_tail(rpaf_info);
+
+	dev_info(dev, "register device finished!\n");
+
+	return 0;
+err_misc_register:
+	if (!IS_ERR_OR_NULL(rpaf_info->misc_dev.name)) {
+		str_name = (char *)rpaf_info->misc_dev.name;
+		devm_kfree(dev, str_name);
+	}
+err_kzalloc_misc_dev_name:
+	devm_kfree(dev, rpaf_info);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_rpaf_misc_register_device);
+
+int snd_soc_rpaf_misc_deregister_device(struct device *dev, unsigned int dsp_id)
+{
+	struct snd_soc_rpaf_info *rpaf_info = NULL;
+	int ret = 0;
+
+	if (IS_ERR_OR_NULL(dev)) {
+		pr_alert("[%s] dev id:%u is null.\n", __func__, dsp_id);
+		return -EFAULT;
+	}
+
+	rpaf_info = snd_soc_rpaf_info_get_from_list_by_dspid(dsp_id);
+	if (IS_ERR_OR_NULL(rpaf_info)) {
+		dev_err(dev, "the dsp_id had been del from rpaf_info list.!\n");
+		return -EINVAL;
+	}
+
+	misc_deregister(&rpaf_info->misc_dev);
+	if (!IS_ERR_OR_NULL(rpaf_info->misc_dev.name))
+		devm_kfree(dev, (char *)rpaf_info->misc_dev.name);
+
+	snd_soc_rpaf_info_list_del(rpaf_info);
+
+	dev_info(dev, "deregister device finished!\n");
+
+	devm_kfree(dev, rpaf_info);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_soc_rpaf_misc_deregister_device);
+
+MODULE_DESCRIPTION("sunxi dsp remote processor audio framework core");
+MODULE_AUTHOR("yumingfeng@allwinnertech.com");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/sunxi/sunxi-rpaf/component/component-driver.c b/sound/soc/sunxi/sunxi-rpaf/component/component-driver.c
new file mode 100644
index 000000000..7a89daeba
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-rpaf/component/component-driver.c
@@ -0,0 +1,177 @@
+/*
+ * sound\sunxi-rpaf\component\rpaf-comp-driver.c
+ * (C) Copyright 2019-2025
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * yumingfeng <yumingfeng@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/printk.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/poll.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/etherdevice.h>
+#include <linux/crypto.h>
+#include <linux/miscdevice.h>
+#include <linux/capability.h>
+
+#include <sound/aw_rpaf/component-driver.h>
+#include <sound/aw_rpaf/component-core.h>
+
+static ssize_t show_rpaf_status(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct snd_soc_rpaf_info *rpaf_info = dev_get_drvdata(dev);
+	int count = 0;
+
+	count += sprintf(buf, "[%s] dump audio status:\n", rpaf_info->name);
+
+	return count;
+}
+
+static ssize_t store_rpaf_status(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	struct snd_soc_rpaf_info *rpaf_info = dev_get_drvdata(dev);
+	int ret = 0;
+	int rw_flag = 0;
+	int input_status_group = 0;
+	int input_status_cmd = 0;
+
+	ret = sscanf(buf, "%d,%d,%d", &rw_flag, &input_status_group,
+				&input_status_cmd);
+	dev_info(dev, "[%s] ret:%d, rw_flag:%d, status_group:%d, status_cmd:%d\n",
+			rpaf_info->name, ret, rw_flag, input_status_group,
+			input_status_cmd);
+	ret = count;
+
+	return ret;
+}
+
+static DEVICE_ATTR(status_debug, 0644, show_rpaf_status, store_rpaf_status);
+
+static struct attribute *rpaf_dev_debug_attrs[] = {
+	&dev_attr_status_debug.attr,
+	NULL,
+};
+
+static struct attribute_group rpaf_dev_debug_attr_group = {
+	.name   = "audio_debug",
+	.attrs  = rpaf_dev_debug_attrs,
+};
+
+static int snd_soc_rpaf_misc_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct device *dev = &pdev->dev;
+	struct snd_soc_rpaf_misc_priv *rpaf_misc_priv = NULL;
+	unsigned int temp_val = 0;
+	int ret = 0;
+
+	rpaf_misc_priv = devm_kzalloc(dev, sizeof(struct snd_soc_rpaf_misc_priv),
+								GFP_KERNEL);
+	if (IS_ERR_OR_NULL(rpaf_misc_priv)) {
+		dev_err(dev, "kzalloc for snd_soc_rpaf_misc_priv failed.\n");
+		return -ENOMEM;
+	}
+	rpaf_misc_priv->dev = dev;
+	dev_set_drvdata(&pdev->dev, rpaf_misc_priv);
+
+	ret = of_property_read_u32(np, "dsp_id", &temp_val);
+	if (ret < 0) {
+		dev_err(dev, "cannot get dsp_id number!\n");
+		goto err_prop_read_dsp_id;
+	}
+	rpaf_misc_priv->dsp_id = temp_val;
+	memset(rpaf_misc_priv->name, 0, sizeof(rpaf_misc_priv->name));
+	snprintf(rpaf_misc_priv->name, sizeof(rpaf_misc_priv->name),
+			"rpaf_dsp%d",
+			rpaf_misc_priv->dsp_id);
+
+	ret  = sysfs_create_group(&pdev->dev.kobj, &rpaf_dev_debug_attr_group);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "failed to create attr group\n");
+		goto err_sysfs_create;
+	}
+
+	ret = snd_soc_rpaf_misc_register_device(&pdev->dev, rpaf_misc_priv->dsp_id);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "dsp_id(%d) deregister dev error(%d).\n",
+					rpaf_misc_priv->dsp_id, ret);
+			goto err_misc_register_device;
+	}
+
+	dev_info(&pdev->dev, "[%s] probe finished!\n", rpaf_misc_priv->name);
+
+	return 0;
+err_misc_register_device:
+	sysfs_remove_group(&pdev->dev.kobj, &rpaf_dev_debug_attr_group);
+err_sysfs_create:
+err_prop_read_dsp_id:
+	devm_kfree(&pdev->dev, rpaf_misc_priv);
+	return ret;
+}
+
+static int snd_soc_rpaf_misc_remove(struct platform_device *pdev)
+{
+	struct snd_soc_rpaf_misc_priv *rpaf_misc_priv = dev_get_drvdata(&pdev->dev);
+	int ret = 0;
+
+	if (IS_ERR_OR_NULL(rpaf_misc_priv)) {
+		dev_err(&pdev->dev, "rpaf_misc_priv is null.\n");
+			return -EFAULT;
+	}
+
+	ret = snd_soc_rpaf_misc_deregister_device(&pdev->dev, rpaf_misc_priv->dsp_id);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "dsp_id(%d) deregister dev error(%d).\n",
+				rpaf_misc_priv->dsp_id, ret);
+		return ret;
+	}
+
+	sysfs_remove_group(&pdev->dev.kobj, &rpaf_dev_debug_attr_group);
+
+	dev_info(&pdev->dev, "[%s] remove finished!\n", rpaf_misc_priv->name);
+
+	devm_kfree(&pdev->dev, rpaf_misc_priv);
+	dev_set_drvdata(&pdev->dev, NULL);
+
+	return ret;
+}
+
+static const struct of_device_id snd_soc_rpaf_misc_ids[] = {
+	{ .compatible = "allwinner,rpaf-dsp0" },
+	{ .compatible = "allwinner,rpaf-dsp1" },
+	{}
+};
+
+static struct platform_driver snd_soc_rpaf_misc_driver = {
+	.probe	= snd_soc_rpaf_misc_probe,
+	.remove	= snd_soc_rpaf_misc_remove,
+	.driver	= {
+		.owner	= THIS_MODULE,
+		.name	= "sunxi-rpaf-dsp",
+		.of_match_table	= snd_soc_rpaf_misc_ids,
+	},
+};
+module_platform_driver(snd_soc_rpaf_misc_driver);
+
+MODULE_DESCRIPTION("sunxi dsp remote processor audio framework driver");
+MODULE_AUTHOR("yumingfeng@allwinnertech.com");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/Kconfig b/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/Kconfig
new file mode 100644
index 000000000..25c348d97
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/Kconfig
@@ -0,0 +1,65 @@
+# AudioCodec Interface
+config SND_SUNXI_SOC_HIFI_CODEC
+	tristate
+
+config SND_SUNXI_SOC_HIFI_CPUDAI
+	tristate
+
+# Digital Audio(I2S/PCM/TDM)
+config SND_SUNXI_SOC_HIFI_DAUDIO
+	tristate
+
+# DMIC Audio Interface
+config SND_SUNXI_SOC_HIFI_DMIC
+	tristate
+
+# SUNXI Platform HIFI
+config SND_SUNXI_SOC_HIFI
+	tristate
+
+config SND_SUNXI_HIFI
+	bool
+	default y if SND_SUNXI_RPAF
+
+# AudioCodec Machine Select
+config SND_SUNXI_HIFI_CODEC
+	tristate "Allwinner Audio Codec HiFi Support"
+	select SND_SUNXI_SOC_HIFI
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	select SND_SUNXI_SOC_HIFI_CODEC
+	select SND_SUNXI_SOC_HIFI_CPUDAI
+	select SND_SUN8IW20_CODEC
+	select SND_SUNXI_SOC_SUN8IW20_CODEC
+	depends on SND_SUNXI_HIFI
+	help
+		Select Y or M to add support for AudioCodec Module in the
+		Allwinner SoCs.
+
+# Daudio Machine Select
+config SND_SUNXI_HIFI_DAUDIO
+	tristate "Allwinner Digital Audio HiFi Support"
+	select SND_SUNXI_SOC_HIFI
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	select SND_SUNXI_SOC_HIFI_DAUDIO
+	select SND_SUNXI_SOC_HIFI_SIMPLE_CARD
+	select SND_SUNXI_SOC_SIMPLE_CARD
+	select SND_SUNXI_SOC_DAUDIO
+	depends on SND_SUNXI_HIFI
+	help
+		Select Y or M to add support for I2S/PCM/TDM Module in the
+		Allwinner SoCs.
+
+# DMIC Machine Select
+config SND_SUNXI_HIFI_DMIC
+	tristate "Allwinner DMIC Support"
+	select SND_SUNXI_SOC_HIFI
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	select SND_SUNXI_SOC_HIFI_DMIC
+	select SND_SUNXI_SOC_HIFI_SIMPLE_CARD
+	select SND_SUNXI_SOC_SIMPLE_CARD
+	select SND_SUNXI_SOC_DMIC
+	depends on SND_SUNXI_HIFI
+	help
+		Select Y or M to add support DMIC Module in Allwinner
+		SoCs.
+
diff --git a/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/Makefile b/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/Makefile
new file mode 100644
index 000000000..88feb35a2
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/Makefile
@@ -0,0 +1,23 @@
+obj-$(CONFIG_SND_SUNXI_HIFI) += rpmsg_hifi.o
+
+# SUNXI Platform Support
+snd-soc-sunxi-hifi-objs := sunxi-hifi-pcm.o
+snd-soc-sunxi-hifi-simple-card-objs := sunxi-hifi-simple-card.o
+snd-soc-sunxi-hifi-daudio-objs := sunxi-daudio.o
+snd-soc-sunxi-hifi-dmic-objs := sunxi-dmic.o
+
+obj-$(CONFIG_SND_SUNXI_SOC_HIFI) += snd-soc-sunxi-hifi.o
+obj-$(CONFIG_SND_SUNXI_SOC_HIFI_DAUDIO) += snd-soc-sunxi-hifi-daudio.o
+obj-$(CONFIG_SND_SUNXI_SOC_HIFI_DMIC) += snd-soc-sunxi-hifi-dmic.o
+
+# SUNXI Codec Embedded Support
+obj-$(CONFIG_SND_SUNXI_SOC_HIFI_CODEC) += sunxi-hifi-codec.o
+obj-$(CONFIG_SND_SUNXI_SOC_HIFI_CPUDAI) += sunxi-hifi-cpudai.o
+
+# SUNXI Audio Simple Card Support
+obj-$(CONFIG_SND_SUNXI_SOC_HIFI_CODEC) += sunxi-hifi-sndcodec.o
+obj-$(CONFIG_SND_SUNXI_SOC_HIFI_SIMPLE_CARD) += snd-soc-sunxi-hifi-simple-card.o
+
+# add the dma_flush range interface for arm64
+obj-$(CONFIG_ARM64) += rpaf_flush_cache.o
+
diff --git a/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/rpaf_flush_cache.S b/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/rpaf_flush_cache.S
new file mode 100644
index 000000000..005dd6852
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/rpaf_flush_cache.S
@@ -0,0 +1,78 @@
+#include <linux/linkage.h>
+
+#define ENDPIPROC(x)			\
+	.globl	__pi_##x;		\
+	.type 	__pi_##x, %function;	\
+	.set	__pi_##x, x;		\
+	.size	__pi_##x, . - x;	\
+	ENDPROC(x)
+
+/*
+ *	rpaf_dma_flush_range(start, size)
+ *
+ *	clean & invalidate D / U line
+ *
+ *	- start   - virtual start address of region
+ *	- size    - size in question
+ */
+#if IS_ENABLED(CONFIG_ARM64_SW_TTBR0_PAN)
+ENTRY(rpaf_dma_flush_range)
+    mrs	x4, DAIF
+    msr	DAIFSet, #2
+    mrs	x2, SP_EL0
+    ldr	x2, [x2, #16]
+    mrs	x3, TTBR1_EL1
+    extr	x3, x3, x2, #48
+    ror	x3, x3, #16
+    msr	TTBR1_EL1, x3
+    isb
+    msr	TTBR0_EL1, x2
+    isb
+    msr	DAIF, x4
+    mrs	x3, CTR_EL0
+    nop
+    ubfx	x3, x3, #16, #4
+    mov	x2, #4
+    lsl	x2, x2, x3
+    add	x1, x0, x1
+    sub	x3, x2, #1
+    bic	x0, x0, x3
+    dc	civac, x0
+    add	x0, x0, x2
+    cmp	x0, x1
+    b.lo	#-12
+    dsb	sy
+    mrs	x2, DAIF
+    msr	DAIFSet, #2
+    mrs	x1, TTBR1_EL1
+    and	x1, x1, #0xffffffffffff
+    sub	x1, x1, #1, lsl #12
+    msr	TTBR0_EL1, x1
+    isb
+    add	x1, x1, #1, lsl #12
+    msr	TTBR1_EL1, x1
+    isb
+    msr	DAIF, x2
+    ret
+ENDPIPROC(rpaf_dma_flush_range)
+#else
+ENTRY(rpaf_dma_flush_range)
+	mrs	x3, ctr_el0
+	nop
+	ubfx	x3, x3, #16, #4
+	mov	x2, #0x4                   	// #4
+	lsl	x2, x2, x3
+	add	x1, x0, x1
+	sub	x3, x2, #0x1
+	bic	x0, x0, x3
+start:
+	dc	civac, x0
+	add	x0, x0, x2
+	cmp	x0, x1
+	b.cc start
+	dsb	sy
+	ret
+	nop
+	nop
+ENDPIPROC(rpaf_dma_flush_range)
+#endif
diff --git a/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/rpmsg_hifi.c b/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/rpmsg_hifi.c
new file mode 100644
index 000000000..6c31a908f
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/rpmsg_hifi.c
@@ -0,0 +1,1474 @@
+/*
+ * Remote processor messaging - hifi0 client driver
+ *
+ * Copyright (C) 2019-2025 Allwinnertech, Inc.
+ *
+ * yumingfeng <yumingfeng@allwinnertech.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/rpmsg.h>
+#include <linux/workqueue.h>
+#include <sound/aw_rpaf/common.h>
+#include <sound/aw_rpaf/mixer.h>
+#include <sound/aw_rpaf/debug.h>
+#include <sound/aw_rpaf/substream.h>
+#include <sound/soc.h>
+#include <sound/soc-topology.h>
+#include <sound/pcm.h>
+#include <sound/soc-dai.h>
+#include <asm/cacheflush.h>
+#include <linux/dma-mapping.h>
+#include <linux/sched/signal.h>
+#include <sound/aw_rpaf/component-core.h>
+#include <sound/aw_rpaf/rpmsg_hifi.h>
+
+#include "sunxi-hifi-daudio.h"
+#include "sunxi-hifi-dmic.h"
+#include "sunxi-hifi-cpudai.h"
+
+#define RPMSG_TIMEOUT_NORMAL    (3000)
+
+struct audio_driver_info {
+	char driver[32];
+	void *data;
+};
+
+/* Should be Register the data at first before Send msg to HiFi dsp */
+static struct audio_driver_info audio_drv_info[DSP_SOUND_CARDS];
+
+static struct rpmsg_hifi_priv *gHifi_priv[2];
+
+int sunxi_hifi_register_sound_drv_info(const char *name, void *data)
+{
+	int i = 0;
+
+	for (i = 0; i < DSP_SOUND_CARDS; i++) {
+		if (IS_ERR_OR_NULL(audio_drv_info[i].data)) {
+			strncpy(audio_drv_info[i].driver, name, 31);
+			audio_drv_info[i].data = data;
+			return 0;
+		}
+	}
+	return -ENOMEM;
+}
+EXPORT_SYMBOL(sunxi_hifi_register_sound_drv_info);
+
+int sunxi_hifi_unregister_sound_drv_info(const char *name, void *data)
+{
+	int i = 0;
+
+	for (i = 0; i < DSP_SOUND_CARDS; i++) {
+		if (!strncmp(audio_drv_info[i].driver, name, 31) &&
+			(audio_drv_info[i].data == data)) {
+			audio_drv_info[i].data = NULL;
+			memset(audio_drv_info[i].driver, 0, 32);
+			return 0;
+		}
+	}
+	return -ENOMEM;
+}
+EXPORT_SYMBOL(sunxi_hifi_unregister_sound_drv_info);
+
+void *sunxi_hifi_find_sound_drv_info_by_name(const char *name)
+{
+	int i = 0;
+
+	if (IS_ERR_OR_NULL(name))
+		return NULL;
+
+	for (i = 0; i < DSP_SOUND_CARDS; i++) {
+		if (!strncmp(name, audio_drv_info[i].driver, 31)) {
+			return audio_drv_info[i].data;
+		}
+	}
+	return NULL;
+}
+EXPORT_SYMBOL(sunxi_hifi_find_sound_drv_info_by_name);
+
+static LIST_HEAD(list_msg_component);
+static DEFINE_MUTEX(mutex_msg_component);
+
+/* find by name and stream */
+struct msg_component_package *sunxi_hifi_list_msg_component_find_item(
+	struct msg_component_package *msg_component)
+{
+	struct msg_component_package *c;
+	struct snd_soc_dsp_component *soc_component;
+	struct snd_soc_dsp_pcm_params *pcm_params;
+
+	if (!msg_component)
+		return NULL;
+
+	soc_component = &msg_component->soc_component;
+	pcm_params = &soc_component->params;
+
+	mutex_lock(&mutex_msg_component);
+	if (list_empty(&list_msg_component)) {
+		mutex_unlock(&mutex_msg_component);
+		return NULL;
+	}
+
+	list_for_each_entry(c, &list_msg_component, list) {
+		struct snd_soc_dsp_component *soc_component = &c->soc_component;
+		struct snd_soc_dsp_pcm_params *params = &soc_component->params;
+		if ((params->stream == pcm_params->stream) &&
+			(!strcmp(params->driver, pcm_params->driver))) {
+			mutex_unlock(&mutex_msg_component);
+			return c;
+		}
+	}
+	mutex_unlock(&mutex_msg_component);
+
+	return NULL;
+}
+EXPORT_SYMBOL(sunxi_hifi_list_msg_component_find_item);
+
+int sunxi_hifi_list_msg_component_add_tail(struct msg_component_package *msg_component)
+{
+	if (!msg_component)
+		return -EINVAL;
+
+	mutex_lock(&mutex_msg_component);
+	list_add_tail(&msg_component->list, &list_msg_component);
+	mutex_unlock(&mutex_msg_component);
+
+	return 0;
+}
+EXPORT_SYMBOL(sunxi_hifi_list_msg_component_add_tail);
+
+int sunxi_hifi_list_msg_component_remove_item(struct msg_component_package *msg_component)
+{
+	struct msg_component_package *c;
+	struct msg_component_package *temp;
+
+	if (!msg_component)
+		return -EINVAL;
+
+	mutex_lock(&mutex_msg_component);
+	if (list_empty(&list_msg_component)) {
+		mutex_unlock(&mutex_msg_component);
+		return 0;
+	}
+	list_for_each_entry_safe(c, temp, &list_msg_component, list) {
+		if (c == msg_component) {
+			list_del(&msg_component->list);
+			mutex_unlock(&mutex_msg_component);
+			return 0;
+		}
+	}
+	mutex_unlock(&mutex_msg_component);
+
+	return 0;
+}
+EXPORT_SYMBOL(sunxi_hifi_list_msg_component_remove_item);
+
+int sunxi_hifi_nonblock_send(unsigned int hifi_id,
+			struct msg_audio_package *msg_package)
+{
+	struct rpmsg_device *rpmsg_dev;
+	int ret = 0;
+
+
+	if ((hifi_id > 1) || (gHifi_priv[hifi_id] == NULL))
+		return -EINVAL;
+
+	rpmsg_dev = gHifi_priv[hifi_id]->rpmsg_dev;
+
+	ret = rpmsg_send(rpmsg_dev->ept, msg_package,
+				sizeof(struct msg_audio_package));
+	if (ret)
+		dev_err(&rpmsg_dev->dev, "rpmsg_send failed: %d\n", ret);
+
+	return ret;
+}
+EXPORT_SYMBOL(sunxi_hifi_nonblock_send);
+
+int sunxi_hifi_component_nonblock_send(unsigned int hifi_id,
+				struct msg_component_package *msg_component)
+{
+	struct snd_soc_dsp_component *soc_component = &msg_component->soc_component;
+	struct msg_audio_package msg_package;
+	struct rpmsg_device *rpmsg_dev;
+	int ret = 0;
+
+	if ((hifi_id > 1) || (gHifi_priv[hifi_id] == NULL))
+		return -EINVAL;
+
+	rpmsg_dev = gHifi_priv[hifi_id]->rpmsg_dev;
+
+	msg_package.audioMsgVal = MSGBOX_SOC_DSP_AUDIO_COMPONENT_COMMAND;
+	msg_package.sharePointer = (unsigned int)__pa(soc_component);
+	sunxi_rpaf_dma_flush_range(soc_component, sizeof(struct snd_soc_dsp_component));
+
+	ret = sunxi_hifi_nonblock_send(hifi_id, &msg_package);
+
+	return ret;
+}
+EXPORT_SYMBOL(sunxi_hifi_component_nonblock_send);
+
+/* BLOCK */
+int sunxi_hifi_component_block_send(unsigned int hifi_id,
+			struct msg_component_package *msg_component)
+{
+	wait_queue_entry_t wait;
+	long tout;
+	struct rpmsg_device *rpmsg_dev;
+	int ret = 0;
+
+	if ((hifi_id > 1) || (gHifi_priv[hifi_id] == NULL))
+		return -EINVAL;
+
+	spin_lock_irq(&msg_component->lock);
+	rpmsg_dev = gHifi_priv[hifi_id]->rpmsg_dev;
+	if (msg_component->wakeup_flag) {
+		dev_warn(&rpmsg_dev->dev, "%s wakeup_flag was not reset.\n", __func__);
+		/* reset */
+		msg_component->wakeup_flag = 0;
+	}
+	/*  */
+	init_waitqueue_entry(&wait, current);
+	set_current_state(TASK_KILLABLE);
+	add_wait_queue(&msg_component->tsleep, &wait);
+
+	/*  */
+	spin_unlock_irq(&msg_component->lock);
+	ret = sunxi_hifi_component_nonblock_send(hifi_id, msg_component);
+	spin_lock_irq(&msg_component->lock);
+	if (ret) {
+		dev_err(&rpmsg_dev->dev, "%s rpmsg_send failed: %d\n", __func__, ret);
+		ret = -EIO;
+		goto err_rpmsg_send;
+	}
+
+	for (;;) {
+		if (fatal_signal_pending(current)) {
+			dev_err(&rpmsg_dev->dev, "%s %d.\n", __func__, __LINE__);
+			ret = -ERESTARTSYS;
+			break;
+		}
+
+		if (msg_component->wakeup_flag == 1) {
+			msg_component->wakeup_flag = 0;
+			break;
+		}
+		/* ,1s */
+		set_current_state(TASK_KILLABLE);
+		spin_unlock_irq(&msg_component->lock);
+		tout = schedule_timeout(msecs_to_jiffies(RPMSG_TIMEOUT_NORMAL));
+		spin_lock_irq(&msg_component->lock);
+		if (!tout) {
+			dev_err(&rpmsg_dev->dev,
+				"line:%d rpmsg_send timeout %d, flag=%d\n",
+				__LINE__, ret, msg_component->wakeup_flag);
+			ret = -EIO;
+			break;
+		} else {
+			if (msg_component->wakeup_flag == 0)
+				continue;
+			else if (msg_component->wakeup_flag == 1) {
+				msg_component->wakeup_flag = 0;
+				break;
+			}
+		}
+	}
+	/*  */
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&msg_component->tsleep, &wait);
+	spin_unlock_irq(&msg_component->lock);
+
+	return ret;
+
+err_rpmsg_send:
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&msg_component->tsleep, &wait);
+	spin_unlock_irq(&msg_component->lock);
+	return ret;
+}
+EXPORT_SYMBOL(sunxi_hifi_component_block_send);
+
+int sunxi_mixer_block_send(unsigned int hifi_id, struct msg_mixer_package *msg_mixer)
+{
+	struct msg_audio_package msg_audio_package;
+	struct rpmsg_device *rpmsg_dev;
+	int *wakeup_flag;
+	int ret = 0;
+	wait_queue_entry_t wait;
+	wait_queue_head_t *cpudai_tsleep;
+	long tout;
+
+	if ((hifi_id > 1) || (gHifi_priv[hifi_id] == NULL)) {
+		pr_err("%s params invalid.\n", __func__);
+		return -EINVAL;
+	}
+
+	spin_lock_irq(&msg_mixer->lock);
+	rpmsg_dev = gHifi_priv[hifi_id]->rpmsg_dev;
+
+	msg_audio_package.audioMsgVal = MSGBOX_SOC_DSP_AUDIO_MIXER_COMMAND;
+	cpudai_tsleep = &msg_mixer->tsleep;
+	wakeup_flag = &msg_mixer->wakeup_flag;
+	msg_audio_package.sharePointer =
+			(unsigned int)__pa(&msg_mixer->soc_mixer);
+	sunxi_rpaf_dma_flush_range(&msg_mixer->soc_mixer, sizeof(struct snd_soc_dsp_mixer));
+	if (*wakeup_flag) {
+		dev_warn(&rpmsg_dev->dev, "%s wakeup_flag was not reset.\n", __func__);
+		/* reset */
+		*wakeup_flag = 0;
+	}
+	/*  */
+	init_waitqueue_entry(&wait, current);
+	set_current_state(TASK_KILLABLE);
+	add_wait_queue(cpudai_tsleep, &wait);
+	/*  */
+	spin_unlock_irq(&msg_mixer->lock);
+	ret = rpmsg_send(rpmsg_dev->ept, &msg_audio_package,
+				  sizeof(struct msg_audio_package));
+	spin_lock_irq(&msg_mixer->lock);
+	if (ret) {
+		dev_err(&rpmsg_dev->dev, "rpmsg_send failed: %d\n", ret);
+		ret = -EIO;
+		goto err_rmpsg_send;
+	}
+
+	for (;;) {
+		if (fatal_signal_pending(current)) {
+			dev_err(&rpmsg_dev->dev, "%s %d.\n", __func__, __LINE__);
+			ret = -ERESTARTSYS;
+			break;
+		}
+
+		if (*wakeup_flag == 1) {
+			*wakeup_flag = 0;
+			break;
+		}
+		/* ,1s */
+		set_current_state(TASK_KILLABLE);
+		spin_unlock_irq(&msg_mixer->lock);
+		tout = schedule_timeout(msecs_to_jiffies(RPMSG_TIMEOUT_NORMAL));
+		spin_lock_irq(&msg_mixer->lock);
+		if (!tout) {
+			dev_err(&rpmsg_dev->dev,
+				"line:%d rpmsg_send timeout %d, flag=%d\n",
+				__LINE__, ret, *wakeup_flag);
+			ret = -EIO;
+			break;
+		} else {
+			if (*wakeup_flag == 0) {
+				continue;
+			} else if (*wakeup_flag == 1) {
+				*wakeup_flag = 0;
+				break;
+			}
+		}
+	}
+
+	/*  */
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(cpudai_tsleep, &wait);
+	spin_unlock_irq(&msg_mixer->lock);
+	return ret;
+
+err_rmpsg_send:
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(cpudai_tsleep, &wait);
+	spin_unlock_irq(&msg_mixer->lock);
+	return ret;
+}
+EXPORT_SYMBOL(sunxi_mixer_block_send);
+
+static int sunxi_hifi_substream_component_block_send(unsigned int hifi_id,
+				struct msg_component_package *msg_component)
+{
+	struct msg_audio_package msg_package;
+	wait_queue_entry_t wait;
+	long tout;
+	struct rpmsg_device *rpmsg_dev;
+	int ret = 0;
+
+	if ((hifi_id > 1) || (gHifi_priv[hifi_id] == NULL))
+		return -EINVAL;
+
+	spin_lock_irq(&msg_component->lock);
+	msg_component->soc_component.comp_mode = SND_DSP_COMPONENT_MODE_STREAM;
+	msg_component->soc_component.cmd_val = SND_SOC_DSP_COMPONENT_SET_STREAM_PARAMS;
+
+	rpmsg_dev = gHifi_priv[hifi_id]->rpmsg_dev;
+	if (msg_component->wakeup_flag) {
+		dev_warn(&rpmsg_dev->dev, "%s wakeup_flag was not reset.\n", __func__);
+		/* reset */
+		msg_component->wakeup_flag = 0;
+	}
+
+	/*  */
+	init_waitqueue_entry(&wait, current);
+	set_current_state(TASK_KILLABLE);
+	add_wait_queue(&msg_component->tsleep, &wait);
+
+	/*  */
+	msg_package.audioMsgVal = MSGBOX_SOC_DSP_AUDIO_COMPONENT_COMMAND;
+	msg_package.sharePointer = (unsigned int)__pa(&msg_component->soc_component);
+	sunxi_rpaf_dma_flush_range(&msg_component->soc_component, sizeof(struct snd_soc_dsp_component));
+	spin_unlock_irq(&msg_component->lock);
+	ret = sunxi_hifi_nonblock_send(hifi_id, &msg_package);
+	spin_lock_irq(&msg_component->lock);
+	if (ret) {
+		dev_err(&rpmsg_dev->dev, "%s rpmsg_send failed: %d\n", __func__, ret);
+		ret = -EIO;
+		goto err_rpmsg_send;
+	}
+
+	for (;;) {
+		if (fatal_signal_pending(current)) {
+			dev_err(&rpmsg_dev->dev, "%s %d.\n", __func__, __LINE__);
+			ret = -ERESTARTSYS;
+			break;
+		}
+
+		if (msg_component->wakeup_flag == 1) {
+			msg_component->wakeup_flag = 0;
+			break;
+		}
+		/* ,1s */
+		set_current_state(TASK_KILLABLE);
+		spin_unlock_irq(&msg_component->lock);
+		tout = schedule_timeout(msecs_to_jiffies(RPMSG_TIMEOUT_NORMAL));
+		spin_lock_irq(&msg_component->lock);
+		if (!tout) {
+			dev_err(&rpmsg_dev->dev,
+				"line:%d rpmsg_send timeout %d, flag=%d\n",
+				__LINE__, ret, msg_component->wakeup_flag);
+			ret = -EIO;
+			break;
+		} else {
+			if (msg_component->wakeup_flag == 0)
+				continue;
+			else if (msg_component->wakeup_flag == 1) {
+				msg_component->wakeup_flag = 0;
+				break;
+			}
+		}
+	}
+	/*  */
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&msg_component->tsleep, &wait);
+	spin_unlock_irq(&msg_component->lock);
+
+	return ret;
+
+err_rpmsg_send:
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&msg_component->tsleep, &wait);
+	spin_unlock_irq(&msg_component->lock);
+	return ret;
+}
+
+int32_t sunxi_hifi_substream_set_stream_component(unsigned int hifi_id,
+		struct snd_soc_dai *dai,
+		struct snd_soc_dsp_substream *soc_substream,
+		struct snd_dsp_component *dsp_component)
+{
+	struct snd_soc_dsp_component *soc_component = NULL;
+	struct msg_component_package *msg_component = NULL;
+	struct snd_soc_dsp_pcm_params *pcm_params = NULL;
+	int i = 0;
+	int ret = 0;
+
+	if (!dsp_component)
+		return -EFAULT;
+
+	msg_component = &dsp_component->msg_component;
+	init_waitqueue_head(&msg_component->tsleep);
+	soc_component = &msg_component->soc_component;
+	memcpy(&soc_component->params, &soc_substream->params,
+		sizeof(struct snd_soc_dsp_pcm_params));
+	pcm_params = &soc_component->params;
+
+	for (i = 0; i < RPAF_COMPONENT_MAX_NUM; i++)
+		soc_component->component_sort[i] = -1;
+
+	soc_component->read_size = pcm_params->channels *
+		snd_pcm_format_size(pcm_params->format, pcm_params->pcm_frames);
+	soc_component->dump_size = soc_component->read_size;
+	if (soc_component->read_size == 0) {
+		dev_err(dai->dev, "pcm_frames is 0.\n");
+		return -EFAULT;
+	}
+
+	if (!soc_component->read_addr) {
+		dma_addr_t read_addr;
+		dsp_component->read_area = dma_alloc_coherent(dai->dev,
+							soc_component->read_size,
+							&read_addr, GFP_KERNEL);
+		if (IS_ERR_OR_NULL(dsp_component->read_area)) {
+			ret = -ENOMEM;
+			goto err_malloc_read_addr;
+		}
+		soc_component->read_addr = read_addr;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(soc_component->dump_addr); i++) {
+		dma_addr_t dump_addr;
+		if (soc_component->dump_addr[i])
+			continue;
+		if ((soc_component->component_type >> i) & 0x1) {
+			awrpaf_debug("component_type:0x%x, i:%d\n",
+				soc_component->component_type, i);
+			dsp_component->dump_area[i] = dma_alloc_coherent(dai->dev,
+							soc_component->dump_size,
+							&dump_addr, GFP_KERNEL);
+			if (IS_ERR_OR_NULL(dsp_component->dump_area[i])) {
+				ret = -ENOMEM;
+				goto err_malloc_dump_addr;
+			}
+			soc_component->dump_addr[i] = dump_addr;
+		}
+	}
+
+	sunxi_hifi_list_msg_component_add_tail(msg_component);
+
+	return sunxi_hifi_substream_component_block_send(hifi_id, msg_component);
+
+err_malloc_dump_addr:
+	dma_free_coherent(dai->dev, soc_component->read_size,
+				dsp_component->read_area, soc_component->read_addr);
+	soc_component->read_addr = 0;
+	dsp_component->read_area = NULL;
+	for (i = 0; i < ARRAY_SIZE(soc_component->dump_addr); i++) {
+		if (!soc_component->dump_addr[i])
+			continue;
+		dma_free_coherent(dai->dev, soc_component->dump_size,
+				dsp_component->dump_area[i], soc_component->dump_addr[i]);
+		soc_component->dump_addr[i] = 0;
+		dsp_component->dump_area[i] = NULL;
+	}
+err_malloc_read_addr:
+	return ret;
+}
+EXPORT_SYMBOL(sunxi_hifi_substream_set_stream_component);
+
+int32_t snd_soc_rpaf_pcm_update_stream_process(struct snd_dsp_component *stream_dsp_component)
+{
+	snd_pcm_uframes_t pos = 0;
+	struct snd_dsp_component *dsp_component = NULL;
+	struct snd_soc_rpaf_pcm_runtime *runtime = NULL;
+	struct msg_component_package *msg_component = NULL;
+	struct snd_soc_dsp_component *soc_component = NULL;
+	ssize_t dump_bytes;
+	void *buffer = NULL;
+
+	snd_soc_rpaf_pcm_stream_component_lock();
+
+	dsp_component = (struct snd_dsp_component *)stream_dsp_component->private_data;
+	if (dsp_component) {
+
+		snd_soc_rpaf_pcm_stream_lock_irq(dsp_component);
+
+		runtime = &dsp_component->runtime;
+		if (!runtime->dump_start) {
+
+			snd_soc_rpaf_pcm_stream_unlock_irq(dsp_component);
+			snd_soc_rpaf_pcm_stream_component_unlock();
+
+			return 0;
+		}
+
+		msg_component = &dsp_component->msg_component;
+		soc_component = &msg_component->soc_component;
+		pos = snd_soc_rpaf_pcm_bytes_to_frames(runtime, runtime->pos);
+		buffer = dsp_component->read_area + runtime->pos;
+
+		snd_soc_rpaf_pcm_stream_unlock_irq(dsp_component);
+
+		dump_bytes = snd_soc_rpaf_pcm_frames_to_bytes(runtime, runtime->period_size);
+
+		if (stream_dsp_component->dump_area[runtime->dump_type]) {
+			memcpy(buffer, stream_dsp_component->dump_area[runtime->dump_type],
+				dump_bytes);
+		}
+		snd_soc_rpaf_pcm_stream_update_complete(dsp_component);
+	}
+
+	snd_soc_rpaf_pcm_stream_component_unlock();
+
+	return 0;
+}
+EXPORT_SYMBOL(snd_soc_rpaf_pcm_update_stream_process);
+
+int32_t sunxi_hifi_substream_release_stream_component(struct snd_soc_dai *dai,
+		struct snd_dsp_component *dsp_component)
+{
+	struct msg_component_package *msg_component = NULL;
+	struct snd_soc_dsp_component *soc_component = NULL;
+	struct snd_dsp_component *component = NULL;
+	int i = 0;
+
+	if (!dsp_component)
+		return -EFAULT;
+
+	component = (struct snd_dsp_component *)dsp_component->private_data;
+	if (component) {
+		dev_info(dai->dev, "clear component.\n");
+		/*  */
+		component->private_data = NULL;
+		snd_soc_rpaf_pcm_stream_update_complete(component);
+	}
+
+	msg_component = &dsp_component->msg_component;
+	soc_component = &msg_component->soc_component;
+
+	sunxi_hifi_list_msg_component_remove_item(msg_component);
+
+	dma_free_coherent(dai->dev, soc_component->read_size,
+				dsp_component->read_area, soc_component->read_addr);
+	soc_component->read_addr = 0;
+	dsp_component->read_area = NULL;
+
+	for (i = 0; i < ARRAY_SIZE(soc_component->dump_addr); i++) {
+		if (!soc_component->dump_addr[i])
+			continue;
+		dma_free_coherent(dai->dev, soc_component->dump_size,
+				dsp_component->dump_area[i],
+				soc_component->dump_addr[i]);
+		soc_component->dump_addr[i] = 0;
+		dsp_component->dump_area[i] = NULL;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(sunxi_hifi_substream_release_stream_component);
+
+static void sunxi_pcm_transfer_complete(struct snd_pcm_substream *substream)
+{
+	struct dmaengine_pcm_runtime_data *prtd = substream->runtime->private_data;
+	unsigned long flags;
+
+	snd_pcm_stream_lock_irqsave(substream, flags);
+	if (!substream->runtime) {
+		snd_pcm_stream_unlock_irqrestore(substream, flags);
+		return;
+	}
+
+	prtd->pos += snd_pcm_lib_period_bytes(substream);
+	if (prtd->pos >= snd_pcm_lib_buffer_bytes(substream))
+		prtd->pos = 0;
+	snd_pcm_stream_unlock_irqrestore(substream, flags);
+
+	snd_pcm_period_elapsed(substream);
+}
+
+int sunxi_hifi_cpudai_substream_block_send(unsigned int hifi_id,
+			struct snd_pcm_substream *substream, struct snd_soc_dai *dai,
+			int stream, unsigned long msg_cmd)
+{
+	struct snd_soc_dai *cpu_dai = NULL;
+	struct snd_soc_pcm_runtime *rtd = NULL;
+	struct sunxi_cpudai_info *sunxi_cpudai = NULL;
+	struct msg_audio_package msg_audio_package;
+	struct rpmsg_device *rpmsg_dev;
+	struct snd_soc_dsp_substream *soc_substream;
+	int *wakeup_flag;
+	int ret = 0;
+	wait_queue_entry_t wait;
+	wait_queue_head_t *cpudai_tsleep;
+	spinlock_t *lock;
+	long tout;
+
+	if ((hifi_id > 1) || (gHifi_priv[hifi_id] == NULL) ||
+		(IS_ERR_OR_NULL(substream) && IS_ERR_OR_NULL(dai))) {
+		pr_err("%s params invalid.\n", __func__);
+		return -EINVAL;
+	}
+
+	if (IS_ERR_OR_NULL(dai)) {
+		rtd = substream->private_data;
+		cpu_dai = rtd->cpu_dai;
+		sunxi_cpudai = snd_soc_dai_get_drvdata(cpu_dai);
+	} else {
+		cpu_dai = dai;
+		sunxi_cpudai = snd_soc_dai_get_drvdata(cpu_dai);
+	}
+
+	rpmsg_dev = gHifi_priv[hifi_id]->rpmsg_dev;
+
+	msg_audio_package.audioMsgVal = msg_cmd;
+	switch (msg_cmd) {
+	case MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND:
+	{
+		struct msg_substream_package *msg_substream;
+
+		/* for substream == NULL */
+		if (IS_ERR_OR_NULL(substream)) {
+			if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+				msg_substream = &sunxi_cpudai->msg_playback;
+			} else {
+				msg_substream = &sunxi_cpudai->msg_capture;
+			}
+		} else if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			msg_substream = &sunxi_cpudai->msg_playback;
+		} else {
+			msg_substream = &sunxi_cpudai->msg_capture;
+		}
+		cpudai_tsleep = &msg_substream->tsleep;
+		lock = &msg_substream->lock;
+		wakeup_flag = &msg_substream->wakeup_flag;
+		soc_substream = &msg_substream->soc_substream;
+
+		msg_audio_package.sharePointer = (unsigned int)__pa(soc_substream);
+		sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+	}
+	break;
+	case MSGBOX_SOC_DSP_AUDIO_DEBUG_COMMAND:
+	{
+		struct msg_debug_package *msg_debug;
+
+		msg_debug = &sunxi_cpudai->msg_debug;
+		cpudai_tsleep = &msg_debug->tsleep;
+		lock = &msg_debug->lock;
+		wakeup_flag = &msg_debug->wakeup_flag;
+
+		msg_audio_package.sharePointer =
+				(unsigned int)__pa(&msg_debug->soc_debug);
+		sunxi_rpaf_dma_flush_range(&msg_debug->soc_debug, sizeof(struct snd_soc_dsp_debug));
+	}
+	break;
+	case MSGBOX_SOC_DSP_AUDIO_COMPONENT_COMMAND:
+	{
+		struct msg_component_package *msg_component;
+		struct snd_dsp_component *dsp_component;
+
+		/* for substream == NULL */
+		if (IS_ERR_OR_NULL(substream)) {
+			if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+				dsp_component = &sunxi_cpudai->dsp_playcomp;
+			} else {
+				dsp_component = &sunxi_cpudai->dsp_capcomp;
+			}
+		} else if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			dsp_component = &sunxi_cpudai->dsp_playcomp;
+		} else {
+			dsp_component = &sunxi_cpudai->dsp_capcomp;
+		}
+		msg_component = &dsp_component->msg_component;
+		cpudai_tsleep = &msg_component->tsleep;
+		lock = &msg_component->lock;
+		wakeup_flag = &msg_component->wakeup_flag;
+
+		msg_audio_package.sharePointer =
+				(unsigned int)__pa(&msg_component->soc_component);
+		sunxi_rpaf_dma_flush_range(&msg_component->soc_component, sizeof(struct snd_soc_dsp_component));
+	}
+	break;
+	default:
+		dev_err(&rpmsg_dev->dev, "msg_cmd error:%lu\n", msg_cmd);
+		return -EINVAL;
+	}
+
+	spin_lock_irq(lock);
+	if (*wakeup_flag) {
+		dev_warn(&rpmsg_dev->dev, "%s wakeup_flag was not reset.\n", __func__);
+		/* reset */
+		*wakeup_flag = 0;
+	}
+
+//	dev_err(&rpmsg_dev->dev, "audioMsgVal:%d, sharePointer:0x%x\n",
+//		msg_audio_package.audioMsgVal, msg_audio_package.sharePointer);
+	/*  */
+	init_waitqueue_entry(&wait, current);
+	set_current_state(TASK_KILLABLE);
+	add_wait_queue(cpudai_tsleep, &wait);
+	/*  */
+	spin_unlock_irq(lock);
+	ret = rpmsg_send(rpmsg_dev->ept, &msg_audio_package,
+				sizeof(struct msg_audio_package));
+	spin_lock_irq(lock);
+	if (ret) {
+		dev_err(&rpmsg_dev->dev, "line:%d rpmsg_send failed: %d\n", __LINE__, ret);
+		ret = -EIO;
+		goto err_rmpsg_send;
+	}
+
+	for (;;) {
+		if (fatal_signal_pending(current)) {
+			dev_err(&rpmsg_dev->dev, "%s %d.\n", __func__, __LINE__);
+			ret = -ERESTARTSYS;
+			break;
+		}
+
+		if (*wakeup_flag == 1) {
+			*wakeup_flag = 0;
+			break;
+		}
+		set_current_state(TASK_KILLABLE);
+		spin_unlock_irq(lock);
+		tout = schedule_timeout(msecs_to_jiffies(RPMSG_TIMEOUT_NORMAL));
+		spin_lock_irq(lock);
+		if (!tout) {
+			dev_err(&rpmsg_dev->dev,
+				"line:%d rpmsg_send timeout %d, flag=%d\n",
+				__LINE__, ret, *wakeup_flag);
+			ret = -EIO;
+			break;
+		} else {
+			if (*wakeup_flag == 0) {
+				continue;
+			} else if (*wakeup_flag == 1) {
+				*wakeup_flag = 0;
+				break;
+			}
+		}
+	}
+
+	/*  */
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(cpudai_tsleep, &wait);
+	spin_unlock_irq(lock);
+	return ret;
+
+err_rmpsg_send:
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(cpudai_tsleep, &wait);
+	spin_unlock_irq(lock);
+	return ret;
+}
+EXPORT_SYMBOL(sunxi_hifi_cpudai_substream_block_send);
+
+int sunxi_hifi_daudio_substream_block_send(unsigned int hifi_id,
+			struct snd_pcm_substream *substream, struct snd_soc_dai *dai,
+			int stream, unsigned long msg_cmd)
+{
+	struct snd_soc_dai *cpu_dai = NULL;
+	struct snd_soc_pcm_runtime *rtd = NULL;
+	struct sunxi_daudio_info *sunxi_daudio = NULL;
+	struct msg_audio_package msg_audio_package;
+	struct rpmsg_device *rpmsg_dev;
+	struct snd_soc_dsp_substream *soc_substream;
+	int *wakeup_flag;
+	int ret = 0;
+	wait_queue_entry_t wait;
+	wait_queue_head_t *daudio_tsleep;
+	spinlock_t *lock;
+	long tout;
+
+	if ((hifi_id > 1) || (gHifi_priv[hifi_id] == NULL) ||
+		(IS_ERR_OR_NULL(substream) && IS_ERR_OR_NULL(dai))) {
+		pr_err("%s params invalid.\n", __func__);
+		return -EINVAL;
+	}
+
+	if (IS_ERR_OR_NULL(dai)) {
+		rtd = substream->private_data;
+		cpu_dai = rtd->cpu_dai;
+		sunxi_daudio = snd_soc_dai_get_drvdata(cpu_dai);
+	} else {
+		cpu_dai = dai;
+		sunxi_daudio = snd_soc_dai_get_drvdata(cpu_dai);
+	}
+
+	rpmsg_dev = gHifi_priv[hifi_id]->rpmsg_dev;
+
+	msg_audio_package.audioMsgVal = msg_cmd;
+	switch (msg_cmd) {
+	case MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND:
+	{
+		struct msg_substream_package *msg_substream;
+
+		/* for substream == NULL */
+		if (IS_ERR_OR_NULL(substream)) {
+			if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+				msg_substream = &sunxi_daudio->msg_playback;
+			} else {
+				msg_substream = &sunxi_daudio->msg_capture;
+			}
+		} else if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			msg_substream = &sunxi_daudio->msg_playback;
+		} else {
+			msg_substream = &sunxi_daudio->msg_capture;
+		}
+		daudio_tsleep = &msg_substream->tsleep;
+		lock = &msg_substream->lock;
+		wakeup_flag = &msg_substream->wakeup_flag;
+		soc_substream = &msg_substream->soc_substream;
+
+		msg_audio_package.sharePointer = (unsigned int)__pa(soc_substream);
+		sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+	}
+	break;
+	case MSGBOX_SOC_DSP_AUDIO_MIXER_COMMAND:
+	{
+		struct msg_mixer_package *msg_mixer;
+
+		msg_mixer = &sunxi_daudio->msg_mixer;
+		daudio_tsleep = &msg_mixer->tsleep;
+		lock = &msg_mixer->lock;
+		wakeup_flag = &msg_mixer->wakeup_flag;
+
+		msg_audio_package.sharePointer =
+				(unsigned int)__pa(&msg_mixer->soc_mixer);
+		sunxi_rpaf_dma_flush_range(&msg_mixer->soc_mixer, sizeof(struct snd_soc_dsp_mixer));
+	}
+	break;
+	case MSGBOX_SOC_DSP_AUDIO_DEBUG_COMMAND:
+	{
+		struct msg_debug_package *msg_debug;
+
+		msg_debug = &sunxi_daudio->msg_debug;
+		daudio_tsleep = &msg_debug->tsleep;
+		lock = &msg_debug->lock;
+		wakeup_flag = &msg_debug->wakeup_flag;
+
+		msg_audio_package.sharePointer =
+				(unsigned int)__pa(&msg_debug->soc_debug);
+		sunxi_rpaf_dma_flush_range(&msg_debug->soc_debug, sizeof(struct snd_soc_dsp_debug));
+	}
+	break;
+	case MSGBOX_SOC_DSP_AUDIO_COMPONENT_COMMAND:
+	{
+		struct msg_component_package *msg_component;
+		struct snd_dsp_component *dsp_component;
+
+		/* for substream == NULL */
+		if (IS_ERR_OR_NULL(substream)) {
+			if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+				dsp_component = &sunxi_daudio->dsp_playcomp;
+			} else {
+				dsp_component = &sunxi_daudio->dsp_capcomp;
+			}
+		} else if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			dsp_component = &sunxi_daudio->dsp_playcomp;
+		} else {
+			dsp_component = &sunxi_daudio->dsp_capcomp;
+		}
+		msg_component = &dsp_component->msg_component;
+		daudio_tsleep = &msg_component->tsleep;
+		lock = &msg_component->lock;
+		wakeup_flag = &msg_component->wakeup_flag;
+
+		msg_audio_package.sharePointer =
+				(unsigned int)__pa(&msg_component->soc_component);
+		sunxi_rpaf_dma_flush_range(&msg_component->soc_component, sizeof(struct snd_soc_dsp_component));
+	}
+	break;
+	default:
+		dev_err(&rpmsg_dev->dev, "msg_cmd error:%lu\n", msg_cmd);
+		return -EINVAL;
+	}
+	spin_lock_irq(lock);
+	if (*wakeup_flag) {
+		dev_warn(&rpmsg_dev->dev, "%s wakeup_flag was not reset.\n", __func__);
+		/* reset */
+		*wakeup_flag = 0;
+	}
+	/*  */
+	init_waitqueue_entry(&wait, current);
+	set_current_state(TASK_KILLABLE);
+	add_wait_queue(daudio_tsleep, &wait);
+	/*  */
+	spin_unlock_irq(lock);
+	ret = rpmsg_send(rpmsg_dev->ept, &msg_audio_package,
+				  sizeof(struct msg_audio_package));
+	spin_lock_irq(lock);
+	if (ret) {
+		dev_err(&rpmsg_dev->dev, "line:%d rpmsg_send failed: %d\n", __LINE__, ret);
+		ret = -EIO;
+		goto err_rmpsg_send;
+	}
+
+//	dev_err(&rpmsg_dev->dev, "%s %d audioMsgVal:%d, sharePointer:0x%x\n",
+//				__func__, __LINE__, msg_audio_package.audioMsgVal,
+//				msg_audio_package.sharePointer);
+	for (;;) {
+		if (fatal_signal_pending(current)) {
+			dev_err(&rpmsg_dev->dev, "%s %d.\n", __func__, __LINE__);
+			ret = -ERESTARTSYS;
+			break;
+		}
+
+		if (*wakeup_flag == 1) {
+			*wakeup_flag = 0;
+			break;
+		}
+		set_current_state(TASK_KILLABLE);
+		spin_unlock_irq(lock);
+		tout = schedule_timeout(msecs_to_jiffies(RPMSG_TIMEOUT_NORMAL));
+		spin_lock_irq(lock);
+		if (!tout) {
+			dev_err(&rpmsg_dev->dev,
+				"line:%d rpmsg_send timeout %d, flag=%d\n",
+				__LINE__, ret, *wakeup_flag);
+			ret = -EIO;
+			break;
+		} else {
+			if (*wakeup_flag == 0)
+				continue;
+			else if (*wakeup_flag == 1) {
+				*wakeup_flag = 0;
+				break;
+			}
+		}
+	}
+
+	/*  */
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(daudio_tsleep, &wait);
+	spin_unlock_irq(lock);
+	return ret;
+
+err_rmpsg_send:
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(daudio_tsleep, &wait);
+	spin_unlock_irq(lock);
+	return ret;
+}
+EXPORT_SYMBOL(sunxi_hifi_daudio_substream_block_send);
+
+int sunxi_hifi_dmic_substream_block_send(unsigned int hifi_id,
+			struct snd_pcm_substream *substream, struct snd_soc_dai *dai,
+			int stream, unsigned long msg_cmd)
+{
+	struct snd_soc_dai *cpu_dai = NULL;
+	struct snd_soc_pcm_runtime *rtd = NULL;
+	struct sunxi_dmic_info *sunxi_dmic = NULL;
+	struct msg_audio_package msg_audio_package;
+	struct rpmsg_device *rpmsg_dev;
+	struct snd_soc_dsp_substream *soc_substream;
+	int *wakeup_flag;
+	int ret = 0;
+	wait_queue_entry_t wait;
+	wait_queue_head_t *dmic_tsleep;
+	spinlock_t *lock;
+	long tout;
+
+	if ((hifi_id > 1) || (gHifi_priv[hifi_id] == NULL) ||
+		(IS_ERR_OR_NULL(substream) && IS_ERR_OR_NULL(dai))) {
+		pr_err("%s params invalid.\n", __func__);
+		return -EINVAL;
+	}
+
+	if (IS_ERR_OR_NULL(dai)) {
+		rtd = substream->private_data;
+		cpu_dai = rtd->cpu_dai;
+		sunxi_dmic = snd_soc_dai_get_drvdata(cpu_dai);
+	} else {
+		cpu_dai = dai;
+		sunxi_dmic = snd_soc_dai_get_drvdata(cpu_dai);
+	}
+
+	rpmsg_dev = gHifi_priv[hifi_id]->rpmsg_dev;
+
+	msg_audio_package.audioMsgVal = msg_cmd;
+	switch (msg_cmd) {
+	case MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND:
+	{
+		struct msg_substream_package *msg_substream;
+
+		msg_substream = &sunxi_dmic->msg_capture;
+		dmic_tsleep = &msg_substream->tsleep;
+		lock = &msg_substream->lock;
+		wakeup_flag = &msg_substream->wakeup_flag;
+		soc_substream = &msg_substream->soc_substream;
+
+		msg_audio_package.sharePointer = (unsigned int)__pa(soc_substream);
+		sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+	}
+	break;
+	case MSGBOX_SOC_DSP_AUDIO_MIXER_COMMAND:
+	{
+		struct msg_mixer_package *msg_mixer;
+
+		msg_mixer = &sunxi_dmic->msg_mixer;
+		dmic_tsleep = &msg_mixer->tsleep;
+		lock = &msg_mixer->lock;
+		wakeup_flag = &msg_mixer->wakeup_flag;
+
+		msg_audio_package.sharePointer =
+				(unsigned int)__pa(&msg_mixer->soc_mixer);
+		sunxi_rpaf_dma_flush_range(&msg_mixer->soc_mixer, sizeof(struct snd_soc_dsp_mixer));
+	}
+	break;
+	case MSGBOX_SOC_DSP_AUDIO_DEBUG_COMMAND:
+	{
+		struct msg_debug_package *msg_debug;
+
+		msg_debug = &sunxi_dmic->msg_debug;
+		dmic_tsleep = &msg_debug->tsleep;
+		lock = &msg_debug->lock;
+		wakeup_flag = &msg_debug->wakeup_flag;
+
+		msg_audio_package.sharePointer =
+				(unsigned int)__pa(&msg_debug->soc_debug);
+		sunxi_rpaf_dma_flush_range(&msg_debug->soc_debug, sizeof(struct snd_soc_dsp_debug));
+	}
+	break;
+	case MSGBOX_SOC_DSP_AUDIO_COMPONENT_COMMAND:
+	{
+		struct msg_component_package *msg_component;
+		struct snd_dsp_component *dsp_component;
+
+		dsp_component = &sunxi_dmic->dsp_capcomp;
+		msg_component = &dsp_component->msg_component;
+		dmic_tsleep = &msg_component->tsleep;
+		lock = &msg_component->lock;
+		wakeup_flag = &msg_component->wakeup_flag;
+
+		msg_audio_package.sharePointer =
+				(unsigned int)__pa(&msg_component->soc_component);
+		sunxi_rpaf_dma_flush_range(&msg_component->soc_component, sizeof(struct snd_soc_dsp_component));
+	}
+	break;
+	default:
+		dev_err(&rpmsg_dev->dev, "msg_cmd error:%lu\n", msg_cmd);
+		return -EINVAL;
+	}
+	spin_lock_irq(lock);
+	if (*wakeup_flag) {
+		dev_warn(&rpmsg_dev->dev, "%s wakeup_flag was not reset.\n", __func__);
+		/* reset */
+		*wakeup_flag = 0;
+	}
+	/*  */
+	init_waitqueue_entry(&wait, current);
+	set_current_state(TASK_KILLABLE);
+	add_wait_queue(dmic_tsleep, &wait);
+	/*  */
+	spin_unlock_irq(lock);
+	ret = rpmsg_send(rpmsg_dev->ept, &msg_audio_package,
+				  sizeof(struct msg_audio_package));
+	spin_lock_irq(lock);
+	if (ret) {
+		dev_err(&rpmsg_dev->dev, "rpmsg_send failed: %d\n", ret);
+		ret = -EIO;
+		goto err_rmpsg_send;
+	}
+
+//	dev_err(&rpmsg_dev->dev, "%s %d audioMsgVal:%d, sharePointer:0x%x\n",
+//				__func__, __LINE__, msg_audio_package.audioMsgVal,
+//				msg_audio_package.sharePointer);
+	for (;;) {
+		if (fatal_signal_pending(current)) {
+			dev_err(&rpmsg_dev->dev, "%s %d.\n", __func__, __LINE__);
+			ret = -ERESTARTSYS;
+			break;
+		}
+
+		if (*wakeup_flag == 1) {
+			*wakeup_flag = 0;
+			break;
+		}
+		set_current_state(TASK_KILLABLE);
+		spin_unlock_irq(lock);
+		tout = schedule_timeout(msecs_to_jiffies(RPMSG_TIMEOUT_NORMAL));
+		spin_lock_irq(lock);
+		if (!tout) {
+			dev_err(&rpmsg_dev->dev,
+				"line:%d rpmsg_send timeout %d, flag=%d\n",
+				__LINE__, ret, *wakeup_flag);
+			ret = -EIO;
+			break;
+		} else {
+			if (*wakeup_flag == 0)
+				continue;
+			else if (*wakeup_flag == 1) {
+				*wakeup_flag = 0;
+				break;
+			}
+		}
+	}
+
+	/*  */
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(dmic_tsleep, &wait);
+	spin_unlock_irq(lock);
+	return ret;
+
+err_rmpsg_send:
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(dmic_tsleep, &wait);
+	spin_unlock_irq(lock);
+	return ret;
+}
+EXPORT_SYMBOL(sunxi_hifi_dmic_substream_block_send);
+
+static int msg_audio_package_is_invalid(unsigned long cmd)
+{
+	switch (cmd) {
+	case MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND:
+	case MSGBOX_SOC_DSP_AUDIO_MIXER_COMMAND:
+	case MSGBOX_SOC_DSP_AUDIO_DEBUG_COMMAND:
+	case MSGBOX_SOC_DSP_AUDIO_COMPONENT_COMMAND:
+		break;
+	default:
+		pr_err("[%s] AudioMsgVal:%lu error!\n", __func__, cmd);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+int rpmsg_irq_schedule(struct rpmsg_hifi_priv *hifi_priv)
+{
+	struct msg_audio_package msg_pack = hifi_priv->msg_pack;
+	unsigned long flags;
+
+	switch (msg_pack.audioMsgVal) {
+	case MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND:
+	{
+		struct snd_soc_dsp_substream *soc_substream;
+		struct snd_soc_dsp_pcm_params *params;
+
+		struct msg_substream_package *msg_substream;
+
+		soc_substream = (struct snd_soc_dsp_substream *)__va(msg_pack.sharePointer);
+		sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+		params = &soc_substream->params;
+
+		msg_substream = container_of(soc_substream, struct msg_substream_package,
+							soc_substream);
+
+		spin_lock_irqsave(&msg_substream->lock, flags);
+		/* rmsgsubstream irq  */
+		if ((msg_pack.audioMsgVal == MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND) &&
+			((soc_substream->cmd_val == SND_SOC_DSP_PCM_READI) ||
+			(soc_substream->cmd_val == SND_SOC_DSP_PCM_WRITEI))) {
+			sunxi_pcm_transfer_complete(msg_substream->substream);
+		}
+		msg_substream->wakeup_flag = 1;
+		/* for update output_addr and read again */
+		wake_up(&msg_substream->tsleep);
+		spin_unlock_irqrestore(&msg_substream->lock, flags);
+#if 0
+		/*  */
+		void *driver_data;
+
+		soc_substream = (struct snd_soc_dsp_substream *)__va(msg_pack.sharePointer);
+		sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+		params = &soc_substream->params;
+		/* find sound device data */
+		driver_data = sunxi_hifi_find_sound_drv_info_by_name(params->driver);
+		if (IS_ERR_OR_NULL(driver_data))
+			return -EFAULT;
+
+		if (!strncmp(params->driver, "audiocodec", sizeof(params->driver))) {
+//			struct sunxi_cpudai_info *sunxi_cpudai = (struct sunxi_cpudai_info *)driver_data;
+			struct msg_substream_package *msg_substream;
+
+			msg_substream = container_of(soc_substream, struct msg_substream_package,
+							soc_substream);
+
+			/* rmsgsubstream irq  */
+			if ((msg_pack.audioMsgVal == MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND) &&
+				((soc_substream->cmd_val == SND_SOC_DSP_PCM_READI) ||
+				(soc_substream->cmd_val == SND_SOC_DSP_PCM_WRITEI))) {
+				sunxi_pcm_transfer_complete(msg_substream->substream);
+			}
+			/* for update output_addr and read again */
+			msg_substream->wakeup_flag = 1;
+			wake_up(&msg_substream->tsleep);
+		} else if (!strncmp(params->driver, "snddaudio0", sizeof(params->driver)) ||
+			!strncmp(params->driver, "snddaudio1", sizeof(params->driver))) {
+//			struct sunxi_daudio_info *sunxi_daudio = (struct sunxi_daudio_info *)driver_data;
+			struct msg_substream_package *msg_substream;
+
+			msg_substream = container_of(soc_substream, struct msg_substream_package,
+							soc_substream);
+
+			/* rmsgsubstream irq  */
+			if ((msg_pack.audioMsgVal == MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND) &&
+				((soc_substream->cmd_val == SND_SOC_DSP_PCM_READI) ||
+				(soc_substream->cmd_val == SND_SOC_DSP_PCM_WRITEI))) {
+				sunxi_pcm_transfer_complete(msg_substream->substream);
+			}
+			/* for update output_addr and read again */
+			msg_substream->wakeup_flag = 1;
+			wake_up(&msg_substream->tsleep);
+		} else if (!strncmp(params->driver, "snddmic", sizeof(params->driver))) {
+//			struct sunxi_dmic_info *sunxi_dmic = (struct sunxi_dmic_info *)driver_data;
+			struct msg_substream_package *msg_substream;
+
+			msg_substream = container_of(soc_substream, struct msg_substream_package,
+							soc_substream);
+
+			/* rmsgsubstream irq  */
+			if ((msg_pack.audioMsgVal == MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND) &&
+				(soc_substream->cmd_val == SND_SOC_DSP_PCM_READI)) {
+				sunxi_pcm_transfer_complete(msg_substream->substream);
+			}
+			msg_substream->wakeup_flag = 1;
+			/* for update output_addr and read again */
+			wake_up(&msg_substream->tsleep);
+		}
+#endif
+	}
+	break;
+	/* wakeup work */
+	case MSGBOX_SOC_DSP_AUDIO_MIXER_COMMAND:
+	{
+		struct msg_mixer_package *msg_mixer;
+		struct snd_soc_dsp_mixer *soc_mixer;
+
+		soc_mixer = (struct snd_soc_dsp_mixer *)__va(msg_pack.sharePointer);
+		sunxi_rpaf_dma_flush_range(soc_mixer, sizeof(struct snd_soc_dsp_mixer));
+		msg_mixer = container_of(soc_mixer, struct msg_mixer_package,
+							soc_mixer);
+		spin_lock_irqsave(&msg_mixer->lock, flags);
+		msg_mixer->wakeup_flag = 1;
+		wake_up(&msg_mixer->tsleep);
+		spin_unlock_irqrestore(&msg_mixer->lock, flags);
+	}
+	break;
+	case MSGBOX_SOC_DSP_AUDIO_DEBUG_COMMAND:
+	{
+		struct snd_soc_dsp_debug *soc_debug;
+
+		soc_debug = (struct snd_soc_dsp_debug *)__va(msg_pack.sharePointer);
+		sunxi_rpaf_dma_flush_range(soc_debug, sizeof(struct snd_soc_dsp_debug));
+	}
+	break;
+	case MSGBOX_SOC_DSP_AUDIO_COMPONENT_COMMAND:
+	{
+		struct snd_soc_dsp_component *soc_component;
+		struct msg_component_package *msg_component;
+
+		soc_component = (struct snd_soc_dsp_component *)__va(msg_pack.sharePointer);
+		sunxi_rpaf_dma_flush_range(soc_component, sizeof(struct snd_soc_dsp_component));
+		msg_component = container_of(soc_component, struct msg_component_package, soc_component);
+		spin_lock_irqsave(&msg_component->lock, flags);
+		msg_component->wakeup_flag = 1;
+		wake_up(&msg_component->tsleep);
+		spin_unlock_irqrestore(&msg_component->lock, flags);
+	}
+	break;
+	default:
+		dev_err_ratelimited(&hifi_priv->rpmsg_dev->dev,
+				"[%s] AudioMsgVal:%u error!\n",
+				__func__, msg_pack.audioMsgVal);
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+static void recv_work_func(struct work_struct *work)
+{
+//	struct rpmsg_hifi_priv *hifi_priv =
+//			container_of(work, struct rpmsg_hifi_priv, rpmsg_recv_work);
+//	struct rpmsg_device *rpmsg_dev = hifi_priv->rpmsg_dev;
+//	struct msg_audio_package *msg_pack = &hifi_priv->msg_pack;
+
+//	rpmsg_irq_complete(hifi_priv->msg_pack);
+}
+
+static int rpmsg_hifi_cb(struct rpmsg_device *rpdev, void *data, int len,
+						 void *priv, u32 src)
+{
+	struct rpmsg_hifi_priv *hifi_priv = dev_get_drvdata(&rpdev->dev);
+	struct msg_audio_package *msg_pack = &hifi_priv->msg_pack;
+
+	hifi_priv->rx_count++;
+	switch (hifi_priv->rx_count) {
+	case 1:
+		msg_pack->audioMsgVal = *((unsigned int *)data);
+		/*  */
+		if (msg_audio_package_is_invalid(msg_pack->audioMsgVal)) {
+			hifi_priv->rx_count = 0;
+			dev_err(&rpdev->dev, "%s failed! audioMsgVal:%u\n", __func__,
+						msg_pack->audioMsgVal);
+			return -EINVAL;
+		}
+		break;
+	case 2:
+		msg_pack->sharePointer = *((unsigned int *)data);
+		break;
+	default:
+		hifi_priv->rx_count = 0;
+		break;
+	}
+	if (hifi_priv->rx_count >= (sizeof(struct msg_audio_package) >> 2)) {
+		hifi_priv->rx_count = 0;
+		rpmsg_irq_schedule(hifi_priv);
+	}
+	return 0;
+}
+
+static int rpmsg_hifi_probe(struct rpmsg_device *rpdev)
+{
+	struct rpmsg_hifi_priv *hifi_priv;
+	int hifi_id = 0;
+
+	dev_info(&rpdev->dev, "id:%s new channel: 0x%x -> 0x%x!\n",
+		  rpdev->id.name, rpdev->src, rpdev->dst);
+
+	hifi_priv = devm_kzalloc(&rpdev->dev, sizeof(struct rpmsg_hifi_priv), GFP_KERNEL);
+	if (!hifi_priv)
+		return -ENOMEM;
+	dev_set_drvdata(&rpdev->dev, hifi_priv);
+	hifi_priv->rpmsg_dev = rpdev;
+
+#if 0
+	sscanf(rpdev->id.name, "sunxi,dsp%d", &hifi_id);
+	if (hifi_id > 1) {
+		ret = -EINVAL;
+		goto err_rpdev_id_name;
+	}
+#endif
+	gHifi_priv[hifi_id] = hifi_priv;
+
+	snprintf(hifi_priv->wq_name, sizeof(hifi_priv->wq_name), "rpmsg_hifi%d", hifi_id);
+	hifi_priv->wq = create_workqueue(hifi_priv->wq_name);
+	INIT_WORK(&hifi_priv->rpmsg_recv_work, recv_work_func);
+//	queue_work(hifi_priv->wq, &hifi_priv->rpmsg_recv_work);
+
+	dev_info(&rpdev->dev, "rpmsg hifi[%d] client driver is probed\n", hifi_id);
+
+	return 0;
+
+//err_rpdev_id_name:
+//	devm_kfree(&rpdev->dev, hifi_priv);
+//	return ret;
+}
+
+static void rpmsg_hifi_remove(struct rpmsg_device *rpdev)
+{
+	struct rpmsg_hifi_priv *hifi_priv = dev_get_drvdata(&rpdev->dev);
+	int i = 0;
+
+	for (i = 0; i < ARRAY_SIZE(gHifi_priv); i++) {
+		if (gHifi_priv[i] == hifi_priv) {
+			gHifi_priv[i] = NULL;
+		}
+	}
+	cancel_work_sync(&(hifi_priv->rpmsg_recv_work));
+	destroy_workqueue(hifi_priv->wq);
+
+	devm_kfree(&rpdev->dev, hifi_priv);
+	dev_info(&rpdev->dev, "rpmsg hifi client driver is removed\n");
+}
+
+static struct rpmsg_device_id rpmsg_driver_hifi_id_table[] = {
+	{ .name	= "sunxi,dsp-msgbox" },
+//	{ .name	= "sunxi,dsp1" },
+	{ },
+};
+MODULE_DEVICE_TABLE(rpmsg, rpmsg_driver_hifi_id_table);
+
+static struct rpmsg_driver rpmsg_hifi_client = {
+	.drv.name	= KBUILD_MODNAME,
+	.id_table	= rpmsg_driver_hifi_id_table,
+	.probe		= rpmsg_hifi_probe,
+	.callback	= rpmsg_hifi_cb,
+	.remove		= rpmsg_hifi_remove,
+};
+module_rpmsg_driver(rpmsg_hifi_client);
+
+MODULE_AUTHOR("yumingfeng@allwinnertech.com");
+MODULE_DESCRIPTION("Remote processor messaging hifi client driver");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-codec.c b/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-codec.c
new file mode 100644
index 000000000..f7ebc61a5
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-codec.c
@@ -0,0 +1,317 @@
+/*
+ * sound\soc\sunxi\hifi-dsp\sunxi-codec.c
+ *
+ * (C) Copyright 2019-2025
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * yumingfeng <yumingfeng@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/pm.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/sunxi-gpio.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
+#include <linux/reset.h>
+#include <asm/dma.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/soc.h>
+#include <sound/initval.h>
+#include <sound/tlv.h>
+#include <sound/aw_rpaf/rpmsg_hifi.h>
+
+#include "sunxi-hifi-codec.h"
+
+#define	DRV_NAME	"sunxi-internal-codec"
+
+static int sunxi_hifi_codec_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static int sunxi_hifi_codec_startup(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static void sunxi_hifi_codec_shutdown(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+}
+
+static int sunxi_hifi_codec_prepare(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static int sunxi_hifi_codec_trigger(struct snd_pcm_substream *substream,
+				int cmd, struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static const struct snd_soc_dai_ops sunxi_hifi_codec_dai_ops = {
+	.startup	= sunxi_hifi_codec_startup,
+	.hw_params	= sunxi_hifi_codec_hw_params,
+	.prepare	= sunxi_hifi_codec_prepare,
+	.trigger	= sunxi_hifi_codec_trigger,
+	.shutdown	= sunxi_hifi_codec_shutdown,
+};
+
+static struct snd_soc_dai_driver sunxi_hifi_codec_dai[] = {
+	{
+		.name	= "sunxi-hifi-codec",
+		.playback = {
+			.stream_name = "Playback",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates	= SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE
+				| SNDRV_PCM_FMTBIT_S32_LE,
+		},
+		.capture = {
+			.stream_name = "Capture",
+			.channels_min = 1,
+			.channels_max = 3,
+			.rates = SNDRV_PCM_RATE_8000_48000
+				| SNDRV_PCM_RATE_KNOT,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE,
+		},
+		.ops = &sunxi_hifi_codec_dai_ops,
+	},
+};
+
+extern int sunxi_mixer_block_send(unsigned int hifi_id,
+						struct msg_mixer_package *msg_mixer);
+#if 0
+static int generic_volume_get(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct msg_mixer_package *msg_mixer = &sunxi_codec->msg_mixer;
+	struct snd_soc_dsp_mixer *soc_mixer = &msg_mixer->soc_mixer;
+	int ret;
+
+	soc_mixer->id = kcontrol->id.numid;
+	strcpy(soc_mixer->ctl_name, kcontrol->id.name);
+	soc_mixer->cmd_val = SND_SOC_DSP_MIXER_READ;
+
+	ret = sunxi_mixer_block_send(SUNXI_HIFI0, msg_mixer);
+	if (ret != 0)
+		return ret;
+
+	ucontrol->value.integer.value[0] = soc_mixer->value;
+	return 0;
+}
+
+static int generic_volume_put(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	struct msg_mixer_package *msg_mixer = &sunxi_codec->msg_mixer;
+	struct snd_soc_dsp_mixer *soc_mixer = &msg_mixer->soc_mixer;
+	int ret;
+
+	soc_mixer->cmd_val = SND_SOC_DSP_MIXER_WRITE;
+	soc_mixer->id = kcontrol->id.numid;
+	strcpy(soc_mixer->ctl_name, kcontrol->id.name);
+	soc_mixer->value = ucontrol->value.integer.value[0];
+
+	ret = sunxi_mixer_block_send(SUNXI_HIFI0, msg_mixer);
+	if (ret != 0)
+		return ret;
+
+	ucontrol->value.integer.value[0] = soc_mixer->value;
+
+	return 0;
+}
+
+static const struct snd_kcontrol_new sunxi_codec_controls[] = {
+	SOC_SINGLE_EXT("MIC1 gain volume", 0, 0, 31, 0, generic_volume_get, generic_volume_put),
+	SOC_SINGLE_EXT("MIC2 gain volume", 0, 0, 31, 0, generic_volume_get, generic_volume_put),
+	SOC_SINGLE_EXT("MIC3 gain volume", 0, 0, 31, 0, generic_volume_get, generic_volume_put),
+	SOC_SINGLE_EXT("MIC4 gain volume", 0, 0, 31, 0, generic_volume_get, generic_volume_put),
+	SOC_SINGLE_EXT("MIC5 gain volume", 0, 0, 31, 0, generic_volume_get, generic_volume_put),
+	SOC_SINGLE_EXT("Speaker volume", 0, 0, 31, 0, generic_volume_get, generic_volume_put),
+};
+#endif
+
+static int sunxi_hifi_codec_probe(struct snd_soc_component *component)
+{
+#if 0
+	struct sunxi_codec_info *sunxi_codec = snd_soc_component_get_drvdata(component);
+	int ret;
+//	sunxi_codec->codec = codec;
+
+	ret = snd_soc_add_component_controls(component, sunxi_codec_controls,
+					ARRAY_SIZE(sunxi_codec_controls));
+	if (ret)
+		pr_err("failed to register codec controls!\n");
+#endif
+	return 0;
+}
+
+static void sunxi_hifi_codec_remove(struct snd_soc_component *component)
+{
+}
+
+static int sunxi_hifi_codec_suspend(struct snd_soc_component *component)
+{
+	return 0;
+}
+
+static int sunxi_hifi_codec_resume(struct snd_soc_component *component)
+{
+	return 0;
+}
+
+static struct snd_soc_component_driver soc_codec_dev_sunxi = {
+	.probe = sunxi_hifi_codec_probe,
+	.remove = sunxi_hifi_codec_remove,
+	.suspend = sunxi_hifi_codec_suspend,
+	.resume = sunxi_hifi_codec_resume,
+//	.ignore_pmdown_time = 1,
+};
+
+#if 0
+static const struct regmap_config sunxi_hifi_codec_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = SUNXI_ADC5_REG,
+	.cache_type = REGCACHE_NONE,
+};
+#endif
+
+static int  sunxi_hifi_codec_dev_probe(struct platform_device *pdev)
+{
+	struct sunxi_codec_info *sunxi_codec;
+	struct device_node *np = pdev->dev.of_node;
+	struct msg_mixer_package *msg_mixer;
+	int ret;
+
+	sunxi_codec = devm_kzalloc(&pdev->dev,
+				sizeof(struct sunxi_codec_info), GFP_KERNEL);
+	if (!sunxi_codec) {
+		dev_err(&pdev->dev, "Can't allocate sunxi codec memory\n");
+		ret = -ENOMEM;
+		goto err_devm_kzalloc;
+	}
+	dev_set_drvdata(&pdev->dev, sunxi_codec);
+	sunxi_codec->dev = &pdev->dev;
+
+	msg_mixer = &sunxi_codec->msg_mixer;
+	init_waitqueue_head(&msg_mixer->tsleep);
+	spin_lock_init(&msg_mixer->lock);
+	msg_mixer->wakeup_flag = 0;
+	/* TODO, config by dts? */
+	msg_mixer->soc_mixer.card = 0;
+	msg_mixer->soc_mixer.device = 0;
+	strcpy(msg_mixer->soc_mixer.driver, "audiocodec");
+
+#if 0
+	/* codec reg_base */
+	ret = of_address_to_resource(np, 0, &sunxi_codec->digital_res);
+	if (ret) {
+		dev_err(&pdev->dev, "parse device node codec resource failed\n");
+		ret = -EINVAL;
+		goto err_get_resource;
+	}
+
+	sunxi_codec->addr_base = of_iomap(np, 0);
+	if (sunxi_codec->addr_base == NULL) {
+		dev_err(&pdev->dev, "digital register iomap failed\n");
+		ret = -EINVAL;
+		goto err_get_iomap;
+	}
+
+	sunxi_codec->regmap = devm_regmap_init_mmio(&pdev->dev,
+				sunxi_codec->addr_base, &sunxi_hifi_codec_regmap_config);
+	if (IS_ERR(sunxi_codec->regmap)) {
+		dev_err(&pdev->dev, "regmap init failed\n");
+		ret = PTR_ERR(sunxi_codec->regmap);
+		goto err_devm_regmap_init;
+	}
+#endif
+	ret = snd_soc_register_component(&pdev->dev, &soc_codec_dev_sunxi,
+				sunxi_hifi_codec_dai, ARRAY_SIZE(sunxi_hifi_codec_dai));
+	if (ret < 0) {
+		dev_err(&pdev->dev, "register codec failed\n");
+		ret = -EBUSY;
+		goto err_register_codec;
+	}
+
+	return 0;
+
+err_register_codec:
+//err_devm_regmap_init:
+//	iounmap(sunxi_codec->addr_base);
+//err_get_iomap:
+//err_get_resource:
+	devm_kfree(&pdev->dev, sunxi_codec);
+err_devm_kzalloc:
+	of_node_put(np);
+	return ret;
+}
+
+static int  __exit sunxi_hifi_codec_dev_remove(struct platform_device *pdev)
+{
+	struct sunxi_codec_info *sunxi_codec = dev_get_drvdata(&pdev->dev);
+	struct device_node *np = pdev->dev.of_node;
+
+	snd_soc_unregister_component(&pdev->dev);
+
+//	iounmap(sunxi_codec->addr_base);
+
+	devm_kfree(&pdev->dev, sunxi_codec);
+	of_node_put(np);
+
+	return 0;
+}
+
+static const struct of_device_id sunxi_hifi_codec_of_match[] = {
+	{ .compatible = "allwinner,sunxi-internal-codec", },
+	{},
+};
+
+static struct platform_driver sunxi_hifi_codec_driver = {
+	.driver = {
+		.name = DRV_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_hifi_codec_of_match,
+	},
+	.probe = sunxi_hifi_codec_dev_probe,
+	.remove = __exit_p(sunxi_hifi_codec_dev_remove),
+};
+module_platform_driver(sunxi_hifi_codec_driver);
+
+MODULE_DESCRIPTION("SUNXI Codec ASoC driver");
+MODULE_AUTHOR("yumingfeng <yumingfeng@allwinnertech.com>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:sunxi-internal-codec");
diff --git a/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-codec.h b/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-codec.h
new file mode 100644
index 000000000..4078e3849
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-codec.h
@@ -0,0 +1,46 @@
+/*
+ * sound\soc\sunxi\hifi-dsp\sunxi-codec.h
+ *
+ * (C) Copyright 2019-2025
+ * allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * yumingfeng <yumingfeng@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#ifndef _SUNXI_CODEC_H
+#define _SUNXI_CODEC_H
+#include "sunxi-hifi-pcm.h"
+
+#define CODEC_TX_FIFO_SIZE 128
+#define CODEC_RX_FIFO_SIZE 256
+
+#define LABEL(constant)		{#constant, constant, 0}
+#define LABEL_END		{NULL, 0, -1}
+
+struct label {
+	const char *name;
+	const unsigned int address;
+	int value;
+};
+
+struct voltage_supply {
+	struct regulator *cpvdd;
+	struct regulator *avcc;
+};
+
+struct sunxi_codec_info {
+	struct device *dev;
+	struct regmap *regmap;
+	struct resource digital_res;
+	void __iomem *addr_base;
+	struct snd_soc_codec *codec;
+	struct msg_mixer_package msg_mixer;
+};
+
+#endif /* __SUNXI_CODEC_H */
diff --git a/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-cpudai.c b/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-cpudai.c
new file mode 100644
index 000000000..895456bdd
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-cpudai.c
@@ -0,0 +1,1035 @@
+/*
+ * sound\soc\sunxi\hifi-dsp\sunxi-cpudai.c
+ *
+ * (C) Copyright 2019-2025
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * yumingfeng <yumingfeng@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
+#include <linux/reset.h>
+#include <asm/dma.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+#include <asm/cacheflush.h>
+#include <sound/aw_rpaf/rpmsg_hifi.h>
+#include <sound/aw_rpaf/component-core.h>
+
+#include "sunxi-hifi-pcm.h"
+#include "sunxi-hifi-cpudai.h"
+#include "sunxi-hifi-codec.h"
+#include "../../../../core/pcm_local.h"
+
+#define DRV_NAME "sunxi-internal-cpudai"
+
+static long playback_component_type;
+module_param(playback_component_type, long, 0644);
+MODULE_PARM_DESC(playback_component_type, "playback component type for dump");
+
+static long capture_component_type;
+module_param(capture_component_type, long, 0644);
+MODULE_PARM_DESC(capture_component_type, "capture component type for dump");
+
+static int sunxi_hifi_cpudai_startup(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	struct sunxi_cpudai_info *sunxi_cpudai = snd_soc_dai_get_drvdata(dai);
+	struct msg_substream_package *msg_substream;
+	struct snd_soc_dsp_substream *soc_substream;
+	struct mutex *rpmsg_mutex;
+	int ret = 0;
+
+	if (IS_ERR_OR_NULL(sunxi_cpudai)) {
+		dev_err(dai->dev, "[%s] sunxi_cpudai is NULL!\n", __func__);
+		return -ENOMEM;
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		snd_soc_dai_set_dma_data(dai, substream,
+					&sunxi_cpudai->playback_dma_param);
+		msg_substream = &sunxi_cpudai->msg_playback;
+		rpmsg_mutex = &sunxi_cpudai->rpmsg_mutex_playback;
+		sunxi_cpudai->playing = 0;
+		soc_substream = &msg_substream->soc_substream;
+		soc_substream->output_addr = sunxi_cpudai->playback_dma_param.phy_addr;
+		dev_dbg(dai->dev, "coherent phy_addr:0x%x\n", soc_substream->output_addr);
+	} else {
+		snd_soc_dai_set_dma_data(dai, substream, &sunxi_cpudai->capture_dma_param);
+		msg_substream = &sunxi_cpudai->msg_capture;
+		rpmsg_mutex = &sunxi_cpudai->rpmsg_mutex_capture;
+		sunxi_cpudai->capturing = 0;
+		soc_substream = &msg_substream->soc_substream;
+		soc_substream->input_addr = sunxi_cpudai->capture_dma_param.phy_addr;
+		dev_dbg(dai->dev, "coherent phy_addr:0x%x\n", soc_substream->input_addr);
+	}
+	msg_substream->substream = substream;
+
+	/* msgbox to dsp */
+	mutex_lock(rpmsg_mutex);
+	awrpaf_debug("\n");
+	soc_substream->cmd_val = SND_SOC_DSP_PCM_STARTUP;
+	ret = sunxi_hifi_cpudai_substream_block_send(SUNXI_HIFI0, substream, dai,
+						substream->stream, MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+	sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+	mutex_unlock(rpmsg_mutex);
+	if (ret < 0) {
+		dev_err(dai->dev, "cpudai send failed.\n");
+		soc_substream->cmd_val = SND_SOC_DSP_PCM_SHUTDOWN;
+		sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+		sunxi_hifi_cpudai_substream_block_send(SUNXI_HIFI0, substream, dai,
+						substream->stream, MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+		awrpaf_debug("\n");
+		return ret;
+	}
+	return soc_substream->ret_val;
+}
+
+static int sunxi_hifi_cpudai_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct sunxi_cpudai_info *sunxi_cpudai = snd_soc_dai_get_drvdata(dai);
+	struct msg_substream_package *msg_substream;
+	struct snd_soc_dsp_substream *soc_substream;
+	struct snd_soc_dsp_pcm_params *pcm_params;
+	unsigned int frame_bytes;
+	unsigned int sample_bits;
+	struct mutex *rpmsg_mutex;
+	int ret = 0;
+
+	if (IS_ERR_OR_NULL(sunxi_cpudai)) {
+		dev_err(dai->dev, "[%s] sunxi_cpudai is null.\n", __func__);
+		return -ENOMEM;
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		msg_substream = &sunxi_cpudai->msg_playback;
+		rpmsg_mutex = &sunxi_cpudai->rpmsg_mutex_playback;
+	} else {
+		msg_substream = &sunxi_cpudai->msg_capture;
+		rpmsg_mutex = &sunxi_cpudai->rpmsg_mutex_capture;
+	}
+	soc_substream = &msg_substream->soc_substream;
+
+	mutex_lock(rpmsg_mutex);
+	pcm_params = &soc_substream->params;
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		pcm_params->format = SND_PCM_FORMAT_S16_LE;
+		sample_bits = 16;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		pcm_params->format = SND_PCM_FORMAT_S24_LE;
+		sample_bits = 32;
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		pcm_params->format = SND_PCM_FORMAT_S32_LE;
+		sample_bits = 32;
+		break;
+	default:
+		mutex_unlock(rpmsg_mutex);
+		dev_err(sunxi_cpudai->dev, "unrecognized format\n");
+		return -EINVAL;
+	}
+
+	pcm_params->channels = params_channels(params);
+	pcm_params->rate = params_rate(params);
+	pcm_params->period_size = params_period_size(params);
+	pcm_params->periods = params_periods(params);
+	pcm_params->pcm_frames = pcm_params->period_size;
+	/* buffer,  */
+	pcm_params->buffer_size = params_buffer_size(params);
+	frame_bytes = pcm_params->channels * sample_bits / 8;
+
+	dev_info(sunxi_cpudai->dev, "======== hw_params ========\n");
+	dev_info(sunxi_cpudai->dev, "pcm_params->format:%u\n", pcm_params->format);
+	dev_info(sunxi_cpudai->dev, "pcm_params->channels:%u\n", pcm_params->channels);
+	dev_info(sunxi_cpudai->dev, "pcm_params->rate:%u\n", pcm_params->rate);
+	dev_info(sunxi_cpudai->dev, "pcm_params->period_size:%u\n", pcm_params->period_size);
+	dev_info(sunxi_cpudai->dev, "pcm_params->periods:%u\n", pcm_params->periods);
+	dev_info(sunxi_cpudai->dev, "pcm_params->pcm_frames:%u\n", pcm_params->pcm_frames);
+	dev_info(sunxi_cpudai->dev, "pcm_params->buffer_size:%u\n", pcm_params->buffer_size);
+	dev_info(sunxi_cpudai->dev, "===========================\n");
+	soc_substream->input_size = pcm_params->period_size * frame_bytes;
+	soc_substream->output_size = pcm_params->period_size * frame_bytes;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		struct snd_dsp_component *dsp_component = &sunxi_cpudai->dsp_playcomp;
+		struct msg_component_package *msg_component = &dsp_component->msg_component;
+		struct snd_soc_dsp_component *soc_component = &msg_component->soc_component;
+
+		soc_component->component_type = playback_component_type;
+
+		ret = sunxi_hifi_substream_set_stream_component(SUNXI_HIFI0,
+				dai, soc_substream, dsp_component);
+		if (ret < 0) {
+			dev_err(dai->dev, "set stream component send failed.\n");
+			return ret;
+		}
+	} else {
+		struct snd_dsp_component *dsp_component = &sunxi_cpudai->dsp_capcomp;
+		struct msg_component_package *msg_component = &dsp_component->msg_component;
+		struct snd_soc_dsp_component *soc_component = &msg_component->soc_component;
+
+		soc_component->component_type = capture_component_type;
+
+		ret = sunxi_hifi_substream_set_stream_component(SUNXI_HIFI0,
+				dai, soc_substream, dsp_component);
+		if (ret < 0) {
+			dev_err(dai->dev, "set stream component send failed.\n");
+			return ret;
+		}
+	}
+
+	/* msgbox to dsp */
+	soc_substream->cmd_val = SND_SOC_DSP_PCM_HW_PARAMS;
+	awrpaf_debug("\n");
+	ret = sunxi_hifi_cpudai_substream_block_send(SUNXI_HIFI0, substream, dai,
+			substream->stream, MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+	sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+	mutex_unlock(rpmsg_mutex);
+	if (ret < 0) {
+		dev_err(dai->dev, "cpudai send failed.\n");
+		return ret;
+	}
+	if (soc_substream->ret_val < 0)
+		dev_err(dai->dev, "soc_substream hw_params ret_val:%d\n",
+				soc_substream->ret_val);
+	return soc_substream->ret_val;
+}
+
+static int sunxi_hifi_cpudai_prepare(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	struct sunxi_cpudai_info *sunxi_cpudai = snd_soc_dai_get_drvdata(dai);
+	struct msg_substream_package *msg_substream;
+	struct snd_soc_dsp_substream *soc_substream;
+	struct mutex *rpmsg_mutex;
+	int ret = 0;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		msg_substream = &sunxi_cpudai->msg_playback;
+		rpmsg_mutex = &sunxi_cpudai->rpmsg_mutex_playback;
+		/* waitting stop play */
+		while (sunxi_cpudai->playing)
+			msleep(20);
+	} else {
+		msg_substream = &sunxi_cpudai->msg_capture;
+		rpmsg_mutex = &sunxi_cpudai->rpmsg_mutex_capture;
+		/* waitting stop capture */
+		while (sunxi_cpudai->capturing)
+			msleep(20);
+	}
+	soc_substream = &msg_substream->soc_substream;
+
+	/* msgbox to dsp */
+	mutex_lock(rpmsg_mutex);
+	awrpaf_debug("\n");
+	soc_substream->cmd_val = SND_SOC_DSP_PCM_PREPARE;
+	ret = sunxi_hifi_cpudai_substream_block_send(SUNXI_HIFI0, substream, dai,
+						substream->stream, MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+	sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+	mutex_unlock(rpmsg_mutex);
+	if (ret < 0) {
+		dev_err(dai->dev, "cpudai send failed.\n");
+		return ret;
+	}
+	return soc_substream->ret_val;
+}
+
+static int sunxi_hifi_cpudai_trigger(struct snd_pcm_substream *substream,
+				int cmd, struct snd_soc_dai *dai)
+{
+	struct sunxi_cpudai_info *sunxi_cpudai = snd_soc_dai_get_drvdata(dai);
+	struct msg_substream_package *msg_substream;
+	struct snd_soc_dsp_substream *soc_substream;
+	struct delayed_work *trigger_work;
+	struct workqueue_struct *wq_pcm;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			msg_substream = &sunxi_cpudai->msg_playback;
+			soc_substream = &msg_substream->soc_substream;
+			soc_substream->cmd_val = SND_SOC_DSP_PCM_WRITEI;
+			trigger_work = &sunxi_cpudai->trigger_work_playback;
+			wq_pcm = sunxi_cpudai->wq_playback;
+		} else {
+			msg_substream = &sunxi_cpudai->msg_capture;
+			soc_substream = &msg_substream->soc_substream;
+			soc_substream->cmd_val = SND_SOC_DSP_PCM_READI;
+			trigger_work = &sunxi_cpudai->trigger_work_capture;
+			wq_pcm = sunxi_cpudai->wq_capture;
+		}
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if ((substream->stream == SNDRV_PCM_STREAM_PLAYBACK) &&
+			(substream->runtime->status->state == SNDRV_PCM_STATE_DRAINING)) {
+			dev_info(dai->dev, "drain stopping\n");
+			return 0;
+		}
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			msg_substream = &sunxi_cpudai->msg_playback;
+			trigger_work = &sunxi_cpudai->trigger_work_playback;
+			wq_pcm = sunxi_cpudai->wq_playback;
+		} else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+			msg_substream = &sunxi_cpudai->msg_capture;
+			trigger_work = &sunxi_cpudai->trigger_work_capture;
+			wq_pcm = sunxi_cpudai->wq_capture;
+		}
+		soc_substream = &msg_substream->soc_substream;
+		soc_substream->cmd_val = SND_SOC_DSP_PCM_STOP;
+		break;
+	case SNDRV_PCM_TRIGGER_DRAIN:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			msg_substream = &sunxi_cpudai->msg_playback;
+			trigger_work = &sunxi_cpudai->trigger_work_playback;
+			wq_pcm = sunxi_cpudai->wq_playback;
+			soc_substream = &msg_substream->soc_substream;
+			soc_substream->cmd_val = SND_SOC_DSP_PCM_DRAIN;
+			dev_info(dai->dev, "drain starting\n");
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+	queue_delayed_work(wq_pcm, trigger_work, 0);
+
+	return 0;
+}
+
+static void sunxi_hifi_cpudai_shutdown(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	struct sunxi_cpudai_info *sunxi_cpudai = snd_soc_dai_get_drvdata(dai);
+	struct msg_substream_package *msg_substream;
+	struct snd_soc_dsp_substream *soc_substream;
+	struct snd_dsp_component *dsp_component;
+	struct mutex *rpmsg_mutex;
+	unsigned int *work_running;
+	int i = 0;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		msg_substream = &sunxi_cpudai->msg_playback;
+		rpmsg_mutex = &sunxi_cpudai->rpmsg_mutex_playback;
+		work_running = &sunxi_cpudai->playing;
+	} else {
+		msg_substream = &sunxi_cpudai->msg_capture;
+		rpmsg_mutex = &sunxi_cpudai->rpmsg_mutex_capture;
+		work_running = &sunxi_cpudai->capturing;
+	}
+	soc_substream = &msg_substream->soc_substream;
+
+	awrpaf_debug("\n");
+	for (i = 0; i < 50; i++) {
+		if (*work_running == 0)
+			break;
+		msleep(20);
+	}
+	awrpaf_debug("\n");
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		dsp_component = &sunxi_cpudai->dsp_playcomp;
+	else
+		dsp_component = &sunxi_cpudai->dsp_capcomp;
+
+	sunxi_hifi_substream_release_stream_component(dai, dsp_component);
+
+	/* msgbox to dsp */
+	mutex_lock(rpmsg_mutex);
+	soc_substream->cmd_val = SND_SOC_DSP_PCM_SHUTDOWN;
+	awrpaf_debug("\n");
+	sunxi_hifi_cpudai_substream_block_send(SUNXI_HIFI0, substream, dai,
+						substream->stream, MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+	sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+	mutex_unlock(rpmsg_mutex);
+
+	msg_substream->substream = NULL;
+}
+
+static struct snd_soc_dai_ops sunxi_hifi_cpudai_dai_ops = {
+	.startup = sunxi_hifi_cpudai_startup,
+	.hw_params = sunxi_hifi_cpudai_hw_params,
+	.prepare = sunxi_hifi_cpudai_prepare,
+	.trigger = sunxi_hifi_cpudai_trigger,
+	.shutdown = sunxi_hifi_cpudai_shutdown,
+};
+
+static int sunxi_hifi_cpudai_init(struct sunxi_cpudai_info *sunxi_cpudai,
+					struct snd_soc_dai *dai)
+{
+	struct msg_substream_package *msg_playback = &sunxi_cpudai->msg_playback;
+	struct msg_substream_package *msg_capture = &sunxi_cpudai->msg_capture;
+	struct msg_debug_package *msg_debug = &sunxi_cpudai->msg_debug;
+//	struct snd_soc_dsp_debug *soc_debug = &msg_debug->soc_debug;
+	struct msg_component_package *msg_component;
+	struct snd_dsp_component *dsp_component;
+//	struct snd_soc_dsp_component *soc_component;
+	struct snd_soc_dsp_substream *soc_substream;
+	struct snd_soc_dsp_pcm_params *pcm_params;
+	int ret = 0;
+
+	sunxi_cpudai->cpu_dai = dai;
+
+	/* init for playback */
+	init_waitqueue_head(&msg_playback->tsleep);
+	spin_lock_init(&msg_playback->lock);
+	msg_playback->wakeup_flag = 0;
+	soc_substream = &msg_playback->soc_substream;
+	pcm_params = &soc_substream->params;
+	/* 1:capture; 0:playback */
+	pcm_params->stream = SND_STREAM_PLAYBACK;
+
+	/*
+	 * (delete: hw:):
+	 * 0: hw:audiocodec;
+	 * 1: hw:snddmic;
+	 * 2: hw:snddaudio0;
+	 */
+	pcm_params->card = sunxi_cpudai->dsp_card;
+	pcm_params->device = sunxi_cpudai->dsp_device;
+	snprintf(pcm_params->driver, 31, "audiocodec");
+
+	/* dma buffer alloc */
+	sunxi_dma_params_alloc_dma_area(dai, &sunxi_cpudai->playback_dma_param);
+	if (!sunxi_cpudai->playback_dma_param.dma_area) {
+		dev_err(dai->dev, "playback dmaengine alloc coherent failed.\n");
+		ret = -ENOMEM;
+		goto err_dma_alloc_playback;
+	}
+
+	/* init for playback component */
+	dsp_component = &sunxi_cpudai->dsp_playcomp;
+	msg_component = &dsp_component->msg_component;
+	init_waitqueue_head(&msg_component->tsleep);
+	spin_lock_init(&msg_component->lock);
+	msg_component->wakeup_flag = 0;
+
+	/* init for capture */
+	init_waitqueue_head(&msg_capture->tsleep);
+	spin_lock_init(&msg_capture->lock);
+	msg_capture->wakeup_flag = 0;
+	soc_substream = &msg_capture->soc_substream;
+	pcm_params = &soc_substream->params;
+	pcm_params->stream = SND_STREAM_CAPTURE;
+
+	pcm_params->card = sunxi_cpudai->dsp_card;
+	pcm_params->device = sunxi_cpudai->dsp_device;
+	snprintf(pcm_params->driver, 31, "audiocodec");
+
+	/* dma buffer alloc */
+	sunxi_dma_params_alloc_dma_area(dai, &sunxi_cpudai->capture_dma_param);
+	if (!sunxi_cpudai->capture_dma_param.dma_area) {
+		dev_err(dai->dev, "capture dmaengine alloc coherent failed.\n");
+		ret = -ENOMEM;
+		goto err_dma_alloc_capture;
+	}
+
+	/* init for capture component */
+	dsp_component = &sunxi_cpudai->dsp_capcomp;
+	msg_component = &dsp_component->msg_component;
+	init_waitqueue_head(&msg_component->tsleep);
+	spin_lock_init(&msg_component->lock);
+	msg_component->wakeup_flag = 0;
+
+	/* init for debug */
+	init_waitqueue_head(&msg_debug->tsleep);
+	spin_lock_init(&msg_debug->lock);
+	msg_debug->wakeup_flag = 0;
+
+	/* register sunxi_cpudai_info to rpmsg_hifi driver */
+	sunxi_hifi_register_sound_drv_info(pcm_params->driver, sunxi_cpudai);
+
+	/* pdata_info */
+	return 0;
+
+err_dma_alloc_capture:
+	sunxi_dma_params_free_dma_area(dai, &sunxi_cpudai->playback_dma_param);
+err_dma_alloc_playback:
+	return ret;
+}
+
+static int sunxi_hifi_cpudai_uninit(struct sunxi_cpudai_info *sunxi_cpudai,
+					struct snd_soc_dai *dai)
+{
+	struct msg_substream_package *msg_substream;
+	struct snd_soc_dsp_substream *soc_substream;
+
+	sunxi_dma_params_free_dma_area(dai, &sunxi_cpudai->playback_dma_param);
+	sunxi_dma_params_free_dma_area(dai, &sunxi_cpudai->capture_dma_param);
+
+	msg_substream = &sunxi_cpudai->msg_playback;
+	soc_substream = &msg_substream->soc_substream;
+	/* for unregister sunxi_cpudai_info from rpmsg_hifi driver */
+	sunxi_hifi_unregister_sound_drv_info(soc_substream->params.driver, sunxi_cpudai);
+
+	return 0;
+}
+
+int sunxi_hifi_cpudai_probe(struct snd_soc_dai *dai)
+{
+	struct sunxi_cpudai_info *sunxi_cpudai = snd_soc_dai_get_drvdata(dai);
+	struct msg_substream_package *msg_capture = &sunxi_cpudai->msg_capture;
+	struct msg_substream_package *msg_playback = &sunxi_cpudai->msg_playback;
+	struct snd_soc_dsp_substream *soc_substream;
+	int ret = 0;
+
+	/* pcm_new will using the dma_param about the cma and fifo params. */
+	snd_soc_dai_init_dma_data(dai, &sunxi_cpudai->playback_dma_param,
+				&sunxi_cpudai->capture_dma_param);
+
+	sunxi_hifi_cpudai_init(sunxi_cpudai, dai);
+
+	dev_info(dai->dev, "%s start.\n", __func__);
+	/* msgbox to dsp */
+	/* for hifi pcm playback create hal object */
+	soc_substream = &msg_playback->soc_substream;
+	soc_substream->cmd_val = SND_SOC_DSP_PCM_PROBE;
+	ret = sunxi_hifi_cpudai_substream_block_send(SUNXI_HIFI0, NULL, dai,
+							SNDRV_PCM_STREAM_PLAYBACK,
+							MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+	sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+	if (ret < 0) {
+		dev_err(dai->dev, "%s probe playback failed.\n", __func__);
+		goto err_probe_playback;
+	} else if (soc_substream->ret_val < 0) {
+		dev_err(dai->dev, "%s probe playback dsp failed.\n", __func__);
+		ret = soc_substream->ret_val;
+		goto err_probe_playback;
+	}
+
+	/* for capture */
+	soc_substream = &msg_capture->soc_substream;
+	soc_substream->cmd_val = SND_SOC_DSP_PCM_PROBE;
+	ret = sunxi_hifi_cpudai_substream_block_send(SUNXI_HIFI0, NULL, dai,
+							SNDRV_PCM_STREAM_CAPTURE,
+							MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+	sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+	if (ret < 0) {
+		dev_err(dai->dev, "%s probe capture failed.\n", __func__);
+		goto err_probe_capture;
+	} else if (soc_substream->ret_val < 0) {
+		dev_err(dai->dev, "%s probe capture dsp failed.\n", __func__);
+		ret = soc_substream->ret_val;
+		goto err_probe_capture;
+	}
+
+	dev_info(dai->dev, "%s stop.\n", __func__);
+	return 0;
+
+err_probe_capture:
+err_probe_playback:
+	sunxi_hifi_cpudai_uninit(sunxi_cpudai, dai);
+	return ret;
+}
+
+static int sunxi_hifi_cpudai_suspend(struct snd_soc_dai *dai)
+{
+	struct sunxi_cpudai_info *sunxi_cpudai = snd_soc_dai_get_drvdata(dai);
+	struct msg_substream_package *msg_capture = &sunxi_cpudai->msg_capture;
+	struct msg_substream_package *msg_playback = &sunxi_cpudai->msg_playback;
+	struct snd_soc_dsp_substream *soc_substream;
+	struct mutex *rpmsg_mutex;
+	int ret;
+
+	pr_debug("[%s] suspend .%s start\n", __func__,
+			dev_name(sunxi_cpudai->dev));
+
+	/* for capture */
+	rpmsg_mutex = &sunxi_cpudai->rpmsg_mutex_capture;
+	mutex_lock(rpmsg_mutex);
+	soc_substream = &msg_capture->soc_substream;
+	soc_substream->cmd_val = SND_SOC_DSP_PCM_SUSPEND;
+	ret = sunxi_hifi_cpudai_substream_block_send(SUNXI_HIFI0, NULL, dai,
+							SNDRV_PCM_STREAM_CAPTURE,
+							MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+	sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+	mutex_unlock(rpmsg_mutex);
+	if (ret < 0) {
+		dev_err(dai->dev, "%s suspend capture failed.\n", __func__);
+		return ret;
+	} else if (soc_substream->ret_val < 0) {
+		dev_err(dai->dev, "%s suspend capture dsp failed.\n", __func__);
+		return soc_substream->ret_val;
+	}
+
+	/* for playback */
+	rpmsg_mutex = &sunxi_cpudai->rpmsg_mutex_playback;
+	mutex_lock(rpmsg_mutex);
+	soc_substream = &msg_playback->soc_substream;
+	soc_substream->cmd_val = SND_SOC_DSP_PCM_SUSPEND;
+	ret = sunxi_hifi_cpudai_substream_block_send(SUNXI_HIFI0, NULL, dai,
+							SNDRV_PCM_STREAM_PLAYBACK,
+							MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+	sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+	mutex_unlock(rpmsg_mutex);
+	if (ret < 0) {
+		dev_err(dai->dev, "%s suspend playback failed.\n", __func__);
+		return ret;
+	} else if (soc_substream->ret_val < 0) {
+		dev_err(dai->dev, "%s suspend playback dsp failed.\n", __func__);
+		return soc_substream->ret_val;
+	}
+
+	pr_debug("[%s] suspend .%s stop\n", __func__,
+			dev_name(sunxi_cpudai->dev));
+	return 0;
+
+}
+
+static int sunxi_hifi_cpudai_resume(struct snd_soc_dai *dai)
+{
+	struct sunxi_cpudai_info *sunxi_cpudai = snd_soc_dai_get_drvdata(dai);
+	struct msg_substream_package *msg_capture = &sunxi_cpudai->msg_capture;
+	struct msg_substream_package *msg_playback = &sunxi_cpudai->msg_playback;
+	struct snd_soc_dsp_substream *soc_substream;
+	struct mutex *rpmsg_mutex;
+	int ret;
+
+	pr_debug("[%s] resume .%s start\n", __func__,
+			dev_name(sunxi_cpudai->dev));
+
+	/* for capture */
+	rpmsg_mutex = &sunxi_cpudai->rpmsg_mutex_capture;
+	mutex_lock(rpmsg_mutex);
+	soc_substream = &msg_capture->soc_substream;
+	soc_substream->cmd_val = SND_SOC_DSP_PCM_RESUME;
+	ret = sunxi_hifi_cpudai_substream_block_send(SUNXI_HIFI0, NULL, dai,
+							SNDRV_PCM_STREAM_CAPTURE,
+							MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+	sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+	mutex_unlock(rpmsg_mutex);
+	if (ret < 0) {
+		dev_err(dai->dev, "%s suspend capture failed.\n", __func__);
+		return ret;
+	} else if (soc_substream->ret_val < 0) {
+		dev_err(dai->dev, "%s suspend capture dsp failed.\n", __func__);
+		return soc_substream->ret_val;
+	}
+
+	/* for playback */
+	rpmsg_mutex = &sunxi_cpudai->rpmsg_mutex_playback;
+	mutex_lock(rpmsg_mutex);
+	soc_substream = &msg_playback->soc_substream;
+	soc_substream->cmd_val = SND_SOC_DSP_PCM_RESUME;
+	ret = sunxi_hifi_cpudai_substream_block_send(SUNXI_HIFI0, NULL, dai,
+							SNDRV_PCM_STREAM_PLAYBACK,
+							MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+	sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+	mutex_unlock(rpmsg_mutex);
+	if (ret < 0) {
+		dev_err(dai->dev, "%s suspend playback failed.\n", __func__);
+		return ret;
+	} else if (soc_substream->ret_val < 0) {
+		dev_err(dai->dev, "%s suspend playback dsp failed.\n", __func__);
+		return soc_substream->ret_val;
+	}
+
+	pr_debug("[%s] resume .%s stop\n", __func__,
+			dev_name(sunxi_cpudai->dev));
+
+	return 0;
+}
+
+int sunxi_hifi_cpudai_remove(struct snd_soc_dai *dai)
+{
+	struct sunxi_cpudai_info *sunxi_cpudai = snd_soc_dai_get_drvdata(dai);
+	struct msg_substream_package *msg_capture = &sunxi_cpudai->msg_capture;
+	struct msg_substream_package *msg_playback = &sunxi_cpudai->msg_playback;
+	struct snd_soc_dsp_substream *soc_substream;
+	int ret = 0;
+
+	dev_info(dai->dev, "%s start.\n", __func__);
+	/* for playback */
+	soc_substream = &msg_playback->soc_substream;
+	soc_substream->cmd_val = SND_SOC_DSP_PCM_REMOVE;
+	sunxi_hifi_cpudai_substream_block_send(SUNXI_HIFI0, NULL, dai,
+							SNDRV_PCM_STREAM_PLAYBACK,
+							MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+
+	/* for capture */
+	soc_substream = &msg_capture->soc_substream;
+	soc_substream->cmd_val = SND_SOC_DSP_PCM_REMOVE;
+	ret = sunxi_hifi_daudio_substream_block_send(SUNXI_HIFI0, NULL, dai,
+							SNDRV_PCM_STREAM_CAPTURE,
+							MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+	sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+	if (ret < 0) {
+		dev_err(dai->dev, "remove send failed.\n");
+		sunxi_hifi_cpudai_uninit(sunxi_cpudai, dai);
+		return -EFAULT;
+	}
+	sunxi_hifi_cpudai_uninit(sunxi_cpudai, dai);
+
+	dev_info(dai->dev, "%s stop.\n", __func__);
+
+	return 0;
+}
+
+static struct snd_soc_dai_driver sunxi_hifi_cpudai_dai = {
+	.probe = sunxi_hifi_cpudai_probe,
+	.remove = sunxi_hifi_cpudai_remove,
+	.suspend = sunxi_hifi_cpudai_suspend,
+	.resume = sunxi_hifi_cpudai_resume,
+	.playback = {
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_8000_192000 |
+			SNDRV_PCM_RATE_KNOT,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE |
+			SNDRV_PCM_FMTBIT_S24_LE |
+			SNDRV_PCM_FMTBIT_S32_LE,
+	},
+	.capture = {
+		.channels_min = 1,
+		.channels_max = 3,
+		.rates = SNDRV_PCM_RATE_8000_48000 |
+			SNDRV_PCM_RATE_KNOT,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE |
+			SNDRV_PCM_FMTBIT_S24_LE |
+			SNDRV_PCM_FMTBIT_S32_LE,
+	},
+	.ops = &sunxi_hifi_cpudai_dai_ops,
+};
+
+static const struct snd_soc_component_driver sunxi_hifi_cpudai_component = {
+	.name = DRV_NAME,
+};
+
+static const struct of_device_id sunxi_hifi_cpudai_of_match[] = {
+	{ .compatible = "allwinner,sunxi-dummy-cpudai", },
+	{},
+};
+
+static void trigger_work_playback_func(struct work_struct *work)
+{
+	struct sunxi_cpudai_info *sunxi_cpudai =
+			container_of(work, struct sunxi_cpudai_info, trigger_work_playback.work);
+	struct msg_substream_package *msg_substream = &sunxi_cpudai->msg_playback;
+	struct snd_pcm_substream *substream = msg_substream->substream;
+	struct snd_soc_dsp_substream *soc_substream = &msg_substream->soc_substream;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	unsigned int pos = 0;
+	int ret = 0;
+
+	for (;;) {
+		pr_debug("[%s] line:%d cmd_val=%d, state=%d\n", __func__, __LINE__,
+			soc_substream->cmd_val,
+			runtime->status->state);
+		mutex_lock(&sunxi_cpudai->rpmsg_mutex_playback);
+		if (soc_substream->cmd_val == SND_SOC_DSP_PCM_WRITEI) {
+			snd_pcm_stream_lock_irq(substream);
+			if (runtime->status->state != SNDRV_PCM_STATE_RUNNING) {
+				dev_err(sunxi_cpudai->cpu_dai->dev,
+					"%s state:%d\n", __func__, runtime->status->state);
+				snd_pcm_stream_unlock_irq(substream);
+				mutex_unlock(&sunxi_cpudai->rpmsg_mutex_playback);
+				break;
+			}
+			sunxi_cpudai->playing = 1;
+			/* update the capture soc_substream output addr */
+			pos = snd_dmaengine_pcm_pointer_no_residue(substream);
+			soc_substream->input_addr = runtime->dma_addr + frames_to_bytes(runtime, pos);
+			snd_pcm_stream_unlock_irq(substream);
+
+			dev_dbg(sunxi_cpudai->cpu_dai->dev,
+				"[%s] dma_addr:0x%x, pos:%u, input_addr:0x%x\n",
+				__func__, runtime->dma_addr, pos, soc_substream->input_addr);
+			ret = sunxi_hifi_cpudai_substream_block_send(SUNXI_HIFI0,
+				substream, sunxi_cpudai->cpu_dai,
+				SNDRV_PCM_STREAM_PLAYBACK, MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+			sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+			mutex_unlock(&sunxi_cpudai->rpmsg_mutex_playback);
+
+			/* component */
+			snd_soc_rpaf_pcm_update_stream_process(&sunxi_cpudai->dsp_playcomp);
+
+			if (ret != 0) {
+				dev_err(sunxi_cpudai->cpu_dai->dev,
+					"%s state:%d, ret=%d\n", __func__, runtime->status->state, ret);
+			}
+			if (runtime->status->state == SNDRV_PCM_STATE_RUNNING) {
+				queue_delayed_work(sunxi_cpudai->wq_playback,
+					&sunxi_cpudai->trigger_work_playback, 0);
+			}
+			break;
+		} else if (soc_substream->cmd_val == SND_SOC_DSP_PCM_STOP) {
+			awrpaf_debug("\n");
+			/* send to dsp */
+			sunxi_hifi_cpudai_substream_block_send(SUNXI_HIFI0,
+				substream, sunxi_cpudai->cpu_dai,
+				SNDRV_PCM_STREAM_PLAYBACK, MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+			sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+			sunxi_cpudai->playing = 0;
+			awrpaf_debug("\n");
+			mutex_unlock(&sunxi_cpudai->rpmsg_mutex_playback);
+			break;
+		} else if (soc_substream->cmd_val == SND_SOC_DSP_PCM_DRAIN) {
+			awrpaf_debug("\n");
+			/* send to dsp */
+			sunxi_hifi_cpudai_substream_block_send(SUNXI_HIFI0,
+				substream, sunxi_cpudai->cpu_dai,
+				SNDRV_PCM_STREAM_PLAYBACK, MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+			sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+			snd_pcm_stream_lock_irq(substream);
+			snd_pcm_drain_done(substream);
+			snd_pcm_update_state(substream, runtime);
+			sunxi_cpudai->playing = 0;
+			snd_pcm_stream_unlock_irq(substream);
+
+			awrpaf_debug("\n");
+			mutex_unlock(&sunxi_cpudai->rpmsg_mutex_playback);
+			break;
+		} else if (soc_substream->cmd_val == SND_SOC_DSP_PCM_SUSPEND) {
+			sunxi_cpudai->playing = 0;
+			mutex_unlock(&sunxi_cpudai->rpmsg_mutex_playback);
+			break;
+		}
+		mutex_unlock(&sunxi_cpudai->rpmsg_mutex_playback);
+	}
+}
+
+static void trigger_work_capture_func(struct work_struct *work)
+{
+	struct sunxi_cpudai_info *sunxi_cpudai =
+			container_of(work, struct sunxi_cpudai_info, trigger_work_capture.work);
+	struct msg_substream_package *msg_substream = &sunxi_cpudai->msg_capture;
+	struct snd_soc_dsp_substream *soc_substream = &msg_substream->soc_substream;
+	struct snd_pcm_substream *substream = msg_substream->substream;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	unsigned int pos = 0;
+	int ret = 0;
+
+	for (;;) {
+		pr_debug("[%s] line:%d cmd_val=%d, state=%d\n", __func__, __LINE__,
+			soc_substream->cmd_val,
+			runtime->status->state);
+		mutex_lock(&sunxi_cpudai->rpmsg_mutex_capture);
+		if (soc_substream->cmd_val == SND_SOC_DSP_PCM_READI) {
+			snd_pcm_sframes_t avail;
+			unsigned long delay;
+
+			if (runtime->status->state != SNDRV_PCM_STATE_RUNNING) {
+				dev_err(sunxi_cpudai->cpu_dai->dev,
+					"%s state:%d\n", __func__, runtime->status->state);
+				mutex_unlock(&sunxi_cpudai->rpmsg_mutex_capture);
+				break;
+			}
+			sunxi_cpudai->capturing = 1;
+
+			if (!soc_substream->audio_standby)
+				goto do_readi;
+			avail = snd_pcm_capture_hw_avail(runtime);
+			if (avail > runtime->period_size)
+				goto do_readi;
+			delay = runtime->period_size * 1000 / runtime->rate;
+			if (delay > 10)
+				delay = 10;
+			pr_debug("[%s] line:%d avail = %ld, delay=%lu\n",
+				__func__, __LINE__, avail, delay);
+			queue_delayed_work(sunxi_cpudai->wq_capture,
+				&sunxi_cpudai->trigger_work_capture, delay);
+			mutex_unlock(&sunxi_cpudai->rpmsg_mutex_capture);
+			break;
+do_readi:
+			/* update the capture soc_substream output addr */
+			pos = snd_dmaengine_pcm_pointer_no_residue(substream);
+			soc_substream->output_addr = runtime->dma_addr + frames_to_bytes(runtime, pos);
+			dev_dbg(sunxi_cpudai->cpu_dai->dev,
+				"[%s] dma_addr:0x%x, pos:%u, output_addr:0x%x\n",
+				 __func__, runtime->dma_addr, pos, soc_substream->output_addr);
+			/* send to dsp */
+			ret = sunxi_hifi_cpudai_substream_block_send(SUNXI_HIFI0,
+				substream, sunxi_cpudai->cpu_dai,
+				SNDRV_PCM_STREAM_CAPTURE, MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+			sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+			mutex_unlock(&sunxi_cpudai->rpmsg_mutex_capture);
+
+			/* component */
+			snd_soc_rpaf_pcm_update_stream_process(&sunxi_cpudai->dsp_capcomp);
+
+			if (ret != 0) {
+				dev_err(sunxi_cpudai->cpu_dai->dev,
+					"%s state:%d, ret=%d\n", __func__, runtime->status->state, ret);
+			}
+			if (runtime->status->state == SNDRV_PCM_STATE_RUNNING) {
+				queue_delayed_work(sunxi_cpudai->wq_capture,
+					&sunxi_cpudai->trigger_work_capture, 0);
+			}
+			break;
+		} else if (soc_substream->cmd_val == SND_SOC_DSP_PCM_STOP) {
+			awrpaf_debug("\n");
+			/* send to dsp */
+			sunxi_hifi_cpudai_substream_block_send(SUNXI_HIFI0,
+				substream, sunxi_cpudai->cpu_dai,
+				SNDRV_PCM_STREAM_CAPTURE, MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+			sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+			sunxi_cpudai->capturing = 0;
+			mutex_unlock(&sunxi_cpudai->rpmsg_mutex_capture);
+			break;
+		} else if (soc_substream->cmd_val == SND_SOC_DSP_PCM_SUSPEND) {
+			sunxi_cpudai->capturing = 0;
+			mutex_unlock(&sunxi_cpudai->rpmsg_mutex_capture);
+			break;
+		}
+		mutex_unlock(&sunxi_cpudai->rpmsg_mutex_capture);
+	}
+}
+
+static int sunxi_hifi_cpudai_dev_probe(struct platform_device *pdev)
+{
+	struct sunxi_cpudai_info *sunxi_cpudai;
+	struct device_node *np = pdev->dev.of_node;
+	unsigned int temp_val = 0;
+	int ret;
+
+	sunxi_cpudai = devm_kzalloc(&pdev->dev,
+			sizeof(struct sunxi_cpudai_info), GFP_KERNEL);
+	if (!sunxi_cpudai) {
+		ret = -ENOMEM;
+		goto err_node_put;
+	}
+	dev_set_drvdata(&pdev->dev, sunxi_cpudai);
+	sunxi_cpudai->dev = &pdev->dev;
+
+	ret = snd_soc_register_component(&pdev->dev, &sunxi_hifi_cpudai_component,
+					&sunxi_hifi_cpudai_dai, 1);
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register DAI: %d\n", ret);
+		ret = -EBUSY;
+		goto err_devm_kfree;
+	}
+
+	ret = asoc_hifi_platform_register(&pdev->dev, SUNXI_HIFI_PCM_OPS_CODEC);
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register PCM: %d\n", ret);
+		goto err_unregister_component;
+	}
+
+	ret = of_property_read_u32(np, "playback_cma", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "playback cma kbytes config missing or invalid.\n");
+		sunxi_cpudai->playback_dma_param.cma_kbytes = SUNXI_AUDIO_CMA_MAX_KBYTES;
+	} else {
+		if (temp_val > SUNXI_AUDIO_CMA_MAX_KBYTES)
+			temp_val = SUNXI_AUDIO_CMA_MAX_KBYTES;
+		else if (temp_val < SUNXI_AUDIO_CMA_MIN_KBYTES)
+			temp_val = SUNXI_AUDIO_CMA_MIN_KBYTES;
+		sunxi_cpudai->playback_dma_param.cma_kbytes = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "capture_cma", &temp_val);
+	if (ret != 0) {
+		dev_warn(&pdev->dev, "capture cma kbytes config missing or invalid.\n");
+		sunxi_cpudai->capture_dma_param.cma_kbytes = SUNXI_AUDIO_CMA_MAX_KBYTES;
+	} else {
+		if (temp_val > SUNXI_AUDIO_CMA_MAX_KBYTES)
+			temp_val = SUNXI_AUDIO_CMA_MAX_KBYTES;
+		else if (temp_val < SUNXI_AUDIO_CMA_MIN_KBYTES)
+			temp_val = SUNXI_AUDIO_CMA_MIN_KBYTES;
+		sunxi_cpudai->capture_dma_param.cma_kbytes = temp_val;
+	}
+
+	sunxi_cpudai->playback_dma_param.fifo_size = CODEC_TX_FIFO_SIZE;
+	sunxi_cpudai->capture_dma_param.fifo_size = CODEC_RX_FIFO_SIZE;
+
+	/* for hifi dsp param init config */
+	/* eg:0 sndcodec; 1 snddmic; 2 snddaudio0; */
+	ret = of_property_read_u32(np, "dsp_card", &temp_val);
+	if (ret < 0)
+		sunxi_cpudai->dsp_card = 0;
+	else
+		sunxi_cpudai->dsp_card = temp_val;
+
+	/* default is 0, for reserved */
+	ret = of_property_read_u32(np, "dsp_device", &temp_val);
+	if (ret < 0)
+		sunxi_cpudai->dsp_device = 0;
+	else
+		sunxi_cpudai->dsp_device = temp_val;
+
+	mutex_init(&sunxi_cpudai->rpmsg_mutex_playback);
+	mutex_init(&sunxi_cpudai->rpmsg_mutex_capture);
+
+	snprintf(sunxi_cpudai->wq_capture_name, sizeof(sunxi_cpudai->wq_capture_name),
+			"hifi-codec-capture");
+	sunxi_cpudai->wq_capture = create_workqueue(sunxi_cpudai->wq_capture_name);
+	if (IS_ERR_OR_NULL(sunxi_cpudai->wq_capture)) {
+		ret = -ENOMEM;
+		goto err_create_wq_capture;
+	}
+	INIT_DELAYED_WORK(&sunxi_cpudai->trigger_work_capture, trigger_work_capture_func);
+	snprintf(sunxi_cpudai->wq_playback_name, sizeof(sunxi_cpudai->wq_playback_name),
+			"hifi-codec-playback");
+	sunxi_cpudai->wq_playback = create_workqueue(sunxi_cpudai->wq_playback_name);
+	if (IS_ERR_OR_NULL(sunxi_cpudai->wq_playback)) {
+		ret = -ENOMEM;
+		goto err_create_wq_playback;
+	}
+	INIT_DELAYED_WORK(&sunxi_cpudai->trigger_work_playback, trigger_work_playback_func);
+
+	return 0;
+
+err_create_wq_playback:
+	mutex_destroy(&sunxi_cpudai->rpmsg_mutex_capture);
+err_create_wq_capture:
+err_unregister_component:
+	snd_soc_unregister_component(&pdev->dev);
+err_devm_kfree:
+	devm_kfree(&pdev->dev, sunxi_cpudai);
+err_node_put:
+	of_node_put(np);
+	return ret;
+}
+
+static int __exit sunxi_hifi_cpudai_dev_remove(struct platform_device *pdev)
+{
+	struct sunxi_cpudai_info *sunxi_cpudai = dev_get_drvdata(&pdev->dev);
+
+	mutex_destroy(&sunxi_cpudai->rpmsg_mutex_playback);
+	mutex_destroy(&sunxi_cpudai->rpmsg_mutex_capture);
+
+	snd_soc_unregister_component(&pdev->dev);
+	devm_kfree(&pdev->dev, sunxi_cpudai);
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+static struct platform_driver sunxi_hifi_cpudai_driver = {
+	.driver = {
+		.name = DRV_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_hifi_cpudai_of_match,
+	},
+	.probe = sunxi_hifi_cpudai_dev_probe,
+	.remove = __exit_p(sunxi_hifi_cpudai_dev_remove),
+};
+module_platform_driver(sunxi_hifi_cpudai_driver);
+
+MODULE_AUTHOR("yumingfeng <yumingfeng@allwinnertech.com>");
+MODULE_DESCRIPTION("SUNXI cpudai ASoC HiFi Interface");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:sunxi-dummy-cpudai");
diff --git a/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-cpudai.h b/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-cpudai.h
new file mode 100644
index 000000000..e40aa1132
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-cpudai.h
@@ -0,0 +1,54 @@
+/*
+ * sound\soc\sunxi\hifi-dsp\sunxi-cpudai.h
+ *
+ * (C) Copyright 2019-2025
+ * allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * yumingfeng <yumingfeng@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#ifndef _SUNXI_CPUDAI_H
+#define _SUNXI_CPUDAI_H
+
+#include "sunxi-hifi-pcm.h"
+
+struct sunxi_cpudai_info {
+	struct device *dev;
+	struct snd_soc_dai *cpu_dai;
+	struct sunxi_dma_params playback_dma_param;
+	struct sunxi_dma_params capture_dma_param;
+
+	/* for hifi */
+	unsigned int capturing;
+	unsigned int playing;
+	char wq_capture_name[32];
+	struct mutex rpmsg_mutex_capture;
+	struct workqueue_struct *wq_capture;
+	struct delayed_work trigger_work_capture;
+	char wq_playback_name[32];
+	struct mutex rpmsg_mutex_playback;
+	struct workqueue_struct *wq_playback;
+	struct delayed_work trigger_work_playback;
+
+	struct msg_substream_package msg_playback;
+	struct msg_substream_package msg_capture;
+
+	/* init for mixer move to codec driver */
+	//struct msg_mixer_package msg_mixer;
+	struct msg_debug_package msg_debug;
+	struct snd_dsp_component dsp_playcomp;
+	struct snd_dsp_component dsp_capcomp;
+
+	/* eg:0 sndcodec; 1 snddmic; 2 snddaudio0; */
+	unsigned int dsp_card;
+	/* default is 0, for reserved */
+	unsigned int dsp_device;
+};
+
+#endif
diff --git a/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-daudio.c b/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-daudio.c
new file mode 100644
index 000000000..3d23d4bcf
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-daudio.c
@@ -0,0 +1,1451 @@
+/* sound\soc\sunxi\hifi-dsp\sunxi-daudio.c
+ *
+ * (C) Copyright 2019-2025
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * yumingfeng <yumingfeng@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/clk.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/regmap.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/regulator/consumer.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+#include <linux/delay.h>
+#include <linux/debugfs.h>
+#include <linux/dma-mapping.h>
+#include <asm/cacheflush.h>
+
+#include <sound/aw_rpaf/rpmsg_hifi.h>
+#include <sound/aw_rpaf/component-core.h>
+#include "../../../../core/pcm_local.h"
+#include "sunxi-hifi-daudio.h"
+
+#define	DRV_NAME	"sunxi-hifi-daudio"
+
+#define	SUNXI_DAUDIO_RATES	(SNDRV_PCM_RATE_8000_48000)
+
+#define	SUNXI_DAUDIO_EXTERNAL_TYPE	1
+
+static long playback_component_type;
+module_param(playback_component_type, long, 0644);
+MODULE_PARM_DESC(playback_component_type, "playback component type for dump");
+
+static long capture_component_type;
+module_param(capture_component_type, long, 0644);
+MODULE_PARM_DESC(capture_component_type, "capture component type for dump");
+
+#ifdef CONFIG_SND_SUNXI_HIFI_DAUDIO_DEBUG
+static struct daudio_reg_label reg_labels[] = {
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_CTL),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_FMT0),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_FMT1),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_INTSTA),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_FIFOCTL),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_FIFOSTA),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_INTCTL),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_CLKDIV),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_TXCNT),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_RXCNT),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_CHCFG),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_TX0CHSEL),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_TX1CHSEL),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_TX2CHSEL),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_TX3CHSEL),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_TX0CHMAP0),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_TX0CHMAP1),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_TX1CHMAP0),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_TX1CHMAP1),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_TX2CHMAP0),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_TX2CHMAP1),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_TX3CHMAP0),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_TX3CHMAP1),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_RXCHSEL),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_RXCHMAP0),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_RXCHMAP1),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_RXCHMAP2),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_RXCHMAP3),
+	DAUDIO_REG_LABEL(SUNXI_DAUDIO_DEBUG),
+	DAUDIO_REG_LABEL_END,
+};
+
+static ssize_t show_daudio_reg(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct sunxi_daudio_info *sunxi_daudio = dev_get_drvdata(dev);
+	struct sunxi_daudio_dts_info *dts_info = NULL;
+	struct sunxi_daudio_mem_info *mem_info = NULL;
+	unsigned int res_size = 0;
+	int count = 0;
+	unsigned int reg_val;
+	int ret = 0;
+	int i = 0;
+
+	if (IS_ERR_OR_NULL(sunxi_daudio)) {
+		dev_err(dev, "sunxi_daudio is NULL!\n");
+		return count;
+	}
+	dts_info = &sunxi_daudio->dts_info;
+	mem_info = &dts_info->mem_info;
+	res_size = resource_size(&mem_info->res);
+
+	count = snprintf(buf, PAGE_SIZE, "Dump daudio reg:\n");
+	if (count > 0) {
+		ret += count;
+	} else {
+		dev_err(dev, "snprintf start error=%d.\n", count);
+		return 0;
+	}
+
+	while ((reg_labels[i].name != NULL) &&
+		(reg_labels[i].address <= res_size)) {
+		regmap_read(mem_info->regmap, reg_labels[i].address, &reg_val);
+		count = snprintf(buf + ret, PAGE_SIZE - ret,
+			"%-23s[0x%02X]: 0x%08X\n",
+			reg_labels[i].name,
+			(reg_labels[i].address), reg_val);
+		if (count > 0) {
+			ret += count;
+		} else {
+			dev_err(dev, "snprintf [i=%d] error=%d.\n", i, count);
+			break;
+		}
+		if (ret > PAGE_SIZE) {
+			ret = PAGE_SIZE;
+			break;
+		}
+		i++;
+	}
+
+	return ret;
+}
+
+/* ex:
+ *param 1: 0 read;1 write
+ *param 2: reg value;
+ *param 3: write value;
+	read:
+		echo 0,0x0 > daudio_reg
+	write:
+		echo 1,0x00,0xa > daudio_reg
+*/
+static ssize_t store_daudio_reg(struct device *dev, struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	int ret;
+	int rw_flag;
+	int reg_val_read;
+	unsigned int input_reg_val = 0;
+	unsigned int input_reg_offset = 0;
+	struct sunxi_daudio_info *sunxi_daudio = dev_get_drvdata(dev);
+	struct sunxi_daudio_dts_info *dts_info = NULL;
+	struct sunxi_daudio_mem_info *mem_info = NULL;
+	unsigned int res_size = 0;
+
+	if (IS_ERR_OR_NULL(sunxi_daudio)) {
+		dev_err(dev, "sunxi_daudio is NULL!\n");
+		return count;
+	}
+	dts_info = &sunxi_daudio->dts_info;
+	mem_info = &dts_info->mem_info;
+	res_size = resource_size(&mem_info->res),
+
+	ret = sscanf(buf, "%d,0x%x,0x%x", &rw_flag, &input_reg_offset,
+			&input_reg_val);
+
+	if (ret == 3 || ret == 2) {
+		if (!(rw_flag == 1 || rw_flag == 0)) {
+			dev_err(dev, "rw_flag should be 0(read) or 1(write).\n");
+			return count;
+		}
+		if (input_reg_offset > res_size) {
+			dev_err(dev, "the reg offset is invalid! [0x0 - 0x%x]\n",
+				res_size);
+			return count;
+		}
+		if (rw_flag) {
+			regmap_write(mem_info->regmap, input_reg_offset,
+					input_reg_val);
+		}
+		regmap_read(mem_info->regmap, input_reg_offset, &reg_val_read);
+		pr_err("\n\n Reg[0x%x] : 0x%x\n\n", input_reg_offset, reg_val_read);
+	} else {
+		pr_err("ret:%d, The num of params invalid!\n", ret);
+		pr_err("\nExample(reg range: 0x0 - 0x%x):\n", res_size);
+		pr_err("\nRead reg[0x04]:\n");
+		pr_err("      echo 0,0x04 > daudio_reg\n");
+		pr_err("Write reg[0x04]=0x10\n");
+		pr_err("      echo 1,0x04,0x10 > daudio_reg\n");
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(daudio_reg, 0644, show_daudio_reg, store_daudio_reg);
+
+static struct attribute *audio_debug_attrs[] = {
+	&dev_attr_daudio_reg.attr,
+	NULL,
+};
+
+static struct attribute_group daudio_debug_attr_group = {
+	.name	= "daudio_debug",
+	.attrs	= audio_debug_attrs,
+};
+#endif
+
+/* dts pcm Audio Mode Select */
+static const struct snd_kcontrol_new sunxi_hifi_daudio_controls[] = {
+	SOC_SINGLE("sunxi daudio loopback debug", SUNXI_DAUDIO_CTL,
+		LOOP_EN, 1, 0),
+};
+
+static int sunxi_hifi_daudio_init(struct sunxi_daudio_info *sunxi_daudio,
+					struct snd_soc_dai *dai)
+{
+	struct sunxi_daudio_dts_info *dts_info = &sunxi_daudio->dts_info;
+	struct sunxi_daudio_platform_data *pdata_info = &dts_info->pdata_info;
+	struct msg_substream_package *msg_playback = &sunxi_daudio->msg_playback;
+	struct msg_substream_package *msg_capture = &sunxi_daudio->msg_capture;
+	struct msg_mixer_package *msg_mixer = &sunxi_daudio->msg_mixer;
+//	struct snd_soc_dsp_mixer *soc_mixer = &msg_mixer->soc_mixer;
+	struct msg_debug_package *msg_debug = &sunxi_daudio->msg_debug;
+//	struct snd_soc_dsp_debug *soc_debug = &msg_debug->soc_debug;
+	struct snd_dsp_component *dsp_component;
+	struct msg_component_package *msg_component;
+//	struct snd_soc_dsp_component *soc_component;
+	struct snd_soc_dsp_substream *soc_substream;
+	struct snd_soc_dsp_pcm_params *pcm_params;
+	int ret = 0;
+
+	sunxi_daudio->cpu_dai = dai;
+
+	if (sunxi_daudio->playback_dma_param.cma_kbytes != 0) {
+		/* init for playback */
+		init_waitqueue_head(&msg_playback->tsleep);
+		spin_lock_init(&msg_playback->lock);
+		msg_playback->wakeup_flag = 0;
+		soc_substream = &msg_playback->soc_substream;
+		pcm_params = &soc_substream->params;
+		/* 1:capture; 0:playback */
+		pcm_params->stream = SND_STREAM_PLAYBACK;
+		pcm_params->card = pdata_info->dsp_card;
+		pcm_params->device = pdata_info->dsp_device;
+		/*
+		 * (delete: hw:):
+		 * 0: hw:audiocodec;
+		 * 1: hw:snddmic;
+		 * 2: hw:snddaudio0;
+		 */
+		snprintf(pcm_params->driver, 31, "snddaudio%d", pdata_info->dsp_daudio);
+		/* dma buffer alloc */
+		sunxi_dma_params_alloc_dma_area(dai, &sunxi_daudio->playback_dma_param);
+		if (!sunxi_daudio->playback_dma_param.dma_area) {
+			dev_err(dai->dev, "playback dmaengine alloc coherent failed.\n");
+			ret = -ENOMEM;
+			goto err_dma_alloc_playback;
+		}
+
+		/* init for playback component */
+		dsp_component = &sunxi_daudio->dsp_playcomp;
+		msg_component = &dsp_component->msg_component;
+		init_waitqueue_head(&msg_component->tsleep);
+		spin_lock_init(&msg_component->lock);
+		msg_component->wakeup_flag = 0;
+	}
+
+	if (sunxi_daudio->capture_dma_param.cma_kbytes != 0) {
+		/* init for capture */
+		init_waitqueue_head(&msg_capture->tsleep);
+		spin_lock_init(&msg_capture->lock);
+		msg_capture->wakeup_flag = 0;
+		soc_substream = &msg_capture->soc_substream;
+		pcm_params = &soc_substream->params;
+		pcm_params->stream = SND_STREAM_CAPTURE;
+		pcm_params->card = pdata_info->dsp_card;
+		pcm_params->device = pdata_info->dsp_device;
+		snprintf(pcm_params->driver, 31, "snddaudio%d", pdata_info->dsp_daudio);
+		/* dma buffer alloc */
+		sunxi_dma_params_alloc_dma_area(dai, &sunxi_daudio->capture_dma_param);
+		if (!sunxi_daudio->capture_dma_param.dma_area) {
+			dev_err(dai->dev, "capture dmaengine alloc coherent failed.\n");
+			ret = -ENOMEM;
+			goto err_dma_alloc_capture;
+		}
+
+		/* init for capture component */
+		dsp_component = &sunxi_daudio->dsp_capcomp;
+		msg_component = &dsp_component->msg_component;
+		init_waitqueue_head(&msg_component->tsleep);
+		spin_lock_init(&msg_component->lock);
+		msg_component->wakeup_flag = 0;
+
+		/* init for mixer */
+		init_waitqueue_head(&msg_mixer->tsleep);
+		spin_lock_init(&msg_mixer->lock);
+		msg_mixer->wakeup_flag = 0;
+
+		/* init for debug */
+		init_waitqueue_head(&msg_debug->tsleep);
+		spin_lock_init(&msg_debug->lock);
+		msg_debug->wakeup_flag = 0;
+	}
+
+	/* register sunxi_daudio_info to rpmsg_hifi driver */
+	sunxi_hifi_register_sound_drv_info(pcm_params->driver, sunxi_daudio);
+
+	/* pdata_info */
+	return 0;
+
+err_dma_alloc_capture:
+	sunxi_dma_params_free_dma_area(dai, &sunxi_daudio->playback_dma_param);
+err_dma_alloc_playback:
+	return ret;
+}
+
+static int sunxi_hifi_daudio_uninit(struct sunxi_daudio_info *sunxi_daudio,
+					struct snd_soc_dai *dai)
+{
+	struct msg_substream_package *msg_substream;
+	struct snd_soc_dsp_substream *soc_substream;
+
+	sunxi_dma_params_free_dma_area(dai, &sunxi_daudio->playback_dma_param);
+	sunxi_dma_params_free_dma_area(dai, &sunxi_daudio->capture_dma_param);
+
+	msg_substream = &sunxi_daudio->msg_playback;
+	soc_substream = &msg_substream->soc_substream;
+	/* for unregister sunxi_daudio_info from rpmsg_hifi driver */
+	sunxi_hifi_unregister_sound_drv_info(soc_substream->params.driver, sunxi_daudio);
+
+	return 0;
+}
+
+static int sunxi_hifi_daudio_dai_startup(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	struct sunxi_daudio_info *sunxi_daudio = snd_soc_dai_get_drvdata(dai);
+	struct msg_substream_package *msg_substream;
+	struct snd_soc_dsp_substream *soc_substream;
+	struct mutex *rpmsg_mutex;
+	int ret = 0;
+
+	if (IS_ERR_OR_NULL(sunxi_daudio)) {
+		dev_err(dai->dev, "[%s] sunxi_daudio is NULL!\n", __func__);
+		return -ENOMEM;
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		snd_soc_dai_set_dma_data(dai, substream,
+					&sunxi_daudio->playback_dma_param);
+		msg_substream = &sunxi_daudio->msg_playback;
+		rpmsg_mutex = &sunxi_daudio->rpmsg_mutex_playback;
+		sunxi_daudio->playing = 0;
+		soc_substream = &msg_substream->soc_substream;
+		soc_substream->output_addr = sunxi_daudio->playback_dma_param.phy_addr;
+		dev_dbg(dai->dev, "coherent phy_addr:0x%x\n", soc_substream->output_addr);
+	} else {
+		snd_soc_dai_set_dma_data(dai, substream,
+					&sunxi_daudio->capture_dma_param);
+		msg_substream = &sunxi_daudio->msg_capture;
+		rpmsg_mutex = &sunxi_daudio->rpmsg_mutex_capture;
+		sunxi_daudio->capturing = 0;
+		soc_substream = &msg_substream->soc_substream;
+		soc_substream->input_addr = sunxi_daudio->capture_dma_param.phy_addr;
+		dev_dbg(dai->dev, "coherent phy_addr:0x%x\n", soc_substream->input_addr);
+	}
+	msg_substream->substream = substream;
+
+	/* msgbox to dsp */
+	mutex_lock(rpmsg_mutex);
+	awrpaf_debug("\n");
+	soc_substream->cmd_val = SND_SOC_DSP_PCM_STARTUP;
+	ret = sunxi_hifi_daudio_substream_block_send(SUNXI_HIFI0, substream, dai,
+						substream->stream, MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+	sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+	mutex_unlock(rpmsg_mutex);
+	if (ret < 0) {
+		dev_err(dai->dev, "cpudai send failed.\n");
+		soc_substream->cmd_val = SND_SOC_DSP_PCM_SHUTDOWN;
+		sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+		sunxi_hifi_daudio_substream_block_send(SUNXI_HIFI0, substream, dai,
+						substream->stream, MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+		return ret;
+	}
+	return soc_substream->ret_val;
+}
+
+static int sunxi_hifi_daudio_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct sunxi_daudio_info *sunxi_daudio = snd_soc_dai_get_drvdata(dai);
+	struct msg_substream_package *msg_substream;
+	struct snd_soc_dsp_substream *soc_substream;
+	struct snd_soc_dsp_pcm_params *pcm_params;
+	struct sunxi_daudio_dts_info *dts_info = NULL;
+	struct sunxi_daudio_mem_info *mem_info = NULL;
+	struct sunxi_daudio_platform_data *pdata_info = NULL;
+	unsigned int frame_bytes;
+	unsigned int sample_bits;
+	struct mutex *rpmsg_mutex;
+	int ret = 0;
+
+	if (IS_ERR_OR_NULL(sunxi_daudio)) {
+		dev_err(dai->dev, "[%s] sunxi_daudio is null.\n", __func__);
+		return -ENOMEM;
+	}
+	dts_info = &sunxi_daudio->dts_info;
+	mem_info = &dts_info->mem_info;
+	pdata_info = &dts_info->pdata_info;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		msg_substream = &sunxi_daudio->msg_playback;
+		rpmsg_mutex = &sunxi_daudio->rpmsg_mutex_playback;
+	} else {
+		msg_substream = &sunxi_daudio->msg_capture;
+		rpmsg_mutex = &sunxi_daudio->rpmsg_mutex_capture;
+	}
+	soc_substream = &msg_substream->soc_substream;
+
+	mutex_lock(rpmsg_mutex);
+	pcm_params = &soc_substream->params;
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		pcm_params->format = SND_PCM_FORMAT_S16_LE;
+		sample_bits = 16;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		pcm_params->format = SND_PCM_FORMAT_S24_LE;
+		sample_bits = 32;
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		pcm_params->format = SND_PCM_FORMAT_S32_LE;
+		sample_bits = 32;
+		break;
+	default:
+		mutex_unlock(rpmsg_mutex);
+		dev_err(sunxi_daudio->dev, "unrecognized format\n");
+		return -EINVAL;
+	}
+	pcm_params->channels = params_channels(params);
+	pcm_params->rate = params_rate(params);
+	pcm_params->period_size = params_period_size(params);
+	pcm_params->periods = params_periods(params);
+	pcm_params->pcm_frames = pcm_params->period_size;
+	/* buffer,  */
+	pcm_params->buffer_size = params_buffer_size(params);
+	frame_bytes = pcm_params->channels * sample_bits / 8;
+
+	dev_info(sunxi_daudio->dev, "======== hw_params ========\n");
+	dev_info(sunxi_daudio->dev, "pcm_params->format:%u\n", pcm_params->format);
+	dev_info(sunxi_daudio->dev, "pcm_params->channels:%u\n", pcm_params->channels);
+	dev_info(sunxi_daudio->dev, "pcm_params->rate:%u\n", pcm_params->rate);
+	dev_info(sunxi_daudio->dev, "pcm_params->period_size:%u\n", pcm_params->period_size);
+	dev_info(sunxi_daudio->dev, "pcm_params->periods:%u\n", pcm_params->periods);
+	dev_info(sunxi_daudio->dev, "pcm_params->pcm_frames:%u\n", pcm_params->pcm_frames);
+	dev_info(sunxi_daudio->dev, "pcm_params->buffer_size:%u\n", pcm_params->buffer_size);
+	dev_info(sunxi_daudio->dev, "===========================\n");
+	soc_substream->input_size = pcm_params->period_size * frame_bytes;
+	soc_substream->output_size = pcm_params->period_size * frame_bytes;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		struct snd_dsp_component *dsp_component = &sunxi_daudio->dsp_playcomp;
+		struct msg_component_package *msg_component = &dsp_component->msg_component;
+		struct snd_soc_dsp_component *soc_component = &msg_component->soc_component;
+
+		soc_component->component_type = playback_component_type;
+
+		ret = sunxi_hifi_substream_set_stream_component(SUNXI_HIFI0,
+				dai, soc_substream, dsp_component);
+		if (ret < 0) {
+			dev_err(dai->dev, "set stream component send failed.\n");
+			return ret;
+		}
+	} else {
+		struct snd_dsp_component *dsp_component = &sunxi_daudio->dsp_capcomp;
+		struct msg_component_package *msg_component = &dsp_component->msg_component;
+		struct snd_soc_dsp_component *soc_component = &msg_component->soc_component;
+
+		soc_component->component_type = capture_component_type;
+
+		ret = sunxi_hifi_substream_set_stream_component(SUNXI_HIFI0,
+				dai, soc_substream, dsp_component);
+		if (ret < 0) {
+			dev_err(dai->dev, "set stream component send failed.\n");
+			return ret;
+		}
+	}
+
+	/* msgbox to dsp */
+	soc_substream->cmd_val = SND_SOC_DSP_PCM_HW_PARAMS;
+	awrpaf_debug("\n");
+	ret = sunxi_hifi_daudio_substream_block_send(SUNXI_HIFI0, substream, dai,
+						substream->stream, MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+	sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+	mutex_unlock(rpmsg_mutex);
+	if (ret < 0) {
+		dev_err(dai->dev, "cpudai send failed.\n");
+		return ret;
+	}
+	return soc_substream->ret_val;
+}
+
+static int sunxi_hifi_daudio_prepare(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	struct sunxi_daudio_info *sunxi_daudio = snd_soc_dai_get_drvdata(dai);
+	struct msg_substream_package *msg_substream;
+	struct snd_soc_dsp_substream *soc_substream;
+	struct mutex *rpmsg_mutex;
+	int ret = 0;
+
+	if (IS_ERR_OR_NULL(sunxi_daudio)) {
+		dev_err(dai->dev, "[%s] sunxi_daudio is null.\n", __func__);
+		return -ENOMEM;
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		msg_substream = &sunxi_daudio->msg_playback;
+		rpmsg_mutex = &sunxi_daudio->rpmsg_mutex_playback;
+		/* wait for stop playback */
+		while (sunxi_daudio->playing)
+			msleep(20);
+	} else {
+		msg_substream = &sunxi_daudio->msg_capture;
+		rpmsg_mutex = &sunxi_daudio->rpmsg_mutex_capture;
+		/* wait for stop capture */
+		while (sunxi_daudio->capturing)
+			msleep(20);
+	}
+	soc_substream = &msg_substream->soc_substream;
+
+	/* msgbox to dsp */
+	mutex_lock(rpmsg_mutex);
+	awrpaf_debug("\n");
+	soc_substream->cmd_val = SND_SOC_DSP_PCM_PREPARE;
+	ret = sunxi_hifi_daudio_substream_block_send(SUNXI_HIFI0, substream, dai,
+						substream->stream, MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+	sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+	mutex_unlock(rpmsg_mutex);
+	if (ret < 0) {
+		dev_err(dai->dev, "cpudai send failed.\n");
+		return ret;
+	}
+	return soc_substream->ret_val;
+}
+
+static int sunxi_hifi_daudio_trigger(struct snd_pcm_substream *substream,
+				int cmd, struct snd_soc_dai *dai)
+{
+	struct sunxi_daudio_info *sunxi_daudio = snd_soc_dai_get_drvdata(dai);
+	struct msg_substream_package *msg_substream;
+	struct snd_soc_dsp_substream *soc_substream;
+	struct work_struct *trigger_work;
+	struct workqueue_struct *wq_pcm;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			msg_substream = &sunxi_daudio->msg_playback;
+			soc_substream = &msg_substream->soc_substream;
+			soc_substream->cmd_val = SND_SOC_DSP_PCM_WRITEI;
+			trigger_work = &sunxi_daudio->trigger_work_playback;
+			wq_pcm = sunxi_daudio->wq_playback;
+		} else {
+			msg_substream = &sunxi_daudio->msg_capture;
+			soc_substream = &msg_substream->soc_substream;
+			soc_substream->cmd_val = SND_SOC_DSP_PCM_READI;
+			trigger_work = &sunxi_daudio->trigger_work_capture;
+			wq_pcm = sunxi_daudio->wq_capture;
+		}
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if ((substream->stream == SNDRV_PCM_STREAM_PLAYBACK) &&
+			(substream->runtime->status->state == SNDRV_PCM_STATE_DRAINING)) {
+			dev_info(dai->dev, "drain stopping\n");
+			return 0;
+		}
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			msg_substream = &sunxi_daudio->msg_playback;
+			trigger_work = &sunxi_daudio->trigger_work_playback;
+			wq_pcm = sunxi_daudio->wq_playback;
+		} else {
+			msg_substream = &sunxi_daudio->msg_capture;
+			trigger_work = &sunxi_daudio->trigger_work_capture;
+			wq_pcm = sunxi_daudio->wq_capture;
+		}
+		soc_substream = &msg_substream->soc_substream;
+		soc_substream->cmd_val = SND_SOC_DSP_PCM_STOP;
+		break;
+	case SNDRV_PCM_TRIGGER_DRAIN:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			msg_substream = &sunxi_daudio->msg_playback;
+			trigger_work = &sunxi_daudio->trigger_work_playback;
+			wq_pcm = sunxi_daudio->wq_playback;
+			soc_substream = &msg_substream->soc_substream;
+			soc_substream->cmd_val = SND_SOC_DSP_PCM_DRAIN;
+			dev_info(dai->dev, "drain starting\n");
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+	queue_work(wq_pcm, trigger_work);
+
+	return 0;
+}
+
+static void sunxi_hifi_daudio_shutdown(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	struct sunxi_daudio_info *sunxi_daudio = snd_soc_dai_get_drvdata(dai);
+	struct msg_substream_package *msg_substream;
+	struct snd_soc_dsp_substream *soc_substream;
+	struct snd_dsp_component *dsp_component;
+	struct mutex *rpmsg_mutex;
+	unsigned int *work_running;
+	int i = 0;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		msg_substream = &sunxi_daudio->msg_playback;
+		rpmsg_mutex = &sunxi_daudio->rpmsg_mutex_playback;
+		work_running = &sunxi_daudio->playing;
+	} else {
+		msg_substream = &sunxi_daudio->msg_capture;
+		rpmsg_mutex = &sunxi_daudio->rpmsg_mutex_capture;
+		work_running = &sunxi_daudio->capturing;
+	}
+	soc_substream = &msg_substream->soc_substream;
+
+	awrpaf_debug("\n");
+	for (i = 0; i < 50; i++) {
+		if (*work_running == 0)
+			break;
+		msleep(20);
+	}
+	awrpaf_debug("\n");
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		dsp_component = &sunxi_daudio->dsp_playcomp;
+	else
+		dsp_component = &sunxi_daudio->dsp_capcomp;
+
+	sunxi_hifi_substream_release_stream_component(dai, dsp_component);
+
+	/* msgbox to dsp */
+	mutex_lock(rpmsg_mutex);
+	soc_substream->cmd_val = SND_SOC_DSP_PCM_SHUTDOWN;
+	sunxi_hifi_daudio_substream_block_send(SUNXI_HIFI0, substream, dai,
+						substream->stream, MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+	sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+	mutex_unlock(rpmsg_mutex);
+
+	msg_substream->substream = NULL;
+}
+
+static struct snd_soc_dai_ops sunxi_hifi_daudio_dai_ops = {
+	.startup = sunxi_hifi_daudio_dai_startup,
+	.hw_params = sunxi_hifi_daudio_hw_params,
+	.prepare = sunxi_hifi_daudio_prepare,
+	.trigger = sunxi_hifi_daudio_trigger,
+	.shutdown = sunxi_hifi_daudio_shutdown,
+};
+
+static int sunxi_hifi_daudio_probe(struct snd_soc_dai *dai)
+{
+	struct sunxi_daudio_info *sunxi_daudio = snd_soc_dai_get_drvdata(dai);
+	struct msg_substream_package *msg_capture = &sunxi_daudio->msg_capture;
+	struct msg_substream_package *msg_playback = &sunxi_daudio->msg_playback;
+	struct snd_soc_dsp_substream *soc_substream;
+	int ret = 0;
+
+	/* pcm_new will using the dma_param about the cma and fifo params. */
+	snd_soc_dai_init_dma_data(dai, &sunxi_daudio->playback_dma_param,
+				&sunxi_daudio->capture_dma_param);
+
+	sunxi_hifi_daudio_init(sunxi_daudio, dai);
+
+	dev_info(dai->dev, "%s start.\n", __func__);
+	/* msgbox to dsp */
+
+	if (sunxi_daudio->playback_dma_param.cma_kbytes != 0) {
+		/* for playback */
+		soc_substream = &msg_playback->soc_substream;
+		soc_substream->cmd_val = SND_SOC_DSP_PCM_PROBE;
+		ret = sunxi_hifi_daudio_substream_block_send(SUNXI_HIFI0, NULL, dai,
+								SNDRV_PCM_STREAM_PLAYBACK,
+								MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+		sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+		if (ret < 0) {
+			dev_err(dai->dev, "%s probe playback failed.\n", __func__);
+			goto err_probe_playback;
+		} else if (soc_substream->ret_val < 0) {
+			dev_err(dai->dev, "%s probe playback dsp failed.\n", __func__);
+			ret = soc_substream->ret_val;
+			goto err_probe_playback;
+		}
+	}
+
+	dev_info(dai->dev, "process.\n");
+
+	if (sunxi_daudio->capture_dma_param.cma_kbytes != 0) {
+		/* for capture */
+		soc_substream = &msg_capture->soc_substream;
+		soc_substream->cmd_val = SND_SOC_DSP_PCM_PROBE;
+		ret = sunxi_hifi_daudio_substream_block_send(SUNXI_HIFI0, NULL, dai,
+								SNDRV_PCM_STREAM_CAPTURE,
+								MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+		sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+		if (ret < 0) {
+			dev_err(dai->dev, "%s probe capture failed.\n", __func__);
+			goto err_probe_capture;
+		} else if (soc_substream->ret_val < 0) {
+			dev_err(dai->dev, "%s probe capture dsp failed.\n", __func__);
+			ret = soc_substream->ret_val;
+			goto err_probe_capture;
+		}
+	}
+	dev_info(dai->dev, "%s stop.\n", __func__);
+	return soc_substream->ret_val;
+
+err_probe_capture:
+err_probe_playback:
+	sunxi_hifi_daudio_uninit(sunxi_daudio, dai);
+	return ret;
+}
+
+static int sunxi_hifi_daudio_remove(struct snd_soc_dai *dai)
+{
+	struct sunxi_daudio_info *sunxi_daudio = snd_soc_dai_get_drvdata(dai);
+	struct msg_substream_package *msg_capture = &sunxi_daudio->msg_capture;
+	struct msg_substream_package *msg_playback = &sunxi_daudio->msg_playback;
+	struct snd_soc_dsp_substream *soc_substream;
+	int ret = 0;
+
+	dev_info(dai->dev, "%s start.\n", __func__);
+	/* for playback */
+	soc_substream = &msg_playback->soc_substream;
+	soc_substream->cmd_val = SND_SOC_DSP_PCM_REMOVE;
+	ret = sunxi_hifi_daudio_substream_block_send(SUNXI_HIFI0, NULL, dai,
+							SNDRV_PCM_STREAM_PLAYBACK,
+							MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+	if (ret < 0)
+		dev_err(dai->dev, "remove send for playback failed.\n");
+
+	/* for capture */
+	soc_substream = &msg_capture->soc_substream;
+	soc_substream->cmd_val = SND_SOC_DSP_PCM_REMOVE;
+	ret = sunxi_hifi_daudio_substream_block_send(SUNXI_HIFI0, NULL, dai,
+							SNDRV_PCM_STREAM_CAPTURE,
+							MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+	if (ret < 0)
+		dev_err(dai->dev, "remove send for capture failed.\n");
+
+	sunxi_hifi_daudio_uninit(sunxi_daudio, dai);
+
+	dev_info(dai->dev, "%s stop.\n", __func__);
+	return ret;
+}
+
+static int sunxi_hifi_daudio_suspend(struct snd_soc_dai *dai)
+{
+	struct sunxi_daudio_info *sunxi_daudio = snd_soc_dai_get_drvdata(dai);
+	struct msg_substream_package *msg_capture = &sunxi_daudio->msg_capture;
+	struct snd_soc_dsp_substream *soc_substream = &msg_capture->soc_substream;
+
+	pr_debug("[daudio] suspend .%s start\n", dev_name(sunxi_daudio->dev));
+
+	/* only for capture */
+	soc_substream->cmd_val = SND_SOC_DSP_PCM_SUSPEND;
+	sunxi_hifi_daudio_substream_block_send(SUNXI_HIFI0, NULL, dai,
+							SNDRV_PCM_STREAM_CAPTURE,
+							MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+	sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+
+	pr_debug("[daudio] suspend .%s end \n", dev_name(sunxi_daudio->dev));
+	return 0;
+}
+
+static int sunxi_hifi_daudio_resume(struct snd_soc_dai *dai)
+{
+	struct sunxi_daudio_info *sunxi_daudio = snd_soc_dai_get_drvdata(dai);
+	struct msg_substream_package *msg_capture = &sunxi_daudio->msg_capture;
+	struct snd_soc_dsp_substream *soc_substream = &msg_capture->soc_substream;
+
+	pr_debug("[%s] resume .%s start\n", __func__,
+			dev_name(sunxi_daudio->dev));
+
+	/* only for capture */
+	soc_substream->cmd_val = SND_SOC_DSP_PCM_RESUME;
+	sunxi_hifi_daudio_substream_block_send(SUNXI_HIFI0, NULL, dai,
+							SNDRV_PCM_STREAM_CAPTURE,
+							MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+	sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+	pr_debug("[%s] resume .%s end\n", __func__,
+			dev_name(sunxi_daudio->dev));
+
+	return 0;
+}
+
+static struct snd_soc_dai_driver sunxi_hifi_daudio_dai = {
+	.probe = sunxi_hifi_daudio_probe,
+	.suspend = sunxi_hifi_daudio_suspend,
+	.resume = sunxi_hifi_daudio_resume,
+	.remove = sunxi_hifi_daudio_remove,
+	.playback = {
+		.channels_min = 1,
+		.channels_max = 8,
+		.rates = SUNXI_DAUDIO_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE
+			| SNDRV_PCM_FMTBIT_S32_LE,
+	},
+	.capture = {
+		.channels_min = 1,
+		.channels_max = 8,
+		.rates = SUNXI_DAUDIO_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE
+			| SNDRV_PCM_FMTBIT_S32_LE,
+	},
+	.ops = &sunxi_hifi_daudio_dai_ops,
+};
+
+static const struct snd_soc_component_driver sunxi_hifi_daudio_component = {
+	.name		= DRV_NAME,
+	.controls	= sunxi_hifi_daudio_controls,
+	.num_controls	= ARRAY_SIZE(sunxi_hifi_daudio_controls),
+};
+
+static struct sunxi_daudio_platform_data sunxi_hifi_daudio_pdata = {
+	.daudio_type = SUNXI_DAUDIO_EXTERNAL_TYPE,
+
+	.pcm_lrck_period = 128,
+	.msb_lsb_first = 0,
+	.sign_extend = 0,
+	.tx_data_mode = 0,
+	.rx_data_mode = 0,
+	.slot_width_select = 32,
+	.frame_type = 0,
+	.tdm_config = 1,
+	.mclk_div = 0,
+};
+
+static const struct of_device_id sunxi_hifi_daudio_of_match[] = {
+	{
+		.compatible = "allwinner,sunxi-hifi-daudio",
+		.data = &sunxi_hifi_daudio_pdata,
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, sunxi_hifi_daudio_of_match);
+
+static struct regmap_config sunxi_daudio_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = SUNXI_DAUDIO_REG_MAX,
+	.cache_type = REGCACHE_NONE,
+};
+
+static void trigger_work_playback_func(struct work_struct *work)
+{
+	struct sunxi_daudio_info *sunxi_daudio =
+			container_of(work, struct sunxi_daudio_info, trigger_work_playback);
+	struct msg_substream_package *msg_substream = &sunxi_daudio->msg_playback;
+	struct snd_pcm_substream *substream = msg_substream->substream;
+	struct snd_soc_dsp_substream *soc_substream = &msg_substream->soc_substream;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	unsigned int pos = 0;
+	int ret = 0;
+
+	for (;;) {
+		mutex_lock(&sunxi_daudio->rpmsg_mutex_playback);
+		if (soc_substream->cmd_val == SND_SOC_DSP_PCM_WRITEI) {
+			snd_pcm_stream_lock_irq(substream);
+			if (runtime->status->state != SNDRV_PCM_STATE_RUNNING) {
+				dev_warn(sunxi_daudio->cpu_dai->dev, "%s state:%d\n",
+						__func__, runtime->status->state);
+				snd_pcm_stream_unlock_irq(substream);
+				mutex_unlock(&sunxi_daudio->rpmsg_mutex_playback);
+				break;
+			}
+			sunxi_daudio->playing = 1;
+			/* update the capture soc_substream output addr */
+			pos = snd_dmaengine_pcm_pointer_no_residue(substream);
+			soc_substream->input_addr = runtime->dma_addr + frames_to_bytes(runtime, pos);
+			snd_pcm_stream_unlock_irq(substream);
+
+//			dev_dbg(sunxi_daudio->cpu_dai->dev,
+//				"[%s] dma_addr:0x%x, pos:%u, input_addr:0x%x\n",
+//				__func__, runtime->dma_addr, pos, soc_substream->input_addr);
+			ret = sunxi_hifi_daudio_substream_block_send(SUNXI_HIFI0,
+				substream, sunxi_daudio->cpu_dai,
+				SNDRV_PCM_STREAM_PLAYBACK, MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+			sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+			mutex_unlock(&sunxi_daudio->rpmsg_mutex_playback);
+
+			/* component */
+			snd_soc_rpaf_pcm_update_stream_process(&sunxi_daudio->dsp_playcomp);
+
+			if (ret != 0) {
+				dev_err(sunxi_daudio->cpu_dai->dev,
+					"%s state:%d, ret=%d\n", __func__, runtime->status->state, ret);
+			}
+			if (runtime->status->state == SNDRV_PCM_STATE_RUNNING)
+				queue_work(sunxi_daudio->wq_playback, &sunxi_daudio->trigger_work_playback);
+			break;
+		} else if (soc_substream->cmd_val == SND_SOC_DSP_PCM_STOP) {
+			awrpaf_debug("\n");
+			/* send to dsp */
+			sunxi_hifi_daudio_substream_block_send(SUNXI_HIFI0,
+				substream, sunxi_daudio->cpu_dai,
+				SNDRV_PCM_STREAM_PLAYBACK, MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+			sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+			sunxi_daudio->playing = 0;
+			mutex_unlock(&sunxi_daudio->rpmsg_mutex_playback);
+			break;
+		} else if (soc_substream->cmd_val == SND_SOC_DSP_PCM_DRAIN) {
+			awrpaf_debug("\n");
+			/* send to dsp */
+			sunxi_hifi_daudio_substream_block_send(SUNXI_HIFI0,
+				substream, sunxi_daudio->cpu_dai,
+				SNDRV_PCM_STREAM_PLAYBACK, MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+			sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+			snd_pcm_stream_lock_irq(substream);
+			snd_pcm_drain_done(substream);
+			snd_pcm_update_state(substream, runtime);
+			sunxi_daudio->playing = 0;
+			snd_pcm_stream_unlock_irq(substream);
+
+			awrpaf_debug("\n");
+			mutex_unlock(&sunxi_daudio->rpmsg_mutex_playback);
+			break;
+		}
+		mutex_unlock(&sunxi_daudio->rpmsg_mutex_playback);
+	}
+}
+
+static void trigger_work_capture_func(struct work_struct *work)
+{
+	struct sunxi_daudio_info *sunxi_daudio =
+			container_of(work, struct sunxi_daudio_info, trigger_work_capture);
+	struct msg_substream_package *msg_substream = &sunxi_daudio->msg_capture;
+	struct snd_soc_dsp_substream *soc_substream = &msg_substream->soc_substream;
+	struct snd_pcm_substream *substream = msg_substream->substream;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	unsigned int pos = 0;
+	int ret = 0;
+
+	for (;;) {
+		mutex_lock(&sunxi_daudio->rpmsg_mutex_capture);
+		if (soc_substream->cmd_val == SND_SOC_DSP_PCM_READI) {
+			snd_pcm_stream_lock_irq(substream);
+			if (runtime->status->state != SNDRV_PCM_STATE_RUNNING) {
+				dev_err(sunxi_daudio->cpu_dai->dev,
+					"%s state:%d\n", __func__, runtime->status->state);
+				snd_pcm_stream_unlock_irq(substream);
+				mutex_unlock(&sunxi_daudio->rpmsg_mutex_capture);
+				break;
+			}
+			sunxi_daudio->capturing = 1;
+			/* update the capture soc_substream output addr */
+			pos = snd_dmaengine_pcm_pointer_no_residue(substream);
+			soc_substream->output_addr = runtime->dma_addr + frames_to_bytes(runtime, pos);
+			snd_pcm_stream_unlock_irq(substream);
+
+//			dev_dbg(sunxi_daudio->cpu_dai->dev,
+//				"[%s] dma_addr:0x%x, pos:%u, output_addr:0x%x\n",
+//				 __func__, runtime->dma_addr, pos, soc_substream->output_addr);
+			/* send to dsp */
+			ret = sunxi_hifi_daudio_substream_block_send(SUNXI_HIFI0,
+				substream, sunxi_daudio->cpu_dai,
+				SNDRV_PCM_STREAM_CAPTURE, MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+			sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+			mutex_unlock(&sunxi_daudio->rpmsg_mutex_capture);
+
+			/* component */
+			snd_soc_rpaf_pcm_update_stream_process(&sunxi_daudio->dsp_capcomp);
+
+			if (ret != 0) {
+				dev_err(sunxi_daudio->cpu_dai->dev,
+					"%s state:%d, ret=%d\n", __func__, runtime->status->state, ret);
+			}
+			if (runtime->status->state == SNDRV_PCM_STATE_RUNNING)
+				queue_work(sunxi_daudio->wq_capture, &sunxi_daudio->trigger_work_capture);
+			break;
+		} else if (soc_substream->cmd_val == SND_SOC_DSP_PCM_STOP) {
+			awrpaf_debug("\n");
+			/* send to dsp */
+			sunxi_hifi_daudio_substream_block_send(SUNXI_HIFI0,
+				substream, sunxi_daudio->cpu_dai,
+				SNDRV_PCM_STREAM_CAPTURE, MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+			sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+			sunxi_daudio->capturing = 0;
+			mutex_unlock(&sunxi_daudio->rpmsg_mutex_capture);
+			break;
+		}
+		mutex_unlock(&sunxi_daudio->rpmsg_mutex_capture);
+	}
+}
+
+static int sunxi_hifi_daudio_dev_probe(struct platform_device *pdev)
+{
+	const struct of_device_id *match = NULL;
+	struct sunxi_daudio_info *sunxi_daudio = NULL;
+	struct sunxi_daudio_dts_info *dts_info = NULL;
+	struct sunxi_daudio_mem_info *mem_info = NULL;
+	struct sunxi_daudio_platform_data *pdata_info = NULL;
+	struct daudio_voltage_supply *vol_supply = NULL;
+	struct device_node *np = pdev->dev.of_node;
+	unsigned int temp_val;
+	int ret;
+
+	dev_info(&pdev->dev, "%s start.\n", __func__);
+
+	match = of_match_device(sunxi_hifi_daudio_of_match, &pdev->dev);
+	if (match) {
+		sunxi_daudio = devm_kzalloc(&pdev->dev,
+					sizeof(struct sunxi_daudio_info),
+					GFP_KERNEL);
+		if (IS_ERR_OR_NULL(sunxi_daudio)) {
+			dev_err(&pdev->dev, "alloc sunxi_daudio failed\n");
+			ret = -ENOMEM;
+			goto err_devm_malloc_sunxi_daudio;
+		}
+		dev_set_drvdata(&pdev->dev, sunxi_daudio);
+		sunxi_daudio->dev = &pdev->dev;
+		dts_info = &sunxi_daudio->dts_info;
+		mem_info = &dts_info->mem_info;
+		pdata_info = &dts_info->pdata_info;
+		vol_supply = &dts_info->vol_supply;
+
+		memcpy(pdata_info, match->data,
+			sizeof(struct sunxi_daudio_platform_data));
+	} else {
+		dev_err(&pdev->dev, "node match failed\n");
+		return -EINVAL;
+	}
+
+	ret = of_address_to_resource(np, 0, &(mem_info->res));
+	if (ret) {
+		dev_err(&pdev->dev, "parse device node resource failed\n");
+		ret = -EINVAL;
+		goto err_of_addr_to_resource;
+	}
+
+	switch (pdata_info->daudio_type) {
+	case	SUNXI_DAUDIO_EXTERNAL_TYPE:
+		ret = of_property_read_u32(np, "tdm_num", &temp_val);
+		if (ret < 0) {
+			dev_warn(&pdev->dev, "tdm configuration missing\n");
+			/*
+			 * warnning just continue,
+			 * making tdm_num as default setting
+			 */
+			pdata_info->tdm_num = 0;
+		} else {
+			/*
+			 * FIXME, for channel number mess,
+			 * so just not check channel overflow
+			 */
+			pdata_info->tdm_num = temp_val;
+		}
+
+		ret = of_property_read_u32(np, "playback_cma", &temp_val);
+		if (ret < 0) {
+			dev_warn(&pdev->dev, "playback cma kbytes config missing or invalid.\n");
+			dts_info->playback_cma = SUNXI_AUDIO_CMA_MAX_KBYTES;
+		} else {
+			if (temp_val > SUNXI_AUDIO_CMA_MAX_KBYTES)
+				temp_val = SUNXI_AUDIO_CMA_MAX_KBYTES;
+			dts_info->playback_cma = temp_val;
+		}
+
+		ret = of_property_read_u32(np, "capture_cma", &temp_val);
+		if (ret != 0) {
+			dev_warn(&pdev->dev, "capture cma kbytes config missing or invalid.\n");
+			dts_info->capture_cma = SUNXI_AUDIO_CMA_MAX_KBYTES;
+		} else {
+			if (temp_val > SUNXI_AUDIO_CMA_MAX_KBYTES)
+				temp_val = SUNXI_AUDIO_CMA_MAX_KBYTES;
+			dts_info->capture_cma = temp_val;
+		}
+		if (!dts_info->playback_cma && !dts_info->capture_cma) {
+			dev_warn(&pdev->dev, "playback and capture cma is 0\n");
+			goto err_cma_bytes;
+		}
+
+		sunxi_daudio->playback_dma_param.cma_kbytes = dts_info->playback_cma;
+		sunxi_daudio->playback_dma_param.fifo_size = DAUDIO_TX_FIFO_SIZE;
+
+		sunxi_daudio->capture_dma_param.cma_kbytes = dts_info->capture_cma;
+		sunxi_daudio->capture_dma_param.fifo_size = DAUDIO_RX_FIFO_SIZE;
+
+		vol_supply->regulator_name = NULL;
+		ret = of_property_read_string(np, "daudio_regulator",
+				&vol_supply->regulator_name);
+		if (ret < 0) {
+			dev_warn(&pdev->dev, "regulator missing or invalid\n");
+			vol_supply->daudio_regulator = NULL;
+		} else {
+			vol_supply->daudio_regulator =
+				regulator_get(NULL, vol_supply->regulator_name);
+			if (IS_ERR_OR_NULL(vol_supply->daudio_regulator)) {
+				dev_err(&pdev->dev, "get duaido[%d] vcc-pin failed\n",
+					pdata_info->tdm_num);
+				ret = -EFAULT;
+				goto err_regulator_get;
+			}
+			ret = regulator_set_voltage(vol_supply->daudio_regulator,
+						3300000, 3300000);
+			if (ret < 0) {
+				dev_err(&pdev->dev, "set duaido[%d] voltage failed\n",
+						pdata_info->tdm_num);
+				ret = -EFAULT;
+				goto err_regulator_set_vol;
+			}
+			ret = regulator_enable(vol_supply->daudio_regulator);
+			if (ret < 0) {
+				dev_err(&pdev->dev, "enable duaido[%d] vcc-pin failed\n",
+						pdata_info->tdm_num);
+				ret = -EFAULT;
+				goto err_regulator_enable;
+			}
+		}
+
+		ret = of_property_read_u32(np, "pcm_lrck_period", &temp_val);
+		if (ret < 0) {
+			dev_warn(&pdev->dev, "pcm_lrck_period config missing or invalid\n");
+			pdata_info->pcm_lrck_period = 0;
+		} else {
+			pdata_info->pcm_lrck_period = temp_val;
+		}
+
+		ret = of_property_read_u32(np, "msb_lsb_first", &temp_val);
+		if (ret < 0) {
+			dev_warn(&pdev->dev, "msb_lsb_first config missing or invalid\n");
+			pdata_info->msb_lsb_first = 0;
+		} else
+			pdata_info->msb_lsb_first = temp_val;
+
+		ret = of_property_read_u32(np, "slot_width_select", &temp_val);
+		if (ret < 0) {
+			dev_warn(&pdev->dev, "slot_width_select config missing or invalid\n");
+			pdata_info->slot_width_select = 0;
+		} else {
+			pdata_info->slot_width_select = temp_val;
+		}
+
+		ret = of_property_read_u32(np, "frametype", &temp_val);
+		if (ret < 0) {
+			dev_warn(&pdev->dev, "frametype config missing or invalid\n");
+			pdata_info->frame_type = 0;
+		} else {
+			pdata_info->frame_type = temp_val;
+		}
+
+		ret = of_property_read_u32(np, "sign_extend", &temp_val);
+		if (ret < 0) {
+			dev_warn(&pdev->dev, "sign_extend config missing or invalid\n");
+			pdata_info->sign_extend = 0;
+		} else
+			pdata_info->sign_extend = temp_val;
+
+		ret = of_property_read_u32(np, "tx_data_mode", &temp_val);
+		if (ret < 0) {
+			dev_warn(&pdev->dev, "tx_data_mode config missing or invalid\n");
+			pdata_info->tx_data_mode = 0;
+		} else
+			pdata_info->tx_data_mode = temp_val;
+
+		ret = of_property_read_u32(np, "rx_data_mode", &temp_val);
+		if (ret < 0) {
+			dev_warn(&pdev->dev, "rx_data_mode config missing or invalid\n");
+			pdata_info->rx_data_mode = 0;
+		} else
+			pdata_info->rx_data_mode = temp_val;
+
+		ret = of_property_read_u32(np, "tdm_config", &temp_val);
+		if (ret < 0) {
+			dev_warn(&pdev->dev, "tdm_config config missing or invalid\n");
+			pdata_info->tdm_config = 1;
+		} else {
+			pdata_info->tdm_config = temp_val;
+		}
+
+		ret = of_property_read_u32(np, "mclk_div", &temp_val);
+		if (ret < 0)
+			pdata_info->mclk_div = 0;
+		else
+			pdata_info->mclk_div = temp_val;
+
+		ret = of_property_read_u32(np, "tx_num", &temp_val);
+		if (ret < 0)
+			pdata_info->tx_num = SUNXI_DAUDIO_TXCH_NUM;
+		else {
+			if ((temp_val < SUNXI_DAUDIO_TXCH_NUM) && (temp_val != 0))
+				pdata_info->tx_num = temp_val;
+			else
+				pdata_info->tx_num = SUNXI_DAUDIO_TXCH_NUM;
+		}
+
+		ret = of_property_read_u32(np, "tx_chmap0", &temp_val);
+		if (ret < 0)
+			pdata_info->tx_chmap0 = SUNXI_DEFAULT_TXCHMAP0;
+		else
+			pdata_info->tx_chmap0 = temp_val;
+
+		ret = of_property_read_u32(np, "tx_chmap1", &temp_val);
+		if (ret < 0)
+			pdata_info->tx_chmap1 = SUNXI_DEFAULT_TXCHMAP1;
+		else
+			pdata_info->tx_chmap1 = temp_val;
+
+		ret = of_property_read_u32(np, "rx_num", &temp_val);
+		if (ret < 0)
+			pdata_info->rx_num = SUNXI_DAUDIO_RXCH_NUM;
+		else {
+			if ((temp_val < SUNXI_DAUDIO_RXCH_NUM) && (temp_val != 0))
+				pdata_info->rx_num = temp_val;
+			else
+				pdata_info->rx_num = SUNXI_DAUDIO_RXCH_NUM;
+		}
+
+		ret = of_property_read_u32(np, "rx_chmap0", &temp_val);
+		if (ret < 0) {
+			if (pdata_info->rx_num == 1)
+				pdata_info->rx_chmap0 = SUNXI_DEFAULT_RXCHMAP;
+			else
+				pdata_info->rx_chmap0 = SUNXI_DEFAULT_RXCHMAP0;
+		} else {
+			pdata_info->rx_chmap0 = temp_val;
+		}
+
+		ret = of_property_read_u32(np, "rx_chmap1", &temp_val);
+		if (ret < 0)
+			pdata_info->rx_chmap1 = SUNXI_DEFAULT_RXCHMAP1;
+		else
+			pdata_info->rx_chmap1 = temp_val;
+
+		ret = of_property_read_u32(np, "rx_chmap2", &temp_val);
+		if (ret < 0)
+			pdata_info->rx_chmap2 = SUNXI_DEFAULT_RXCHMAP3;
+		else
+			pdata_info->rx_chmap2 = temp_val;
+
+		ret = of_property_read_u32(np, "rx_chmap3", &temp_val);
+		if (ret < 0)
+			pdata_info->rx_chmap3 = SUNXI_DEFAULT_RXCHMAP3;
+		else
+			pdata_info->rx_chmap3 = temp_val;
+
+		/* for hifi dsp param init config */
+		ret = of_property_read_u32(np, "dsp_daudio", &temp_val);
+		if (ret < 0)
+			pdata_info->dsp_daudio = 0;
+		else
+			pdata_info->dsp_daudio = temp_val;
+
+		switch (pdata_info->dsp_daudio) {
+		case 0:
+		case 1:
+			break;
+		default:
+			dev_warn(&pdev->dev, "dsp_daudio setting overflow\n");
+			ret = -EFAULT;
+			goto err_dsp_daudio_tdm_num;
+			break;
+		}
+		dev_warn(&pdev->dev, "dsp_daudio = %d\n", pdata_info->dsp_daudio);
+
+		/* eg:0 sndcodec; 1 snddmic; 2 snddaudio0; */
+		ret = of_property_read_u32(np, "dsp_card", &temp_val);
+		if (ret < 0)
+			pdata_info->dsp_card = 2;
+		else
+			pdata_info->dsp_card = temp_val;
+
+		/* default is 0, for reserved */
+		ret = of_property_read_u32(np, "dsp_device", &temp_val);
+		if (ret < 0)
+			pdata_info->dsp_device = 0;
+		else
+			pdata_info->dsp_device = temp_val;
+		break;
+	default:
+		dev_err(&pdev->dev, "missing digital audio type\n");
+		ret = -EINVAL;
+		goto err_daudio_pdata_type;
+	}
+
+	mem_info->memregion = devm_request_mem_region(&pdev->dev,
+					mem_info->res.start,
+					resource_size(&mem_info->res),
+					DRV_NAME);
+	if (IS_ERR_OR_NULL(mem_info->memregion)) {
+		dev_err(&pdev->dev, "Memory region already claimed\n");
+		ret = -EBUSY;
+		goto err_devm_request_region;
+	}
+
+	mem_info->membase = devm_ioremap(&pdev->dev,
+					mem_info->memregion->start,
+					resource_size(mem_info->memregion));
+	if (IS_ERR_OR_NULL(mem_info->membase)) {
+		dev_err(&pdev->dev, "ioremap failed\n");
+		ret = -EBUSY;
+		goto err_devm_ioremap;
+	}
+
+	sunxi_daudio_regmap_config.max_register = resource_size(&mem_info->res);
+	mem_info->regmap = devm_regmap_init_mmio(&pdev->dev,
+					mem_info->membase,
+					&sunxi_daudio_regmap_config);
+	if (IS_ERR_OR_NULL(mem_info->regmap)) {
+		dev_err(&pdev->dev, "regmap init failed\n");
+		ret = -EINVAL;
+		goto err_devm_regmap_init;
+	}
+
+	ret = snd_soc_register_component(&pdev->dev, &sunxi_hifi_daudio_component,
+					&sunxi_hifi_daudio_dai, 1);
+	if (ret) {
+		dev_err(&pdev->dev, "component register failed\n");
+		ret = -ENOMEM;
+		goto err_register_component;
+	}
+
+	ret = asoc_hifi_platform_register(&pdev->dev, SUNXI_HIFI_PCM_OPS_DAUDIO);
+	if (ret) {
+		dev_err(&pdev->dev, "register ASoC platform failed\n");
+		ret = -ENOMEM;
+		goto err_asoc_hifi_platform_register;
+	}
+
+	mutex_init(&sunxi_daudio->rpmsg_mutex_playback);
+	mutex_init(&sunxi_daudio->rpmsg_mutex_capture);
+
+	snprintf(sunxi_daudio->wq_capture_name, sizeof(sunxi_daudio->wq_capture_name),
+			"hifi-tdm%d-c", pdata_info->dsp_daudio);
+	sunxi_daudio->wq_capture = create_workqueue(sunxi_daudio->wq_capture_name);
+	INIT_WORK(&sunxi_daudio->trigger_work_capture, trigger_work_capture_func);
+//	queue_work(sunxi_daudio->wq_capture, &sunxi_daudio->trigger_work_capture);
+	snprintf(sunxi_daudio->wq_playback_name, sizeof(sunxi_daudio->wq_playback_name),
+			"hifi-tdm%d-p", pdata_info->dsp_daudio);
+	sunxi_daudio->wq_playback = create_workqueue(sunxi_daudio->wq_playback_name);
+	INIT_WORK(&sunxi_daudio->trigger_work_playback, trigger_work_playback_func);
+//	queue_work(sunxi_daudio->wq_playback, &sunxi_daudio->trigger_work_playback);
+
+#ifdef CONFIG_SND_SUNXI_HIFI_DAUDIO_DEBUG
+	ret  = sysfs_create_group(&pdev->dev.kobj, &daudio_debug_attr_group);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to create attr group\n");
+		goto err_sysfs_create_debug;
+	}
+#endif
+	dev_info(&pdev->dev, "%s stop.\n", __func__);
+
+	return 0;
+
+#ifdef CONFIG_SND_SUNXI_HIFI_DAUDIO_DEBUG
+err_sysfs_create_debug:
+	mutex_destroy(&sunxi_daudio->rpmsg_mutex_playback);
+	mutex_destroy(&sunxi_daudio->rpmsg_mutex_capture);
+#endif
+err_asoc_hifi_platform_register:
+	snd_soc_unregister_component(&pdev->dev);
+err_register_component:
+err_devm_regmap_init:
+	devm_iounmap(&pdev->dev, mem_info->membase);
+err_devm_ioremap:
+	devm_release_mem_region(&pdev->dev, mem_info->memregion->start,
+				resource_size(mem_info->memregion));
+err_devm_request_region:
+err_dsp_daudio_tdm_num:
+	if (vol_supply->daudio_regulator)
+		regulator_disable(vol_supply->daudio_regulator);
+err_regulator_enable:
+err_regulator_set_vol:
+	if (vol_supply->daudio_regulator)
+		regulator_put(vol_supply->daudio_regulator);
+err_cma_bytes:
+err_regulator_get:
+err_daudio_pdata_type:
+err_of_addr_to_resource:
+	devm_kfree(&pdev->dev, sunxi_daudio);
+err_devm_malloc_sunxi_daudio:
+	of_node_put(np);
+	return ret;
+}
+
+static int __exit sunxi_hifi_daudio_dev_remove(struct platform_device *pdev)
+{
+	struct sunxi_daudio_info *sunxi_daudio = dev_get_drvdata(&pdev->dev);
+	struct sunxi_daudio_dts_info *dts_info = &sunxi_daudio->dts_info;
+	struct sunxi_daudio_mem_info *mem_info = &dts_info->mem_info;
+	struct daudio_voltage_supply *vol_supply = &dts_info->vol_supply;
+
+	dev_info(&pdev->dev, "%s start.\n", __func__);
+
+#ifdef CONFIG_SND_SUNXI_HIFI_DAUDIO_DEBUG
+	sysfs_remove_group(&pdev->dev.kobj, &daudio_debug_attr_group);
+#endif
+
+	cancel_work_sync(&(sunxi_daudio->trigger_work_capture));
+	destroy_workqueue(sunxi_daudio->wq_capture);
+	cancel_work_sync(&(sunxi_daudio->trigger_work_playback));
+	destroy_workqueue(sunxi_daudio->wq_playback);
+
+	mutex_destroy(&sunxi_daudio->rpmsg_mutex_playback);
+	mutex_destroy(&sunxi_daudio->rpmsg_mutex_capture);
+
+	snd_soc_unregister_component(&pdev->dev);
+	devm_iounmap(&pdev->dev, mem_info->membase);
+	devm_release_mem_region(&pdev->dev, mem_info->memregion->start,
+				resource_size(mem_info->memregion));
+	if (!IS_ERR_OR_NULL(vol_supply->daudio_regulator)) {
+		regulator_disable(vol_supply->daudio_regulator);
+		regulator_put(vol_supply->daudio_regulator);
+	}
+
+	devm_kfree(&pdev->dev, sunxi_daudio);
+
+	dev_info(&pdev->dev, "%s stop.\n", __func__);
+
+	return 0;
+}
+
+static struct platform_driver sunxi_hifi_daudio_driver = {
+	.probe = sunxi_hifi_daudio_dev_probe,
+	.remove = __exit_p(sunxi_hifi_daudio_dev_remove),
+	.driver = {
+		.name = DRV_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_hifi_daudio_of_match,
+	},
+};
+
+module_platform_driver(sunxi_hifi_daudio_driver);
+MODULE_AUTHOR("yumingfeng <yumingfeng@allwinnertech.com>");
+MODULE_DESCRIPTION("SUNXI DAI AUDIO ASoC Interface");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:sunxi-daudio");
diff --git a/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-daudio.h b/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-daudio.h
new file mode 100644
index 000000000..74bc68da6
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-daudio.h
@@ -0,0 +1,125 @@
+/*
+ * sound\soc\sunxi\hifi-dsp\sunxi-daudio.h
+ *
+ * (C) Copyright 2019-2025
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * yumingfeng <yumingfeng@allwinertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef	__SUNXI_HIFI_DAUDIO_H_
+#define	__SUNXI_HIFI_DAUDIO_H_
+
+#include "sunxi-hifi-pcm.h"
+
+/*
+ * Platform    I2S_count      ARM	DSP
+ * sun50iw11	  5	      0-2	3-4
+ */
+
+#define DAUDIO_RX_FIFO_SIZE 64
+#define DAUDIO_TX_FIFO_SIZE 128
+
+struct daudio_label {
+	unsigned long address;
+	int value;
+};
+
+struct daudio_reg_label {
+	const char *name;
+	const unsigned int address;
+	int value;
+};
+
+#define DAUDIO_REG_LABEL(constant) {#constant, constant, 0}
+#define DAUDIO_REG_LABEL_END {NULL, -1, 0}
+
+struct sunxi_daudio_mem_info {
+	struct resource res;
+	void __iomem *membase;
+	struct resource *memregion;
+	struct regmap *regmap;
+};
+
+struct sunxi_daudio_platform_data {
+	unsigned int daudio_type;
+
+	unsigned int pcm_lrck_period;
+	unsigned int msb_lsb_first:1;
+	unsigned int sign_extend:2;
+	unsigned int tx_data_mode:2;
+	unsigned int rx_data_mode:2;
+	unsigned int slot_width_select;
+	unsigned int frame_type;
+	unsigned int tdm_config;
+	unsigned int tdm_num;
+	unsigned int mclk_div;
+	unsigned int tx_num;
+	unsigned int tx_chmap0;
+	unsigned int tx_chmap1;
+	unsigned int rx_num;
+	unsigned int rx_chmap0;
+	unsigned int rx_chmap1;
+	unsigned int rx_chmap2;
+	unsigned int rx_chmap3;
+
+	/* eg:0 snddaudio0, 1 snddaudio1 */
+	unsigned int dsp_daudio;
+	/* eg:0 sndcodec; 1 snddmic; 2 snddaudio0; */
+	unsigned int dsp_card;
+	/* default is 0, for reserved */
+	unsigned int dsp_device;
+};
+
+struct daudio_voltage_supply {
+	struct regulator *daudio_regulator;
+	const char *regulator_name;
+};
+
+struct sunxi_daudio_dts_info {
+	struct sunxi_daudio_mem_info mem_info;
+	struct sunxi_daudio_platform_data pdata_info;
+	struct daudio_voltage_supply vol_supply;
+
+	/* value must be (2^n)Kbyte */
+	size_t playback_cma;
+	size_t capture_cma;
+};
+
+struct sunxi_daudio_info {
+	struct device *dev;
+	struct sunxi_daudio_dts_info dts_info;
+	struct sunxi_dma_params playback_dma_param;
+	struct sunxi_dma_params capture_dma_param;
+	struct snd_soc_dai *cpu_dai;
+	struct daudio_label *reg_label;
+
+	/* for hifi */
+	unsigned int capturing;
+	unsigned int playing;
+	char wq_capture_name[32];
+	struct mutex rpmsg_mutex_capture;
+	struct workqueue_struct *wq_capture;
+	struct work_struct trigger_work_capture;
+	char wq_playback_name[32];
+	struct mutex rpmsg_mutex_playback;
+	struct workqueue_struct *wq_playback;
+	struct work_struct trigger_work_playback;
+
+	struct msg_substream_package msg_playback;
+	struct msg_substream_package msg_capture;
+	struct msg_mixer_package msg_mixer;
+	struct msg_debug_package msg_debug;
+
+	struct snd_dsp_component dsp_playcomp;
+	struct snd_dsp_component dsp_capcomp;
+};
+
+#endif	/* __SUNXI_DAUDIO_H_ */
diff --git a/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-dmic.c b/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-dmic.c
new file mode 100644
index 000000000..a973e5b31
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-dmic.c
@@ -0,0 +1,963 @@
+/*
+ * sound\sunxi-rpaf\soc\sunxi\hifi-dsp\sunxi-dmic.c
+ *
+ * (C) Copyright 2019-2025
+ * AllWinner Technology Co., Ltd. <www.allwinnertech.com>
+ * yumingfeng <yumingfeng@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/regmap.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/initval.h>
+#include <linux/dma-mapping.h>
+#include <asm/cacheflush.h>
+
+#include <sound/aw_rpaf/rpmsg_hifi.h>
+#include <sound/aw_rpaf/component-core.h>
+
+#include "sunxi-hifi-dmic.h"
+
+#define	DRV_NAME	"sunxi-dmic"
+
+#define	SUNXI_DMIC_RATES (SNDRV_PCM_RATE_8000_48000 | SNDRV_PCM_RATE_KNOT)
+
+static long capture_component_type;
+module_param(capture_component_type, long, 0644);
+MODULE_PARM_DESC(capture_component_type, "capture component type for dump");
+
+#ifdef CONFIG_SND_SUNXI_HIFI_DMIC_DEBUG
+static struct sunxi_dmic_reg_label reg_labels[] = {
+	SUNXI_DMIC_REG_LABEL(SUNXI_DMIC_EN),
+	SUNXI_DMIC_REG_LABEL(SUNXI_DMIC_SR),
+	SUNXI_DMIC_REG_LABEL(SUNXI_DMIC_CTR),
+	SUNXI_DMIC_REG_LABEL(SUNXI_DMIC_INTC),
+	SUNXI_DMIC_REG_LABEL(SUNXI_DMIC_INTS),
+	SUNXI_DMIC_REG_LABEL(SUNXI_DMIC_FIFO_CTR),
+	SUNXI_DMIC_REG_LABEL(SUNXI_DMIC_FIFO_STA),
+	SUNXI_DMIC_REG_LABEL(SUNXI_DMIC_CH_NUM),
+	SUNXI_DMIC_REG_LABEL(SUNXI_DMIC_CH_MAP),
+	SUNXI_DMIC_REG_LABEL(SUNXI_DMIC_CNT),
+	SUNXI_DMIC_REG_LABEL(SUNXI_DMIC_DATA0_1_VOL),
+	SUNXI_DMIC_REG_LABEL(SUNXI_DMIC_DATA2_3_VOL),
+	SUNXI_DMIC_REG_LABEL(SUNXI_DMIC_HPF_CTRL),
+	SUNXI_DMIC_REG_LABEL(SUNXI_DMIC_HPF_COEF),
+	SUNXI_DMIC_REG_LABEL(SUNXI_DMIC_HPF_GAIN),
+	SUNXI_DMIC_REG_LABEL_END,
+};
+
+static ssize_t show_dmic_reg(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct sunxi_dmic_info *sunxi_dmic = dev_get_drvdata(dev);
+	struct sunxi_dmic_dts_info *dts_info = NULL;
+	struct sunxi_dmic_mem_info *mem_info = NULL;
+	int count = 0;
+	unsigned int reg_val;
+	int ret = 0;
+	int i = 0;
+
+	if (IS_ERR_OR_NULL(sunxi_dmic)) {
+		dev_err(dev, "sunxi_dmic is NULL!\n");
+		return count;
+	}
+	dts_info = &sunxi_dmic->dts_info;
+	mem_info = &dts_info->mem_info;
+
+	count = snprintf(buf, PAGE_SIZE, "Dump dmic reg:\n");
+	if (count > 0) {
+		ret += count;
+	} else {
+		dev_err(dev, "snprintf start error=%d.\n", count);
+		return 0;
+	}
+
+	while (reg_labels[i].name != NULL) {
+		regmap_read(mem_info->regmap, reg_labels[i].value, &reg_val);
+		count = snprintf(buf + ret, PAGE_SIZE - ret,
+			"%-23s[0x%02X]: 0x%08X\n",
+			reg_labels[i].name,
+			(reg_labels[i].value), reg_val);
+		if (count > 0) {
+			ret += count;
+		} else {
+			dev_err(dev, "snprintf [i=%d] error=%d.\n", i, count);
+			break;
+		}
+		if (ret > PAGE_SIZE) {
+			ret = PAGE_SIZE;
+			break;
+		}
+		i++;
+	}
+
+	return ret;
+}
+
+/* ex:
+ *param 1: 0 read;1 write
+ *param 2: reg value;
+ *param 3: write value;
+	read:
+		echo 0,0x0 > dmic_reg
+	write:
+		echo 1,0x00,0xa > dmic_reg
+*/
+static ssize_t store_dmic_reg(struct device *dev, struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	int ret;
+	int rw_flag;
+	int reg_val_read;
+	unsigned int input_reg_val = 0;
+	unsigned int input_reg_offset = 0;
+	struct sunxi_dmic_info *sunxi_dmic = dev_get_drvdata(dev);
+	struct sunxi_dmic_dts_info *dts_info = NULL;
+	struct sunxi_dmic_mem_info *mem_info = NULL;
+
+	if (IS_ERR_OR_NULL(sunxi_dmic)) {
+		dev_err(dev, "sunxi_dmic is NULL!\n");
+		return count;
+	}
+	dts_info = &sunxi_dmic->dts_info;
+	mem_info = &dts_info->mem_info;
+
+	ret = sscanf(buf, "%d,0x%x,0x%x", &rw_flag, &input_reg_offset,
+			&input_reg_val);
+
+	if (ret == 3 || ret == 2) {
+		if (!(rw_flag == 1 || rw_flag == 0)) {
+			dev_err(dev, "rw_flag should be 0(read) or 1(write).\n");
+			return count;
+		}
+		if (input_reg_offset > SUNXI_DMIC_REG_MAX) {
+			pr_err("the reg offset is invalid! [0x0 - 0x%x]\n",
+				SUNXI_DMIC_REG_MAX);
+			return count;
+		}
+		if (rw_flag) {
+			regmap_write(mem_info->regmap, input_reg_offset,
+					input_reg_val);
+		}
+		regmap_read(mem_info->regmap, input_reg_offset, &reg_val_read);
+		pr_err("\n\n Reg[0x%x] : 0x%x\n\n", input_reg_offset, reg_val_read);
+	} else {
+		pr_err("ret:%d, The num of params invalid!\n", ret);
+		pr_err("\nExample(reg range:0x0 - 0x%x):\n", SUNXI_DMIC_REG_MAX);
+		pr_err("\nRead reg[0x04]:\n");
+		pr_err("      echo 0,0x04 > dmic_reg\n");
+		pr_err("Write reg[0x04]=0x10\n");
+		pr_err("      echo 1,0x04,0x10 > dmic_reg\n");
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(dmic_reg, 0644, show_dmic_reg, store_dmic_reg);
+
+static struct attribute *audio_debug_attrs[] = {
+	&dev_attr_dmic_reg.attr,
+	NULL,
+};
+
+static struct attribute_group dmic_debug_attr_group = {
+	.name	= "dmic_debug",
+	.attrs	= audio_debug_attrs,
+};
+#endif
+
+static int sunxi_hifi_dmic_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct sunxi_dmic_info *sunxi_dmic = snd_soc_dai_get_drvdata(dai);
+	struct msg_substream_package *msg_substream;
+	struct snd_soc_dsp_substream *soc_substream;
+	struct snd_soc_dsp_pcm_params *pcm_params;
+	struct sunxi_dmic_dts_info *dts_info = NULL;
+	struct sunxi_dmic_mem_info *mem_info = NULL;
+	unsigned int frame_bytes;
+	unsigned int sample_bits;
+	struct mutex *rpmsg_mutex;
+	struct snd_dsp_component *dsp_component;
+	struct msg_component_package *msg_component;
+	struct snd_soc_dsp_component *soc_component;
+	int ret = 0;
+
+	if (IS_ERR_OR_NULL(sunxi_dmic)) {
+		dev_err(dai->dev, "sunxi_dmic is NULL!\n");
+		return -ENOMEM;
+	}
+	dts_info = &sunxi_dmic->dts_info;
+	mem_info = &dts_info->mem_info;
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		msg_substream = &sunxi_dmic->msg_capture;
+		rpmsg_mutex = &sunxi_dmic->rpmsg_mutex_capture;
+	}
+	soc_substream = &msg_substream->soc_substream;
+
+	mutex_lock(rpmsg_mutex);
+	pcm_params = &soc_substream->params;
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		pcm_params->format = SND_PCM_FORMAT_S16_LE;
+		sample_bits = 16;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		pcm_params->format = SND_PCM_FORMAT_S24_LE;
+		sample_bits = 32;
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		pcm_params->format = SND_PCM_FORMAT_S32_LE;
+		sample_bits = 32;
+		break;
+	default:
+		mutex_unlock(rpmsg_mutex);
+		dev_err(sunxi_dmic->dev, "unrecognized format\n");
+		return -EINVAL;
+	}
+	pcm_params->channels = params_channels(params);
+	pcm_params->rate = params_rate(params);
+	pcm_params->period_size = params_period_size(params);
+	pcm_params->periods = params_periods(params);
+	pcm_params->pcm_frames = pcm_params->period_size;
+	/* buffer,  */
+	pcm_params->buffer_size = params_buffer_size(params);
+	frame_bytes = pcm_params->channels * sample_bits / 8;
+
+	dev_info(sunxi_dmic->dev, "======== hw_params ========\n");
+	dev_info(sunxi_dmic->dev, "pcm_params->format:%u\n", pcm_params->format);
+	dev_info(sunxi_dmic->dev, "pcm_params->channels:%u\n", pcm_params->channels);
+	dev_info(sunxi_dmic->dev, "pcm_params->rate:%u\n", pcm_params->rate);
+	dev_info(sunxi_dmic->dev, "pcm_params->period_size:%u\n", pcm_params->period_size);
+	dev_info(sunxi_dmic->dev, "pcm_params->periods:%u\n", pcm_params->periods);
+	dev_info(sunxi_dmic->dev, "pcm_params->pcm_frames:%u\n", pcm_params->pcm_frames);
+	dev_info(sunxi_dmic->dev, "pcm_params->buffer_size:%u\n", pcm_params->buffer_size);
+	dev_info(sunxi_dmic->dev, "===========================\n");
+	soc_substream->input_size = pcm_params->period_size * frame_bytes;
+	soc_substream->output_size = pcm_params->period_size * frame_bytes;
+
+	dsp_component = &sunxi_dmic->dsp_capcomp;
+	msg_component = &dsp_component->msg_component;
+	soc_component = &msg_component->soc_component;
+	soc_component->component_type = capture_component_type;
+
+	ret = sunxi_hifi_substream_set_stream_component(SUNXI_HIFI0,
+			dai, soc_substream, dsp_component);
+	if (ret < 0) {
+		dev_err(dai->dev, "set stream component send failed.\n");
+		return ret;
+	}
+
+	/* msgbox to dsp */
+	soc_substream->cmd_val = SND_SOC_DSP_PCM_HW_PARAMS;
+	awrpaf_debug("\n");
+	ret = sunxi_hifi_dmic_substream_block_send(SUNXI_HIFI0, substream, dai,
+						substream->stream, MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+	sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+	mutex_unlock(rpmsg_mutex);
+	if (ret < 0) {
+		dev_err(dai->dev, "cpudai send failed.\n");
+		return ret;
+	}
+	return soc_substream->ret_val;
+}
+
+static int sunxi_hifi_dmic_trigger(struct snd_pcm_substream *substream,
+				int cmd, struct snd_soc_dai *dai)
+{
+	int ret = 0;
+	struct sunxi_dmic_info *sunxi_dmic = snd_soc_dai_get_drvdata(dai);
+	struct msg_substream_package *msg_substream;
+	struct snd_soc_dsp_substream *soc_substream;
+	struct work_struct *trigger_work;
+	struct workqueue_struct *wq_pcm;
+
+	if (IS_ERR_OR_NULL(sunxi_dmic)) {
+		dev_err(dai->dev, "sunxi_dmic is NULL!\n");
+		return -ENOMEM;
+	}
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		msg_substream = &sunxi_dmic->msg_capture;
+		soc_substream = &msg_substream->soc_substream;
+		soc_substream->cmd_val = SND_SOC_DSP_PCM_READI;
+		trigger_work = &sunxi_dmic->trigger_work_capture;
+		wq_pcm = sunxi_dmic->wq_capture;
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		msg_substream = &sunxi_dmic->msg_capture;
+		trigger_work = &sunxi_dmic->trigger_work_capture;
+		wq_pcm = sunxi_dmic->wq_capture;
+		soc_substream = &msg_substream->soc_substream;
+		soc_substream->cmd_val = SND_SOC_DSP_PCM_STOP;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	queue_work(wq_pcm, trigger_work);
+	return ret;
+}
+
+/*
+ * Reset & Flush FIFO
+ */
+static int sunxi_hifi_dmic_prepare(struct snd_pcm_substream *substream,
+			struct snd_soc_dai *dai)
+{
+	struct sunxi_dmic_info *sunxi_dmic = snd_soc_dai_get_drvdata(dai);
+	struct msg_substream_package *msg_substream;
+	struct snd_soc_dsp_substream *soc_substream;
+	struct mutex *rpmsg_mutex;
+	int ret = 0;
+
+	if (IS_ERR_OR_NULL(sunxi_dmic)) {
+		dev_err(dai->dev, "sunxi_dmic is NULL!\n");
+		return -ENOMEM;
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		msg_substream = &sunxi_dmic->msg_capture;
+		rpmsg_mutex = &sunxi_dmic->rpmsg_mutex_capture;
+		/* wait for stop capture */
+		while (sunxi_dmic->capturing)
+			msleep(20);
+	}
+	soc_substream = &msg_substream->soc_substream;
+
+	/* msgbox to dsp */
+	mutex_lock(rpmsg_mutex);
+	awrpaf_debug("\n");
+	soc_substream->cmd_val = SND_SOC_DSP_PCM_PREPARE;
+	ret = sunxi_hifi_dmic_substream_block_send(SUNXI_HIFI0, substream, dai,
+						substream->stream, MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+	sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+	mutex_unlock(rpmsg_mutex);
+	if (ret < 0) {
+		dev_err(dai->dev, "cpudai send failed.\n");
+		return ret;
+	}
+	return soc_substream->ret_val;
+}
+
+static int sunxi_hifi_dmic_startup(struct snd_pcm_substream *substream,
+			struct snd_soc_dai *dai)
+{
+	struct sunxi_dmic_info *sunxi_dmic = snd_soc_dai_get_drvdata(dai);
+	struct msg_substream_package *msg_substream;
+	struct snd_soc_dsp_substream *soc_substream;
+	struct mutex *rpmsg_mutex;
+	int ret = 0;
+
+	if (IS_ERR_OR_NULL(sunxi_dmic)) {
+		dev_err(dai->dev, "sunxi_dmic is NULL!\n");
+		return -ENOMEM;
+	}
+
+	snd_soc_dai_set_dma_data(dai, substream,
+					&sunxi_dmic->capture_dma_param);
+
+	msg_substream = &sunxi_dmic->msg_capture;
+	rpmsg_mutex = &sunxi_dmic->rpmsg_mutex_capture;
+	sunxi_dmic->capturing = 0;
+	soc_substream = &msg_substream->soc_substream;
+	soc_substream->input_addr = sunxi_dmic->capture_dma_param.phy_addr;
+	dev_dbg(dai->dev, "coherent phy_addr:0x%x\n", soc_substream->input_addr);
+	msg_substream->substream = substream;
+
+	/* msgbox to dsp */
+	mutex_lock(rpmsg_mutex);
+	awrpaf_debug("\n");
+	soc_substream->cmd_val = SND_SOC_DSP_PCM_STARTUP;
+	ret = sunxi_hifi_dmic_substream_block_send(SUNXI_HIFI0, substream, dai,
+						substream->stream, MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+	sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+	mutex_unlock(rpmsg_mutex);
+	if (ret < 0) {
+		dev_err(dai->dev, "cpudai send failed.\n");
+		soc_substream->cmd_val = SND_SOC_DSP_PCM_SHUTDOWN;
+		sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+		sunxi_hifi_dmic_substream_block_send(SUNXI_HIFI0, substream, dai,
+						substream->stream, MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+		return ret;
+	}
+	return soc_substream->ret_val;
+}
+
+static void sunxi_hifi_dmic_shutdown(struct snd_pcm_substream *substream,
+			struct snd_soc_dai *dai)
+{
+	struct sunxi_dmic_info *sunxi_dmic = snd_soc_dai_get_drvdata(dai);
+	struct msg_substream_package *msg_substream;
+	struct snd_soc_dsp_substream *soc_substream;
+	struct mutex *rpmsg_mutex;
+	unsigned int *work_running;
+	int i = 0;
+
+	if (IS_ERR_OR_NULL(sunxi_dmic)) {
+		dev_err(dai->dev, "sunxi_dmic is NULL!\n");
+		return;
+	}
+
+	sunxi_dmic->capture_en = 0;
+
+	msg_substream = &sunxi_dmic->msg_capture;
+	rpmsg_mutex = &sunxi_dmic->rpmsg_mutex_capture;
+	work_running = &sunxi_dmic->capturing;
+	soc_substream = &msg_substream->soc_substream;
+
+	awrpaf_debug("\n");
+	for (i = 0; i < 50; i++) {
+		if (*work_running == 0)
+			break;
+		msleep(20);
+	}
+	awrpaf_debug("\n");
+
+	sunxi_hifi_substream_release_stream_component(dai, &sunxi_dmic->dsp_capcomp);
+
+	/* msgbox to dsp */
+	mutex_lock(rpmsg_mutex);
+	soc_substream->cmd_val = SND_SOC_DSP_PCM_SHUTDOWN;
+	sunxi_hifi_dmic_substream_block_send(SUNXI_HIFI0, substream, dai,
+						substream->stream, MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+	sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+	mutex_unlock(rpmsg_mutex);
+
+	msg_substream->substream = NULL;
+}
+
+static struct snd_soc_dai_ops sunxi_hifi_dmic_dai_ops = {
+	.startup = sunxi_hifi_dmic_startup,
+	.hw_params = sunxi_hifi_dmic_hw_params,
+	.prepare = sunxi_hifi_dmic_prepare,
+	.trigger = sunxi_hifi_dmic_trigger,
+	.shutdown = sunxi_hifi_dmic_shutdown,
+};
+
+static int sunxi_hifi_dmic_init(struct sunxi_dmic_info *sunxi_dmic,
+					struct snd_soc_dai *dai)
+{
+	struct sunxi_dmic_dts_info *dts_info = &sunxi_dmic->dts_info;
+	struct msg_substream_package *msg_capture = &sunxi_dmic->msg_capture;
+	struct msg_mixer_package *msg_mixer = &sunxi_dmic->msg_mixer;
+//	struct snd_soc_dsp_mixer *soc_mixer = &msg_mixer->soc_mixer;
+	struct msg_debug_package *msg_debug = &sunxi_dmic->msg_debug;
+	struct msg_component_package *msg_component;
+	struct snd_dsp_component *dsp_component;
+//	struct snd_soc_dsp_component *soc_component;
+	struct snd_soc_dsp_substream *soc_substream;
+	struct snd_soc_dsp_pcm_params *pcm_params;
+	int ret = 0;
+
+	sunxi_dmic->cpu_dai = dai;
+	/* init for capture */
+	init_waitqueue_head(&msg_capture->tsleep);
+	spin_lock_init(&msg_capture->lock);
+	msg_capture->wakeup_flag = 0;
+	soc_substream = &msg_capture->soc_substream;
+	pcm_params = &soc_substream->params;
+	pcm_params->stream = SND_STREAM_CAPTURE;
+	pcm_params->card = dts_info->dsp_card;
+	pcm_params->device = dts_info->dsp_device;
+	snprintf(pcm_params->driver, 31, "snddmic");
+	/* dma buffer alloc */
+	sunxi_dma_params_alloc_dma_area(dai, &sunxi_dmic->capture_dma_param);
+	if (!sunxi_dmic->capture_dma_param.dma_area) {
+		dev_err(dai->dev, "capture dmaengine alloc coherent failed.\n");
+		ret = -ENOMEM;
+		goto err_dma_alloc_capture;
+	}
+
+	/* init for capture component */
+	dsp_component = &sunxi_dmic->dsp_capcomp;
+	msg_component = &dsp_component->msg_component;
+	init_waitqueue_head(&msg_component->tsleep);
+	spin_lock_init(&msg_component->lock);
+	msg_component->wakeup_flag = 0;
+
+	/* init for mixer */
+	init_waitqueue_head(&msg_mixer->tsleep);
+	spin_lock_init(&msg_mixer->lock);
+	msg_mixer->wakeup_flag = 0;
+
+	/* init for debug */
+	init_waitqueue_head(&msg_debug->tsleep);
+	spin_lock_init(&msg_debug->lock);
+	msg_debug->wakeup_flag = 0;
+
+	/* register sunxi_dmic_info to rpmsg_hifi driver */
+	sunxi_hifi_register_sound_drv_info(pcm_params->driver, sunxi_dmic);
+
+	/* pdata_info */
+	return 0;
+
+err_dma_alloc_capture:
+	return ret;
+}
+
+static int sunxi_hifi_dmic_uninit(struct sunxi_dmic_info *sunxi_dmic,
+					struct snd_soc_dai *dai)
+{
+	struct msg_substream_package *msg_capture = &sunxi_dmic->msg_capture;
+	struct snd_soc_dsp_substream *soc_substream;
+	struct snd_soc_dsp_pcm_params *pcm_params;
+
+	sunxi_dma_params_free_dma_area(dai, &sunxi_dmic->capture_dma_param);
+
+	soc_substream = &msg_capture->soc_substream;
+	pcm_params = &soc_substream->params;
+	sunxi_hifi_unregister_sound_drv_info(pcm_params->driver, sunxi_dmic);
+
+	return 0;
+}
+
+/* Dmic module init status */
+static int sunxi_hifi_dmic_probe(struct snd_soc_dai *dai)
+{
+	struct sunxi_dmic_info *sunxi_dmic = snd_soc_dai_get_drvdata(dai);
+	struct msg_substream_package *msg_capture = &sunxi_dmic->msg_capture;
+	struct snd_soc_dsp_substream *soc_substream;
+	int ret = 0;
+
+	if (IS_ERR_OR_NULL(sunxi_dmic)) {
+		dev_err(dai->dev, "sunxi_dmic is NULL!\n");
+		return -ENOMEM;
+	}
+
+	dev_info(dai->dev, "%s start.\n", __func__);
+	/* pcm_new will using the dma_param about the cma and fifo params. */
+	snd_soc_dai_init_dma_data(dai, NULL, &sunxi_dmic->capture_dma_param);
+
+	sunxi_hifi_dmic_init(sunxi_dmic, dai);
+
+	/* msgbox to dsp */
+	/* for capture */
+	soc_substream = &msg_capture->soc_substream;
+	soc_substream->cmd_val = SND_SOC_DSP_PCM_PROBE;
+	ret = sunxi_hifi_dmic_substream_block_send(SUNXI_HIFI0, NULL, dai,
+							SNDRV_PCM_STREAM_CAPTURE,
+							MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+	sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+	if (ret < 0) {
+		dev_err(dai->dev, "probe send failed.\n");
+		sunxi_hifi_dmic_uninit(sunxi_dmic, dai);
+		return -EFAULT;
+	}
+	dev_info(dai->dev, "%s stop.\n", __func__);
+
+	return soc_substream->ret_val;
+}
+
+static int sunxi_hifi_dmic_suspend(struct snd_soc_dai *cpu_dai)
+{
+	struct sunxi_dmic_info *sunxi_dmic = snd_soc_dai_get_drvdata(cpu_dai);
+	struct msg_substream_package *msg_capture;
+	struct snd_soc_dsp_substream *soc_substream;
+
+	pr_debug("[DMIC]Enter %s\n", __func__);
+
+	if (IS_ERR_OR_NULL(sunxi_dmic)) {
+		dev_err(cpu_dai->dev, "sunxi_dmic is NULL!\n");
+		return -ENOMEM;
+	}
+	msg_capture = &sunxi_dmic->msg_capture;
+	soc_substream = &msg_capture->soc_substream;
+
+	/* only for capture */
+	soc_substream->cmd_val = SND_SOC_DSP_PCM_SUSPEND;
+	sunxi_hifi_dmic_substream_block_send(SUNXI_HIFI0, NULL, cpu_dai,
+							SNDRV_PCM_STREAM_CAPTURE,
+							MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+	sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+	pr_debug("[DMIC]End %s\n", __func__);
+
+	return 0;
+}
+
+static int sunxi_hifi_dmic_resume(struct snd_soc_dai *cpu_dai)
+{
+	struct sunxi_dmic_info *sunxi_dmic = snd_soc_dai_get_drvdata(cpu_dai);
+	struct msg_substream_package *msg_capture;
+	struct snd_soc_dsp_substream *soc_substream;
+
+	pr_debug("[DMIC]Enter %s\n", __func__);
+
+	if (IS_ERR_OR_NULL(sunxi_dmic)) {
+		dev_err(cpu_dai->dev, "sunxi_dmic is NULL!\n");
+		return -ENOMEM;
+	}
+	msg_capture = &sunxi_dmic->msg_capture;
+	soc_substream = &msg_capture->soc_substream;
+
+	/* only for capture */
+	soc_substream->cmd_val = SND_SOC_DSP_PCM_RESUME;
+	sunxi_hifi_dmic_substream_block_send(SUNXI_HIFI0, NULL, cpu_dai,
+							SNDRV_PCM_STREAM_CAPTURE,
+							MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+	sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+	pr_debug("[DMIC]End %s\n", __func__);
+
+	return 0;
+}
+
+static int sunxi_hifi_dmic_remove(struct snd_soc_dai *dai)
+{
+	struct sunxi_dmic_info *sunxi_dmic = snd_soc_dai_get_drvdata(dai);
+	struct msg_substream_package *msg_capture = &sunxi_dmic->msg_capture;
+	struct snd_soc_dsp_substream *soc_substream;
+	int ret = 0;
+
+	dev_info(dai->dev, "%s start.\n", __func__);
+
+	if (IS_ERR_OR_NULL(sunxi_dmic)) {
+		dev_err(dai->dev, "sunxi_dmic is NULL!\n");
+		return -ENOMEM;
+	}
+	/* msgbox to dsp */
+	/* for capture */
+	soc_substream = &msg_capture->soc_substream;
+	soc_substream->cmd_val = SND_SOC_DSP_PCM_REMOVE;
+	ret = sunxi_hifi_dmic_substream_block_send(SUNXI_HIFI0, NULL, dai,
+							SNDRV_PCM_STREAM_CAPTURE,
+							MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+	if (ret < 0) {
+		dev_err(dai->dev, "remove send failed.\n");
+		sunxi_hifi_dmic_uninit(sunxi_dmic, dai);
+		return -EFAULT;
+	}
+
+	sunxi_hifi_dmic_uninit(sunxi_dmic, dai);
+	dev_info(dai->dev, "%s stop.\n", __func__);
+
+	return 0;
+}
+
+static struct snd_soc_dai_driver sunxi_hifi_dmic_dai = {
+	.probe = sunxi_hifi_dmic_probe,
+	.suspend = sunxi_hifi_dmic_suspend,
+	.resume = sunxi_hifi_dmic_resume,
+	.remove = sunxi_hifi_dmic_remove,
+	.capture = {
+		.channels_min = 1,
+		.channels_max = 8,
+		.rates = SUNXI_DMIC_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE |
+				SNDRV_PCM_FMTBIT_S32_LE,
+	},
+	.ops = &sunxi_hifi_dmic_dai_ops,
+};
+
+static const struct snd_soc_component_driver sunxi_hifi_dmic_component = {
+	.name = DRV_NAME,
+};
+
+static struct regmap_config sunxi_dmic_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = SUNXI_DMIC_REG_MAX,
+	.cache_type = REGCACHE_NONE,
+};
+
+static void trigger_work_capture_func(struct work_struct *work)
+{
+	struct sunxi_dmic_info *sunxi_dmic =
+			container_of(work, struct sunxi_dmic_info, trigger_work_capture);
+	struct msg_substream_package *msg_substream = &sunxi_dmic->msg_capture;
+	struct snd_soc_dsp_substream *soc_substream = &msg_substream->soc_substream;
+	struct snd_pcm_substream *substream = msg_substream->substream;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	unsigned int pos = 0;
+	int ret = 0;
+
+	for (;;) {
+		mutex_lock(&sunxi_dmic->rpmsg_mutex_capture);
+		if (soc_substream->cmd_val == SND_SOC_DSP_PCM_READI) {
+			snd_pcm_stream_lock_irq(substream);
+			if (runtime->status->state != SNDRV_PCM_STATE_RUNNING) {
+				dev_err(sunxi_dmic->cpu_dai->dev, "%s state:%d\n",
+						__func__, runtime->status->state);
+				snd_pcm_stream_unlock_irq(substream);
+				mutex_unlock(&sunxi_dmic->rpmsg_mutex_capture);
+				break;
+			}
+			sunxi_dmic->capturing = 1;
+			/* update the capture soc_substream output addr */
+			pos = snd_dmaengine_pcm_pointer_no_residue(substream);
+			soc_substream->output_addr = runtime->dma_addr + frames_to_bytes(runtime, pos);
+			snd_pcm_stream_unlock_irq(substream);
+
+//			dev_dbg(sunxi_dmic->cpu_dai->dev,
+//				"[%s] dma_addr:0x%x, pos:%u, output_addr:0x%x\n",
+//				 __func__, runtime->dma_addr, pos, soc_substream->output_addr);
+			/* send to dsp */
+			ret = sunxi_hifi_dmic_substream_block_send(SUNXI_HIFI0,
+				substream, sunxi_dmic->cpu_dai,
+				SNDRV_PCM_STREAM_CAPTURE, MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+			sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+			mutex_unlock(&sunxi_dmic->rpmsg_mutex_capture);
+
+			/* component */
+			snd_soc_rpaf_pcm_update_stream_process(&sunxi_dmic->dsp_capcomp);
+
+			if (ret != 0) {
+				dev_err(sunxi_dmic->cpu_dai->dev,
+					"%s state:%d, ret=%d\n", __func__, runtime->status->state, ret);
+			}
+			if (substream->runtime->status->state == SNDRV_PCM_STATE_RUNNING)
+				queue_work(sunxi_dmic->wq_capture, &sunxi_dmic->trigger_work_capture);
+			break;
+		} else if (soc_substream->cmd_val == SND_SOC_DSP_PCM_STOP) {
+			awrpaf_debug("\n");
+			/* send to dsp */
+			sunxi_hifi_dmic_substream_block_send(SUNXI_HIFI0,
+				substream, sunxi_dmic->cpu_dai,
+				SNDRV_PCM_STREAM_CAPTURE, MSGBOX_SOC_DSP_AUDIO_PCM_COMMAND);
+			sunxi_rpaf_dma_flush_range(soc_substream, sizeof(struct snd_soc_dsp_substream));
+			sunxi_dmic->capturing = 0;
+			mutex_unlock(&sunxi_dmic->rpmsg_mutex_capture);
+			break;
+		}
+		mutex_unlock(&sunxi_dmic->rpmsg_mutex_capture);
+	}
+}
+
+static int sunxi_hifi_dmic_dev_probe(struct platform_device *pdev)
+{
+	struct sunxi_dmic_info *sunxi_dmic = NULL;
+	struct sunxi_dmic_dts_info *dts_info = NULL;
+	struct sunxi_dmic_mem_info *mem_info = NULL;
+	struct device_node *np = pdev->dev.of_node;
+	unsigned int temp_val;
+	int ret;
+
+	dev_info(&pdev->dev, "%s start.\n", __func__);
+
+	sunxi_dmic = devm_kzalloc(&pdev->dev, sizeof(struct sunxi_dmic_info), GFP_KERNEL);
+	if (IS_ERR_OR_NULL(sunxi_dmic)) {
+		dev_err(&pdev->dev, "sunxi_dmic allocate failed\n");
+		return -ENOMEM;
+	}
+	dev_set_drvdata(&pdev->dev, sunxi_dmic);
+
+	sunxi_dmic->dev = &pdev->dev;
+	dts_info = &sunxi_dmic->dts_info;
+	mem_info = &dts_info->mem_info;
+	sunxi_dmic->dai_drv = sunxi_hifi_dmic_dai;
+	sunxi_dmic->dai_drv.name = dev_name(&pdev->dev);
+
+	sunxi_dmic->capture_en = 0;
+
+	ret = of_address_to_resource(np, 0, &(mem_info->res));
+	if (ret) {
+		dev_err(&pdev->dev, "parse device node resource failed\n");
+		ret = -EINVAL;
+		goto err_of_addr_to_resource;
+	}
+
+	mem_info->memregion = devm_request_mem_region(&pdev->dev,
+					mem_info->res.start,
+					resource_size(&mem_info->res),
+					DRV_NAME);
+	if (IS_ERR_OR_NULL(mem_info->memregion)) {
+		dev_err(&pdev->dev, "Memory region already claimed\n");
+		ret = -EBUSY;
+		goto err_devm_request_region;
+	}
+
+	mem_info->membase = devm_ioremap(&pdev->dev,
+					mem_info->memregion->start,
+					resource_size(mem_info->memregion));
+	if (IS_ERR_OR_NULL(mem_info->membase)) {
+		dev_err(&pdev->dev, "ioremap failed\n");
+		ret = -EBUSY;
+		goto err_devm_ioremap;
+	}
+
+	sunxi_dmic_regmap_config.max_register = resource_size(&mem_info->res);
+	mem_info->regmap = devm_regmap_init_mmio(&pdev->dev,
+					mem_info->membase,
+					&sunxi_dmic_regmap_config);
+	if (IS_ERR_OR_NULL(mem_info->regmap)) {
+		dev_err(&pdev->dev, "regmap init failed\n");
+		ret = -EINVAL;
+		goto err_devm_regmap_init;
+	}
+	ret = of_property_read_u32(np, "capture_cma", &temp_val);
+	if (ret != 0) {
+		dev_warn(&pdev->dev, "capture cma kbytes config missing or invalid.\n");
+		dts_info->capture_cma = SUNXI_AUDIO_CMA_MAX_KBYTES;
+	} else {
+		if (temp_val > SUNXI_AUDIO_CMA_MAX_KBYTES)
+			temp_val = SUNXI_AUDIO_CMA_MAX_KBYTES;
+		else if (temp_val < SUNXI_AUDIO_CMA_MIN_KBYTES)
+			temp_val = SUNXI_AUDIO_CMA_MIN_KBYTES;
+		dts_info->capture_cma = temp_val;
+	}
+
+	sunxi_dmic->capture_dma_param.cma_kbytes = dts_info->capture_cma;
+	sunxi_dmic->capture_dma_param.fifo_size = DMIC_RX_FIFO_SIZE;
+
+	/* eg:0 sndcodec; 1 snddmic; 2 snddaudio0; */
+	ret = of_property_read_u32(np, "dsp_card", &temp_val);
+	if (ret < 0)
+		dts_info->dsp_card = 1;
+	else
+		dts_info->dsp_card = temp_val;
+
+	/* default is 0, for reserved */
+	ret = of_property_read_u32(np, "dsp_device", &temp_val);
+	if (ret < 0)
+		dts_info->dsp_device = 0;
+	else
+		dts_info->dsp_device = temp_val;
+
+	mutex_init(&sunxi_dmic->rpmsg_mutex_capture);
+
+	snprintf(sunxi_dmic->wq_capture_name, sizeof(sunxi_dmic->wq_capture_name),
+			"hifi-dmic-capture");
+	sunxi_dmic->wq_capture = create_workqueue(sunxi_dmic->wq_capture_name);
+	if (IS_ERR_OR_NULL(sunxi_dmic->wq_capture)) {
+		ret = -ENOMEM;
+		goto err_create_wq_capture;
+	}
+	INIT_WORK(&sunxi_dmic->trigger_work_capture, trigger_work_capture_func);
+//	queue_work(sunxi_dmic->wq_capture, &sunxi_dmic->trigger_work_capture);
+
+	/*
+	 * Register a component with automatic unregistration when the device is
+	 * unregistered.
+	 */
+	ret = devm_snd_soc_register_component(&pdev->dev, &sunxi_hifi_dmic_component,
+					&sunxi_dmic->dai_drv, 1);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "Could not register DAI: %d\n", ret);
+		ret = -ENOMEM;
+		goto err_devm_register_component;
+	}
+
+	/*
+	 * Register a platform driver with automatic unregistration when the device is
+	 * unregistered.
+	 */
+	ret = asoc_hifi_platform_register(&pdev->dev, SUNXI_HIFI_PCM_OPS_DMIC);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "Could not register PCM: %d\n", ret);
+		ret = -ENOMEM;
+		goto err_platform_register;
+	}
+
+#ifdef CONFIG_SND_SUNXI_HIFI_DMIC_DEBUG
+	ret  = sysfs_create_group(&pdev->dev.kobj, &dmic_debug_attr_group);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to create attr group\n");
+		goto err_sysfs_create_debug;
+	}
+#endif
+
+	dev_info(&pdev->dev, "%s stop.\n", __func__);
+
+	return 0;
+
+#ifdef CONFIG_SND_SUNXI_HIFI_DMIC_DEBUG
+err_sysfs_create_debug:
+#endif
+err_platform_register:
+err_devm_register_component:
+err_create_wq_capture:
+	mutex_destroy(&sunxi_dmic->rpmsg_mutex_capture);
+err_devm_regmap_init:
+	devm_iounmap(&pdev->dev, mem_info->membase);
+err_devm_ioremap:
+	devm_release_mem_region(&pdev->dev, mem_info->memregion->start,
+				resource_size(mem_info->memregion));
+err_devm_request_region:
+err_of_addr_to_resource:
+	devm_kfree(&pdev->dev, sunxi_dmic);
+	return ret;
+}
+
+static int __exit sunxi_hifi_dmic_dev_remove(struct platform_device *pdev)
+{
+	struct sunxi_dmic_info *sunxi_dmic = NULL;
+	struct sunxi_dmic_dts_info *dts_info = NULL;
+	struct sunxi_dmic_mem_info *mem_info = NULL;
+
+	sunxi_dmic = platform_get_drvdata(pdev);
+	if (IS_ERR_OR_NULL(sunxi_dmic)) {
+		dev_err(&pdev->dev, "sunxi_dmic is NULL!\n");
+		return -ENOMEM;
+	}
+
+	dev_info(&pdev->dev, "%s start.\n", __func__);
+
+	dts_info = &sunxi_dmic->dts_info;
+	mem_info = &dts_info->mem_info;
+
+#ifdef CONFIG_SND_SUNXI_HIFI_DMIC_DEBUG
+	sysfs_remove_group(&pdev->dev.kobj, &dmic_debug_attr_group);
+#endif
+
+	cancel_work_sync(&(sunxi_dmic->trigger_work_capture));
+	destroy_workqueue(sunxi_dmic->wq_capture);
+
+	mutex_destroy(&sunxi_dmic->rpmsg_mutex_capture);
+
+	devm_iounmap(&pdev->dev, mem_info->membase);
+	devm_release_mem_region(&pdev->dev, mem_info->memregion->start,
+				resource_size(mem_info->memregion));
+	devm_kfree(&pdev->dev, sunxi_dmic);
+
+	platform_set_drvdata(pdev, NULL);
+
+	dev_info(&pdev->dev, "%s stop.\n", __func__);
+	return 0;
+}
+
+static const struct of_device_id sunxi_hifi_dmic_of_match[] = {
+	{ .compatible = "allwinner,sunxi-dmic", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, sunxi_hifi_dmic_of_match);
+
+static struct platform_driver sunxi_hifi_dmic_driver = {
+	.probe = sunxi_hifi_dmic_dev_probe,
+	.remove = __exit_p(sunxi_hifi_dmic_dev_remove),
+	.driver = {
+		.name = DRV_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_hifi_dmic_of_match,
+	},
+};
+module_platform_driver(sunxi_hifi_dmic_driver);
+
+MODULE_AUTHOR("yumingfeng <yumingfeng@allwinnertech.com>");
+MODULE_DESCRIPTION("SUNXI DMIC Machine ASoC HiFi driver");
+MODULE_ALIAS("platform:sunxi-dmic");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-dmic.h b/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-dmic.h
new file mode 100644
index 000000000..3bb5edcea
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-dmic.h
@@ -0,0 +1,62 @@
+/*
+ * sound\sunxi-rpaf\soc\sunxi\hifi-dsp\sunxi_dmic.h
+ *
+ * (C) Copyright 2019-2025
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * yumingfeng <yumingfeng@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __SUNXI_HIFI_DMIC_H
+#define __SUNXI_HIFI_DMIC_H
+
+#include "sunxi-hifi-pcm.h"
+
+struct sunxi_dmic_mem_info {
+	struct resource res;
+	void __iomem *membase;
+	struct resource *memregion;
+	struct regmap	*regmap;
+};
+
+struct sunxi_dmic_dts_info {
+	struct sunxi_dmic_mem_info mem_info;
+	/* eg:0 sndcodec; 1 snddmic; 2 snddaudio0; */
+	unsigned int dsp_card;
+	/* default is 0, for reserved */
+	unsigned int dsp_device;
+	/* value must be (2^n)Kbyte */
+	size_t capture_cma;
+	unsigned int rx_chmap;
+	unsigned int data_vol;
+};
+
+struct sunxi_dmic_info {
+	struct device *dev;
+	struct snd_soc_dai_driver dai_drv;
+	struct snd_soc_dai *cpu_dai;
+	struct sunxi_dmic_dts_info dts_info;
+	struct sunxi_dma_params capture_dma_param;
+	bool capture_en;
+	unsigned int chan_en;
+
+	/* for hifi */
+	unsigned int capturing;
+	char wq_capture_name[32];
+	struct mutex rpmsg_mutex_capture;
+	struct workqueue_struct *wq_capture;
+	struct work_struct trigger_work_capture;
+
+	struct msg_substream_package msg_capture;
+	struct msg_mixer_package msg_mixer;
+	struct msg_debug_package msg_debug;
+	struct snd_dsp_component dsp_capcomp;
+};
+#endif /* SUNXI_DMIC_H */
diff --git a/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-pcm.c b/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-pcm.c
new file mode 100644
index 000000000..bdfc3cec7
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-pcm.c
@@ -0,0 +1,454 @@
+/*
+ * sound\soc\sunxi\hifi-dsp\sunxi-hifi-pcm.c
+ *
+ * (C) Copyright 2019-2025
+ * AllWinner Technology Co., Ltd. <www.allwinnertech.com>
+ * yumingfeng <yumingfeng@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/dmaengine_pcm.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
+#include <asm/dma.h>
+#include "sunxi-hifi-pcm.h"
+#include "sunxi-hifi-cpudai.h"
+#include "sunxi-hifi-daudio.h"
+#include "sunxi-hifi-dmic.h"
+
+static u64 sunxi_pcm_mask = DMA_BIT_MASK(32);
+
+static struct snd_pcm_hardware sunxi_pcm_hardware = {
+	.info			= SNDRV_PCM_INFO_INTERLEAVED
+				| SNDRV_PCM_INFO_BLOCK_TRANSFER
+				| SNDRV_PCM_INFO_MMAP
+				| SNDRV_PCM_INFO_MMAP_VALID
+				| SNDRV_PCM_INFO_PAUSE
+				| SNDRV_PCM_INFO_RESUME
+				| SNDRV_PCM_INFO_DRAIN_TRIGGER,
+	.formats		= SNDRV_PCM_FMTBIT_S8
+				| SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE
+				| SNDRV_PCM_FMTBIT_S32_LE,
+	.rates			= SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+	.rate_min		= 8000,
+	.rate_max		= 48000,
+	.channels_min		= 1,
+	.channels_max		= 8,
+	/* value must be (2^n)Kbyte */
+	.buffer_bytes_max	= SUNXI_AUDIO_CMA_MAX_BYTES_MAX,
+	.period_bytes_min	= 256,
+	/* value must be (2^(n-1))Kbyte */
+	.period_bytes_max	= SUNXI_AUDIO_CMA_MAX_BYTES_MAX / 2,
+	.periods_min		= 2,
+	.periods_max		= 32,
+	.fifo_size		= 128,
+};
+
+int sunxi_dma_params_alloc_dma_area(struct snd_soc_dai *dai,
+						struct sunxi_dma_params *dma_params)
+{
+	size_t cma_bytes = SUNXI_AUDIO_CMA_BLOCK_BYTES;
+
+	cma_bytes = dma_params->cma_kbytes * SUNXI_AUDIO_CMA_BLOCK_BYTES;
+	if (cma_bytes > SUNXI_AUDIO_CMA_MAX_BYTES_MAX)
+		cma_bytes = SUNXI_AUDIO_CMA_MAX_BYTES_MAX;
+	if (cma_bytes < SUNXI_AUDIO_CMA_MAX_BYTES_MIN)
+		cma_bytes = SUNXI_AUDIO_CMA_MAX_BYTES_MIN;
+	dma_params->dma_area = dma_alloc_coherent(dai->dev, cma_bytes,
+					&dma_params->phy_addr, GFP_KERNEL);
+	if (!dma_params->dma_area) {
+		dev_err(dai->dev, "dmaengine alloc coherent failed.\n");
+		return -ENOMEM;
+	}
+//	dev_info(dai->dev, "dmaengine alloc coherent phy_addr:0x%x\n", dma_params->phy_addr);
+	dma_params->phy_bytes = cma_bytes;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sunxi_dma_params_alloc_dma_area);
+
+int sunxi_dma_params_free_dma_area(struct snd_soc_dai *dai,
+						struct sunxi_dma_params *dma_params)
+{
+
+	if (dma_params->dma_area)
+		dma_free_coherent(dai->dev, dma_params->phy_bytes,
+				dma_params->dma_area, dma_params->phy_addr);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sunxi_dma_params_free_dma_area);
+
+static int sunxi_hifi_pcm_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct device *dev = rtd->dev;
+
+	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+	dev_info(dev, "%s\n", __func__);
+	return 0;
+}
+
+static int sunxi_hifi_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct device *dev = rtd->dev;
+
+	snd_pcm_set_runtime_buffer(substream, NULL);
+	dev_info(dev, "%s\n", __func__);
+	return 0;
+}
+
+static int sunxi_hifi_pcm_prepare_and_submit(struct snd_pcm_substream *substream)
+{
+	struct dmaengine_pcm_runtime_data *prtd = substream->runtime->private_data;
+
+	prtd->pos = 0;
+
+	return 0;
+}
+
+static int sunxi_hifi_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		sunxi_hifi_pcm_prepare_and_submit(substream);
+		break;
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		break;
+	}
+	return 0;
+}
+
+static const char * const dmaengine_pcm_dma_channel_names[] = {
+		[SNDRV_PCM_STREAM_PLAYBACK] = "tx",
+		[SNDRV_PCM_STREAM_CAPTURE] = "rx",
+};
+
+static int sunxi_hifi_pcm_open(struct snd_pcm_substream *substream)
+{
+	int ret = 0;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct dmaengine_pcm_runtime_data *prtd;
+	struct device *dev = rtd->dev;
+	struct sunxi_dma_params *dma_params = NULL;
+
+	dma_params = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
+	if (IS_ERR_OR_NULL(dma_params)) {
+		dev_err(dev, "dma_params is null.\n");
+		return -EFAULT;
+	}
+	/* Set HW params now that initialization is complete */
+	sunxi_pcm_hardware.buffer_bytes_max = dma_params->cma_kbytes *
+					SUNXI_AUDIO_CMA_BLOCK_BYTES;
+	sunxi_pcm_hardware.period_bytes_max = sunxi_pcm_hardware.buffer_bytes_max / 2;
+	sunxi_pcm_hardware.fifo_size = dma_params->fifo_size;
+
+	snd_soc_set_runtime_hwparams(substream, &sunxi_pcm_hardware);
+	ret = snd_pcm_hw_constraint_integer(substream->runtime,
+							SNDRV_PCM_HW_PARAM_PERIODS);
+	if (ret < 0) {
+		dev_err(dev, "hw constraint integer failed with err %d\n", ret);
+		return ret;
+	}
+
+	prtd = kzalloc(sizeof(*prtd), GFP_KERNEL);
+	if (!prtd)
+		return -ENOMEM;
+
+	prtd->dma_chan = NULL;
+
+	substream->runtime->private_data = prtd;
+
+	return 0;
+}
+
+static int sunxi_hifi_pcm_mmap(struct snd_pcm_substream *substream,
+		struct vm_area_struct *vma)
+{
+	struct snd_pcm_runtime *runtime = NULL;
+
+	if (substream->runtime != NULL) {
+		runtime = substream->runtime;
+
+		return dma_mmap_wc(substream->pcm->card->dev, vma,
+				runtime->dma_area,
+				runtime->dma_addr,
+				runtime->dma_bytes);
+	} else {
+		pr_err("substream->runtime is NULL!\n");
+		return -1;
+	}
+
+}
+
+static int sunxi_hifi_pcm_copy(struct snd_pcm_substream *substream, int a,
+	 snd_pcm_uframes_t hwoff, void __user *buf, snd_pcm_uframes_t frames)
+{
+	char *hwbuf;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct device *dev = rtd->dev;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		hwbuf = runtime->dma_area + frames_to_bytes(runtime, hwoff);
+		if (copy_from_user(hwbuf, buf, frames_to_bytes(runtime, frames))) {
+			dev_err(dev, "copy_from_user failed.\n");
+			return -EFAULT;
+		}
+	} else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		hwbuf = runtime->dma_area + frames_to_bytes(runtime, hwoff);
+		if (copy_to_user(buf, hwbuf, frames_to_bytes(runtime, frames))) {
+			dev_err(dev, "copy_to_user failed.\n");
+			return -EFAULT;
+		}
+	}
+
+	return 0;
+}
+
+static int sunxi_hifi_pcm_daudio_copy(struct snd_pcm_substream *substream, int a,
+	 snd_pcm_uframes_t hwoff, void __user *buf, snd_pcm_uframes_t frames)
+{
+	char *hwbuf;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+//	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+//	struct snd_soc_platform *platform = rtd->platform;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		hwbuf = runtime->dma_area + frames_to_bytes(runtime, hwoff);
+		if (copy_from_user(hwbuf, buf, frames_to_bytes(runtime, frames))) {
+//			dev_err(platform->dev, "copy_from_user failed.\n");
+			pr_err("[%s] -> copy_from_user failed.\n", __func__);
+			return -EFAULT;
+		}
+
+//		dev_dbg_ratelimited(platform->dev, "copy_from_user hwoff:%lu, frames:%lu.\n", hwoff, frames);
+		pr_err("[%s] -> copy_from_user hwoff:%lu, frames:%lu.\n", __func__, hwoff, frames);
+	} else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		hwbuf = runtime->dma_area + frames_to_bytes(runtime, hwoff);
+		if (copy_to_user(buf, hwbuf, frames_to_bytes(runtime, frames))) {
+//			dev_err(platform->dev, "copy_to_user failed.\n");
+			pr_err("[%s] -> copy_to_user failed.\n", __func__);
+			return -EFAULT;
+		}
+//		dev_dbg_ratelimited(platform->dev, "copy_to_user hwoff:%lu, frames:%lu.\n", hwoff, frames);
+		pr_err("[%s] -> copy_to_user hwoff:%lu, frames:%lu.\n", __func__, hwoff, frames);
+	}
+
+	return 0;
+}
+
+/* dsp */
+static snd_pcm_uframes_t sunxi_hifi_pcm_pointer(struct snd_pcm_substream *substream)
+{
+	return snd_dmaengine_pcm_pointer_no_residue(substream);
+}
+
+static int sunxi_hifi_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	return 0;
+}
+
+static int sunxi_hifi_pcm_close(struct snd_pcm_substream *substream)
+{
+	struct dmaengine_pcm_runtime_data *prtd = substream->runtime->private_data;
+
+	kfree(prtd);
+
+	return 0;
+}
+
+static struct snd_pcm_ops sunxi_hifi_pcm_ops = {
+	.open		= sunxi_hifi_pcm_open,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= sunxi_hifi_pcm_hw_params,
+	.prepare    = sunxi_hifi_pcm_prepare,
+	.trigger	= sunxi_hifi_pcm_trigger,
+	.pointer	= sunxi_hifi_pcm_pointer,
+	.mmap		= sunxi_hifi_pcm_mmap,
+	.copy_user	= sunxi_hifi_pcm_copy,
+	.hw_free	= sunxi_hifi_pcm_hw_free,
+	.close		= sunxi_hifi_pcm_close,
+};
+
+static struct snd_pcm_ops sunxi_hifi_pcm_ops_daudio = {
+	.open		= sunxi_hifi_pcm_open,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= sunxi_hifi_pcm_hw_params,
+	.prepare    = sunxi_hifi_pcm_prepare,
+	.trigger	= sunxi_hifi_pcm_trigger,
+	.pointer	= sunxi_hifi_pcm_pointer,
+	.mmap		= sunxi_hifi_pcm_mmap,
+	.copy_user	= sunxi_hifi_pcm_daudio_copy,
+	.hw_free	= sunxi_hifi_pcm_hw_free,
+	.close		= sunxi_hifi_pcm_close,
+};
+
+static int sunxi_hifi_pcm_preallocate_stream_dma_buffer(struct snd_pcm *pcm,
+			int stream, size_t buffer_bytes_max)
+{
+	struct snd_pcm_str *streams = NULL;
+	struct snd_pcm_substream *substream = NULL;
+	struct snd_dma_buffer *dma_buf = NULL;
+
+	streams = &pcm->streams[stream];
+	if (IS_ERR_OR_NULL(streams)) {
+		pr_err("[%s] stream=%d streams is null!\n", __func__, stream);
+		return -EFAULT;
+	}
+	substream = pcm->streams[stream].substream;
+	if (IS_ERR_OR_NULL(substream)) {
+		pr_err("[%s] stream=%d substream is null!\n", __func__, stream);
+		return -EFAULT;
+	}
+	dma_buf = &substream->dma_buffer;
+	dma_buf->dev.type = SNDRV_DMA_TYPE_DEV;
+	dma_buf->dev.dev = pcm->card->dev;
+	dma_buf->private_data = NULL;
+	if (buffer_bytes_max > SUNXI_AUDIO_CMA_MAX_BYTES_MAX)
+		buffer_bytes_max = SUNXI_AUDIO_CMA_MAX_BYTES_MAX;
+	if (buffer_bytes_max < SUNXI_AUDIO_CMA_MAX_BYTES_MIN)
+		buffer_bytes_max = SUNXI_AUDIO_CMA_MAX_BYTES_MIN;
+
+	dma_buf->area = dma_alloc_coherent(pcm->card->dev, buffer_bytes_max,
+					&dma_buf->addr, GFP_KERNEL);
+	if (!dma_buf->area) {
+		dev_err(pcm->card->dev, "dmaengine alloc coherent failed.\n");
+		return -ENOMEM;
+	}
+	dma_buf->bytes = buffer_bytes_max;
+
+	return 0;
+}
+
+static void sunxi_hifi_pcm_free_dma_buffers(struct snd_pcm *pcm)
+{
+	struct snd_pcm_substream *substream;
+	struct snd_dma_buffer *dma_buf;
+	int stream;
+
+	for (stream = 0; stream < 2; stream++) {
+		substream = pcm->streams[stream].substream;
+		if (!substream)
+			continue;
+
+		dma_buf = &substream->dma_buffer;
+		if (!dma_buf->area)
+			continue;
+
+		dma_free_coherent(pcm->card->dev, dma_buf->bytes,
+				dma_buf->area, dma_buf->addr);
+		dma_buf->area = NULL;
+	}
+}
+
+static int sunxi_hifi_pcm_new(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_card *card = rtd->card->snd_card;
+	struct snd_soc_dai_link *dai_link = rtd->dai_link;
+	struct snd_pcm *pcm = rtd->pcm;
+	struct device *dev = rtd->dev;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct sunxi_dma_params *playback_dma_data = cpu_dai->playback_dma_data;
+	struct sunxi_dma_params *capture_dma_data = cpu_dai->capture_dma_data;
+	size_t capture_cma_bytes = SUNXI_AUDIO_CMA_BLOCK_BYTES;
+	size_t playback_cma_bytes = SUNXI_AUDIO_CMA_BLOCK_BYTES;
+	int ret = 0;
+
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &sunxi_pcm_mask;
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = 0xffffffff;
+
+	if (!IS_ERR_OR_NULL(playback_dma_data))
+		playback_cma_bytes *= playback_dma_data->cma_kbytes;
+	if (!IS_ERR_OR_NULL(capture_dma_data))
+		capture_cma_bytes *= capture_dma_data->cma_kbytes;
+
+	if (dai_link->playback_only) {
+		ret = sunxi_hifi_pcm_preallocate_stream_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_PLAYBACK, playback_cma_bytes);
+		if (ret) {
+			dev_err(dev, "pcm new playback failed with err=%d\n", ret);
+			return ret;
+		}
+	} else if (dai_link->capture_only) {
+		ret = sunxi_hifi_pcm_preallocate_stream_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_CAPTURE, capture_cma_bytes);
+		if (ret) {
+			dev_err(dev, "pcm new capture failed with err=%d\n", ret);
+			return ret;
+		}
+	} else {
+		ret = sunxi_hifi_pcm_preallocate_stream_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_PLAYBACK, playback_cma_bytes);
+		if (ret) {
+			dev_err(dev, "[%s] pcm new playback failed with err=%d\n", pcm->id, ret);
+		}
+		ret = sunxi_hifi_pcm_preallocate_stream_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_CAPTURE, capture_cma_bytes);
+		if (ret) {
+			dev_err(dev, "[%s] pcm new capture failed with err=%d\n", pcm->id, ret);
+		}
+	}
+
+	return 0;
+}
+
+static struct snd_soc_component_driver sunxi_hifi_soc_platform[SUNXI_HIFI_PCM_OPS_MAX] = {
+	[SUNXI_HIFI_PCM_OPS_CODEC] = {
+		.ops		= &sunxi_hifi_pcm_ops,
+		.pcm_new	= sunxi_hifi_pcm_new,
+		.pcm_free	= sunxi_hifi_pcm_free_dma_buffers,
+	},
+	[SUNXI_HIFI_PCM_OPS_DAUDIO] = {
+		.ops		= &sunxi_hifi_pcm_ops_daudio,
+		.pcm_new	= sunxi_hifi_pcm_new,
+		.pcm_free	= sunxi_hifi_pcm_free_dma_buffers,
+	},
+	[SUNXI_HIFI_PCM_OPS_DMIC] = {
+		.ops		= &sunxi_hifi_pcm_ops,
+		.pcm_new	= sunxi_hifi_pcm_new,
+		.pcm_free	= sunxi_hifi_pcm_free_dma_buffers,
+	},
+};
+
+/*
+ * Register a platform driver with automatic unregistration when the device is
+ * unregistered.
+ */
+int asoc_hifi_platform_register(struct device *dev, unsigned int ops_type)
+{
+	if (ops_type >= SUNXI_HIFI_PCM_OPS_MAX)
+		return -EFAULT;
+	return devm_snd_soc_register_component(dev, &sunxi_hifi_soc_platform[ops_type], NULL, 0);
+}
+EXPORT_SYMBOL_GPL(asoc_hifi_platform_register);
+
+MODULE_AUTHOR("yumingfeng@allwinnertech.com");
+MODULE_DESCRIPTION("sunxi ASoC HiFi platform Driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-pcm.h b/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-pcm.h
new file mode 100644
index 000000000..fa8a0bbdf
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-pcm.h
@@ -0,0 +1,68 @@
+/* sound\soc\sunxi\hifi-dsp\sunxi-pcm.h
+ *
+ * (C) Copyright 2019-2025
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * yumingfeng <yumingfeng@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#ifndef __SUNXI_HIFI_PCM_H_
+#define __SUNXI_HIFI_PCM_H_
+
+#define SUNXI_AUDIO_CMA_BLOCK_BYTES 1024
+#define SUNXI_AUDIO_CMA_MAX_KBYTES 1024
+#define SUNXI_AUDIO_CMA_MIN_KBYTES 64
+#define SUNXI_AUDIO_CMA_MAX_BYTES_MAX \
+		(SUNXI_AUDIO_CMA_BLOCK_BYTES * SUNXI_AUDIO_CMA_MAX_KBYTES)
+#define SUNXI_AUDIO_CMA_MAX_BYTES_MIN \
+		(SUNXI_AUDIO_CMA_BLOCK_BYTES * SUNXI_AUDIO_CMA_MIN_KBYTES)
+
+#include <sound/pcm.h>
+#include <linux/dmaengine.h>
+#include <sound/aw_rpaf/common.h>
+#include <sound/aw_rpaf/mixer.h>
+#include <sound/aw_rpaf/debug.h>
+#include <sound/aw_rpaf/substream.h>
+#include <sound/aw_rpaf/component.h>
+#include <sound/aw_rpaf/component-core.h>
+
+/* sync from kernel/sound/core/pcm_dmaengine.c */
+struct dmaengine_pcm_runtime_data {
+	struct dma_chan *dma_chan;
+	dma_cookie_t cookie;
+
+	unsigned int pos;
+};
+
+struct sunxi_dma_params {
+	char *name;
+	dma_addr_t dma_addr;
+	/* value must be (2^n)Kbyte */
+	size_t cma_kbytes;
+	size_t fifo_size;
+
+	unsigned char *dma_area;/* virtual pointer */
+	dma_addr_t phy_addr;	/* physical address */
+	size_t phy_bytes;			/* buffer size in bytes */
+};
+
+enum sunxi_hifi_pcm_ops_type {
+	SUNXI_HIFI_PCM_OPS_CODEC = 0,
+	SUNXI_HIFI_PCM_OPS_DAUDIO = 1,
+	SUNXI_HIFI_PCM_OPS_DMIC = 2,
+	SUNXI_HIFI_PCM_OPS_MAX,
+};
+
+int sunxi_dma_params_alloc_dma_area(struct snd_soc_dai *dai,
+						struct sunxi_dma_params *dma_params);
+int sunxi_dma_params_free_dma_area(struct snd_soc_dai *dai,
+						struct sunxi_dma_params *dma_params);
+
+int asoc_hifi_platform_register(struct device *dev, unsigned int ops_type);
+#endif /* __SUNXI_PCM_H_ */
diff --git a/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-simple-card.c b/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-simple-card.c
new file mode 100644
index 000000000..56f21a4f4
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-simple-card.c
@@ -0,0 +1,523 @@
+/*
+ * ASoC simple sound card support
+ *
+ * Copyright (C) 2020 Renesas Solutions Corp.
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * based on ${LINUX}/sound/soc/generic/simple-card.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/gpio.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/platform_device.h>
+#include <linux/string.h>
+#include <sound/jack.h>
+#include <sound/simple_card.h>
+#include <sound/soc-dai.h>
+#include <sound/soc.h>
+
+#define DAI	"sound-dai"
+#define CELL	"#sound-dai-cells"
+#define PREFIX	"simple-audio-card,"
+
+static int asoc_simple_parse_dai(struct device_node *node,
+		struct snd_soc_dai_link_component *dlc,
+		int *is_single_link)
+{
+	struct of_phandle_args args;
+	int ret;
+
+	if (!node)
+		return 0;
+
+	/*
+	 * Get node via "sound-dai = <&phandle port>"
+	 * it will be used as xxx_of_node on soc_bind_dai_link()
+	 */
+	ret = of_parse_phandle_with_args(node, DAI, CELL, 0, &args);
+	if (ret)
+		return ret;
+
+	/*
+	 * FIXME
+	 *
+	 * Here, dlc->dai_name is pointer to CPU/Codec DAI name.
+	 * If user unbinded CPU or Codec driver, but not for Sound Card,
+	 * dlc->dai_name is keeping unbinded CPU or Codec
+	 * driver's pointer.
+	 *
+	 * If user re-bind CPU or Codec driver again, ALSA SoC will try
+	 * to rebind Card via snd_soc_try_rebind_card(), but because of
+	 * above reason, it might can't bind Sound Card.
+	 * Because Sound Card is pointing to released dai_name pointer.
+	 *
+	 * To avoid this rebind Card issue,
+	 * 1) It needs to alloc memory to keep dai_name eventhough
+	 *    CPU or Codec driver was unbinded, or
+	 * 2) user need to rebind Sound Card everytime
+	 *    if he unbinded CPU or Codec.
+	 */
+	ret = snd_soc_of_get_dai_name(node, &dlc->dai_name);
+	if (ret < 0)
+		return ret;
+
+	dlc->of_node = args.np;
+
+	if (is_single_link)
+		*is_single_link = !args.args_count;
+
+	return 0;
+}
+
+static int asoc_simple_card_startup(struct snd_pcm_substream *substream)
+{
+#if 0
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct asoc_simple_priv *priv =	snd_soc_card_get_drvdata(rtd->card);
+	struct simple_dai_props *dai_props =
+		simple_priv_to_props(priv, rtd->num);
+	int ret;
+
+	ret = clk_prepare_enable(dai_props->cpu_dai.clk);
+	if (ret)
+		return ret;
+
+	ret = clk_prepare_enable(dai_props->codec_dai.clk);
+	if (ret)
+		clk_disable_unprepare(dai_props->cpu_dai.clk);
+
+	return ret;
+#endif
+	return 0;
+}
+
+static void asoc_simple_card_shutdown(struct snd_pcm_substream *substream)
+{
+#if 0
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct asoc_simple_priv *priv =	snd_soc_card_get_drvdata(rtd->card);
+	struct simple_dai_props *dai_props =
+		simple_priv_to_props(priv, rtd->num);
+
+	clk_disable_unprepare(dai_props->cpu_dai.clk);
+
+	clk_disable_unprepare(dai_props->codec_dai.clk);
+#endif
+}
+
+static int asoc_simple_card_hw_params(struct snd_pcm_substream *substream,
+				      struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct asoc_simple_priv *priv = snd_soc_card_get_drvdata(rtd->card);
+	struct snd_soc_dai_link *dai_link = simple_priv_to_link(priv, rtd->num);//num is idx????
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	int ret, clk_div;
+	unsigned int freq;
+
+	switch (params_rate(params)) {
+	case 8000:
+	case 12000:
+	case 16000:
+	case 24000:
+	case 32000:
+	case 48000:
+	case 64000:
+	case 96000:
+	case 192000:
+		freq = 24576000;
+		break;
+	case 11025:
+	case 22050:
+	case 44100:
+	case 88200:
+	case 176400:
+		freq = 22579200;
+		break;
+	default:
+		dev_err(rtd->dev, "Invalid rate %d\n", params_rate(params));
+		return -EINVAL;
+	}
+
+	ret = snd_soc_dai_set_sysclk(codec_dai, 0, freq, SND_SOC_CLOCK_IN);
+	if (ret && ret != -ENOTSUPP) {
+		dev_err(rtd->dev, "cadec_dai set sysclk failed.\n");
+		return ret;
+	}
+	ret = snd_soc_dai_set_sysclk(cpu_dai, 0, freq, SND_SOC_CLOCK_OUT);
+	if (ret && ret != -ENOTSUPP) {
+		dev_err(rtd->dev, "cpu_dai set sysclk failed.\n");
+		return ret;
+	}
+
+	ret = snd_soc_dai_set_pll(codec_dai, 0, 0, freq, freq);
+	/* if (ret < 0) */
+	/* 	dev_warn(rtd->dev, "codec_dai set set_pll failed.\n"); */
+
+	/* set codec dai fmt */
+	ret = snd_soc_dai_set_fmt(codec_dai, dai_link->dai_fmt);
+	if (ret && ret != -ENOTSUPP)
+		dev_warn(rtd->dev, "codec dai set fmt failed\n");
+
+	/* set cpu dai fmt */
+	ret = snd_soc_dai_set_fmt(cpu_dai, dai_link->dai_fmt);
+	if (ret && ret != -ENOTSUPP)
+		dev_warn(rtd->dev, "cpu dai set fmt failed\n");
+
+	clk_div = freq/params_rate(params);
+
+	if (cpu_dai->driver->ops->set_clkdiv) {
+		ret = snd_soc_dai_set_clkdiv(cpu_dai, 0, clk_div);
+		if (ret < 0) {
+			dev_err(rtd->dev, "set clkdiv failed.\n");
+			return ret;
+		}
+	}
+
+	if (codec_dai->driver->ops->set_clkdiv) {
+		ret = snd_soc_dai_set_clkdiv(codec_dai, 0, clk_div);
+		if (ret < 0) {
+			dev_err(rtd->dev, "codec_dai set clkdiv failed\n");
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static struct snd_soc_ops asoc_simple_card_ops = {
+	.startup = asoc_simple_card_startup,
+	.shutdown = asoc_simple_card_shutdown,
+	.hw_params = asoc_simple_card_hw_params,
+};
+
+static int asoc_simple_card_dai_init(struct snd_soc_pcm_runtime *rtd)
+{
+#if 0
+	struct simple_card_data *priv =	snd_soc_card_get_drvdata(rtd->card);
+	struct snd_soc_dai *codec = rtd->codec_dai;
+	struct snd_soc_dai *cpu = rtd->cpu_dai;
+	struct simple_dai_props *dai_props =
+		simple_priv_to_props(priv, rtd->num);
+	int ret;
+
+	ret = asoc_simple_card_init_dai(codec, &dai_props->codec_dai);
+	if (ret < 0)
+		return ret;
+
+	ret = asoc_simple_card_init_dai(cpu, &dai_props->cpu_dai);
+	if (ret < 0)
+		return ret;
+
+	ret = asoc_simple_card_init_hp(rtd->card, &priv->hp_jack, PREFIX);
+	if (ret < 0)
+		return ret;
+
+	ret = asoc_simple_card_init_mic(rtd->card, &priv->mic_jack, PREFIX);
+	if (ret < 0)
+		return ret;
+#endif
+	return 0;
+}
+
+static int asoc_simple_card_dai_link_of(struct device_node *node,
+					struct asoc_simple_priv *priv,
+					int idx,
+					bool is_top_level_node)
+{
+	struct device *dev = simple_priv_to_dev(priv);
+	struct snd_soc_dai_link *dai_link = simple_priv_to_link(priv, idx);
+	struct device_node *cpu = NULL;
+	struct device_node *plat = NULL;
+	struct device_node *codec = NULL;
+	char prop[128];
+	char *prefix = "";
+	int ret, single_cpu;
+
+	/* For single DAI link & old style of DT node */
+	if (is_top_level_node)
+		prefix = PREFIX;
+
+	snprintf(prop, sizeof(prop), "%scpu", prefix);
+	cpu = of_get_child_by_name(node, prop);
+
+	if (!cpu) {
+		ret = -EINVAL;
+		dev_err(dev, "%s: Can't find %s DT node\n", __func__, prop);
+		goto dai_link_of_err;
+	}
+
+	snprintf(prop, sizeof(prop), "%splat", prefix);
+	plat = of_get_child_by_name(node, prop);
+
+	snprintf(prop, sizeof(prop), "%scodec", prefix);
+	codec = of_get_child_by_name(node, prop);
+
+	if (!codec) {
+		ret = -EINVAL;
+		dev_err(dev, "%s: Can't find %s DT node\n", __func__, prop);
+		goto dai_link_of_err;
+	}
+
+	ret = asoc_simple_parse_daifmt(dev, node, codec,
+				       prefix, &dai_link->dai_fmt);
+	if (ret < 0)
+		goto dai_link_of_err;
+
+	ret = asoc_simple_parse_cpu(cpu, dai_link, &single_cpu);
+	if (ret < 0)
+		goto dai_link_of_err;
+
+	ret = asoc_simple_parse_codec(codec, dai_link);
+	if (ret < 0) {
+		dai_link->codecs->name = "snd-soc-dummy";
+		dai_link->codecs->dai_name = "snd-soc-dummy-dai";
+	}
+
+	ret = asoc_simple_parse_platform(plat, dai_link);
+	if (ret < 0)
+		goto dai_link_of_err;
+
+	ret = asoc_simple_set_dailink_name(dev, dai_link,
+					   "%s-%s",
+					   dai_link->cpus->dai_name,
+					   dai_link->codecs->dai_name);
+	if (ret < 0)
+		goto dai_link_of_err;
+
+	dai_link->ops = &asoc_simple_card_ops;
+	dai_link->init = asoc_simple_card_dai_init;
+
+	dev_dbg(dev, "\tname : %s\n", dai_link->stream_name);
+	dev_dbg(dev, "\tformat : %04x\n", dai_link->dai_fmt);
+	dev_dbg(dev, "\tcpu : %s \n",
+		dai_link->cpus->name);
+	dev_dbg(dev, "\tcodec : %s \n",
+		dai_link->codecs->name);
+
+	asoc_simple_canonicalize_cpu(dai_link, single_cpu);
+	asoc_simple_canonicalize_platform(dai_link);
+
+dai_link_of_err:
+	of_node_put(cpu);
+	of_node_put(codec);
+
+	return ret;
+}
+
+static int asoc_simple_card_parse_of(struct device_node *node,
+				     struct asoc_simple_priv *priv)
+{
+	struct device *dev = simple_priv_to_dev(priv);
+	struct device_node *dai_link;
+	int ret;
+
+	if (!node)
+		return -EINVAL;
+
+	/* The off-codec widgets */
+	ret = asoc_simple_parse_widgets(&priv->snd_card, PREFIX);
+	if (ret < 0)
+		return ret;
+
+	/* DAPM routes */
+	ret = asoc_simple_parse_routing(&priv->snd_card, PREFIX);
+	if (ret < 0)
+		return ret;
+
+	ret = asoc_simple_parse_pin_switches(&priv->snd_card, PREFIX);
+	if (ret < 0)
+		return ret;
+
+	dai_link = of_get_child_by_name(node, PREFIX "dai-link");
+	/* Single/Muti DAI link(s) & New style of DT node */
+	if (dai_link) {
+		struct device_node *np = NULL;
+		int i = 0;
+
+		for_each_child_of_node(node, np) {
+			dev_dbg(dev, "\tlink %d:\n", i);
+			ret = asoc_simple_card_dai_link_of(np, priv,
+							   i, false);
+			if (ret < 0) {
+				of_node_put(np);
+				goto card_parse_end;
+			}
+			i++;
+		}
+	} else {
+		/* For single DAI link & old style of DT node */
+		ret = asoc_simple_card_dai_link_of(node, priv, 0, true);
+		if (ret < 0)
+			goto card_parse_end;
+	}
+
+	ret = asoc_simple_parse_card_name(&priv->snd_card, PREFIX);
+
+card_parse_end:
+	of_node_put(dai_link);
+
+	return ret;
+}
+
+static int sunxi_hdmiaudio_set_audio_mode(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	struct asoc_simple_priv *priv =
+				snd_soc_card_get_drvdata(card);
+
+	priv->hdmi_format = ucontrol->value.integer.value[0];
+	return 0;
+}
+
+static int sunxi_hdmiaudio_get_audio_mode(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	struct asoc_simple_priv *priv =
+				snd_soc_card_get_drvdata(card);
+
+	ucontrol->value.integer.value[0] = priv->hdmi_format;
+	return 0;
+}
+
+static const char *hdmiaudio_format_function[] = {"NULL", "PCM", "AC3",
+		"MPEG1", "MP3", "MPEG2", "AAC", "DTS", "ATRAC", "ONE_BIT_AUDIO",
+		"DOLBY_DIGITAL_PLUS", "DTS_HD", "MAT", "WMAPRO"};
+
+static const struct soc_enum hdmiaudio_format_enum[] = {
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(hdmiaudio_format_function),
+			hdmiaudio_format_function),
+};
+
+/* pcm dts ac3 Audio Mode Select */
+static const struct snd_kcontrol_new sunxi_hdmiaudio_controls[] = {
+	SOC_ENUM_EXT("hdmi audio format Function", hdmiaudio_format_enum[0],
+		sunxi_hdmiaudio_get_audio_mode, sunxi_hdmiaudio_set_audio_mode),
+};
+
+static int simple_soc_probe(struct snd_soc_card *card)
+{
+	/* struct asoc_simple_priv *priv = snd_soc_card_get_drvdata(card); */
+	int ret;
+
+	if (strstr(card->dev->of_node->name, "sndhdmi")) {
+		ret = snd_soc_add_card_controls(card, sunxi_hdmiaudio_controls,
+					ARRAY_SIZE(sunxi_hdmiaudio_controls));
+		if (ret)
+			dev_warn(card->dev,
+				"Failed to register audio hdmi mode control.\n");
+	} else if (strstr(card->dev->of_node->name, "dmic")) {
+		/* dmic only have capture function */
+		card->dai_link->capture_only = 1;
+	}
+#if 0
+	ret = asoc_simple_init_hp(card, &priv->hp_jack, PREFIX);
+	if (ret < 0)
+		return ret;
+
+	ret = asoc_simple_init_mic(card, &priv->mic_jack, PREFIX);
+	if (ret < 0)
+		return ret;
+#endif
+	return 0;
+}
+
+static int asoc_simple_card_probe(struct platform_device *pdev)
+{
+	struct asoc_simple_priv *priv;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct snd_soc_card *card;
+	struct link_info li;
+	int ret;
+
+	/* Allocate the private data and the DAI link array */
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	card = simple_priv_to_card(priv);
+	card->owner		= THIS_MODULE;
+	card->dev		= dev;
+	card->probe		= simple_soc_probe;
+
+	memset(&li, 0, sizeof(li));
+
+	/* Get the number of DAI links */
+	if (np && of_get_child_by_name(np, PREFIX "dai-link"))
+		li.link = of_get_child_count(np);
+	else
+		li.link = 1;
+
+	ret = asoc_simple_init_priv(priv, &li);
+	if (ret < 0)
+		return ret;
+
+	if (np && of_device_is_available(np)) {
+
+		ret = asoc_simple_card_parse_of(np, priv);
+		if (ret < 0) {
+			if (ret != -EPROBE_DEFER)
+				dev_err(dev, "parse error %d\n", ret);
+			goto err;
+		}
+
+	} else {
+		dev_err(dev, "simple card dts available\n");
+	}
+
+	snd_soc_card_set_drvdata(&priv->snd_card, priv);
+
+	/* asoc_simple_debug_info(priv); */
+	ret = devm_snd_soc_register_card(&pdev->dev, &priv->snd_card);
+	if (ret >= 0)
+		return ret;
+err:
+	asoc_simple_clean_reference(&priv->snd_card);
+
+	return ret;
+}
+
+static int asoc_simple_card_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+	/* struct asoc_simple_priv *priv = snd_soc_card_get_drvdata(card); */
+
+	/* asoc_simple_card_remove_jack(&priv->hp_jack); */
+	/* asoc_simple_card_remove_jack(&priv->mic_jack); */
+
+	return asoc_simple_clean_reference(card);
+}
+
+static const struct of_device_id asoc_simple_of_match[] = {
+	{ .compatible = "sunxi,simple-audio-card", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, asoc_simple_of_match);
+
+static struct platform_driver asoc_simple_card = {
+	.driver = {
+		.name = "sunxi-audio-card",
+		.pm = &snd_soc_pm_ops,
+		.of_match_table = asoc_simple_of_match,
+	},
+	.probe = asoc_simple_card_probe,
+	.remove = asoc_simple_card_remove,
+};
+
+module_platform_driver(asoc_simple_card);
+
+MODULE_AUTHOR("bantao@allwinnertech.com>");
+MODULE_ALIAS("platform:asoc-simple-card");
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("ASoC Simple Sound Card");
diff --git a/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-sndcodec.c b/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-sndcodec.c
new file mode 100644
index 000000000..65dad4985
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-sndcodec.c
@@ -0,0 +1,186 @@
+/*
+ * sound\soc\sunxi\hifi-dsp\sunxi-sndcodec.c
+ *
+ * (C) Copyright 2019-2025
+ * allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * yumingfeng <yumingfeng@allwinnetech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/io.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <linux/of.h>
+#include <sound/pcm_params.h>
+
+#include "sunxi-hifi-sndcodec.h"
+
+static int sunxi_hifi_sndcodec_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_card *card = rtd->card;
+
+	dev_info(card->dev, "%s\n", __func__);
+	return 0;
+}
+
+static int sunxi_hifi_sndcodec_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_card *card = rtd->card;
+
+	dev_info(card->dev, "%s\n", __func__);
+	return 0;
+}
+
+static void sunxi_hifi_sndcodec_shutdown(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_card *card = rtd->card;
+
+	dev_info(card->dev, "%s\n", __func__);
+}
+
+/*
+ * Card initialization
+ */
+static int sunxi_hifi_sndcodec_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_card *card = rtd->card;
+
+	dev_info(card->dev, "%s\n", __func__);
+	return 0;
+}
+
+static struct snd_soc_ops sunxi_hifi_sndcodec_ops = {
+	.startup = sunxi_hifi_sndcodec_startup,
+	.hw_params	= sunxi_hifi_sndcodec_hw_params,
+	.shutdown = sunxi_hifi_sndcodec_shutdown,
+};
+
+SND_SOC_DAILINK_DEFS(sunxi_hifi_dai_link,
+	DAILINK_COMP_ARRAY(COMP_CPU("sunxi-dummy-cpudai")),
+	DAILINK_COMP_ARRAY(COMP_CODEC("sunxi-internal-codec", "sunxi-hifi-codec")),
+	DAILINK_COMP_ARRAY(COMP_PLATFORM("sunxi-dummy-cpudai")));
+
+static struct snd_soc_dai_link sunxi_hifi_sndcodec_dai_link = {
+	.name		= "audiocodec",
+	.stream_name	= "SUNXI-CODEC",
+	.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF
+			| SND_SOC_DAIFMT_CBM_CFM,
+	.init		= sunxi_hifi_sndcodec_init,
+	.ops		= &sunxi_hifi_sndcodec_ops,
+	SND_SOC_DAILINK_REG(sunxi_hifi_dai_link),
+};
+
+static int sunxi_hifi_sndcodec_suspend(struct snd_soc_card *card)
+{
+	return 0;
+}
+
+static int sunxi_hifi_sndcodec_resume(struct snd_soc_card *card)
+{
+	return 0;
+}
+
+static struct snd_soc_card snd_soc_sunxi_hifi_sndcodec = {
+	.name		= "audiocodec",
+	.owner		= THIS_MODULE,
+	.dai_link	= &sunxi_hifi_sndcodec_dai_link,
+	.num_links	= 1,
+	.suspend_post	= sunxi_hifi_sndcodec_suspend,
+	.resume_post	= sunxi_hifi_sndcodec_resume,
+};
+
+static int sunxi_hifi_sndcodec_dev_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct snd_soc_card *card = &snd_soc_sunxi_hifi_sndcodec;
+	struct sunxi_sndcodec_priv *sndcodec_priv;
+	struct snd_soc_dai_link *dai_link = &sunxi_hifi_sndcodec_dai_link;
+	int ret = 0;
+
+	sndcodec_priv = devm_kzalloc(&pdev->dev,
+		sizeof(struct sunxi_sndcodec_priv), GFP_KERNEL);
+	if (!sndcodec_priv)
+		return -ENOMEM;
+
+	/* dai link */
+	dai_link->cpus->dai_name = NULL;
+	dai_link->cpus->of_node = of_parse_phandle(np,
+					"sunxi,cpudai-controller", 0);
+	if (!dai_link->cpus->of_node) {
+		dev_err(&pdev->dev, "Property 'sunxi,cpudai-controller' missing or invalid\n");
+		ret = -EINVAL;
+		goto err_devm_kfree;
+	} else {
+		dai_link->platforms->name = NULL;
+		dai_link->platforms->of_node = dai_link->cpus->of_node;
+	}
+	dai_link->codecs->name = NULL;
+	dai_link->codecs->of_node = of_parse_phandle(np,
+						"sunxi,audio-codec", 0);
+	if (!dai_link->codecs->of_node) {
+		dev_err(&pdev->dev, "Property 'sunxi,audio-codec' missing or invalid\n");
+		ret = -EINVAL;
+		goto err_devm_kfree;
+	}
+
+	/* register the soc card */
+	card->dev = &pdev->dev;
+
+	snd_soc_card_set_drvdata(card, sndcodec_priv);
+	ret = snd_soc_register_card(card);
+	if (ret) {
+		dev_err(&pdev->dev, "snd_soc_register_card failed %d\n", ret);
+		goto err_devm_kfree;
+	}
+
+	return 0;
+
+err_devm_kfree:
+	devm_kfree(&pdev->dev, sndcodec_priv);
+	return ret;
+}
+
+static int __exit sunxi_hifi_sndcodec_dev_remove(struct platform_device *pdev)
+{
+	struct sunxi_sndcodec_priv *sndcodec_priv = dev_get_drvdata(&pdev->dev);
+
+	snd_soc_unregister_card(&snd_soc_sunxi_hifi_sndcodec);
+	devm_kfree(&pdev->dev, sndcodec_priv);
+
+	return 0;
+}
+
+static const struct of_device_id sunxi_card_of_match[] = {
+	{ .compatible = "allwinner,sunxi-codec-machine", },
+	{},
+};
+
+static struct platform_driver sunxi_machine_driver = {
+	.driver = {
+		.name = "sunxi-codec-machine",
+		.owner = THIS_MODULE,
+		.pm = &snd_soc_pm_ops,
+		.of_match_table = sunxi_card_of_match,
+	},
+	.probe = sunxi_hifi_sndcodec_dev_probe,
+	.remove = __exit_p(sunxi_hifi_sndcodec_dev_remove),
+};
+
+module_platform_driver(sunxi_machine_driver);
+
+MODULE_AUTHOR("yumingfeng <yumingfeng@allwinnertech.com>");
+MODULE_DESCRIPTION("SUNXI Codec Machine ASoC HiFi driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:sunxi-codec-machine");
diff --git a/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-sndcodec.h b/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-sndcodec.h
new file mode 100644
index 000000000..d1e42a9ee
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-rpaf/sunxi-hifi/sunxi-hifi-sndcodec.h
@@ -0,0 +1,31 @@
+/*
+ * sound\soc\sunxi\hifi-dsp\sunxi-sndcodec.h
+ *
+ * (C) Copyright 2019-2025
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * yumingfeng <yumingfeng@allwinertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef	__SUNXI_SNDCODEC_H_
+#define	__SUNXI_SNDCODEC_H_
+
+#include "sunxi-hifi-codec.h"
+
+enum sunxi_sndcodec_div_id {
+	CODEC_DIV_PLAYBACK = 0,
+	CODEC_DIV_CAPTURE = 1,
+};
+
+struct sunxi_sndcodec_priv {
+	struct snd_soc_card *card;
+};
+
+#endif
diff --git a/sound/soc/sunxi/sunxi-rx-sync.c b/sound/soc/sunxi/sunxi-rx-sync.c
new file mode 100644
index 000000000..ebeee1211
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-rx-sync.c
@@ -0,0 +1,256 @@
+/*
+ * sound\soc\sunxi\sunxi-rx-sync.c
+ * (C) Copyright 2014-2018
+ * AllWinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+/*#define DEBUG*/
+#include <linux/module.h>
+#include <linux/init.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include "sunxi-rx-sync.h"
+
+#define RX_SYNC_DEV_MAX 8
+
+typedef void (*enable_func)(void *data, bool enable);
+
+typedef struct {
+	void *data;
+	/*enable_func route_enable;*/
+	enable_func rx_enable;
+} rx_sync_dev_t;
+
+static struct {
+	rx_sync_dev_t dev_info[RX_SYNC_DOMAIN_CNT][RX_SYNC_DEV_MAX];
+	int total_count[RX_SYNC_DOMAIN_CNT];
+	int enabled_count[RX_SYNC_DOMAIN_CNT];
+	rx_sync_dev_t *last_enabled_dev[RX_SYNC_DOMAIN_CNT];
+} rx_sync_data;
+
+DEFINE_SPINLOCK(rx_sync_lock);
+
+/* Return the rx_sync id. The id is unique in its own domain. */
+int sunxi_rx_sync_probe(rx_sync_domain_t domain)
+{
+	int ret = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&rx_sync_lock, flags);
+	rx_sync_data.total_count[domain]++;
+	pr_debug("[%s] line:%d domain=%d, total_count=%d\n", __func__, __LINE__,
+			domain, rx_sync_data.total_count[domain]);
+	if (rx_sync_data.total_count[domain] > RX_SYNC_DEV_MAX) {
+		pr_err("[%s] line:%d domain=%d, too many rx_sync devices "
+				"(current=%d, max=%d)\n", __func__, __LINE__, domain,
+				rx_sync_data.total_count[domain], RX_SYNC_DEV_MAX);
+		ret = -EINVAL;
+		goto unlock;
+	}
+	/* Use total_count to define rx_sync id */
+	ret = rx_sync_data.total_count[domain] - 1;
+unlock:
+	spin_unlock_irqrestore(&rx_sync_lock, flags);
+	return ret;
+}
+EXPORT_SYMBOL(sunxi_rx_sync_probe);
+
+void sunxi_rx_sync_remove(rx_sync_domain_t domain)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&rx_sync_lock, flags);
+	rx_sync_data.total_count[domain]--;
+	pr_debug("[%s] line:%d domain=%d, total_count=%d\n", __func__, __LINE__,
+			domain, rx_sync_data.total_count[domain]);
+	if (rx_sync_data.total_count[domain] < 0)
+		rx_sync_data.total_count[domain] = 0;
+	spin_unlock_irqrestore(&rx_sync_lock, flags);
+}
+EXPORT_SYMBOL(sunxi_rx_sync_remove);
+
+void sunxi_rx_sync_startup(void *data, rx_sync_domain_t domain, int id,
+		/*void (*route_enable)(void *data, bool enable),*/
+		void (*rx_enable)(void *data, bool enable))
+{
+	unsigned long flags;
+
+	if (id < 0 || id >= RX_SYNC_DEV_MAX)
+		return;
+
+	spin_lock_irqsave(&rx_sync_lock, flags);
+	rx_sync_data.dev_info[domain][id].data = data;
+	/*rx_sync_data.dev_info[domain][id].route_enable = route_enable;*/
+	rx_sync_data.dev_info[domain][id].rx_enable = rx_enable;
+
+	pr_debug("[%s] line:%d domain=%d, id=%d\n", __func__, __LINE__, domain, id);
+	spin_unlock_irqrestore(&rx_sync_lock, flags);
+}
+EXPORT_SYMBOL(sunxi_rx_sync_startup);
+
+void sunxi_rx_sync_shutdown(rx_sync_domain_t domain, int id)
+{
+	unsigned long flags;
+	int i;
+	int enabled_count = 0;
+
+	if (id < 0 || id >= RX_SYNC_DEV_MAX)
+		return;
+
+	spin_lock_irqsave(&rx_sync_lock, flags);
+	pr_debug("[%s] line:%d domian=%d, id=%d, enabled_count=%d\n", __func__, __LINE__,
+			domain, id, rx_sync_data.enabled_count[domain]);
+
+	/*
+	 * Ensure that only if all devices in all domains have been disabled,
+	 * the rx_sync_data could be reset.
+	 */
+	for (i = 0; i < RX_SYNC_DOMAIN_CNT; i++)
+		enabled_count += rx_sync_data.enabled_count[i];
+	if (enabled_count > 0)
+		goto unlock;
+	pr_debug("[%s] line:%d domian=%d, id=%d, sum of enabled_count is %d, reset rx_sync_data\n",
+			__func__, __LINE__, domain, id, enabled_count);
+	memset(rx_sync_data.dev_info, 0,
+			sizeof(rx_sync_dev_t) * RX_SYNC_DOMAIN_CNT * RX_SYNC_DEV_MAX);
+	for (i = 0; i < RX_SYNC_DOMAIN_CNT; i++)
+		rx_sync_data.last_enabled_dev[i] = NULL;
+
+unlock:
+	spin_unlock_irqrestore(&rx_sync_lock, flags);
+}
+EXPORT_SYMBOL(sunxi_rx_sync_shutdown);
+
+void sunxi_rx_sync_control(rx_sync_domain_t domain, int id, bool enable)
+{
+	unsigned long flags;
+	int i, j;
+	int total_count = 0;
+	int enabled_count = 0;
+
+	pr_debug("[%s] line:%d domain=%d, id=%d, enable=%d, enabled_count=%d\n",
+			__func__, __LINE__, domain, id, enable,
+			rx_sync_data.enabled_count[domain]);
+	if (id < 0 || id >= RX_SYNC_DEV_MAX)
+		return;
+
+	spin_lock_irqsave(&rx_sync_lock, flags);
+	if (enable) {
+		rx_sync_data.enabled_count[domain]++;
+		/*
+		 * Store the pointer of last enabled device.
+		 */
+		if (rx_sync_data.enabled_count[domain] == rx_sync_data.total_count[domain]) {
+			rx_sync_data.last_enabled_dev[domain] = &rx_sync_data.dev_info[domain][id];
+			pr_debug("[%s] line:%d domain=%d, id=%d, last_enabled_dev=0x%p\n",
+					__func__, __LINE__, domain, id,
+					rx_sync_data.last_enabled_dev[domain]);
+		} else if (rx_sync_data.enabled_count[domain] > rx_sync_data.total_count[domain]) {
+			pr_err("[%s] line:%d domain=%d, enabled_count(%d) is more than "
+				"total_count(%d). %s was called incorrectly?\n",
+				__func__, __LINE__, domain, rx_sync_data.enabled_count[domain],
+				rx_sync_data.total_count[domain], __func__);
+			goto unlock;
+		}
+
+		/*
+		 * Check all devices in all domains. Only if the last device in
+		 * all domains runs here, we will run route_enable(1) in all devices,
+		 * and rx_enable(1) in only the last device in each domain.
+		 */
+		for (i = 0; i < RX_SYNC_DOMAIN_CNT; i++) {
+			total_count += rx_sync_data.total_count[i];
+			enabled_count += rx_sync_data.enabled_count[i];
+		}
+		if (enabled_count < total_count) {
+			goto unlock;
+		} else if (enabled_count > total_count) {
+			pr_err("[%s] line:%d, sum of enabled_count(%d) is more than "
+				"total_count(%d). %s was called incorrectly?\n",
+				__func__, __LINE__, enabled_count, total_count, __func__);
+			goto unlock;
+		}
+#if 0
+		for (i = 0; i < RX_SYNC_DOMAIN_CNT; i++) {
+			for (j = 0; j < rx_sync_data.total_count[i]; j++) {
+				void *data = rx_sync_data.dev_info[i][j].data;
+
+				pr_debug("[%s] line:%d domain=%d, id=%d, route enable\n",
+					__func__, __LINE__, i, j);
+				rx_sync_data.dev_info[i][j].route_enable(data, 1);
+			}
+		}
+#endif
+		for (i = 0; i < RX_SYNC_DOMAIN_CNT; i++) {
+			rx_sync_dev_t *dev = rx_sync_data.last_enabled_dev[i];
+			if (!dev)
+				continue;
+			pr_debug("[%s] line:%d domain=%d, device=0x%p, rx enable\n",
+					__func__, __LINE__, i, dev);
+			dev->rx_enable(dev->data, 1);
+		}
+
+	} else {
+		rx_sync_data.enabled_count[domain]--;
+
+		if (rx_sync_data.enabled_count[domain] > 0) {
+			goto unlock;
+		} else if (rx_sync_data.enabled_count[domain] < 0) {
+			pr_err("[%s] line:%d domain=%d, enabled_count(%d) is less than 0. "
+				"%s was called incorrectly?\n", __func__, __LINE__, domain,
+				rx_sync_data.enabled_count[domain], __func__);
+			goto unlock;
+		}
+
+		/*
+		 * Check all devices in all domains. Only if the last device in
+		 * all domains runs here, we will run route_enable(0) in all devices,
+		 * and rx_enable(0) in only the last device in each domain.
+		 */
+		for (i = 0; i < RX_SYNC_DOMAIN_CNT; i++) {
+			enabled_count += rx_sync_data.enabled_count[i];
+		}
+		if (enabled_count > 0) {
+			goto unlock;
+		} else if (enabled_count < 0) {
+			pr_err("[%s] line:%d, sum of enabled_count(%d) is less than 0."
+				"%s was called incorrectly?\n", __func__, __LINE__,
+				enabled_count, __func__);
+			goto unlock;
+		}
+#if 0
+		for (i = 0; i < RX_SYNC_DOMAIN_CNT; i++) {
+			for (j = 0; j < rx_sync_data.total_count[i]; j++) {
+				void *data = rx_sync_data.dev_info[i][j].data;
+
+				pr_debug("[%s] line:%d domain=%d, id=%d, route disable\n",
+					__func__, __LINE__, i, j);
+				rx_sync_data.dev_info[i][j].route_enable(data, 0);
+			}
+		}
+#endif
+		for (i = 0; i < RX_SYNC_DOMAIN_CNT; i++) {
+			rx_sync_dev_t *dev = rx_sync_data.last_enabled_dev[i];
+			if (!dev)
+				continue;
+			pr_debug("[%s] line:%d domain=%d, device=0x%p, rx disable\n",
+					__func__, __LINE__, i, dev);
+			dev->rx_enable(dev->data, 0);
+		}
+	}
+unlock:
+	spin_unlock_irqrestore(&rx_sync_lock, flags);
+	return;
+}
+EXPORT_SYMBOL(sunxi_rx_sync_control);
+
+MODULE_DESCRIPTION("sunxi rx sync driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/sunxi/sunxi-rx-sync.h b/sound/soc/sunxi/sunxi-rx-sync.h
new file mode 100644
index 000000000..93efc2f91
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-rx-sync.h
@@ -0,0 +1,55 @@
+/* sound\soc\sunxi\sunxi-rx-sync.h
+ * (C) Copyright 2019-2025
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#ifndef __SUNXI_RX_SYNC_H_
+#define __SUNXI_RX_SYNC_H_
+
+typedef enum {
+	RX_SYNC_SYS_DOMAIN,
+	RX_SYNC_DSP_DOMAIN,
+	RX_SYNC_DOMAIN_CNT
+} rx_sync_domain_t;
+
+#ifdef CONFIG_SUNXI_RX_SYNC
+int sunxi_rx_sync_probe(rx_sync_domain_t domain);
+void sunxi_rx_sync_remove(rx_sync_domain_t domain);
+void sunxi_rx_sync_startup(void *data, rx_sync_domain_t domain, int id,
+		//void (*route_enable)(void *data, bool enable),
+		void (*rx_enable)(void *data, bool enable));
+void sunxi_rx_sync_shutdown(rx_sync_domain_t domain, int id);
+void sunxi_rx_sync_control(rx_sync_domain_t domain, int id, bool enable);
+#else
+static inline int sunxi_rx_sync_probe(rx_sync_domain_t domain)
+{
+	return 0;
+}
+static inline void sunxi_rx_sync_remove(rx_sync_domain_t domain)
+{
+	return;
+}
+static inline void sunxi_rx_sync_startup(void *data, rx_sync_domain_t domain, int id,
+		//void (*route_enable)(void *data, bool enable),
+		void (*rx_enable)(void *data, bool enable))
+{
+	return;
+}
+static inline void sunxi_rx_sync_shutdown(rx_sync_domain_t domain, int id)
+{
+	return;
+}
+static inline void sunxi_rx_sync_control(rx_sync_domain_t domain, int id, bool enable)
+{
+	return;
+}
+#endif
+
+#endif /* __SUNXI_RX_SYNC_H_ */
diff --git a/sound/soc/sunxi/sunxi-simple-card.c b/sound/soc/sunxi/sunxi-simple-card.c
new file mode 100644
index 000000000..dd0734e58
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-simple-card.c
@@ -0,0 +1,566 @@
+/*
+ * ASoC simple sound card support
+ *
+ * Copyright (C) 2020 Renesas Solutions Corp.
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * based on ${LINUX}/sound/soc/generic/simple-card.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/gpio.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/platform_device.h>
+#include <linux/string.h>
+#include <sound/jack.h>
+#include <sound/simple_card.h>
+#include <sound/soc-dai.h>
+#include <sound/soc.h>
+
+#define DAI	"sound-dai"
+#define CELL	"#sound-dai-cells"
+#define PREFIX	"simple-audio-card,"
+
+static int asoc_simple_parse_dai(struct device_node *node,
+		struct snd_soc_dai_link_component *dlc,
+		int *is_single_link)
+{
+	struct of_phandle_args args;
+	int ret;
+
+	if (!node)
+		return 0;
+
+	/*
+	 * Get node via "sound-dai = <&phandle port>"
+	 * it will be used as xxx_of_node on soc_bind_dai_link()
+	 */
+	ret = of_parse_phandle_with_args(node, DAI, CELL, 0, &args);
+	if (ret)
+		return ret;
+
+	/*
+	 * FIXME
+	 *
+	 * Here, dlc->dai_name is pointer to CPU/Codec DAI name.
+	 * If user unbinded CPU or Codec driver, but not for Sound Card,
+	 * dlc->dai_name is keeping unbinded CPU or Codec
+	 * driver's pointer.
+	 *
+	 * If user re-bind CPU or Codec driver again, ALSA SoC will try
+	 * to rebind Card via snd_soc_try_rebind_card(), but because of
+	 * above reason, it might can't bind Sound Card.
+	 * Because Sound Card is pointing to released dai_name pointer.
+	 *
+	 * To avoid this rebind Card issue,
+	 * 1) It needs to alloc memory to keep dai_name eventhough
+	 *    CPU or Codec driver was unbinded, or
+	 * 2) user need to rebind Sound Card everytime
+	 *    if he unbinded CPU or Codec.
+	 */
+	ret = snd_soc_of_get_dai_name(node, &dlc->dai_name);
+	if (ret < 0)
+		return ret;
+
+	dlc->of_node = args.np;
+
+	if (is_single_link)
+		*is_single_link = !args.args_count;
+
+	return 0;
+}
+
+static int asoc_simple_card_startup(struct snd_pcm_substream *substream)
+{
+#if 0
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct asoc_simple_priv *priv =	snd_soc_card_get_drvdata(rtd->card);
+	struct simple_dai_props *dai_props =
+		simple_priv_to_props(priv, rtd->num);
+	int ret;
+
+	ret = clk_prepare_enable(dai_props->cpu_dai.clk);
+	if (ret)
+		return ret;
+
+	ret = clk_prepare_enable(dai_props->codec_dai.clk);
+	if (ret)
+		clk_disable_unprepare(dai_props->cpu_dai.clk);
+
+	return ret;
+#endif
+	return 0;
+}
+
+static void asoc_simple_card_shutdown(struct snd_pcm_substream *substream)
+{
+#if 0
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct asoc_simple_priv *priv =	snd_soc_card_get_drvdata(rtd->card);
+	struct simple_dai_props *dai_props =
+		simple_priv_to_props(priv, rtd->num);
+
+	clk_disable_unprepare(dai_props->cpu_dai.clk);
+
+	clk_disable_unprepare(dai_props->codec_dai.clk);
+#endif
+}
+
+static int asoc_simple_card_hw_params(struct snd_pcm_substream *substream,
+				      struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct asoc_simple_priv *priv = snd_soc_card_get_drvdata(rtd->card);
+	struct snd_soc_dai_link *dai_link = simple_priv_to_link(priv, rtd->num);//num is idx????
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	int ret, clk_div;
+	unsigned int freq;
+
+	switch (params_rate(params)) {
+	case 8000:
+	case 12000:
+	case 16000:
+	case 24000:
+	case 32000:
+	case 48000:
+	case 64000:
+	case 96000:
+	case 192000:
+		freq = 24576000;
+		break;
+	case 11025:
+	case 22050:
+	case 44100:
+	case 88200:
+	case 176400:
+		freq = 22579200;
+		break;
+	default:
+		dev_err(rtd->dev, "Invalid rate %d\n", params_rate(params));
+		return -EINVAL;
+	}
+
+	ret = snd_soc_dai_set_sysclk(codec_dai, 0, freq, SND_SOC_CLOCK_IN);
+	if (ret && ret != -ENOTSUPP) {
+		dev_err(rtd->dev, "cadec_dai set sysclk failed.\n");
+		return ret;
+	}
+	ret = snd_soc_dai_set_sysclk(cpu_dai, 0, freq, SND_SOC_CLOCK_OUT);
+	if (ret && ret != -ENOTSUPP) {
+		dev_err(rtd->dev, "cpu_dai set sysclk failed.\n");
+		return ret;
+	}
+
+	ret = snd_soc_dai_set_pll(codec_dai, 0, 0, freq, freq);
+	/* if (ret < 0) */
+	/* 	dev_warn(rtd->dev, "codec_dai set set_pll failed.\n"); */
+
+	/* set codec dai fmt */
+	ret = snd_soc_dai_set_fmt(codec_dai, dai_link->dai_fmt);
+	if (ret && ret != -ENOTSUPP)
+		dev_warn(rtd->dev, "codec dai set fmt failed\n");
+
+	/* set cpu dai fmt */
+	ret = snd_soc_dai_set_fmt(cpu_dai, dai_link->dai_fmt);
+	if (ret && ret != -ENOTSUPP)
+		dev_warn(rtd->dev, "cpu dai set fmt failed\n");
+
+	clk_div = freq/params_rate(params);
+
+	if (cpu_dai->driver->ops->set_clkdiv) {
+		ret = snd_soc_dai_set_clkdiv(cpu_dai, 0, clk_div);
+		if (ret < 0) {
+			dev_err(rtd->dev, "set clkdiv failed.\n");
+			return ret;
+		}
+	}
+
+	if (codec_dai->driver->ops->set_clkdiv) {
+		ret = snd_soc_dai_set_clkdiv(codec_dai, 0, clk_div);
+		if (ret < 0) {
+			dev_err(rtd->dev, "codec_dai set clkdiv failed\n");
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static struct snd_soc_ops asoc_simple_card_ops = {
+	.startup = asoc_simple_card_startup,
+	.shutdown = asoc_simple_card_shutdown,
+	.hw_params = asoc_simple_card_hw_params,
+};
+
+static int asoc_simple_card_dai_init(struct snd_soc_pcm_runtime *rtd)
+{
+#if 0
+	struct simple_card_data *priv =	snd_soc_card_get_drvdata(rtd->card);
+	struct snd_soc_dai *codec = rtd->codec_dai;
+	struct snd_soc_dai *cpu = rtd->cpu_dai;
+	struct simple_dai_props *dai_props =
+		simple_priv_to_props(priv, rtd->num);
+	int ret;
+
+	ret = asoc_simple_card_init_dai(codec, &dai_props->codec_dai);
+	if (ret < 0)
+		return ret;
+
+	ret = asoc_simple_card_init_dai(cpu, &dai_props->cpu_dai);
+	if (ret < 0)
+		return ret;
+
+	ret = asoc_simple_card_init_hp(rtd->card, &priv->hp_jack, PREFIX);
+	if (ret < 0)
+		return ret;
+
+	ret = asoc_simple_card_init_mic(rtd->card, &priv->mic_jack, PREFIX);
+	if (ret < 0)
+		return ret;
+#endif
+	return 0;
+}
+
+int asoc_simple_parse_daistream(struct device *dev,
+				struct device_node *node,
+				char *prefix,
+				struct snd_soc_dai_link *dai_link)
+{
+	char prop[128];
+	unsigned int dai_stream = 0;
+	unsigned int playback_only = BIT(0);
+	unsigned int capture_only = BIT(1);
+
+	if (!prefix)
+		prefix = "";
+
+	/* check "[prefix]playback_only" */
+	snprintf(prop, sizeof(prop), "%splayback_only", prefix);
+	if (of_property_read_bool(node, prop))
+		dai_stream |= playback_only;
+
+	/* check "[prefix]capture_only" */
+	snprintf(prop, sizeof(prop), "%scapture_only", prefix);
+	if (of_property_read_bool(node, prop))
+		dai_stream |= capture_only;
+
+	if (dai_stream == (playback_only | capture_only)) {
+		pr_err("unsupport stream\n");
+		dai_link->playback_only = 0;
+		dai_link->capture_only = 0;
+	} else if (dai_stream == playback_only) {
+		dai_link->playback_only = 1;
+	} else if (dai_stream == capture_only) {
+		dai_link->capture_only = 1;
+	} else {
+		dai_link->playback_only = 0;
+		dai_link->capture_only = 0;
+	}
+
+	return 0;
+}
+
+static int asoc_simple_card_dai_link_of(struct device_node *node,
+					struct asoc_simple_priv *priv,
+					int idx,
+					bool is_top_level_node)
+{
+	struct device *dev = simple_priv_to_dev(priv);
+	struct snd_soc_dai_link *dai_link = simple_priv_to_link(priv, idx);
+	struct device_node *cpu = NULL;
+	struct device_node *plat = NULL;
+	struct device_node *codec = NULL;
+	char prop[128];
+	char *prefix = "";
+	int ret, single_cpu;
+
+	/* For single DAI link & old style of DT node */
+	if (is_top_level_node)
+		prefix = PREFIX;
+
+	snprintf(prop, sizeof(prop), "%scpu", prefix);
+	cpu = of_get_child_by_name(node, prop);
+
+	if (!cpu) {
+		ret = -EINVAL;
+		dev_err(dev, "%s: Can't find %s DT node\n", __func__, prop);
+		goto dai_link_of_err;
+	}
+
+	snprintf(prop, sizeof(prop), "%splat", prefix);
+	plat = of_get_child_by_name(node, prop);
+
+	snprintf(prop, sizeof(prop), "%scodec", prefix);
+	codec = of_get_child_by_name(node, prop);
+
+	if (!codec) {
+		ret = -EINVAL;
+		dev_err(dev, "%s: Can't find %s DT node\n", __func__, prop);
+		goto dai_link_of_err;
+	}
+
+	ret = asoc_simple_parse_daistream(dev, node, prefix, dai_link);
+	if (ret < 0)
+		goto dai_link_of_err;
+
+	ret = asoc_simple_parse_daifmt(dev, node, codec,
+				       prefix, &dai_link->dai_fmt);
+	if (ret < 0)
+		goto dai_link_of_err;
+
+	ret = asoc_simple_parse_cpu(cpu, dai_link, &single_cpu);
+	if (ret < 0)
+		goto dai_link_of_err;
+
+	ret = asoc_simple_parse_codec(codec, dai_link);
+	if (ret < 0) {
+		if (ret == -EPROBE_DEFER)
+			goto dai_link_of_err;
+		dai_link->codecs->name = "snd-soc-dummy";
+		dai_link->codecs->dai_name = "snd-soc-dummy-dai";
+		dev_err(dev, "use dummy codec for simple card.\n");
+	}
+
+	ret = asoc_simple_parse_platform(plat, dai_link);
+	if (ret < 0)
+		goto dai_link_of_err;
+
+	ret = asoc_simple_set_dailink_name(dev, dai_link,
+					   "%s-%s",
+					   dai_link->cpus->dai_name,
+					   dai_link->codecs->dai_name);
+	if (ret < 0)
+		goto dai_link_of_err;
+
+	dai_link->ops = &asoc_simple_card_ops;
+	dai_link->init = asoc_simple_card_dai_init;
+
+	dev_dbg(dev, "\tname : %s\n", dai_link->stream_name);
+	dev_dbg(dev, "\tformat : %04x\n", dai_link->dai_fmt);
+	dev_dbg(dev, "\tcpu : %s \n",
+		dai_link->cpus->name);
+	dev_dbg(dev, "\tcodec : %s \n",
+		dai_link->codecs->name);
+
+	asoc_simple_canonicalize_cpu(dai_link, single_cpu);
+	asoc_simple_canonicalize_platform(dai_link);
+
+dai_link_of_err:
+	of_node_put(cpu);
+	of_node_put(codec);
+
+	return ret;
+}
+
+static int asoc_simple_card_parse_of(struct device_node *node,
+				     struct asoc_simple_priv *priv)
+{
+	struct device *dev = simple_priv_to_dev(priv);
+	struct device_node *dai_link;
+	int ret;
+
+	if (!node)
+		return -EINVAL;
+
+	/* The off-codec widgets */
+	ret = asoc_simple_parse_widgets(&priv->snd_card, PREFIX);
+	if (ret < 0)
+		return ret;
+
+	/* DAPM routes */
+	ret = asoc_simple_parse_routing(&priv->snd_card, PREFIX);
+	if (ret < 0)
+		return ret;
+
+	ret = asoc_simple_parse_pin_switches(&priv->snd_card, PREFIX);
+	if (ret < 0)
+		return ret;
+
+	dai_link = of_get_child_by_name(node, PREFIX "dai-link");
+	/* Single/Muti DAI link(s) & New style of DT node */
+	if (dai_link) {
+		struct device_node *np = NULL;
+		int i = 0;
+
+		for_each_child_of_node(node, np) {
+			dev_dbg(dev, "\tlink %d:\n", i);
+			ret = asoc_simple_card_dai_link_of(np, priv,
+							   i, false);
+			if (ret < 0) {
+				of_node_put(np);
+				goto card_parse_end;
+			}
+			i++;
+		}
+	} else {
+		/* For single DAI link & old style of DT node */
+		ret = asoc_simple_card_dai_link_of(node, priv, 0, true);
+		if (ret < 0)
+			goto card_parse_end;
+	}
+
+	ret = asoc_simple_parse_card_name(&priv->snd_card, PREFIX);
+
+card_parse_end:
+	of_node_put(dai_link);
+
+	return ret;
+}
+
+static int sunxi_hdmiaudio_set_audio_mode(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	struct asoc_simple_priv *priv =
+				snd_soc_card_get_drvdata(card);
+
+	priv->hdmi_format = ucontrol->value.integer.value[0];
+	return 0;
+}
+
+static int sunxi_hdmiaudio_get_audio_mode(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	struct asoc_simple_priv *priv =
+				snd_soc_card_get_drvdata(card);
+
+	ucontrol->value.integer.value[0] = priv->hdmi_format;
+	return 0;
+}
+
+static const char *hdmiaudio_format_function[] = {"NULL", "PCM", "AC3",
+		"MPEG1", "MP3", "MPEG2", "AAC", "DTS", "ATRAC", "ONE_BIT_AUDIO",
+		"DOLBY_DIGITAL_PLUS", "DTS_HD", "MAT", "WMAPRO"};
+
+static const struct soc_enum hdmiaudio_format_enum[] = {
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(hdmiaudio_format_function),
+			hdmiaudio_format_function),
+};
+
+/* pcm dts ac3 Audio Mode Select */
+static const struct snd_kcontrol_new sunxi_hdmiaudio_controls[] = {
+	SOC_ENUM_EXT("hdmi audio format Function", hdmiaudio_format_enum[0],
+		sunxi_hdmiaudio_get_audio_mode, sunxi_hdmiaudio_set_audio_mode),
+};
+
+static int simple_soc_probe(struct snd_soc_card *card)
+{
+	/* struct asoc_simple_priv *priv = snd_soc_card_get_drvdata(card); */
+	int ret;
+
+	if (strstr(card->name, "sndhdmi")) {
+		ret = snd_soc_add_card_controls(card, sunxi_hdmiaudio_controls,
+					ARRAY_SIZE(sunxi_hdmiaudio_controls));
+		if (ret)
+			dev_warn(card->dev,
+				"Failed to register audio hdmi mode control.\n");
+	}
+#if 0
+	ret = asoc_simple_init_hp(card, &priv->hp_jack, PREFIX);
+	if (ret < 0)
+		return ret;
+
+	ret = asoc_simple_init_mic(card, &priv->mic_jack, PREFIX);
+	if (ret < 0)
+		return ret;
+#endif
+	return 0;
+}
+
+static int asoc_simple_card_probe(struct platform_device *pdev)
+{
+	struct asoc_simple_priv *priv;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct snd_soc_card *card;
+	struct link_info li;
+	int ret;
+
+	/* Allocate the private data and the DAI link array */
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	card = simple_priv_to_card(priv);
+	card->owner		= THIS_MODULE;
+	card->dev		= dev;
+	card->probe		= simple_soc_probe;
+
+	memset(&li, 0, sizeof(li));
+
+	/* Get the number of DAI links */
+	if (np && of_get_child_by_name(np, PREFIX "dai-link"))
+		li.link = of_get_child_count(np);
+	else
+		li.link = 1;
+
+	ret = asoc_simple_init_priv(priv, &li);
+	if (ret < 0)
+		return ret;
+
+	if (np && of_device_is_available(np)) {
+
+		ret = asoc_simple_card_parse_of(np, priv);
+		if (ret < 0) {
+			if (ret != -EPROBE_DEFER)
+				dev_err(dev, "parse error %d\n", ret);
+			goto err;
+		}
+
+	} else {
+		dev_err(dev, "simple card dts available\n");
+	}
+
+	snd_soc_card_set_drvdata(&priv->snd_card, priv);
+
+	/* asoc_simple_debug_info(priv); */
+	ret = devm_snd_soc_register_card(&pdev->dev, &priv->snd_card);
+	if (ret >= 0)
+		return ret;
+err:
+	asoc_simple_clean_reference(&priv->snd_card);
+
+	return ret;
+}
+
+static int asoc_simple_card_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+	/* struct asoc_simple_priv *priv = snd_soc_card_get_drvdata(card); */
+
+	/* asoc_simple_card_remove_jack(&priv->hp_jack); */
+	/* asoc_simple_card_remove_jack(&priv->mic_jack); */
+
+	return asoc_simple_clean_reference(card);
+}
+
+static const struct of_device_id asoc_simple_of_match[] = {
+	{ .compatible = "sunxi,simple-audio-card", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, asoc_simple_of_match);
+
+static struct platform_driver asoc_simple_card = {
+	.driver = {
+		.name = "sunxi-audio-card",
+		.pm = &snd_soc_pm_ops,
+		.of_match_table = asoc_simple_of_match,
+	},
+	.probe = asoc_simple_card_probe,
+	.remove = asoc_simple_card_remove,
+};
+
+module_platform_driver(asoc_simple_card);
+
+MODULE_AUTHOR("bantao@allwinnertech.com>");
+MODULE_ALIAS("platform:asoc-simple-card");
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("ASoC Simple Sound Card");
diff --git a/sound/soc/sunxi/sunxi-spdif.c b/sound/soc/sunxi/sunxi-spdif.c
new file mode 100644
index 000000000..1b9c18d57
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-spdif.c
@@ -0,0 +1,1651 @@
+/*
+ * sound\soc\sunxi\sunxi-spdif.c
+ * (C) Copyright 2019-2025
+ * allwinnertech Technology Co., Ltd. <www.allwinnertech.com>
+ * yumingfeng <yumingfeng@allwinnertech.com>
+ * luguofang <luguofang@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/slab.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/regmap.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
+#include <linux/of_gpio.h>
+#include <linux/sunxi-gpio.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/reset.h>
+#include <asm/dma.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+
+#include "sunxi-spdif.h"
+#include "sunxi-pcm.h"
+
+#define	DRV_NAME	"sunxi-spdif"
+
+#define SUNXI_SPDIF_DEBUG
+
+struct sample_rate {
+	unsigned int samplerate;
+	unsigned int rate_bit;
+};
+
+/* Origin freq convert */
+static const struct sample_rate sample_rate_orig[] = {
+	{22050,  0xB},
+	{24000,  0x9},
+	{32000,  0xC},
+	{44100,  0xF},
+	{48000,  0xD},
+	{88200,  0x7},
+	{96000,  0x5},
+	{176400, 0x3},
+	{192000, 0x1},
+};
+
+static const struct sample_rate sample_rate_freq[] = {
+	{22050,  0x4},
+	{24000,  0x6},
+	{32000,  0x3},
+	{44100,  0x0},
+	{48000,  0x2},
+	{88200,  0x8},
+	{96000,  0xA},
+	{176400, 0xC},
+	{192000, 0xE},
+};
+
+#ifdef SUNXI_SPDIF_DEBUG
+static struct sunxi_spdif_reg_label reg_labels[] = {
+	SPDIF_REG_LABEL(SUNXI_SPDIF_CTL),
+	SPDIF_REG_LABEL(SUNXI_SPDIF_TXCFG),
+	SPDIF_REG_LABEL(SUNXI_SPDIF_RXCFG),
+	SPDIF_REG_LABEL(SUNXI_SPDIF_INT_STA),
+	SPDIF_REG_LABEL(SUNXI_SPDIF_FIFO_CTL),
+	SPDIF_REG_LABEL(SUNXI_SPDIF_FIFO_STA),
+	SPDIF_REG_LABEL(SUNXI_SPDIF_INT),
+	SPDIF_REG_LABEL(SUNXI_SPDIF_TXCNT),
+	SPDIF_REG_LABEL(SUNXI_SPDIF_RXCNT),
+	SPDIF_REG_LABEL(SUNXI_SPDIF_TXCH_STA0),
+	SPDIF_REG_LABEL(SUNXI_SPDIF_TXCH_STA1),
+	SPDIF_REG_LABEL(SUNXI_SPDIF_RXCH_STA0),
+	SPDIF_REG_LABEL(SUNXI_SPDIF_RXCH_STA1),
+	SPDIF_REG_LABEL_END,
+};
+
+static ssize_t show_spdif_reg(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct sunxi_spdif_info *sunxi_spdif = dev_get_drvdata(dev);
+	struct sunxi_spdif_mem_info *mem_info = NULL;
+	int count = 0;
+	unsigned int reg_val;
+	int ret = 0;
+	int i = 0;
+
+	if (IS_ERR_OR_NULL(sunxi_spdif)) {
+		dev_err(dev, "sunxi_spdif is NULL!\n");
+		return count;
+	}
+	mem_info = &sunxi_spdif->mem_info;
+
+	count = snprintf(buf, PAGE_SIZE, "Dump spdif reg:\n");
+	if (count > 0) {
+		ret += count;
+	} else {
+		dev_err(dev, "snprintf start error=%d.\n", count);
+		return 0;
+	}
+
+	while (reg_labels[i].name != NULL) {
+		regmap_read(mem_info->regmap, reg_labels[i].value, &reg_val);
+		count = snprintf(buf + ret, PAGE_SIZE - ret,
+			"%-23s[0x%02X]: 0x%08X\n",
+			reg_labels[i].name,
+			(reg_labels[i].value), reg_val);
+		if (count > 0) {
+			ret += count;
+		} else {
+			dev_err(dev, "snprintf [i=%d] error=%d.\n", i, count);
+			break;
+		}
+		if (ret > PAGE_SIZE) {
+			ret = PAGE_SIZE;
+			break;
+		}
+		i++;
+	}
+
+	return ret;
+}
+
+/* ex:
+ *param 1: 0 read;1 write
+ *param 2: reg value;
+ *param 3: write value;
+	read:
+		echo 0,0x0 > spdif_reg
+	write:
+		echo 1,0x00,0xa > spdif_reg
+*/
+static ssize_t store_spdif_reg(struct device *dev, struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	int ret;
+	int rw_flag;
+	int reg_val_read;
+	unsigned int input_reg_val = 0;
+	unsigned int input_reg_offset = 0;
+	struct sunxi_spdif_info *sunxi_spdif = dev_get_drvdata(dev);
+	struct sunxi_spdif_mem_info *mem_info = NULL;
+
+	if (IS_ERR_OR_NULL(sunxi_spdif)) {
+		dev_err(dev, "sunxi_spdif is NULL!\n");
+		return count;
+	}
+	mem_info = &sunxi_spdif->mem_info;
+
+	ret = sscanf(buf, "%d,0x%x,0x%x", &rw_flag, &input_reg_offset,
+			&input_reg_val);
+
+	if (ret == 3 || ret == 2) {
+		if (!(rw_flag == 1 || rw_flag == 0)) {
+			dev_err(dev, "rw_flag should be 0(read) or 1(write).\n");
+			return count;
+		}
+		if (input_reg_offset > SUNXI_SPDIF_REG_MAX) {
+			pr_err("the reg offset is invalid! [0x0 - 0x%x]\n",
+				SUNXI_SPDIF_REG_MAX);
+			return count;
+		}
+		if (rw_flag) {
+			regmap_write(mem_info->regmap, input_reg_offset,
+					input_reg_val);
+		}
+		regmap_read(mem_info->regmap, input_reg_offset, &reg_val_read);
+		pr_err("\n\n Reg[0x%x] : 0x%x\n\n", input_reg_offset, reg_val_read);
+	} else {
+		pr_err("ret:%d, The num of params invalid!\n", ret);
+		pr_err("\nExample(reg range: 0x0 - 0x%x):\n", SUNXI_SPDIF_REG_MAX);
+		pr_err("\nRead reg[0x04]:\n");
+		pr_err("      echo 0,0x04 > spdif_reg\n");
+		pr_err("Write reg[0x04]=0x10\n");
+		pr_err("      echo 1,0x04,0x10 > spdif_reg\n");
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(spdif_reg, 0644, show_spdif_reg, store_spdif_reg);
+
+static struct attribute *audio_debug_attrs[] = {
+	&dev_attr_spdif_reg.attr,
+	NULL,
+};
+
+static struct attribute_group spdif_debug_attr_group = {
+	.name	= "spdif_debug",
+	.attrs	= audio_debug_attrs,
+};
+#endif
+
+static int sunxi_spdif_set_audio_mode(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sunxi_spdif_info *sunxi_spdif = snd_soc_component_get_drvdata(component);
+	struct sunxi_spdif_mem_info *mem_info = &sunxi_spdif->mem_info;
+	unsigned int reg_val;
+
+	regmap_read(mem_info->regmap, SUNXI_SPDIF_TXCH_STA0, &reg_val);
+
+	switch (ucontrol->value.integer.value[0]) {
+	case 0:
+		reg_val = 0;
+		break;
+	case 1:
+		reg_val = 1;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	regmap_update_bits(mem_info->regmap, SUNXI_SPDIF_TXCFG,
+			(1 << TXCFG_DATA_TYPE), (reg_val << TXCFG_DATA_TYPE));
+	regmap_update_bits(mem_info->regmap, SUNXI_SPDIF_TXCH_STA0,
+			(1 << TXCHSTA0_AUDIO), (reg_val << TXCHSTA0_AUDIO));
+	regmap_update_bits(mem_info->regmap, SUNXI_SPDIF_RXCH_STA0,
+			(1 << RXCHSTA0_AUDIO), (reg_val << RXCHSTA0_AUDIO));
+
+	return 0;
+}
+
+static int sunxi_spdif_get_audio_mode(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sunxi_spdif_info *sunxi_spdif = snd_soc_component_get_drvdata(component);
+	struct sunxi_spdif_mem_info *mem_info = &sunxi_spdif->mem_info;
+	unsigned int reg_val;
+
+	regmap_read(mem_info->regmap, SUNXI_SPDIF_TXCFG, &reg_val);
+	ucontrol->value.integer.value[0] = (reg_val >> TXCFG_DATA_TYPE) & 0x1;
+
+	return 0;
+}
+
+static const char *spdif_format_function[] = {"PCM", "DTS"};
+static const struct soc_enum spdif_format_enum[] = {
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(spdif_format_function),
+			spdif_format_function),
+};
+
+#if IS_ENABLED(CONFIG_SND_SUNXI_SOC_SPDIF_RX_IEC61937)
+static int sunxi_spdif_set_rx_data_type(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sunxi_spdif_info *sunxi_spdif = snd_soc_component_get_drvdata(component);
+	struct sunxi_spdif_mem_info *mem_info = &sunxi_spdif->mem_info;
+	unsigned int reg_val;
+
+	switch (ucontrol->value.integer.value[0]) {
+	case 0:
+		reg_val = 0;
+		break;
+	case 1:
+		reg_val = 1;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* Spdif Rx use the non-auto mode */
+	regmap_update_bits(mem_info->regmap, SUNXI_SPDIF_EXP_CTL,
+			(1 << RX_MODE), (0 << RX_MODE));
+	regmap_update_bits(mem_info->regmap, SUNXI_SPDIF_EXP_CTL,
+			(1 << RX_MODE_MAN), (reg_val << RX_MODE_MAN));
+
+	return 0;
+}
+
+static int sunxi_spdif_get_rx_data_type(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sunxi_spdif_info *sunxi_spdif = snd_soc_component_get_drvdata(component);
+	struct sunxi_spdif_mem_info *mem_info = &sunxi_spdif->mem_info;
+	unsigned int reg_val;
+
+	regmap_read(mem_info->regmap, SUNXI_SPDIF_EXP_CTL, &reg_val);
+	ucontrol->value.integer.value[0] = (reg_val >> RX_MODE_MAN) & 0x1;
+
+	return 0;
+}
+
+static const char *spdif_rx_data_type[] = {"IEC-60958", "IEC-61937"};
+static const struct soc_enum spdif_rx_data_type_enum[] = {
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(spdif_rx_data_type),
+			spdif_rx_data_type),
+};
+#endif
+
+static int sunxi_spdif_get_hub_mode(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sunxi_spdif_info *sunxi_spdif = snd_soc_component_get_drvdata(component);
+	struct sunxi_spdif_mem_info *mem_info = &sunxi_spdif->mem_info;
+	unsigned int reg_val;
+
+	regmap_read(mem_info->regmap, SUNXI_SPDIF_FIFO_CTL, &reg_val);
+
+	ucontrol->value.integer.value[0] =
+			((reg_val & (1 << FIFO_CTL_HUBEN)) ? 1 : 0);
+	return 0;
+}
+
+static int sunxi_spdif_set_hub_mode(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sunxi_spdif_info *sunxi_spdif = snd_soc_component_get_drvdata(component);
+	struct sunxi_spdif_mem_info *mem_info = &sunxi_spdif->mem_info;
+
+	switch (ucontrol->value.integer.value[0]) {
+	case 0:
+		regmap_update_bits(mem_info->regmap, SUNXI_SPDIF_FIFO_CTL,
+				(1 << FIFO_CTL_HUBEN), (0 << FIFO_CTL_HUBEN));
+		regmap_update_bits(mem_info->regmap, SUNXI_SPDIF_TXCFG,
+				(1 << TXCFG_TXEN), (0 << TXCFG_TXEN));
+		break;
+	case 1:
+		regmap_update_bits(mem_info->regmap, SUNXI_SPDIF_FIFO_CTL,
+				(1 << FIFO_CTL_HUBEN), (1 << FIFO_CTL_HUBEN));
+		regmap_update_bits(mem_info->regmap, SUNXI_SPDIF_TXCFG,
+				(1 << TXCFG_TXEN), (1 << TXCFG_TXEN));
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/* sunxi spdif hub mdoe select */
+static const char *spdif_hub_function[] = {"Disable", "Enable"};
+
+static const struct soc_enum spdif_hub_mode_enum[] = {
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(spdif_hub_function),
+			spdif_hub_function),
+};
+
+/* dts pcm Audio Mode Select */
+static const struct snd_kcontrol_new sunxi_spdif_controls[] = {
+	SOC_ENUM_EXT("spdif audio format function", spdif_format_enum[0],
+			sunxi_spdif_get_audio_mode, sunxi_spdif_set_audio_mode),
+#if IS_ENABLED(CONFIG_SND_SUNXI_SOC_SPDIF_RX_IEC61937)
+	SOC_ENUM_EXT("spdif rx data type", spdif_rx_data_type_enum[0],
+			sunxi_spdif_get_rx_data_type, sunxi_spdif_set_rx_data_type),
+#endif
+	SOC_ENUM_EXT("sunxi spdif hub mode", spdif_hub_mode_enum[0],
+			sunxi_spdif_get_hub_mode, sunxi_spdif_set_hub_mode),
+	SOC_SINGLE("sunxi spdif loopback debug", SUNXI_SPDIF_CTL,
+			CTL_LOOP_EN, 1, 0),
+};
+
+static void sunxi_spdif_txctrl_enable(struct sunxi_spdif_info *sunxi_spdif,
+				int enable)
+{
+	struct sunxi_spdif_mem_info *mem_info = &sunxi_spdif->mem_info;
+
+	if (enable) {
+		regmap_update_bits(mem_info->regmap, SUNXI_SPDIF_TXCFG,
+				(1 << TXCFG_TXEN), (1 << TXCFG_TXEN));
+		regmap_update_bits(mem_info->regmap, SUNXI_SPDIF_INT,
+				(1 << INT_TXDRQEN), (1 << INT_TXDRQEN));
+	} else {
+		regmap_update_bits(mem_info->regmap, SUNXI_SPDIF_TXCFG,
+				(1 << TXCFG_TXEN), (0 << TXCFG_TXEN));
+		regmap_update_bits(mem_info->regmap, SUNXI_SPDIF_INT,
+				(1 << INT_TXDRQEN), (0 << INT_TXDRQEN));
+	}
+}
+
+static void sunxi_spdif_rxctrl_enable(struct sunxi_spdif_info *sunxi_spdif,
+				int enable)
+{
+	struct sunxi_spdif_mem_info *mem_info = &sunxi_spdif->mem_info;
+
+	if (enable) {
+		regmap_update_bits(mem_info->regmap, SUNXI_SPDIF_RXCFG,
+				(1 << RXCFG_CHSR_CP), (1 << RXCFG_CHSR_CP));
+
+		regmap_update_bits(mem_info->regmap, SUNXI_SPDIF_INT,
+				(1 << INT_RXDRQEN), (1 << INT_RXDRQEN));
+		regmap_update_bits(mem_info->regmap, SUNXI_SPDIF_RXCFG,
+				(1 << RXCFG_RXEN), (1 << RXCFG_RXEN));
+		if (sunxi_spdif->rx_sync_en) {
+			sunxi_rx_sync_control(sunxi_spdif->rx_sync_domain,
+					sunxi_spdif->rx_sync_id, 1);
+		}
+	} else {
+		regmap_update_bits(mem_info->regmap, SUNXI_SPDIF_RXCFG,
+				(1 << RXCFG_RXEN), (0 << RXCFG_RXEN));
+		regmap_update_bits(mem_info->regmap, SUNXI_SPDIF_INT,
+				(1 << INT_RXDRQEN), (0 << INT_RXDRQEN));
+		if (sunxi_spdif->rx_sync_en) {
+			sunxi_rx_sync_control(sunxi_spdif->rx_sync_domain,
+					sunxi_spdif->rx_sync_id, 0);
+		}
+	}
+}
+
+static void sunxi_spdif_init(struct sunxi_spdif_info *sunxi_spdif)
+{
+	struct sunxi_spdif_mem_info *mem_info = &sunxi_spdif->mem_info;
+
+	/* FIFO CTL register default setting */
+	regmap_update_bits(mem_info->regmap, SUNXI_SPDIF_FIFO_CTL,
+			(CTL_TXTL_MASK << FIFO_CTL_TXTL),
+			(CTL_TXTL_DEFAULT << FIFO_CTL_TXTL));
+	regmap_update_bits(mem_info->regmap, SUNXI_SPDIF_FIFO_CTL,
+			(CTL_RXTL_MASK << FIFO_CTL_RXTL),
+			(CTL_RXTL_DEFAULT << FIFO_CTL_RXTL));
+
+	/* send tx channel status info */
+	regmap_update_bits(mem_info->regmap, SUNXI_SPDIF_TXCFG,
+		(1 << TXCFG_CHAN_STA_EN), (1 << TXCFG_CHAN_STA_EN));
+
+	regmap_write(mem_info->regmap, SUNXI_SPDIF_TXCH_STA0,
+			0x2 << TXCHSTA0_CHNUM);
+	regmap_write(mem_info->regmap, SUNXI_SPDIF_RXCH_STA0,
+			0x2 << RXCHSTA0_CHNUM);
+
+	if (sunxi_spdif->rx_sync_en)
+		regmap_update_bits(mem_info->regmap, SUNXI_SPDIF_FIFO_CTL,
+				(0x1 << SPDIF_RX_SYNC_EN), (0x1 << SPDIF_RX_SYNC_EN));
+}
+
+static int sunxi_spdif_dai_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params,
+				struct snd_soc_dai *dai)
+{
+	struct sunxi_spdif_info *sunxi_spdif = snd_soc_dai_get_drvdata(dai);
+	struct sunxi_spdif_mem_info *mem_info = &sunxi_spdif->mem_info;
+	unsigned int tx_input_mode = 0;
+	unsigned int rx_output_mode = 0;
+	unsigned int origin_freq_bit = 0, sample_freq_bit = 0;
+	unsigned int reg_temp;
+	unsigned int i;
+
+	/* two substream should be warking on same samplerate */
+	mutex_lock(&sunxi_spdif->mutex);
+	if (sunxi_spdif->active > 1) {
+		if (params_rate(params) != sunxi_spdif->rate) {
+			dev_err(sunxi_spdif->dev, "params_rate[%d] != %d\n",
+				params_rate(params), sunxi_spdif->rate);
+			mutex_unlock(&sunxi_spdif->mutex);
+			return -EINVAL;
+		}
+	}
+	mutex_unlock(&sunxi_spdif->mutex);
+
+	switch (params_format(params)) {
+	case	SNDRV_PCM_FORMAT_S16_LE:
+		reg_temp = 0;
+		tx_input_mode = 1;
+		rx_output_mode = 3;
+		break;
+	case	SNDRV_PCM_FORMAT_S20_3LE:
+		reg_temp = 1;
+		tx_input_mode = 0;
+		rx_output_mode = 0;
+		break;
+	case	SNDRV_PCM_FORMAT_S32_LE:
+		/* only for the compatible of tinyalsa */
+	case	SNDRV_PCM_FORMAT_S24_LE:
+		reg_temp = 2;
+		tx_input_mode = 0;
+		rx_output_mode = 0;
+		break;
+	default:
+		dev_err(sunxi_spdif->dev, "params_format[%d] error!\n",
+			params_format(params));
+		return -EINVAL;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(sample_rate_orig); i++) {
+		if (params_rate(params) == sample_rate_orig[i].samplerate) {
+			origin_freq_bit = sample_rate_orig[i].rate_bit;
+			break;
+		}
+	}
+
+	for (i = 0; i < ARRAY_SIZE(sample_rate_freq); i++) {
+		if (params_rate(params) == sample_rate_freq[i].samplerate) {
+			sample_freq_bit = sample_rate_freq[i].rate_bit;
+			sunxi_spdif->rate = sample_rate_freq[i].samplerate;
+			break;
+		}
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		regmap_update_bits(mem_info->regmap, SUNXI_SPDIF_TXCFG,
+			(3<<TXCFG_SAMPLE_BIT), (reg_temp<<TXCFG_SAMPLE_BIT));
+
+		regmap_update_bits(mem_info->regmap, SUNXI_SPDIF_FIFO_CTL,
+					(1<<FIFO_CTL_TXIM),
+					(tx_input_mode << FIFO_CTL_TXIM));
+
+		if (params_channels(params) == 1) {
+			regmap_update_bits(mem_info->regmap,
+				SUNXI_SPDIF_TXCFG, (1 << TXCFG_SINGLE_MOD),
+				(1 << TXCFG_SINGLE_MOD));
+		} else {
+			regmap_update_bits(mem_info->regmap,
+				SUNXI_SPDIF_TXCFG, (1 << TXCFG_SINGLE_MOD),
+				(0 << TXCFG_SINGLE_MOD));
+		}
+
+		/* samplerate conversion */
+		regmap_update_bits(mem_info->regmap, SUNXI_SPDIF_TXCH_STA0,
+				(0xF << TXCHSTA0_SAMFREQ),
+				(sample_freq_bit << TXCHSTA0_SAMFREQ));
+		regmap_update_bits(mem_info->regmap, SUNXI_SPDIF_TXCH_STA1,
+				(0xF << TXCHSTA1_ORISAMFREQ),
+				(origin_freq_bit << TXCHSTA1_ORISAMFREQ));
+		switch (reg_temp) {
+		case	0:
+			regmap_update_bits(mem_info->regmap,
+				SUNXI_SPDIF_TXCH_STA1,
+				(0xF << TXCHSTA1_MAXWORDLEN),
+				(2 << TXCHSTA1_MAXWORDLEN));
+			break;
+		case	1:
+			regmap_update_bits(mem_info->regmap,
+				SUNXI_SPDIF_TXCH_STA1,
+				(0xF << TXCHSTA1_MAXWORDLEN),
+				(0xC << TXCHSTA1_MAXWORDLEN));
+			break;
+		case	2:
+			regmap_update_bits(mem_info->regmap,
+					SUNXI_SPDIF_TXCH_STA1,
+					(0xF << TXCHSTA1_MAXWORDLEN),
+					(0xB << TXCHSTA1_MAXWORDLEN));
+			break;
+		default:
+			dev_err(sunxi_spdif->dev, "unexpection error\n");
+			return -EINVAL;
+		}
+	} else {
+		/*
+		 * FIXME, not sync as spec says, just test 16bit & 24bit,
+		 * using 3 working ok
+		 */
+		regmap_update_bits(mem_info->regmap, SUNXI_SPDIF_FIFO_CTL,
+				(0x3 << FIFO_CTL_RXOM),
+				(rx_output_mode << FIFO_CTL_RXOM));
+		regmap_update_bits(mem_info->regmap, SUNXI_SPDIF_RXCH_STA0,
+				(0xF<<RXCHSTA0_SAMFREQ),
+				(sample_freq_bit << RXCHSTA0_SAMFREQ));
+		regmap_update_bits(mem_info->regmap, SUNXI_SPDIF_RXCH_STA1,
+				(0xF<<RXCHSTA1_ORISAMFREQ),
+				(origin_freq_bit << RXCHSTA1_ORISAMFREQ));
+
+		switch (reg_temp) {
+		case	0:
+			regmap_update_bits(mem_info->regmap,
+					SUNXI_SPDIF_RXCH_STA1,
+					(0xF << RXCHSTA1_MAXWORDLEN),
+					(2 << RXCHSTA1_MAXWORDLEN));
+			break;
+		case	1:
+			regmap_update_bits(mem_info->regmap,
+					SUNXI_SPDIF_RXCH_STA1,
+					(0xF << RXCHSTA1_MAXWORDLEN),
+					(0xC << RXCHSTA1_MAXWORDLEN));
+			break;
+		case	2:
+			regmap_update_bits(mem_info->regmap,
+					SUNXI_SPDIF_RXCH_STA1,
+					(0xF << RXCHSTA1_MAXWORDLEN),
+					(0xB << RXCHSTA1_MAXWORDLEN));
+			break;
+		default:
+			dev_err(sunxi_spdif->dev, "unexpection error\n");
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+static int sunxi_spdif_dai_set_sysclk(struct snd_soc_dai *dai, int clk_id,
+						unsigned int freq, int dir)
+{
+	struct sunxi_spdif_info *sunxi_spdif = snd_soc_dai_get_drvdata(dai);
+	struct sunxi_spdif_clk_info *clk_info = &sunxi_spdif->clk_info;
+	struct clk *clk_parent;
+
+	mutex_lock(&sunxi_spdif->mutex);
+	sunxi_spdif->active++;
+	if (sunxi_spdif->active != 1) {
+		mutex_unlock(&sunxi_spdif->mutex);
+		return 0;
+	}
+	dev_info(sunxi_spdif->dev, "active: %u\n", sunxi_spdif->active);
+	if (freq == 24576000) {
+		clk_parent = clk_info->clk_pll1_div;
+	} else if (freq == 22579200) {
+		clk_parent = clk_info->clk_pll;
+		switch (clk_info->clk_parent) {
+		case SPDIF_CLK_PLL_AUDIO_X1:
+			if (clk_set_rate(clk_info->clk_pll, freq)) {
+				dev_err(sunxi_spdif->dev,
+					"clk pll set rate to %uHz failed\n", freq);
+				mutex_unlock(&sunxi_spdif->mutex);
+				return -EBUSY;
+			}
+			break;
+		default:
+		case SPDIF_CLK_PLL_AUDIO_X4:
+			if (clk_set_rate(clk_info->clk_pll, freq * 4)) {
+				dev_err(sunxi_spdif->dev,
+					"clk module set rate to %uHz failed\n", freq * 4);
+				mutex_unlock(&sunxi_spdif->mutex);
+				return -EBUSY;
+			}
+			break;
+		}
+	}
+	if (clk_set_parent(clk_info->clk_module, clk_parent)) {
+		pr_err("set parent of clk_module failed!\n");
+		mutex_unlock(&sunxi_spdif->mutex);
+		return -EBUSY;
+	}
+	if (clk_set_rate(clk_info->clk_module, freq)) {
+		dev_err(sunxi_spdif->dev,
+			"clk module set rate to %uHz failed\n", freq);
+		mutex_unlock(&sunxi_spdif->mutex);
+		return -EBUSY;
+	}
+#if IS_ENABLED(CONFIG_SND_SUNXI_SOC_SPDIF_RX_IEC61937)
+	if (clk_set_parent(clk_info->clk_module_rx, clk_info->clk_pll_periph)) {
+		pr_err("set parent of clk_module to clk_pll failed!\n");
+		mutex_unlock(&sunxi_spdif->mutex);
+		return -EBUSY;
+	}
+
+	if (clk_set_rate(clk_info->clk_module_rx, 200000000)) {
+		pr_err("spdif: spdif rx source set pll1 rate failed\n");
+		mutex_unlock(&sunxi_spdif->mutex);
+		return -EBUSY;
+	}
+#endif
+	mutex_unlock(&sunxi_spdif->mutex);
+
+	return 0;
+}
+
+static int sunxi_spdif_dai_set_clkdiv(struct snd_soc_dai *dai,
+					int clk_id, int clk_div)
+{
+	struct sunxi_spdif_info *sunxi_spdif = snd_soc_dai_get_drvdata(dai);
+	struct sunxi_spdif_mem_info *mem_info = &sunxi_spdif->mem_info;
+
+	mutex_lock(&sunxi_spdif->mutex);
+	if (sunxi_spdif->configured == false) {
+		switch (clk_id) {
+		case 0:
+			clk_div = clk_div >> 7;//fs = PLL/[(div+1)*64*2]
+			regmap_update_bits(mem_info->regmap,
+				SUNXI_SPDIF_TXCFG,
+				(0x1F << TXCFG_CLK_DIV_RATIO),
+				((clk_div - 1) << TXCFG_CLK_DIV_RATIO));
+			break;
+		default:
+			break;
+		}
+	}
+	sunxi_spdif->configured = true;
+	mutex_unlock(&sunxi_spdif->mutex);
+
+	return 0;
+}
+
+static void sunxi_spdif_rx_enable(void *data, bool enable)
+{
+	struct snd_soc_component *component = data;
+	struct sunxi_spdif_info *sunxi_spdif = snd_soc_component_get_drvdata(component);
+	struct sunxi_spdif_mem_info *mem_info = NULL;
+
+	mem_info = &sunxi_spdif->mem_info;
+	if (enable)
+		regmap_update_bits(mem_info->regmap, SUNXI_SPDIF_FIFO_CTL,
+				(0x1 << SPDIF_RX_SYNC_EN_START),
+				(0x1 << SPDIF_RX_SYNC_EN_START));
+	else
+		regmap_update_bits(mem_info->regmap, SUNXI_SPDIF_FIFO_CTL,
+				(0x1 << SPDIF_RX_SYNC_EN_START),
+				(0x0 << SPDIF_RX_SYNC_EN_START));
+
+}
+
+static int sunxi_spdif_dai_startup(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	struct sunxi_spdif_info *sunxi_spdif = snd_soc_dai_get_drvdata(dai);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		snd_soc_dai_set_dma_data(dai, substream,
+				&sunxi_spdif->playback_dma_param);
+	} else {
+		snd_soc_dai_set_dma_data(dai, substream,
+				&sunxi_spdif->capture_dma_param);
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE &&
+		sunxi_spdif->rx_sync_en) {
+		sunxi_rx_sync_startup((void *)dai->component,
+			sunxi_spdif->rx_sync_domain, sunxi_spdif->rx_sync_id,
+			sunxi_spdif_rx_enable);
+	}
+
+	return 0;
+}
+
+static void sunxi_spdif_dai_shutdown(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	struct sunxi_spdif_info *sunxi_spdif = snd_soc_dai_get_drvdata(dai);
+
+	mutex_lock(&sunxi_spdif->mutex);
+	if (sunxi_spdif->active) {
+		sunxi_spdif->active--;
+		if (sunxi_spdif->active == 0)
+			sunxi_spdif->configured = false;
+	}
+	mutex_unlock(&sunxi_spdif->mutex);
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE &&
+		sunxi_spdif->rx_sync_en) {
+		sunxi_rx_sync_shutdown(sunxi_spdif->rx_sync_domain,
+			sunxi_spdif->rx_sync_id);
+	}
+}
+
+static int sunxi_spdif_trigger(struct snd_pcm_substream *substream,
+					int cmd, struct snd_soc_dai *dai)
+{
+	struct sunxi_spdif_info *sunxi_spdif = snd_soc_dai_get_drvdata(dai);
+	struct sunxi_spdif_pinctl_info *pin_info = &sunxi_spdif->pin_info;
+	int ret = 0;
+
+	switch (cmd) {
+	case	SNDRV_PCM_TRIGGER_START:
+	case	SNDRV_PCM_TRIGGER_RESUME:
+	case	SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (pin_info->gpio_cfg.used) {
+			gpio_set_value(pin_info->gpio_cfg.gpio,
+					pin_info->gpio_cfg.level);
+		}
+
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			sunxi_spdif_txctrl_enable(sunxi_spdif, 1);
+		else
+			sunxi_spdif_rxctrl_enable(sunxi_spdif, 1);
+		break;
+	case	SNDRV_PCM_TRIGGER_STOP:
+	case	SNDRV_PCM_TRIGGER_SUSPEND:
+	case	SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			sunxi_spdif_txctrl_enable(sunxi_spdif, 0);
+		else
+			sunxi_spdif_rxctrl_enable(sunxi_spdif, 0);
+
+		if (pin_info->gpio_cfg.used) {
+			gpio_set_value(pin_info->gpio_cfg.gpio,
+					!pin_info->gpio_cfg.level);
+		}
+		break;
+	default:
+		dev_err(sunxi_spdif->dev, "cmd error.\n");
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+/* Flush FIFO & Interrupt */
+static int sunxi_spdif_prepare(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	struct sunxi_spdif_info *sunxi_spdif = snd_soc_dai_get_drvdata(dai);
+	struct sunxi_spdif_mem_info *mem_info = &sunxi_spdif->mem_info;
+	unsigned int reg_val;
+
+	/*as you need to clean up TX or RX FIFO , need to turn off GEN bit*/
+	regmap_update_bits(mem_info->regmap, SUNXI_SPDIF_CTL,
+			(1 << CTL_GEN_EN), (0 << CTL_GEN_EN));
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		regmap_update_bits(mem_info->regmap, SUNXI_SPDIF_FIFO_CTL,
+				(1 << FIFO_CTL_FTX), (1 << FIFO_CTL_FTX));
+		regmap_write(mem_info->regmap, SUNXI_SPDIF_TXCNT, 0);
+	} else {
+		regmap_update_bits(mem_info->regmap, SUNXI_SPDIF_FIFO_CTL,
+				(1 << FIFO_CTL_FRX), (1 << FIFO_CTL_FRX));
+		regmap_write(mem_info->regmap, SUNXI_SPDIF_RXCNT, 0);
+	}
+
+	/* clear all interrupt status */
+	regmap_read(mem_info->regmap, SUNXI_SPDIF_INT_STA, &reg_val);
+	regmap_write(mem_info->regmap, SUNXI_SPDIF_INT_STA, reg_val);
+
+	/* need reset */
+	regmap_update_bits(mem_info->regmap, SUNXI_SPDIF_CTL,
+			(1 << CTL_RESET) | (1 << CTL_GEN_EN),
+			(1 << CTL_RESET) | (1 << CTL_GEN_EN));
+
+	return 0;
+}
+
+static int sunxi_spdif_probe(struct snd_soc_dai *dai)
+{
+	struct sunxi_spdif_info *sunxi_spdif = snd_soc_dai_get_drvdata(dai);
+	struct sunxi_spdif_mem_info *mem_info = &sunxi_spdif->mem_info;
+
+	mutex_init(&sunxi_spdif->mutex);
+
+	/* pcm_new will using the dma_param about the cma and fifo params. */
+	snd_soc_dai_init_dma_data(dai, &sunxi_spdif->playback_dma_param,
+				&sunxi_spdif->capture_dma_param);
+
+	sunxi_spdif_init(sunxi_spdif);
+	regmap_update_bits(mem_info->regmap, SUNXI_SPDIF_CTL,
+			(1 << CTL_GEN_EN), (1 << CTL_GEN_EN));
+
+	return 0;
+}
+
+static int sunxi_spdif_remove(struct snd_soc_dai *dai)
+{
+	struct sunxi_spdif_info *sunxi_spdif = snd_soc_dai_get_drvdata(dai);
+
+	mutex_destroy(&sunxi_spdif->mutex);
+
+	return 0;
+}
+
+static int sunxi_spdif_suspend(struct snd_soc_dai *dai)
+{
+	struct sunxi_spdif_info *sunxi_spdif = snd_soc_dai_get_drvdata(dai);
+	struct sunxi_spdif_mem_info *mem_info = &sunxi_spdif->mem_info;
+	struct sunxi_spdif_clk_info *clk_info = &sunxi_spdif->clk_info;
+	struct sunxi_spdif_pinctl_info *pin_info = &sunxi_spdif->pin_info;
+
+	regmap_update_bits(mem_info->regmap, SUNXI_SPDIF_CTL,
+				(1 << CTL_GEN_EN), (0 << CTL_GEN_EN));
+
+	pinctrl_select_state(pin_info->pinctrl, pin_info->pinstate_sleep);
+
+	clk_disable_unprepare(clk_info->clk_module);
+	clk_disable_unprepare(clk_info->clk_pll);
+	clk_disable_unprepare(clk_info->clk_pll1_div);
+	clk_disable_unprepare(clk_info->clk_pll1);
+#if IS_ENABLED(CONFIG_SND_SUNXI_SOC_SPDIF_RX_IEC61937)
+	clk_disable_unprepare(clk_info->clk_module_rx);
+	clk_disable_unprepare(clk_info->clk_pll_periph);
+#endif
+	clk_disable_unprepare(clk_info->clk_bus);
+	reset_control_assert(clk_info->clk_rst);
+
+	return 0;
+}
+
+static int sunxi_spdif_resume(struct snd_soc_dai *dai)
+{
+	struct sunxi_spdif_info *sunxi_spdif = snd_soc_dai_get_drvdata(dai);
+	struct sunxi_spdif_mem_info *mem_info = &sunxi_spdif->mem_info;
+	struct sunxi_spdif_clk_info *clk_info = &sunxi_spdif->clk_info;
+	struct sunxi_spdif_pinctl_info *pin_info = &sunxi_spdif->pin_info;
+
+	reset_control_deassert(clk_info->clk_rst);
+	clk_prepare_enable(clk_info->clk_bus);
+	clk_prepare_enable(clk_info->clk_pll);
+	clk_prepare_enable(clk_info->clk_pll1);
+	clk_prepare_enable(clk_info->clk_pll1_div);
+	clk_prepare_enable(clk_info->clk_module);
+#if IS_ENABLED(CONFIG_SND_SUNXI_SOC_SPDIF_RX_IEC61937)
+	clk_prepare_enable(clk_info->clk_pll_periph);
+	clk_prepare_enable(clk_info->clk_module_rx);
+#endif
+
+	pinctrl_select_state(pin_info->pinctrl, pin_info->pinstate);
+
+	sunxi_spdif_init(sunxi_spdif);
+
+	regmap_update_bits(mem_info->regmap, SUNXI_SPDIF_CTL,
+				(1 << CTL_GEN_EN), (1 << CTL_GEN_EN));
+
+	return 0;
+}
+
+static struct snd_soc_dai_ops sunxi_spdif_dai_ops = {
+	.hw_params	= sunxi_spdif_dai_hw_params,
+	.set_clkdiv	= sunxi_spdif_dai_set_clkdiv,
+	.set_sysclk	= sunxi_spdif_dai_set_sysclk,
+	.startup	= sunxi_spdif_dai_startup,
+	.shutdown	= sunxi_spdif_dai_shutdown,
+	.trigger	= sunxi_spdif_trigger,
+	.prepare	= sunxi_spdif_prepare,
+};
+
+static struct snd_soc_dai_driver sunxi_spdif_dai = {
+	.probe		= sunxi_spdif_probe,
+	.suspend	= sunxi_spdif_suspend,
+	.resume		= sunxi_spdif_resume,
+	.remove		= sunxi_spdif_remove,
+	.playback = {
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = SUNXI_SPDIF_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE
+			| SNDRV_PCM_FMTBIT_S24_LE
+			| SNDRV_PCM_FMTBIT_S32_LE,
+	},
+	.capture = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = SUNXI_SPDIF_RATES,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE
+			| SNDRV_PCM_FMTBIT_S24_LE
+			| SNDRV_PCM_FMTBIT_S32_LE,
+	},
+	.ops = &sunxi_spdif_dai_ops,
+};
+
+/*****************************************************************************/
+#if IS_ENABLED(CONFIG_SND_SUNXI_SOC_SPDIF_RX_IEC61937)
+static int sunxi_spdif_get_params_info(struct sunxi_spdif_info *sunxi_spdif)
+{
+	struct sunxi_spdif_mem_info *mem_info = &sunxi_spdif->mem_info;
+	struct sunxi_spdif_rx_info *rx_info = &sunxi_spdif->rx_info;
+	int reg_val;
+
+	regmap_read(mem_info->regmap, SUNXI_SPDIF_RXCH_STA0, &reg_val);
+	rx_info->rx_params.freq = (reg_val & (0xF << RXCHSTA0_SAMFREQ));
+	rx_info->rx_params.channels = (reg_val & (0xF << RXCHSTA0_CHNUM));
+
+	regmap_read(mem_info->regmap, SUNXI_SPDIF_RXCH_STA1, &reg_val);
+	rx_info->rx_params.orig_freq = (reg_val & (0xF << RXCHSTA1_ORISAMFREQ));
+	rx_info->rx_params.bits = (reg_val & (0x7 << RXCHSTA1_SAMWORDLEN));
+
+	regmap_read(mem_info->regmap, SUNXI_SPDIF_EXP_INFO1, &reg_val);
+	rx_info->rx_params.refreq = (reg_val & (0xFFFF << SAMPLE_RATE_VAL));
+
+	switch (rx_info->rx_params.freq) {
+	case 0:
+		rx_info->rx_params.freq = 44100;
+		break;
+	case 2:
+		rx_info->rx_params.freq = 48000;
+		break;
+	case 3:
+		rx_info->rx_params.freq = 32000;
+		break;
+	case 4:
+		rx_info->rx_params.freq = 22050;
+		break;
+	case 6:
+		rx_info->rx_params.freq = 24000;
+		break;
+	case 9:
+		rx_info->rx_params.freq = 768000;
+		break;
+	case 10:
+		rx_info->rx_params.freq = 96000;
+		break;
+	case 12:
+		rx_info->rx_params.freq = 176400;
+		break;
+	case 14:
+		rx_info->rx_params.freq = 192000;
+		break;
+	default:
+		rx_info->rx_params.freq = 0;
+	}
+
+	switch (rx_info->rx_params.orig_freq) {
+	case 1:
+		rx_info->rx_params.orig_freq = 192000;
+		break;
+	case 2:
+		rx_info->rx_params.orig_freq = 12000;
+		break;
+	case 3:
+		rx_info->rx_params.orig_freq = 176400;
+		break;
+	case 5:
+		rx_info->rx_params.orig_freq = 96000;
+		break;
+	case 6:
+		rx_info->rx_params.orig_freq = 8000;
+		break;
+	case 7:
+		rx_info->rx_params.orig_freq = 88200;
+		break;
+	case 8:
+		rx_info->rx_params.orig_freq = 16000;
+		break;
+	case 9:
+		rx_info->rx_params.orig_freq = 24000;
+		break;
+	case 10:
+		rx_info->rx_params.orig_freq = 11250;
+		break;
+	case 11:
+		rx_info->rx_params.orig_freq = 22050;
+		break;
+	case 12:
+		rx_info->rx_params.orig_freq = 32000;
+		break;
+	case 13:
+		rx_info->rx_params.orig_freq = 48000;
+		break;
+	case 15:
+		rx_info->rx_params.orig_freq = 44100;
+		break;
+	default:
+		rx_info->rx_params.orig_freq = 0;
+	}
+
+#if 1
+	/* 200MHZ - Sysclk */
+	if (rx_info->rx_params.refreq > 9065 && rx_info->rx_params.freq < 9075) {
+		rx_info->rx_params.orig_freq = 22050;
+	} else if (rx_info->rx_params.refreq > 8328 && rx_info->rx_params.freq < 8338) {
+		rx_info->rx_params.orig_freq = 24000;
+	} else if (rx_info->rx_params.refreq > 6245 && rx_info->rx_params.freq < 6255) {
+		rx_info->rx_params.orig_freq = 32000;
+	} else if (rx_info->rx_params.refreq > 4530 && rx_info->rx_params.freq < 4540) {
+		rx_info->rx_params.orig_freq = 44100;
+	} else if (rx_info->rx_params.refreq > 4161 && rx_info->rx_params.freq < 4171) {
+		rx_info->rx_params.orig_freq = 48000;
+	} else if (rx_info->rx_params.refreq > 2078 && rx_info->rx_params.freq < 2088) {
+		rx_info->rx_params.orig_freq = 96000;
+	} else if (rx_info->rx_params.refreq > 1128 && rx_info->rx_params.freq < 1138) {
+		rx_info->rx_params.orig_freq = 176400;
+	} else if (rx_info->rx_params.refreq > 1036 && rx_info->rx_params.freq < 1046) {
+		rx_info->rx_params.orig_freq = 192000;
+	} else {
+		rx_info->rx_params.orig_freq = 0;
+	}
+#else
+	/* 196.608MHZ - Sysclk */
+	if (rx_info->rx_params.refreq > 8911 && rx_info->rx_params.freq < 8921) {
+		rx_info->rx_params.orig_freq = 22050;
+	} else if (rx_info->rx_params.refreq > 8187 && rx_info->rx_params.freq < 8197) {
+		rx_info->rx_params.orig_freq = 24000;
+	} else if (rx_info->rx_params.refreq > 6139 && rx_info->rx_params.freq < 6149) {
+		rx_info->rx_params.orig_freq = 32000;
+	} else if (rx_info->rx_params.refreq > 4453 && rx_info->rx_params.freq < 4463) {
+		rx_info->rx_params.orig_freq = 44100;
+	} else if (rx_info->rx_params.refreq > 4091 && rx_info->rx_params.freq < 4101) {
+		rx_info->rx_params.orig_freq = 48000;
+	} else if (rx_info->rx_params.refreq > 2043 && rx_info->rx_params.freq < 2053) {
+		rx_info->rx_params.orig_freq = 96000;
+	} else if (rx_info->rx_params.refreq > 1109 && rx_info->rx_params.freq < 1119) {
+		rx_info->rx_params.orig_freq = 176400;
+	} else if (rx_info->rx_params.refreq > 1019 && rx_info->rx_params.freq < 1029) {
+		rx_info->rx_params.orig_freq = 192000;
+	} else {
+		rx_info->rx_params.orig_freq = 0;
+	}
+#endif
+
+	return 0;
+};
+
+static ssize_t spdif_rx_show_bits(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct sunxi_spdif_info *sunxi_spdif = dev_get_drvdata(dev);
+	struct sunxi_spdif_rx_info *rx_info = &sunxi_spdif->rx_info;
+	int count = 0;
+
+	sunxi_spdif_get_params_info(sunxi_spdif);
+	count += sprintf(buf, "%d\n", rx_info->rx_params.bits);
+
+	return count;
+}
+
+static ssize_t spdif_rx_show_orig_freq(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct sunxi_spdif_info *sunxi_spdif = dev_get_drvdata(dev);
+	struct sunxi_spdif_rx_info *rx_info = &sunxi_spdif->rx_info;
+	int count = 0;
+
+	sunxi_spdif_get_params_info(sunxi_spdif);
+	count += sprintf(buf, "%d\n", rx_info->rx_params.orig_freq);
+
+	return count;
+}
+
+static ssize_t spdif_rx_show_channels(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct sunxi_spdif_info *sunxi_spdif = dev_get_drvdata(dev);
+	struct sunxi_spdif_rx_info *rx_info = &sunxi_spdif->rx_info;
+	int count = 0;
+
+	sunxi_spdif_get_params_info(sunxi_spdif);
+	count += sprintf(buf, "%d\n", (rx_info->rx_params.channels + 1));
+
+	return count;
+}
+
+static ssize_t spdif_rx_show_freq(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct sunxi_spdif_info *sunxi_spdif = dev_get_drvdata(dev);
+	struct sunxi_spdif_rx_info *rx_info = &sunxi_spdif->rx_info;
+	int count = 0;
+
+	sunxi_spdif_get_params_info(sunxi_spdif);
+	count += sprintf(buf, "%d\n", rx_info->rx_params.freq);
+
+	return count;
+}
+
+static DEVICE_ATTR(spdif_rx_bits, 0444, spdif_rx_show_bits, NULL);
+static DEVICE_ATTR(spdif_rx_orig_freq, 0444, spdif_rx_show_orig_freq, NULL);
+static DEVICE_ATTR(spdif_rx_channels, 0444, spdif_rx_show_channels, NULL);
+static DEVICE_ATTR(spdif_rx_freq, 0444, spdif_rx_show_freq, NULL);
+#endif
+
+static int sunxi_spdif_component_probe(struct snd_soc_component *component)
+{
+#if IS_ENABLED(CONFIG_SND_SUNXI_SOC_SPDIF_RX_IEC61937)
+	/* To get the SPDIF RX Params */
+	device_create_file(component->dev, &dev_attr_spdif_rx_freq);
+	device_create_file(component->dev, &dev_attr_spdif_rx_channels);
+	device_create_file(component->dev, &dev_attr_spdif_rx_bits);
+	device_create_file(component->dev, &dev_attr_spdif_rx_orig_freq);
+
+#endif
+
+	return 0;
+}
+
+static const struct snd_soc_component_driver sunxi_spdif_component = {
+	.name		= DRV_NAME,
+	.probe		= sunxi_spdif_component_probe,
+	.controls	= sunxi_spdif_controls,
+	.num_controls	= ARRAY_SIZE(sunxi_spdif_controls),
+};
+
+/*****************************************************************************/
+
+static const struct regmap_config sunxi_spdif_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = SUNXI_SPDIF_REG_MAX,
+	.cache_type = REGCACHE_NONE,
+};
+
+static int sunxi_spdif_mem_init(struct platform_device *pdev,
+		struct device_node *np, struct sunxi_spdif_info *sunxi_spdif)
+{
+	struct sunxi_spdif_mem_info *mem_info = &sunxi_spdif->mem_info;
+	int ret = 0;
+
+	ret = of_address_to_resource(np, 0, &mem_info->res);
+	if (ret) {
+		dev_err(&pdev->dev, "Can't parse device node resource\n");
+		ret = -ENODEV;
+		goto err_of_get_addr_resource;
+	}
+
+	mem_info->memregion = devm_request_mem_region(&pdev->dev, mem_info->res.start,
+					    resource_size(&mem_info->res), DRV_NAME);
+	if (mem_info->memregion == NULL) {
+		dev_err(&pdev->dev, "Memory region already claimed\n");
+		ret = -EBUSY;
+		goto err_devm_mem_region;
+	}
+
+	mem_info->membase = devm_ioremap(&pdev->dev, mem_info->res.start,
+						resource_size(&mem_info->res));
+	if (IS_ERR_OR_NULL(mem_info->membase)) {
+		dev_err(&pdev->dev, "Can't remap sunxi spdif registers\n");
+		ret = -EINVAL;
+		goto err_devm_ioremap;
+	}
+
+	mem_info->regmap = devm_regmap_init_mmio(&pdev->dev,
+			mem_info->membase, &sunxi_spdif_regmap_config);
+	if (IS_ERR_OR_NULL(mem_info->regmap)) {
+		dev_err(&pdev->dev, "regmap sunxi spdif membase failed\n");
+		ret = PTR_ERR(mem_info->regmap);
+		goto err_devm_regmap;
+	}
+
+	return 0;
+
+err_devm_regmap:
+	devm_iounmap(&pdev->dev, mem_info->membase);
+err_devm_ioremap:
+err_devm_mem_region:
+err_of_get_addr_resource:
+	devm_kfree(&pdev->dev, sunxi_spdif);
+	return ret;
+};
+
+static int sunxi_spdif_clk_init(struct platform_device *pdev,
+		struct device_node *np, struct sunxi_spdif_info *sunxi_spdif)
+{
+	struct sunxi_spdif_clk_info *clk_info = &sunxi_spdif->clk_info;
+	int ret = 0;
+
+	ret = of_property_read_u32(np, "clk_parent", (u32 *)&clk_info->clk_parent);
+	if (ret != 0) {
+		dev_warn(&pdev->dev, "clk_parent config missing or invalid.\n");
+		clk_info->clk_parent = SPDIF_CLK_PLL_AUDIO_X4;
+	}
+
+	clk_info->clk_pll = of_clk_get_by_name(np, "pll_audio0");
+	clk_info->clk_module = of_clk_get_by_name(np, "spdif");
+	clk_info->clk_bus = of_clk_get_by_name(np, "spdif_bus");
+	clk_info->clk_pll1 = of_clk_get_by_name(np, "pll_audio1");
+	clk_info->clk_pll1_div = of_clk_get_by_name(np, "pll_audio1_div5");
+#if IS_ENABLED(CONFIG_SND_SUNXI_SOC_SPDIF_RX_IEC61937)
+	clk_info->clk_pll_periph = of_clk_get_by_name(np, "pll_periph");
+	clk_info->clk_module_rx = of_clk_get_by_name(np, "spdif_rx");
+#endif
+	clk_info->clk_rst = devm_reset_control_get(&pdev->dev, NULL);
+
+	if (clk_set_parent(clk_info->clk_module, clk_info->clk_pll1_div)) {
+		dev_err(&pdev->dev,
+			"set parent of clk_module to clk_pll failed!\n");
+		ret = -EINVAL;
+		goto err_clk_set;
+	}
+
+	if (clk_set_rate(clk_info->clk_module, 24576000)) {
+		dev_err(&pdev->dev,
+			"set clk module rate failed\n");
+		goto err_clk_set;
+	}
+
+#if IS_ENABLED(CONFIG_SND_SUNXI_SOC_SPDIF_RX_IEC61937)
+	if (clk_set_parent(clk_info->clk_module_rx, clk_info->clk_pll_periph)) {
+		dev_err(&pdev->dev,
+			"set parent of clk_module to clk_pll failed!\n");
+		ret = -EINVAL;
+		goto err_clk_set;
+	}
+
+	if (clk_set_rate(clk_info->clk_module_rx, 200000000)) {
+		pr_err("spdif: set spdif rx rate failed\n");
+		ret = -EINVAL;
+		goto err_clk_set;
+	}
+#endif
+
+	if (reset_control_deassert(clk_info->clk_rst)) {
+		pr_err("spdif: deassert the spdif reset failed\n");
+		ret = -EINVAL;
+		goto err_clk_set;
+	}
+
+	if (clk_prepare_enable(clk_info->clk_bus)) {
+		dev_err(&pdev->dev, "spdif clk bus enable failed\n");
+		ret = -EBUSY;
+		goto err_clk_bus_enable;
+	}
+
+	if (clk_prepare_enable(clk_info->clk_pll)) {
+		dev_err(&pdev->dev, "clk_pll enable failed\n");
+		ret = -EBUSY;
+		goto err_clk_pll_enable;
+	}
+
+	if (clk_prepare_enable(clk_info->clk_pll1)) {
+		dev_err(&pdev->dev, "clk_pll1 enable failed\n");
+		ret = -EBUSY;
+		goto err_clk_pll1_enable;
+	}
+
+	if (clk_prepare_enable(clk_info->clk_pll1_div)) {
+		dev_err(&pdev->dev, "clk_pll1_div enable failed\n");
+		ret = -EBUSY;
+		goto err_clk_pll1_div_enable;
+	}
+
+	if (clk_prepare_enable(clk_info->clk_module)) {
+		dev_err(&pdev->dev, "moduleclk enable failed\n");
+		ret = -EBUSY;
+		goto err_clk_module_enable;
+	}
+
+#if IS_ENABLED(CONFIG_SND_SUNXI_SOC_SPDIF_RX_IEC61937)
+	if (clk_prepare_enable(clk_info->clk_pll_periph)) {
+		dev_err(&pdev->dev, "clk_pll1_div enable failed\n");
+		ret = -EBUSY;
+		goto err_clk_periph_enable;
+	}
+
+	if (clk_prepare_enable(clk_info->clk_module_rx)) {
+		dev_err(&pdev->dev, "clk_module_rx enable failed\n");
+		ret = -EBUSY;
+		goto err_clk_module_rx_enable;
+	}
+#endif
+
+	return 0;
+
+#if IS_ENABLED(CONFIG_SND_SUNXI_SOC_SPDIF_RX_IEC61937)
+err_clk_module_rx_enable:
+	clk_disable_unprepare(clk_info->clk_pll_periph);
+err_clk_periph_enable:
+	clk_disable_unprepare(clk_info->clk_module);
+#endif
+err_clk_module_enable:
+	clk_disable_unprepare(clk_info->clk_pll1_div);
+err_clk_pll1_div_enable:
+	clk_disable_unprepare(clk_info->clk_pll1);
+err_clk_pll1_enable:
+	clk_disable_unprepare(clk_info->clk_pll);
+err_clk_pll_enable:
+	clk_disable_unprepare(clk_info->clk_bus);
+err_clk_bus_enable:
+	reset_control_assert(clk_info->clk_rst);
+err_clk_set:
+#if IS_ENABLED(CONFIG_SND_SUNXI_SOC_SPDIF_RX_IEC61937)
+	clk_put(clk_info->clk_module_rx);
+	clk_put(clk_info->clk_pll_periph);
+#endif
+	clk_put(clk_info->clk_pll1_div);
+	clk_put(clk_info->clk_pll1);
+	clk_put(clk_info->clk_bus);
+	clk_put(clk_info->clk_module);
+	clk_put(clk_info->clk_pll);
+
+	return ret;
+};
+
+static int sunxi_spdif_pinctrl_init(struct platform_device *pdev,
+		struct device_node *np, struct sunxi_spdif_info *sunxi_spdif)
+{
+	struct sunxi_spdif_pinctl_info *pin_info = &sunxi_spdif->pin_info;
+	struct gpio_config config;
+	int ret = 0;
+
+	pin_info->pinctrl = devm_pinctrl_get(&pdev->dev);
+	if (IS_ERR_OR_NULL(pin_info->pinctrl)) {
+		dev_err(&pdev->dev,
+			"request pinctrl handle for audio failed\n");
+		ret = -EINVAL;
+		return ret;
+	}
+
+	pin_info->pinstate = pinctrl_lookup_state(pin_info->pinctrl,
+					PINCTRL_STATE_DEFAULT);
+	if (IS_ERR_OR_NULL(pin_info->pinstate)) {
+		dev_err(&pdev->dev, "lookup pin default state failed\n");
+		ret = -EINVAL;
+		return ret;
+	}
+
+	pin_info->pinstate_sleep = pinctrl_lookup_state(
+				pin_info->pinctrl, PINCTRL_STATE_SLEEP);
+	if (IS_ERR_OR_NULL(pin_info->pinstate_sleep)) {
+		dev_err(&pdev->dev, "lookup pin sleep state failed\n");
+		ret = -EINVAL;
+		return ret;
+	}
+
+	ret = pinctrl_select_state(pin_info->pinctrl, pin_info->pinstate);
+	if (ret) {
+		dev_err(sunxi_spdif->dev, "select pin default state failed\n");
+		ret = -EBUSY;
+		return ret;
+	}
+
+	pin_info->gpio_cfg.gpio = of_get_named_gpio_flags(np, "gpio-spdif", 0,
+					(enum of_gpio_flags *)&config);
+	if (!gpio_is_valid(pin_info->gpio_cfg.gpio)) {
+		dev_err(&pdev->dev, "Not using gpio-spdif gpio from dts\n");
+		pin_info->gpio_cfg.used = 0;
+	} else {
+		pin_info->gpio_cfg.level = of_property_read_bool(np, "gpio-level");
+		dev_info(&pdev->dev, "get gpio-level = %d.\n",
+					pin_info->gpio_cfg.level);
+
+		ret = devm_gpio_request(&pdev->dev, pin_info->gpio_cfg.gpio, "SPDIF");
+		if (ret < 0) {
+			dev_err(&pdev->dev, "failed to request gpio-spdif gpio\n");
+			goto err_devm_gpio_request;
+		} else {
+			pin_info->gpio_cfg.used = 1;
+			gpio_direction_output(pin_info->gpio_cfg.gpio,
+				!pin_info->gpio_cfg.level);
+		}
+	}
+
+	return 0;
+
+err_devm_gpio_request:
+	devm_pinctrl_put(pin_info->pinctrl);
+	return ret;
+};
+
+static int sunxi_spdif_dts_params_init(struct platform_device *pdev,
+		struct device_node *np, struct sunxi_spdif_info *sunxi_spdif)
+{
+	struct sunxi_spdif_dts_info *dts_info = &sunxi_spdif->dts_info;
+	unsigned int temp_val = 0;
+	int ret = 0;
+
+	ret = of_property_read_u32(np, "playback_cma", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "playback cma kbytes config missing or invalid.\n");
+		dts_info->playback_cma = SUNXI_AUDIO_CMA_MAX_KBYTES;
+	} else {
+		if (temp_val > SUNXI_AUDIO_CMA_MAX_KBYTES)
+			temp_val = SUNXI_AUDIO_CMA_MAX_KBYTES;
+		else if (temp_val < SUNXI_AUDIO_CMA_MIN_KBYTES)
+			temp_val = SUNXI_AUDIO_CMA_MIN_KBYTES;
+		dts_info->playback_cma = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "capture_cma", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "capture cma kbytes config missing or invalid.\n");
+		dts_info->capture_cma = SUNXI_AUDIO_CMA_MAX_KBYTES;
+	} else {
+		if (temp_val > SUNXI_AUDIO_CMA_MAX_KBYTES)
+			temp_val = SUNXI_AUDIO_CMA_MAX_KBYTES;
+		else if (temp_val < SUNXI_AUDIO_CMA_MIN_KBYTES)
+			temp_val = SUNXI_AUDIO_CMA_MIN_KBYTES;
+		dts_info->capture_cma = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "rx_sync_en", &temp_val);
+	if (ret != 0) {
+		dev_warn(&pdev->dev, "rx_sync_en config missing or invalid.\n");
+		sunxi_spdif->rx_sync_en = 0;
+	} else {
+		sunxi_spdif->rx_sync_en = temp_val;
+	}
+
+	if (sunxi_spdif->rx_sync_en) {
+		sunxi_spdif->rx_sync_domain = RX_SYNC_SYS_DOMAIN;
+		sunxi_spdif->rx_sync_id =
+			sunxi_rx_sync_probe(sunxi_spdif->rx_sync_domain);
+		if (sunxi_spdif->rx_sync_id < 0) {
+			dev_err(&pdev->dev, "sunxi_rx_sync_probe failed\n");
+			return -EINVAL;
+		}
+		dev_info(&pdev->dev, "sunxi_rx_sync_probe successful. domain=%d, id=%d\n",
+			sunxi_spdif->rx_sync_domain,
+			sunxi_spdif->rx_sync_id);
+	}
+
+	return 0;
+};
+
+static void sunxi_spdif_dma_params_init(struct resource res,
+					struct sunxi_spdif_info *sunxi_spdif)
+{
+	struct sunxi_spdif_dts_info *dts_info = &sunxi_spdif->dts_info;
+
+	sunxi_spdif->playback_dma_param.dma_addr = res.start + SUNXI_SPDIF_TXFIFO;
+	sunxi_spdif->playback_dma_param.dst_maxburst = 8;
+	sunxi_spdif->playback_dma_param.src_maxburst = 8;
+	sunxi_spdif->playback_dma_param.cma_kbytes = dts_info->playback_cma;
+	sunxi_spdif->playback_dma_param.fifo_size = SPDIF_TX_FIFO_SIZE;
+
+	sunxi_spdif->capture_dma_param.dma_addr = res.start + SUNXI_SPDIF_RXFIFO;
+	sunxi_spdif->capture_dma_param.src_maxburst = 8;
+	sunxi_spdif->capture_dma_param.dst_maxburst = 8;
+	sunxi_spdif->capture_dma_param.cma_kbytes = dts_info->capture_cma;
+	sunxi_spdif->capture_dma_param.fifo_size = SPDIF_RX_FIFO_SIZE;
+};
+
+static int  sunxi_spdif_dev_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct sunxi_spdif_info *sunxi_spdif = NULL;
+	struct sunxi_spdif_dts_info *dts_info = NULL;
+	struct sunxi_spdif_mem_info *mem_info = NULL;
+	struct sunxi_spdif_clk_info *clk_info = NULL;
+	struct sunxi_spdif_pinctl_info *pin_info = NULL;
+	int ret;
+
+	sunxi_spdif = devm_kzalloc(&pdev->dev,
+				sizeof(struct sunxi_spdif_info), GFP_KERNEL);
+	if (IS_ERR_OR_NULL(sunxi_spdif)) {
+		ret = -ENOMEM;
+		goto err_devm_malloc_spdif;
+	}
+
+	dev_set_drvdata(&pdev->dev, sunxi_spdif);
+	sunxi_spdif->dev = &pdev->dev;
+	sunxi_spdif->dai = sunxi_spdif_dai;
+	sunxi_spdif->dai.name = dev_name(&pdev->dev);
+	dts_info = &sunxi_spdif->dts_info;
+	mem_info = &sunxi_spdif->mem_info;
+	clk_info = &sunxi_spdif->clk_info;
+	pin_info = &sunxi_spdif->pin_info;
+
+	/* mem init about */
+	ret = sunxi_spdif_mem_init(pdev, np, sunxi_spdif);
+	if (ret) {
+		dev_err(&pdev->dev, "[%s] failed\n", __func__);
+		ret = -EINVAL;
+		return ret;
+	}
+
+	/* clk init about */
+	ret = sunxi_spdif_clk_init(pdev, np, sunxi_spdif);
+	if (ret) {
+		dev_err(&pdev->dev, "[%s] failed\n", __func__);
+		ret = -EINVAL;
+		return ret;
+	}
+
+	/* pinctrl init about */
+	ret = sunxi_spdif_pinctrl_init(pdev, np, sunxi_spdif);
+	if (ret) {
+		dev_err(&pdev->dev, "[%s] failed\n", __func__);
+		ret = -EINVAL;
+		return ret;
+	}
+
+	/* dts params about */
+	ret = sunxi_spdif_dts_params_init(pdev, np, sunxi_spdif);
+	if (ret) {
+		dev_err(&pdev->dev, "[%s] failed\n", __func__);
+		ret = -EINVAL;
+		return ret;
+	}
+
+	/* dma params about */
+	sunxi_spdif_dma_params_init(sunxi_spdif->mem_info.res, sunxi_spdif);
+
+	/* Codec component about register */
+	ret = snd_soc_register_component(&pdev->dev, &sunxi_spdif_component,
+					&sunxi_spdif->dai, 1);
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register DAI: %d\n", ret);
+		ret = -ENOMEM;
+		goto err_snd_register_component;
+	}
+
+	/* PCM Interface about register */
+	ret = asoc_dma_platform_register(&pdev->dev, 0);
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register PCM: %d\n", ret);
+		ret = -ENOMEM;
+		goto err_register_platform;
+	}
+
+#ifdef SUNXI_SPDIF_DEBUG
+	ret  = sysfs_create_group(&pdev->dev.kobj, &spdif_debug_attr_group);
+	if (ret)
+		dev_err(&pdev->dev, "failed to create attr group\n");
+#endif
+
+	return 0;
+
+err_register_platform:
+	snd_soc_unregister_component(&pdev->dev);
+err_snd_register_component:
+	devm_kfree(&pdev->dev, sunxi_spdif);
+err_devm_malloc_spdif:
+	of_node_put(np);
+	return ret;
+}
+
+static int __exit sunxi_spdif_dev_remove(struct platform_device *pdev)
+{
+	struct sunxi_spdif_info *sunxi_spdif = dev_get_drvdata(&pdev->dev);
+	struct sunxi_spdif_mem_info *mem_info = &sunxi_spdif->mem_info;
+	struct sunxi_spdif_clk_info *clk_info = &sunxi_spdif->clk_info;
+	struct sunxi_spdif_pinctl_info *pin_info = &sunxi_spdif->pin_info;
+
+	if (sunxi_spdif->rx_sync_en)
+		sunxi_rx_sync_remove(sunxi_spdif->rx_sync_domain);
+
+#ifdef SUNXI_SPDIF_DEBUG
+	sysfs_remove_group(&pdev->dev.kobj, &spdif_debug_attr_group);
+#endif
+
+	snd_soc_unregister_component(&pdev->dev);
+
+	if (gpio_is_valid(pin_info->gpio_cfg.gpio))
+		devm_gpio_free(&pdev->dev, pin_info->gpio_cfg.gpio);
+	devm_pinctrl_put(pin_info->pinctrl);
+
+	clk_disable_unprepare(clk_info->clk_module);
+	clk_put(clk_info->clk_module);
+	clk_disable_unprepare(clk_info->clk_pll);
+	clk_put(clk_info->clk_pll);
+	clk_disable_unprepare(clk_info->clk_bus);
+	clk_put(clk_info->clk_bus);
+	reset_control_assert(clk_info->clk_rst);
+
+	devm_iounmap(&pdev->dev, mem_info->membase);
+	devm_kfree(&pdev->dev, sunxi_spdif);
+
+	return 0;
+}
+
+static const struct of_device_id sunxi_spdif_of_match[] = {
+	{ .compatible = "allwinner,sunxi-spdif", },
+	{},
+};
+
+static struct platform_driver sunxi_spdif_driver = {
+	.probe = sunxi_spdif_dev_probe,
+	.remove = __exit_p(sunxi_spdif_dev_remove),
+	.driver = {
+		.name = DRV_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_spdif_of_match,
+	},
+};
+
+module_platform_driver(sunxi_spdif_driver);
+
+MODULE_AUTHOR("yumingfeng <yumingfeng@allwinnertech.com>");
+MODULE_DESCRIPTION("SUNXI SPDIF ASoC Interface");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:sunxi-spdif");
diff --git a/sound/soc/sunxi/sunxi-spdif.h b/sound/soc/sunxi/sunxi-spdif.h
new file mode 100644
index 000000000..50a31b6ae
--- /dev/null
+++ b/sound/soc/sunxi/sunxi-spdif.h
@@ -0,0 +1,322 @@
+/*
+ * sound\soc\sunxi\sunxi-spdif.h
+ * (C) Copyright 2019-2025
+ * allwinnertech Technology Co., Ltd. <www.allwinnertech.com>
+ * yumingfeng <yumingfeng@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef	__SUNXI_SPDIF_H_
+#define	__SUNXI_SPDIF_H_
+
+#include "sunxi-pcm.h"
+
+/* SPDIF register definition */
+#define	SUNXI_SPDIF_CTL		0x00
+#define	SUNXI_SPDIF_TXCFG	0x04
+#define	SUNXI_SPDIF_RXCFG	0x08
+#define SUNXI_SPDIF_INT_STA	(0x0C)
+#define	SUNXI_SPDIF_RXFIFO	0x10
+#define	SUNXI_SPDIF_FIFO_CTL	0x14
+#define	SUNXI_SPDIF_FIFO_STA	0x18
+#define	SUNXI_SPDIF_INT		0x1C
+#define SUNXI_SPDIF_TXFIFO	(0x20)
+#define	SUNXI_SPDIF_TXCNT	0x24
+#define	SUNXI_SPDIF_RXCNT	0x28
+#define	SUNXI_SPDIF_TXCH_STA0	0x2C
+#define	SUNXI_SPDIF_TXCH_STA1	0x30
+#define	SUNXI_SPDIF_RXCH_STA0	0x34
+#define	SUNXI_SPDIF_RXCH_STA1	0x38
+
+#if IS_ENABLED(CONFIG_SND_SUNXI_SOC_SPDIF_RX_IEC61937)
+#define	SUNXI_SPDIF_EXP_CTL	0x40
+#define	SUNXI_SPDIF_EXP_ISTA	0x44
+#define	SUNXI_SPDIF_EXP_INFO0	0x48
+#define	SUNXI_SPDIF_EXP_INFO1	0x4C
+#define	SUNXI_SPDIF_EXP_DBG0	0x50
+#define	SUNXI_SPDIF_EXP_DBG1	0x54
+#define	SUNXI_SPDIF_EXP_VER	0x58
+#endif
+
+#if IS_ENABLED(CONFIG_SND_SUNXI_SOC_SPDIF_RX_IEC61937)
+#define SUNXI_SPDIF_REG_MAX SUNXI_SPDIF_EXP_VER
+#else
+#define SUNXI_SPDIF_REG_MAX SUNXI_SPDIF_RXCH_STA1
+#endif
+
+/* SUNXI_SPDIF_CTL register */
+#define	CTL_RESET		0
+#define	CTL_GEN_EN		1
+#define	CTL_LOOP_EN		2
+#define	CTL_RESET_RX		0
+
+/* SUNXI_SPDIF_TXCFG register */
+#define	TXCFG_TXEN		0
+/* Chan status generated form TX_CHSTA */
+#define	TXCFG_CHAN_STA_EN	1
+#define	TXCFG_SAMPLE_BIT	2
+#define	TXCFG_CLK_DIV_RATIO	4
+#define	TXCFG_DATA_TYPE		16
+/* Only valid in PCM mode */
+#define	TXCFG_ASS		17
+#define	TXCFG_SINGLE_MOD	31
+
+/* SUNXI_SPDIF_RXCFG register */
+#define	RXCFG_RXEN		0
+#define	RXCFG_CHSR_CP		1
+#define	RXCFG_CHST_SRC		3
+#define	RXCFG_LOCK_FLAG		4
+
+/* SUNXI_SPDIF_FIFO_CTL register */
+#define	FIFO_CTL_RXOM		0
+#define	FIFO_CTL_TXIM		2
+#define	FIFO_CTL_RXTL		4
+#define	FIFO_CTL_TXTL		12
+#define	SPDIF_RX_SYNC_EN	20
+#define	SPDIF_RX_SYNC_EN_START	21
+#define	FIFO_CTL_FRX		29
+#define	FIFO_CTL_FTX		30
+#define	FIFO_CTL_HUBEN		31
+#define	CTL_TXTL_MASK		0xFF
+#define	CTL_TXTL_DEFAULT	0x40
+#define	CTL_RXTL_MASK		0x7F
+#define	CTL_RXTL_DEFAULT	0x20
+
+/* SUNXI_SPDIF_FIFO_STA register */
+#define	FIFO_STA_RXA_CNT	0
+#define	FIFO_STA_RXA		15
+#define	FIFO_STA_TXA_CNT	16
+#define	FIFO_STA_TXE		31
+
+/* SUNXI_SPDIF_INT register */
+#define	INT_RXAIEN		0
+#define	INT_RXOIEN		1
+#define	INT_RXDRQEN		2
+#define	INT_TXEIEN		4
+#define	INT_TXOIEN		5
+#define	INT_TXUIEN		6
+#define	INT_TXDRQEN		7
+#define	INT_RXPAREN		16
+#define	INT_RXUNLOCKEN		17
+#define	INT_RXLOCKEN		18
+
+/* SUNXI_SPDIF_INT_STA	*/
+#define	INT_STA_RXA		0
+#define	INT_STA_RXO		1
+#define	INT_STA_TXE		4
+#define	INT_STA_TXO		5
+#define	INT_STA_TXU		6
+#define	INT_STA_RXPAR		16
+#define	INT_STA_RXUNLOCK	17
+#define	INT_STA_RXLOCK		18
+
+/* SUNXI_SPDIF_TXCH_STA0 register */
+#define	TXCHSTA0_PRO		0
+#define	TXCHSTA0_AUDIO		1
+#define	TXCHSTA0_CP		2
+#define	TXCHSTA0_EMPHASIS	3
+#define	TXCHSTA0_MODE		6
+#define	TXCHSTA0_CATACOD	8
+#define	TXCHSTA0_SRCNUM		16
+#define	TXCHSTA0_CHNUM		20
+#define	TXCHSTA0_SAMFREQ	24
+#define	TXCHSTA0_CLK		28
+
+/* SUNXI_SPDIF_TXCH_STA1 register */
+#define	TXCHSTA1_MAXWORDLEN	0
+#define	TXCHSTA1_SAMWORDLEN	1
+#define	TXCHSTA1_ORISAMFREQ	4
+#define	TXCHSTA1_CGMSA		8
+
+/* SUNXI_SPDIF_RXCH_STA0 register */
+#define	RXCHSTA0_PRO		0
+#define	RXCHSTA0_AUDIO		1
+#define	RXCHSTA0_CP		2
+#define	RXCHSTA0_EMPHASIS	3
+#define	RXCHSTA0_MODE		6
+#define	RXCHSTA0_CATACOD	8
+#define	RXCHSTA0_SRCNUM		16
+#define	RXCHSTA0_CHNUM		20
+#define	RXCHSTA0_SAMFREQ	24
+#define	RXCHSTA0_CLK		28
+
+/* SUNXI_SPDIF_RXCH_STA1 register */
+#define	RXCHSTA1_MAXWORDLEN	0
+#define	RXCHSTA1_SAMWORDLEN	1
+#define	RXCHSTA1_ORISAMFREQ	4
+#define	RXCHSTA1_CGMSA		8
+
+#if IS_ENABLED(CONFIG_SND_SUNXI_SOC_SPDIF_RX_IEC61937)
+/* SUNXI_SPDIF_EXP_CTL register */
+#define INSET_DET_NUM		0
+#define INSET_DET_EN		8
+#define SYNCW_BIT_EN		9
+#define DATA_TYPE_BIT_EN	10
+#define DATA_LEG_BIT_EN		11
+#define AUDIO_DATA_BIT_EN	12
+#define RX_MODE			13
+#define RX_MODE_MAN		14
+#define UNIT_SEL		15
+#define RPOTBF_NUM		16
+#define BURST_DATA_OUT_SEL	30
+
+/* SUNXI_SPDIF_EXP_ISTA register */
+#define INSET_INT		0
+#define PAPB_CAP_INT		1
+#define PCPD_CAP_INT		2
+#define RPDB_ERR_INT		3
+#define PC_DTYOE_CH_INT		4
+#define PC_ERR_FLAG_INT		5
+#define PC_BIT_CH_INT		6
+#define PC_PAUSE_STOP_INT	7
+#define PD_CHAN_INT		8
+#define INSET_INT_EN		16
+#define PAPB_CAP_INT_EN		17
+#define PCPD_CAP_INT_EN		18
+#define RPDB_ERR_INT_EN		19
+#define PC_DTYOE_CH_INT_EN	20
+#define PC_ERR_FLAG_INT_EN	21
+#define PC_BIT_CH_INT_EN	22
+#define PC_PAUSE_STOP_INT_EN	23
+#define PD_CHAN_INT_EN		24
+
+/* SUNXI_SPDIF_EXP_INFO0 register */
+#define PD_DATA_INFO		0
+#define PC_DATA_INFO		16
+
+/* SUNXI_SPDIF_EXP_INFO1 register */
+#define SAMPLE_RATE_VAL		0
+#define RPOTBF_VAL		16
+
+/* SUNXI_SPDIF_EXP_DBG0 register */
+#define RE_DATA_COUNT_VAL	0
+#define DATA_CAP_STA_MACHE	16
+
+/* SUNXI_SPDIF_EXP_DBG1 register */
+#define SAMPLE_RATE_COUNT	0
+#define RPOTBF_COUNT		16
+
+/* SUNXI_SPDIF_EXP_VER register */
+#define MOD_VER			0
+#endif
+
+#define SPDIF_REG_LABEL(constant) \
+{ \
+	#constant, constant \
+}
+
+#define SPDIF_REG_LABEL_END \
+{ \
+	NULL, -1 \
+}
+
+#define SUNXI_SPDIF_RATES (SNDRV_PCM_RATE_8000_192000 | SNDRV_PCM_RATE_KNOT)
+
+#define SPDIF_RX_FIFO_SIZE 64
+#define SPDIF_TX_FIFO_SIZE 128
+
+#define SPDIF_CLK_PLL_AUDIO_X1 0
+#define SPDIF_CLK_PLL_AUDIO_X4 1
+
+struct sunxi_spdif_reg_label {
+	const char *name;
+	int value;
+};
+
+struct spdif_gpio_ {
+	u32 gpio;
+	bool level;
+	bool used;
+};
+
+struct sunxi_spdif_mem_info {
+	struct resource res;
+	void __iomem *membase;
+	struct resource *memregion;
+	struct regmap *regmap;
+};
+
+struct sunxi_spdif_clk_info {
+	struct clk *clk_pll;
+	struct clk *clk_module;
+	struct clk *clk_bus;
+	struct clk *clk_pll1;
+	struct clk *clk_pll1_div;
+#if IS_ENABLED(CONFIG_SND_SUNXI_SOC_SPDIF_RX_IEC61937)
+	struct clk *clk_pll_periph;
+	struct clk *clk_module_rx;
+#endif
+	struct reset_control *clk_rst;
+	unsigned int clk_parent;
+};
+
+struct sunxi_spdif_pinctl_info {
+	struct pinctrl *pinctrl;
+	struct pinctrl_state *pinstate;
+	struct pinctrl_state *pinstate_sleep;
+
+	struct spdif_gpio_ gpio_cfg;
+};
+
+struct sunxi_spdif_dts_info {
+	/* value must be (2^n)Kbyte */
+	size_t playback_cma;
+	size_t capture_cma;
+};
+
+#if IS_ENABLED(CONFIG_SND_SUNXI_SOC_SPDIF_RX_IEC61937)
+struct sunxi_spdif_rx_params {
+	u32 freq;
+	u32 orig_freq;
+	u32 refreq;
+	u32 channels;
+	u32 bits;
+};
+
+struct sunxi_spdif_rx_info {
+#if 0
+	u32 spdif_inset_int;
+	u32 spdif_rxlock_int;
+	u32 spdif_rxunlock_int;
+	u32 spdif_papb_int;
+	u32 channel_status;
+#endif
+	struct sunxi_spdif_rx_params rx_params;
+};
+#endif
+
+struct sunxi_spdif_info {
+	struct device *dev;
+
+	struct sunxi_spdif_mem_info mem_info;
+	struct sunxi_spdif_clk_info clk_info;
+	struct sunxi_spdif_pinctl_info pin_info;
+	struct sunxi_spdif_dts_info dts_info;
+#if IS_ENABLED(CONFIG_SND_SUNXI_SOC_SPDIF_RX_IEC61937)
+	struct sunxi_spdif_rx_info rx_info;
+
+	unsigned int spdif_rx_type;
+	/* spdif in irq */
+//	int spdif_irq;
+#endif
+	struct sunxi_dma_params playback_dma_param;
+	struct sunxi_dma_params capture_dma_param;
+
+	struct mutex mutex;
+	struct snd_soc_dai_driver dai;
+	unsigned int rate;
+	unsigned int active;
+	bool configured;
+
+	unsigned int rx_sync_en;
+	int rx_sync_id;
+	rx_sync_domain_t rx_sync_domain;
+};
+#endif	/* __SUNXI_SPDIF_H_ */
diff --git a/sound/soc/sunxi/sunxi_sound_log.h b/sound/soc/sunxi/sunxi_sound_log.h
new file mode 100644
index 000000000..3d087f853
--- /dev/null
+++ b/sound/soc/sunxi/sunxi_sound_log.h
@@ -0,0 +1,36 @@
+/*
+ * sound\soc\sunxi\sunxi_sound_log.h
+ * (C) Copyright 2021-2026
+ * allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <Dby@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#ifndef SUNXI_SOUND_LOG_H
+#define SUNXI_SOUND_LOG_H
+#include <linux/kernel.h>
+
+#define SOUND_LOG_ERR(fmt, arg...) do { \
+	    pr_err("[sound %d\t][%s] " fmt, __LINE__, __func__, ##arg); \
+	} while (0)
+
+#define SOUND_LOG_WARN(fmt, arg...) do { \
+	    pr_warning("[sound %d\t][%s] " fmt, __LINE__, __func__, ##arg); \
+	} while (0)
+
+#define SOUND_LOG_INFO(fmt, arg...) do { \
+	    pr_info("[sound %d\t][%s] " fmt, __LINE__, __func__, ##arg); \
+	} while (0)
+
+#define SOUND_LOG_DEBUG(fmt, arg...) do { \
+	    pr_debug("[sound %d\t][%s] " fmt, __LINE__, __func__, ##arg); \
+	} while (0)
+
+#endif /* SUNXI_SOUND_LOG_H */
+
diff --git a/sound/soc/sunxi_v2/Kconfig b/sound/soc/sunxi_v2/Kconfig
new file mode 100644
index 000000000..929187ba7
--- /dev/null
+++ b/sound/soc/sunxi_v2/Kconfig
@@ -0,0 +1,97 @@
+# common
+config SND_SOC_SUNXI_PCM
+	tristate
+
+config SND_SOC_SUNXI_MACH
+	tristate
+
+# internal codec
+config SND_SOC_SUNXI_SUN50IW9_CODEC
+	tristate
+
+# ahub temp
+config SND_SOC_SUNXI_AHUB_TMP
+	tristate
+
+
+# menu select
+menu "Allwinner Audio support"
+	depends on ARCH_SUNXI
+
+menu "Codec drivers"
+
+config SND_SOC_SUNXI_INTERNALCODEC
+	tristate "Allwinner INTERNAL CODEC support"
+	select SND_SOC_SUNXI_SUN50IW9_CODEC if ARCH_SUN50IW9
+	depends on ARCH_SUN50IW9
+	help
+	    Select Y or M to support INTERNAL CODEC Module in the Allwinner SoCs.
+
+config SND_SOC_SUNXI_DUMMYCODEC
+	tristate "Allwinner DUMMY CODEC support"
+	help
+	    Select Y or M to support DUMMY CODEC Module in the Allwinner SoCs.
+
+endmenu
+
+menu "Platform(Audio Interface) drivers"
+
+# aaudio
+config SND_SOC_SUNXI_AAUDIO
+	tristate "Allwinner AAUDIO support"
+	select REGMAP_MMIO
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	select SND_SOC_SUNXI_PCM
+	select SND_SOC_SUNXI_MACH
+	depends on ARCH_SUN50IW9
+	help
+	    Select Y or M to support AAUDIO Module in the Allwinner SoCs.
+
+# spdif
+config SND_SOC_SUNXI_SPDIF
+	tristate "Allwinner SPDIF Support"
+	select REGMAP_MMIO
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	select SND_SOC_SUNXI_PCM
+	select SND_SOC_SUNXI_MACH
+	depends on ARCH_SUN50IW9
+	help
+	    Select Y or M to support SPDIF Module in Allwinner SoCs.
+
+# dmic
+config SND_SOC_SUNXI_DMIC
+	tristate "Allwinner DMIC support"
+	select REGMAP_MMIO
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	select SND_SOC_SUNXI_PCM
+	select SND_SOC_SUNXI_MACH
+	depends on ARCH_SUN50IW9
+	help
+	    Select Y or M to support DMIC Module in Allwinner SoCs.
+
+# daudio
+config SND_SOC_SUNXI_DAUDIO
+	tristate "Allwinner DAUDIO Support"
+	select REGMAP_MMIO
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	select SND_SOC_SUNXI_PCM
+	select SND_SOC_SUNXI_MACH
+	depends on !ARCH_SUN50IW9
+	help
+	    Select Y or M to support I2S/PCM/TDM Module in Allwinner SoCs.
+
+# ahub
+config SND_SOC_SUNXI_AHUB
+	tristate "Allwinner AHUB Support"
+	select REGMAP_MMIO
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	select SND_SOC_SUNXI_PCM
+#	select SND_SOC_SUNXI_MACH
+	select SND_SOC_SUNXI_AHUB_TMP
+	depends on ARCH_SUN50IW9
+	help
+	    Select Y or M to support AHUB Module in Allwinner SoCs.
+
+endmenu
+
+endmenu
diff --git a/sound/soc/sunxi_v2/Makefile b/sound/soc/sunxi_v2/Makefile
new file mode 100644
index 000000000..ce41d4e9a
--- /dev/null
+++ b/sound/soc/sunxi_v2/Makefile
@@ -0,0 +1,43 @@
+# common -> platform of dma
+snd_soc_sunxi_pcm-objs				+= snd_sunxi_pcm.o
+obj-$(CONFIG_SND_SOC_SUNXI_PCM)			+= snd_soc_sunxi_pcm.o
+
+# common -> machine
+snd_soc_sunxi_machine-objs			+= snd_sunxi_mach.o
+snd_soc_sunxi_machine-objs			+= snd_sunxi_mach_utils.o
+obj-$(CONFIG_SND_SOC_SUNXI_MACH)		+= snd_soc_sunxi_machine.o
+
+# internal codec -> codec
+ifneq ($(CONFIG_SND_SOC_SUNXI_SUN50IW9_CODEC), n)
+snd_soc_sunxi_internal_codec-objs		+= snd_sun50iw9_codec.o
+# e.g.
+# else ifneq ($(CONFIG_SND_SOC_SUNXI_SUNxxIWxx_CODEC), n)
+# snd_soc_sunxi_internal_codec-objs		+= snd_sunxxiwxx_codec.o
+endif
+snd_soc_sunxi_internal_codec-objs		+= snd_sunxi_common.o
+snd_soc_sunxi_internal_codec-objs		+= snd_sunxi_adapter.o
+snd_soc_sunxi_internal_codec-objs		+= snd_sunxi_internal_codec.o
+obj-$(CONFIG_SND_SOC_SUNXI_INTERNALCODEC)	+= snd_soc_sunxi_internal_codec.o
+
+# dummy codec -> codec
+snd_soc_sunxi_dummy_codec-objs			+= snd_sunxi_dummy_codec.o
+obj-$(CONFIG_SND_SOC_SUNXI_DUMMYCODEC)		+= snd_soc_sunxi_dummy_codec.o
+
+# aaudio/spdif/dmic/daudio/ahub -> platform
+snd_soc_sunxi_aaudio-objs			+= snd_sunxi_aaudio.o
+obj-$(CONFIG_SND_SOC_SUNXI_AAUDIO)		+= snd_soc_sunxi_aaudio.o
+
+snd_soc_sunxi_spdif-objs			+= snd_sunxi_spdif.o
+obj-$(CONFIG_SND_SOC_SUNXI_SPDIF)		+= snd_soc_sunxi_spdif.o
+
+snd_soc_sunxi_dmic-objs				+= snd_sunxi_dmic.o
+obj-$(CONFIG_SND_SOC_SUNXI_DMIC)		+= snd_soc_sunxi_dmic.o
+
+snd_soc_sunxi_daudio-objs			+= snd_sunxi_daudio.o
+obj-$(CONFIG_SND_SOC_SUNXI_DAUDIO)		+= snd_soc_sunxi_daudio.o
+
+#snd_soc_sunxi_ahub-objs			+= snd_sunxi_ahub.o
+#obj-$(CONFIG_SND_SOC_SUNXI_AHUB)		+= snd_soc_sunxi_ahub.o
+
+# ahub tmp
+obj-$(CONFIG_SND_SOC_SUNXI_AHUB_TMP)		+= ahub/
diff --git a/sound/soc/sunxi_v2/ahub/Makefile b/sound/soc/sunxi_v2/ahub/Makefile
new file mode 100644
index 000000000..ddb0f84d4
--- /dev/null
+++ b/sound/soc/sunxi_v2/ahub/Makefile
@@ -0,0 +1,10 @@
+# SUNXI Ahub
+obj-$(CONFIG_SND_SOC_SUNXI_AHUB_TMP)		+= sunxi-pcm.o
+obj-$(CONFIG_SND_SOC_SUNXI_AHUB_TMP)		+= sunxi_ahub.o
+obj-$(CONFIG_SND_SOC_SUNXI_AHUB_TMP)		+= sunxi_ahub_cpudai.o
+obj-$(CONFIG_SND_SOC_SUNXI_AHUB_TMP)		+= sunxi-sndahub.o
+obj-$(CONFIG_SND_SOC_SUNXI_AHUB_TMP)		+= sunxi_ahub_daudio.o
+obj-$(CONFIG_SND_SOC_SUNXI_AHUB_TMP)		+= sunxi-snddaudio.o
+obj-$(CONFIG_SND_SOC_SUNXI_AHUB_TMP)		+= sunxi-hdmi.o
+obj-$(CONFIG_SND_SOC_SUNXI_AHUB_TMP)		+= sunxi-sndhdmi.o
+obj-$(CONFIG_SND_SOC_SUNXI_AHUB_TMP)		+= sunxi_netlink.o
\ No newline at end of file
diff --git a/sound/soc/sunxi_v2/ahub/sunxi-hdmi.c b/sound/soc/sunxi_v2/ahub/sunxi-hdmi.c
new file mode 100644
index 000000000..c285a765b
--- /dev/null
+++ b/sound/soc/sunxi_v2/ahub/sunxi-hdmi.c
@@ -0,0 +1,408 @@
+/*
+ * sound\soc\sunxi\sunxi-hdmi.c
+ * (C) Copyright 2014-2019
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * huangxin <huangxin@allwinnertech.com>
+ * yumingfeng <yumingfeng@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <linux/io.h>
+#include <video/drv_hdmi.h>
+
+#include "sunxi-pcm.h"
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+
+static bool			hdmiaudio_reset_en;
+atomic_t			pcm_count_num;
+static __audio_hdmi_func	g_hdmi_func;
+static hdmi_audio_t		hdmi_para;
+
+struct sunxi_hdmi_priv {
+	hdmi_audio_t hdmi_para;
+	bool update_param;
+};
+
+module_param_named(hdmiaudio_reset_en, hdmiaudio_reset_en,
+		bool, S_IRUGO | S_IWUSR);
+
+void audio_set_hdmi_func(__audio_hdmi_func *hdmi_func)
+{
+	if (hdmi_func) {
+		g_hdmi_func.hdmi_audio_enable	= hdmi_func->hdmi_audio_enable;
+		g_hdmi_func.hdmi_set_audio_para	=
+			hdmi_func->hdmi_set_audio_para;
+		g_hdmi_func.hdmi_is_playback	= hdmi_func->hdmi_is_playback;
+	} else {
+		pr_err("error:%s,line:%d\n", __func__, __LINE__);
+	}
+}
+EXPORT_SYMBOL(audio_set_hdmi_func);
+
+int sunxi_hdmi_codec_hw_params(struct snd_pcm_substream *substream,
+					struct snd_pcm_hw_params *params,
+					struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_card *card = rtd->card;
+	struct sndhdmi_priv *sndhdmi_priv = snd_soc_card_get_drvdata(card);
+	struct sunxi_hdmi_priv *sunxi_hdmi = snd_soc_component_get_drvdata(dai->component);
+
+	hdmi_para.sample_rate = params_rate(params);
+	hdmi_para.channel_num = params_channels(params);
+	hdmi_para.data_raw = sndhdmi_priv->hdmi_format;
+
+	if (sunxi_hdmi != NULL) {
+		if (sunxi_hdmi->hdmi_para.sample_rate != hdmi_para.sample_rate) {
+			sunxi_hdmi->hdmi_para.sample_rate = hdmi_para.sample_rate;
+			sunxi_hdmi->update_param = 1;
+		}
+		if (sunxi_hdmi->hdmi_para.channel_num != hdmi_para.channel_num) {
+			sunxi_hdmi->hdmi_para.channel_num = hdmi_para.channel_num;
+			sunxi_hdmi->update_param = 1;
+		}
+		if (sunxi_hdmi->hdmi_para.data_raw != hdmi_para.data_raw) {
+			sunxi_hdmi->hdmi_para.data_raw = hdmi_para.data_raw;
+			sunxi_hdmi->update_param = 1;
+		}
+	} else {
+		pr_warn("[%s] sunxi_hdmi is null.\n", __func__);
+	}
+
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		hdmi_para.sample_bit = 16;
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+		hdmi_para.sample_bit = 24;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		hdmi_para.sample_bit = 24;
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		hdmi_para.sample_bit = 24;
+		break;
+	default:
+		return -EINVAL;
+	}
+	/*
+	 * PCM = 1,
+	 * AC3 = 2,
+	 * MPEG1 = 3,
+	 * MP3 = 4,
+	 * MPEG2 = 5,
+	 * AAC = 6,
+	 * DTS = 7,
+	 * ATRAC = 8,
+	 * ONE_BIT_AUDIO = 9,
+	 * DOLBY_DIGITAL_PLUS = 10,
+	 * DTS_HD = 11,
+	 * MAT = 12,
+	 * DST = 13,
+	 * WMAPRO = 14.
+	 */
+	if (hdmi_para.data_raw > 1)
+		hdmi_para.sample_bit = 24;
+
+	if ((sunxi_hdmi != NULL) &&
+		(sunxi_hdmi->hdmi_para.sample_bit != hdmi_para.sample_bit)) {
+		sunxi_hdmi->hdmi_para.sample_bit = hdmi_para.sample_bit;
+		sunxi_hdmi->update_param = 1;
+	}
+
+	if (hdmi_para.channel_num == 8)
+		hdmi_para.ca = 0x13;
+	else if (hdmi_para.channel_num == 6)
+		hdmi_para.ca = 0x0b;
+	else if ((hdmi_para.channel_num >= 3))
+		hdmi_para.ca = 0x1f;
+	else
+		hdmi_para.ca = 0x0;
+
+	if ((sunxi_hdmi != NULL) &&
+		(sunxi_hdmi->hdmi_para.ca != hdmi_para.ca)) {
+		sunxi_hdmi->hdmi_para.ca = hdmi_para.ca;
+		sunxi_hdmi->update_param = 1;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(sunxi_hdmi_codec_hw_params);
+
+static int sunxi_hdmi_codec_set_dai_fmt(struct snd_soc_dai *codec_dai,
+			       unsigned int fmt)
+{
+	return 0;
+}
+
+int sunxi_hdmi_codec_prepare(struct snd_pcm_substream *substream,
+	struct snd_soc_dai *dai)
+{
+	struct sunxi_hdmi_priv *sunxi_hdmi = snd_soc_component_get_drvdata(dai->component);
+
+	if (hdmiaudio_reset_en == false) {
+		if ((sunxi_hdmi != NULL) && (sunxi_hdmi->update_param)) {
+			pr_warn("sunxi->update_param:%d\n", sunxi_hdmi->update_param);
+			atomic_set(&pcm_count_num, 0);
+			sunxi_hdmi->update_param = 0;
+		} else if (atomic_read(&pcm_count_num) == 0)
+			atomic_inc(&pcm_count_num);
+	} else if (hdmiaudio_reset_en == true)
+		atomic_set(&pcm_count_num, 0);
+
+	/*
+	 * set the first pcm param, need set the hdmi audio pcm param
+	 * set the data_raw param, need set the hdmi audio raw param
+	 */
+	if (!g_hdmi_func.hdmi_set_audio_para) {
+		pr_warn("hdmi video isn't insmod, hdmi interface is null\n");
+		return 0;
+	}
+
+	if (hdmiaudio_reset_en) {
+		pr_warn("[%s] raw:%d, sample_bit:%d, channel:%d, "
+			"sample_rate:%d, hdmiaudio_reset_en:%d\n", __func__,
+			hdmi_para.data_raw, hdmi_para.sample_bit,
+			hdmi_para.channel_num, hdmi_para.sample_rate,
+			hdmiaudio_reset_en);
+	}
+
+	if (atomic_read(&pcm_count_num) < 1) {
+		g_hdmi_func.hdmi_set_audio_para(&hdmi_para);
+		g_hdmi_func.hdmi_audio_enable(1, 1);
+		/*
+		 * When the params was be changed,
+		 * the hdmi clk should be shake hands again,
+		 * it needs some time to finishe.
+		 */
+		msleep(1200);
+	}
+	return 0;
+}
+EXPORT_SYMBOL(sunxi_hdmi_codec_prepare);
+
+void sunxi_hdmi_codec_shutdown(struct snd_pcm_substream *substream,
+					struct snd_soc_dai *dai)
+{
+	struct sunxi_hdmi_priv *sunxi_hdmi = snd_soc_component_get_drvdata(dai->component);
+
+	if (sunxi_hdmi)
+		sunxi_hdmi->update_param = 0;
+
+	if (g_hdmi_func.hdmi_audio_enable)
+		g_hdmi_func.hdmi_audio_enable(0, 1);
+}
+EXPORT_SYMBOL(sunxi_hdmi_codec_shutdown);
+
+static int sunxi_hdmi_codec_trigger(struct snd_pcm_substream *substream,
+				int cmd, struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static int sunxi_hdmi_codec_suspend(struct snd_soc_component *dai)
+{
+	return 0;
+}
+
+static int sunxi_hdmi_codec_resume(struct snd_soc_component *dai)
+{
+	atomic_set(&pcm_count_num, 0);
+	return 0;
+}
+
+static struct snd_soc_dai_ops sunxi_hdmi_dai_ops = {
+	.hw_params	= sunxi_hdmi_codec_hw_params,
+	.set_fmt	= sunxi_hdmi_codec_set_dai_fmt,
+	.trigger	= sunxi_hdmi_codec_trigger,
+	.prepare	= sunxi_hdmi_codec_prepare,
+	.shutdown	= sunxi_hdmi_codec_shutdown,
+};
+
+static struct snd_soc_dai_driver sunxi_hdmi_codec_dai = {
+	.name		= "audiohdmi-dai",
+	.playback	= {
+		.stream_name	= "Playback",
+		.channels_min	= 1,
+		.channels_max	= 8,
+		.rates		= SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+		.formats	= SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE
+				| SNDRV_PCM_FMTBIT_S32_LE,
+	},
+//#ifdef CONFIG_SUNXI_AUDIO_DEBUG
+	/* HDMI capture only for i2s loop(chan <= 2ch) debug */
+	.capture	= {
+		.stream_name	= "Capture",
+		.channels_min	= 1,
+		.channels_max	= 2,
+		.rates		= SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+		.formats	= SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE
+				| SNDRV_PCM_FMTBIT_S32_LE,
+	},
+//#endif
+	.ops			= &sunxi_hdmi_dai_ops,
+};
+
+static int sunxi_hdmi_codec_soc_probe(struct snd_soc_component *component)
+{
+	struct sunxi_hdmi_priv *sunxi_hdmi = NULL;
+
+	atomic_set(&pcm_count_num, 0);
+
+	if (!component) {
+		pr_err("error:%s,line:%d\n", __func__, __LINE__);
+		return -EAGAIN;
+	}
+
+	sunxi_hdmi = kzalloc(sizeof(struct sunxi_hdmi_priv), GFP_KERNEL);
+	if (sunxi_hdmi == NULL) {
+		pr_err("[%s] cannot malloc sunxi_hdmi.\n", __func__);
+		return -ENOMEM;
+	}
+	snd_soc_component_set_drvdata(component, sunxi_hdmi);
+
+	return 0;
+}
+
+static void sunxi_hdmi_codec_soc_remove(struct snd_soc_component *component)
+{
+	struct sunxi_hdmi_priv *sunxi_hdmi = NULL;
+
+	if (!component) {
+		pr_err("[%s] codec is null.\n", __func__);
+	} else {
+		sunxi_hdmi = snd_soc_component_get_drvdata(component);
+		kfree(sunxi_hdmi);
+	}
+}
+
+static struct snd_soc_component_driver soc_codec_dev_sunxi_hdmi = {
+	.probe		= sunxi_hdmi_codec_soc_probe,
+	.remove		= sunxi_hdmi_codec_soc_remove,
+	.suspend	= sunxi_hdmi_codec_suspend,
+	.resume		= sunxi_hdmi_codec_resume,
+};
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static inline void hdmiaudio_early_suspend(struct early_suspend *h)
+{
+}
+
+static inline void hdmiaudio_late_resume(struct early_suspend *h)
+{
+	atomic_set(&pcm_count_num, 0);
+}
+
+static struct early_suspend hdmiaudio_early_suspend_handler = {
+	.level		= EARLY_SUSPEND_LEVEL_BLANK_SCREEN,
+	.suspend	= hdmiaudio_early_suspend,
+	.resume		= hdmiaudio_late_resume,
+};
+#endif
+
+static int sunxi_hdmi_codec_probe(struct platform_device *pdev)
+{
+	if (!pdev) {
+		pr_err("error:%s,line:%d\n", __func__, __LINE__);
+		return -EAGAIN;
+	}
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	register_early_suspend(&hdmiaudio_early_suspend_handler);
+#endif
+	return snd_soc_register_component(&pdev->dev, &soc_codec_dev_sunxi_hdmi,
+				&sunxi_hdmi_codec_dai, 1);
+}
+
+static int __exit sunxi_hdmi_codec_remove(struct platform_device *pdev)
+{
+	if (!pdev) {
+		pr_err("error:%s,line:%d\n", __func__, __LINE__);
+		return -EAGAIN;
+	}
+
+	snd_soc_unregister_component(&pdev->dev);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	unregister_early_suspend(&hdmiaudio_early_suspend_handler);
+#endif
+
+	return 0;
+}
+
+void sunxi_hdmiaudio_device_release(struct device *dev)
+{
+	dev_notice(dev, "[%s] device_release.\n", __func__);
+}
+
+/*data relating*/
+static struct platform_device sunxi_hdmi_codec_device = {
+	.name	= "sunxi-hdmiaudio-codec",
+	.dev	= {
+		.release = sunxi_hdmiaudio_device_release,
+	},
+};
+
+static struct platform_driver sunxi_hdmi_codec_driver = {
+	.driver = {
+		.name	= "sunxi-hdmiaudio-codec",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= sunxi_hdmi_codec_probe,
+	.remove		= __exit_p(sunxi_hdmi_codec_remove),
+};
+
+static int __init sunxi_hdmi_codec_init(void)
+{
+	int err = 0;
+
+	err = platform_device_register(&sunxi_hdmi_codec_device);
+	if (err < 0) {
+		pr_err("sunxi hdmi codec register device failed\n");
+		return err;
+	}
+
+	err = platform_driver_register(&sunxi_hdmi_codec_driver);
+	if (err < 0) {
+		platform_device_unregister(&sunxi_hdmi_codec_device);
+		pr_err("sunxi hdmi codec register driver failed\n");
+		return err;
+	}
+
+	pr_warn("[%s] driver and deivce register finished.\n", __func__);
+
+	return 0;
+}
+module_init(sunxi_hdmi_codec_init);
+
+static void __exit sunxi_hdmi_codec_exit(void)
+{
+	platform_driver_unregister(&sunxi_hdmi_codec_driver);
+	platform_device_unregister(&sunxi_hdmi_codec_device);
+
+	pr_warn("[%s] driver and deivce unregister finished.\n", __func__);
+}
+module_exit(sunxi_hdmi_codec_exit);
+
+MODULE_DESCRIPTION("SUNXI ALSA HDMI Codec driver");
+MODULE_AUTHOR("huangxin, <huangxin@allwinnertech.com>");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/sunxi_v2/ahub/sunxi-pcm.c b/sound/soc/sunxi_v2/ahub/sunxi-pcm.c
new file mode 100644
index 000000000..7e8c61f99
--- /dev/null
+++ b/sound/soc/sunxi_v2/ahub/sunxi-pcm.c
@@ -0,0 +1,637 @@
+/*
+ * sound\soc\sunxi\sunxi-pcm.c
+ * (C) Copyright 2014-2018
+ * AllWinner Technology Co., Ltd. <www.allwinnertech.com>
+ * wolfgang huang <huangjinhui@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+//#include <linux/dma/sunxi-dma.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/dmaengine_pcm.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
+#include <asm/dma.h>
+#include "sunxi-pcm.h"
+
+static int raw_flag = 1;
+static dma_addr_t hdmiraw_dma_addr;
+static dma_addr_t hdmipcm_dma_addr;
+static int numtotal;
+static unsigned char *hdmiraw_dma_area;	/* DMA area */
+static unsigned int channel_status[192];
+
+static u64 sunxi_pcm_mask = DMA_BIT_MASK(32);
+
+struct headbpcuv {
+	unsigned char other:3;
+	unsigned char V:1;
+	unsigned char U:1;
+	unsigned char C:1;
+	unsigned char P:1;
+	unsigned char B:1;
+};
+
+union head61937 {
+	struct headbpcuv head0;
+	unsigned char head1;
+} head;
+
+union word {
+	struct {
+		unsigned int bit0:1;
+		unsigned int bit1:1;
+		unsigned int bit2:1;
+		unsigned int bit3:1;
+		unsigned int bit4:1;
+		unsigned int bit5:1;
+		unsigned int bit6:1;
+		unsigned int bit7:1;
+		unsigned int bit8:1;
+		unsigned int bit9:1;
+		unsigned int bit10:1;
+		unsigned int bit11:1;
+		unsigned int bit12:1;
+		unsigned int bit13:1;
+		unsigned int bit14:1;
+		unsigned int bit15:1;
+		unsigned int rsvd:16;
+	} bits;
+	unsigned int wval;
+} wordformat;
+
+static const struct snd_pcm_hardware sunxi_pcm_hardware = {
+	.info			= SNDRV_PCM_INFO_INTERLEAVED
+				| SNDRV_PCM_INFO_BLOCK_TRANSFER
+				| SNDRV_PCM_INFO_MMAP
+				| SNDRV_PCM_INFO_MMAP_VALID
+				| SNDRV_PCM_INFO_PAUSE
+				| SNDRV_PCM_INFO_RESUME,
+	.formats		= SNDRV_PCM_FMTBIT_S8
+				| SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S20_3LE
+				| SNDRV_PCM_FMTBIT_S24_LE
+				| SNDRV_PCM_FMTBIT_S32_LE,
+	.rates			= SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+	.rate_min		= 8000,
+	.rate_max		= 192000,
+	.channels_min		= 1,
+	.channels_max		= 8,
+	.period_bytes_min	= 256,
+#if defined(CONFIG_ARCH_SUN50IW9)
+	.buffer_bytes_max	= 1024 * 256,	/* value must be (2^n)Kbyte */
+	.period_bytes_max	= 1024 * 128,
+#else
+	.buffer_bytes_max	= 1024 * 1024,	/* value must be (2^n)Kbyte */
+	.period_bytes_max	= 1024 * 256,
+#endif
+	.periods_min		= 1,
+	.periods_max		= 8,
+	.fifo_size		= 128,
+};
+
+int sunxi_ahub_get_rawflag(void)
+{
+	return raw_flag;
+}
+
+int hdmi_transfer_format_61937_to_60958(int *out, short *temp,
+					int samples, int rate)
+{
+	int ret = 0;
+	int i;
+	static int numtotal;
+	union word w1;
+
+	samples >>= 1;
+	head.head0.other = 0;
+	head.head0.B = 1;
+	head.head0.P = 0;
+	head.head0.C = 0;
+	head.head0.U = 0;
+	head.head0.V = 1;
+
+	for (i = 0; i < 192; i++)
+		channel_status[i] = 0;
+
+	channel_status[1] = 1;
+	/* sample rates */
+	if (rate == 32000) {
+		channel_status[24] = 1;
+		channel_status[25] = 1;
+		channel_status[26] = 0;
+		channel_status[27] = 0;
+	} else if (rate == 44100) {
+		channel_status[24] = 0;
+		channel_status[25] = 0;
+		channel_status[26] = 0;
+		channel_status[27] = 0;
+	} else if (rate == 48000) {
+		channel_status[24] = 0;
+		channel_status[25] = 1;
+		channel_status[26] = 0;
+		channel_status[27] = 0;
+	} else if (rate == (32000*4)) {
+		channel_status[24] = 1;
+		channel_status[25] = 0;
+		channel_status[26] = 0;
+		channel_status[27] = 0;
+	} else if (rate == (44100*4)) {
+		channel_status[24] = 0;
+		channel_status[25] = 0;
+		channel_status[26] = 1;
+		channel_status[27] = 1;
+	} else if (rate == (48000*4)) {
+		channel_status[24] = 0;
+		channel_status[25] = 1;
+		channel_status[26] = 1;
+		channel_status[27] = 1;
+		if (raw_flag == 12 || raw_flag == 11) {
+			channel_status[24] = 1;
+			channel_status[25] = 0;
+			channel_status[26] = 0;
+			channel_status[27] = 1;
+		}
+	} else {
+		channel_status[24] = 0;
+		channel_status[25] = 1;
+		channel_status[26] = 0;
+		channel_status[27] = 0;
+	}
+
+	for (i = 0; i < samples; i++, numtotal++) {
+		if ((numtotal % 384 == 0) || (numtotal % 384 == 1))
+			head.head0.B = 1;
+		else
+			head.head0.B = 0;
+
+		head.head0.C = channel_status[(numtotal % 384)/2];
+
+		if (numtotal % 384 == 0)
+			numtotal = 0;
+
+		w1.wval = (*temp) & (0xffff);
+
+		head.head0.P = w1.bits.bit15 ^ w1.bits.bit14 ^ w1.bits.bit13
+			^ w1.bits.bit12 ^ w1.bits.bit11 ^ w1.bits.bit10
+			^ w1.bits.bit9 ^ w1.bits.bit8 ^ w1.bits.bit7
+			^ w1.bits.bit6 ^ w1.bits.bit5 ^ w1.bits.bit4
+			^ w1.bits.bit3 ^ w1.bits.bit2 ^ w1.bits.bit1
+			^ w1.bits.bit0;
+
+		ret = (int)(head.head1) << 24;
+		/* 11 may can be replace by 8 or 12 */
+		ret |= (int)((w1.wval)&(0xffff)) << 11;
+		*out = ret;
+		out++;
+		temp++;
+	}
+	return 0;
+}
+
+static int sunxi_pcm_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct sunxi_dma_params *dmap;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct device *dev = rtd->dev;
+	struct dma_chan *chan;
+	struct dma_slave_config slave_config;
+	int ret;
+
+#if defined(CONFIG_ARCH_SUN50IW10)
+	if (strcmp(rtd->card->name, "sun50iw10-codec") == 0) {
+		dmap = snd_soc_dai_get_dma_data(rtd->codec_dai, substream);
+	} else {
+		dmap = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
+	}
+#else
+	dmap = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
+#endif
+
+	ret = snd_hwparams_to_dma_slave_config(substream, params,
+					&slave_config);
+	if (ret) {
+		dev_err(dev, "hw params config failed with err %d\n", ret);
+		return ret;
+	}
+
+	slave_config.dst_maxburst = dmap->dst_maxburst;
+	slave_config.src_maxburst = dmap->src_maxburst;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		slave_config.dst_addr = dmap->dma_addr;
+		slave_config.src_addr_width = slave_config.dst_addr_width;
+		/*
+		slave_config.slave_id = sunxi_slave_id(dmap->dma_drq_type_num,
+						DRQSRC_SDRAM);
+		*/
+	} else {
+		slave_config.src_addr =	dmap->dma_addr;
+		slave_config.dst_addr_width = slave_config.src_addr_width;
+		/*
+		slave_config.slave_id = sunxi_slave_id(DRQDST_SDRAM,
+						dmap->dma_drq_type_num);
+		*/
+	}
+
+	chan = snd_dmaengine_pcm_get_chan(substream);
+	if (chan == NULL) {
+		pr_err("[%s] dma pcm get chan failed! chan is NULL!\n", __func__);
+		return -EINVAL;
+	}
+
+	ret = dmaengine_slave_config(chan, &slave_config);
+	if (ret < 0) {
+		dev_err(dev, "dma slave config failed with err %d\n", ret);
+		return ret;
+	}
+
+	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+
+	return 0;
+}
+
+
+static int sunxi_pcm_hdmi_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_card *card = rtd->card;
+	struct device *dev = card->dev;
+	struct dma_chan *chan = snd_dmaengine_pcm_get_chan(substream);
+	struct dma_slave_config slave_config;
+	struct sunxi_dma_params *dmap;
+	struct sndhdmi_priv *sndhdmi_priv = snd_soc_card_get_drvdata(card);
+	int ret;
+
+	raw_flag = sndhdmi_priv->hdmi_format;
+	pr_info("raw_flag value is %u\n", raw_flag);
+	dmap = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
+
+	ret = snd_hwparams_to_dma_slave_config(substream, params,
+						&slave_config);
+	if (ret) {
+		dev_err(dev, "hw params config failed with err %d\n", ret);
+		return ret;
+	}
+
+	slave_config.dst_maxburst = dmap->dst_maxburst;
+	slave_config.src_maxburst = dmap->src_maxburst;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		slave_config.dst_addr =	dmap->dma_addr;
+		slave_config.src_addr_width = slave_config.dst_addr_width;
+		/*
+		slave_config.slave_id = sunxi_slave_id(dmap->dma_drq_type_num,
+						DRQSRC_SDRAM);
+		*/
+	} else {
+		slave_config.src_addr =	dmap->dma_addr;
+		slave_config.dst_addr_width = slave_config.src_addr_width;
+		/*
+		slave_config.slave_id = sunxi_slave_id(DRQDST_SDRAM,
+						dmap->dma_drq_type_num);
+		*/
+	}
+
+	/*raw_flag>1. rawdata*/
+	if (raw_flag > 1) {
+		slave_config.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+		slave_config.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+#ifndef CONFIG_SND_SOC_SUNXI_AHUB_TMP
+	strcpy(substream->pcm->card->id, "sndhdmiraw");
+#endif
+		if (!dev->dma_mask)
+			dev->dma_mask = &sunxi_pcm_mask;
+		if (!dev->coherent_dma_mask)
+			dev->coherent_dma_mask = 0xffffffff;
+
+		hdmiraw_dma_area = dma_alloc_coherent(dev,
+				(2 * params_buffer_bytes(params)),
+				&hdmiraw_dma_addr, GFP_KERNEL);
+		if (hdmiraw_dma_area == NULL) {
+			pr_err("hdmi:raw:get mem failed...\n");
+			return -ENOMEM;
+		}
+		hdmipcm_dma_addr = substream->dma_buffer.addr;
+		substream->dma_buffer.addr = (dma_addr_t)hdmiraw_dma_addr;
+	} else {
+#ifndef CONFIG_SND_SOC_SUNXI_AHUB_TMP
+	strcpy(substream->pcm->card->id, "sndhdmi");
+#endif
+
+	}
+
+	ret = dmaengine_slave_config(chan, &slave_config);
+	if (ret < 0) {
+		dev_err(dev, "dma slave config failed with err %d\n", ret);
+		return ret;
+	}
+
+	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+
+	return 0;
+}
+
+static int sunxi_pcm_hdmi_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct device *dev = rtd->dev;
+
+	if (snd_pcm_lib_buffer_bytes(substream) && (raw_flag > 1)) {
+		dma_free_coherent(dev,
+				(2 * snd_pcm_lib_buffer_bytes(substream)),
+				hdmiraw_dma_area, hdmiraw_dma_addr);
+		substream->dma_buffer.addr = hdmipcm_dma_addr;
+		hdmiraw_dma_area = NULL;
+	}
+	snd_pcm_set_runtime_buffer(substream, NULL);
+
+	return 0;
+}
+
+static int sunxi_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	snd_pcm_set_runtime_buffer(substream, NULL);
+
+	return 0;
+}
+
+static int sunxi_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		switch (cmd) {
+		case SNDRV_PCM_TRIGGER_START:
+		case SNDRV_PCM_TRIGGER_RESUME:
+		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+			snd_dmaengine_pcm_trigger(substream,
+					SNDRV_PCM_TRIGGER_START);
+			break;
+		case SNDRV_PCM_TRIGGER_SUSPEND:
+		case SNDRV_PCM_TRIGGER_STOP:
+		case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+			snd_dmaengine_pcm_trigger(substream,
+					SNDRV_PCM_TRIGGER_STOP);
+			break;
+		}
+	} else {
+		switch (cmd) {
+		case SNDRV_PCM_TRIGGER_START:
+		case SNDRV_PCM_TRIGGER_RESUME:
+		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+			snd_dmaengine_pcm_trigger(substream,
+					SNDRV_PCM_TRIGGER_START);
+			break;
+		case SNDRV_PCM_TRIGGER_SUSPEND:
+		case SNDRV_PCM_TRIGGER_STOP:
+		case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+			snd_dmaengine_pcm_trigger(substream,
+					SNDRV_PCM_TRIGGER_STOP);
+			break;
+		}
+	}
+	return 0;
+}
+
+static const char * const dmaengine_pcm_dma_channel_names[] = {
+	[SNDRV_PCM_STREAM_PLAYBACK] = "tx",
+	[SNDRV_PCM_STREAM_CAPTURE] = "rx",
+};
+
+static int sunxi_pcm_open(struct snd_pcm_substream *substream)
+{
+	int ret = 0;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_component *component =
+		snd_soc_rtdcom_lookup(rtd, SUNXI_DMAENGINE_PCM_DRV_NAME);
+	struct device *dev = component->dev;
+	struct dma_chan *chan;
+
+	numtotal = 0;
+	/* Set HW params now that initialization is complete */
+	snd_soc_set_runtime_hwparams(substream, &sunxi_pcm_hardware);
+	ret = snd_pcm_hw_constraint_integer(substream->runtime,
+					    SNDRV_PCM_HW_PARAM_PERIODS);
+	if (ret < 0)
+		return ret;
+
+	chan = dma_request_chan(dev, dmaengine_pcm_dma_channel_names[substream->stream]);
+	if (IS_ERR(chan)) {
+		dev_err(dev, "DMA channels request %s failed.\n",
+				dmaengine_pcm_dma_channel_names[substream->stream]);
+		return -EINVAL;
+	}
+
+	ret = snd_dmaengine_pcm_open(substream, chan);
+	if (ret < 0) {
+		dev_err(dev, "dmaengine pcm open failed with err %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int sunxi_pcm_mmap(struct snd_pcm_substream *substream,
+	struct vm_area_struct *vma)
+{
+	struct snd_pcm_runtime *runtime = NULL;
+
+	if (substream->runtime != NULL) {
+		runtime = substream->runtime;
+
+		return dma_mmap_wc(substream->pcm->card->dev, vma,
+				runtime->dma_area,
+				runtime->dma_addr,
+				runtime->dma_bytes);
+	} else {
+		return -1;
+	}
+
+}
+
+static int sunxi_pcm_copy(struct snd_pcm_substream *substream, int channel,
+			  unsigned long hwoff, void __user *buf,
+			  unsigned long bytes)
+{
+	int ret = 0;
+	char *hwbuf;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		hwbuf = runtime->dma_area + hwoff;
+		if (copy_from_user(hwbuf, buf, bytes))
+			return -EFAULT;
+		if (raw_flag > 1) {
+			char *hdmihw_area = hdmiraw_dma_area + 2 * hwoff;
+			hdmi_transfer_format_61937_to_60958((int *)hdmihw_area,
+							    (short *)hwbuf,
+							    bytes,
+							    runtime->rate);
+		}
+	} else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		hwbuf = runtime->dma_area + hwoff;
+		if (copy_to_user(buf, hwbuf, bytes))
+			return -EFAULT;
+	}
+
+	return ret;
+}
+
+/* For passthrough mode: using no_residue */
+snd_pcm_uframes_t sunxi_dmaengine_pcm_pointer(struct snd_pcm_substream *substream)
+{
+	if (raw_flag > 1)
+		return snd_dmaengine_pcm_pointer_no_residue(substream);
+	else
+		return snd_dmaengine_pcm_pointer(substream);
+}
+
+static struct snd_pcm_ops sunxi_pcm_ops = {
+	.open		= sunxi_pcm_open,
+	.close		= snd_dmaengine_pcm_close_release_chan,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= sunxi_pcm_hw_params,
+	.hw_free	= sunxi_pcm_hw_free,
+	.trigger	= sunxi_pcm_trigger,
+	.pointer	= snd_dmaengine_pcm_pointer,
+	.mmap		= sunxi_pcm_mmap,
+};
+
+static struct snd_pcm_ops sunxi_pcm_ops_no_residue = {
+	.open		= sunxi_pcm_open,
+	.close		= snd_dmaengine_pcm_close_release_chan,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= sunxi_pcm_hdmi_hw_params,
+	.hw_free	= sunxi_pcm_hdmi_hw_free,
+	.trigger	= sunxi_pcm_trigger,
+	.pointer	= sunxi_dmaengine_pcm_pointer,
+	.mmap		= sunxi_pcm_mmap,
+	.copy_user	= sunxi_pcm_copy,
+};
+
+static int sunxi_pcm_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
+{
+	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+	size_t size = 0;
+
+	size = sunxi_pcm_hardware.buffer_bytes_max;
+	buf->dev.type = SNDRV_DMA_TYPE_DEV;
+	buf->dev.dev = pcm->card->dev;
+	buf->private_data = NULL;
+	buf->area = dma_alloc_coherent(pcm->card->dev, size,
+					&buf->addr, GFP_KERNEL);
+	if (!buf->area)
+		return -ENOMEM;
+	buf->bytes = size;
+
+	return 0;
+}
+
+static void sunxi_pcm_free_dma_buffers(struct snd_pcm *pcm)
+{
+	struct snd_pcm_substream *substream;
+	struct snd_dma_buffer *buf;
+	int stream;
+
+	for (stream = 0; stream < 2; stream++) {
+		substream = pcm->streams[stream].substream;
+		if (!substream)
+			continue;
+
+		buf = &substream->dma_buffer;
+		if (!buf->area)
+			continue;
+
+		dma_free_coherent(pcm->card->dev, buf->bytes,
+				buf->area, buf->addr);
+		buf->area = NULL;
+	}
+}
+
+
+static int sunxi_pcm_new(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_card *card = rtd->card->snd_card;
+	struct snd_pcm *pcm = rtd->pcm;
+	int ret = 0;
+
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &sunxi_pcm_mask;
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = 0xffffffff;
+
+	if (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream) {
+		ret = sunxi_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_PLAYBACK);
+		if (ret)
+			goto out;
+	}
+
+	if (pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream) {
+		ret = sunxi_pcm_preallocate_dma_buffer(pcm,
+			SNDRV_PCM_STREAM_CAPTURE);
+		if (ret)
+			goto out;
+	}
+out:
+	return ret;
+}
+
+static struct snd_soc_component_driver sunxi_soc_platform = {
+	.name		= SUNXI_DMAENGINE_PCM_DRV_NAME,
+	.ops		= &sunxi_pcm_ops,
+	.pcm_new	= sunxi_pcm_new,
+	.pcm_free	= sunxi_pcm_free_dma_buffers,
+};
+
+static const struct snd_soc_component_driver sunxi_soc_platform_no_residue = {
+	.name		= SUNXI_DMAENGINE_PCM_DRV_NAME,
+	.ops		= &sunxi_pcm_ops_no_residue,
+	.pcm_new	= sunxi_pcm_new,
+	.pcm_free	= sunxi_pcm_free_dma_buffers,
+};
+
+int asoc_dma_platform_register(struct device *dev, unsigned int flags)
+{
+	/*
+	 * FIXME, Don't try to request the DMA channels through devicetree.
+	 * in sunxi famaily, using HDMI, will decodec rawdata, should be using
+	 * self defined copy function, so using this flag just mark diff with
+	 * normal audio platform copy function, no relation with devicetree
+	 */
+	if (flags & SND_DMAENGINE_PCM_FLAG_NO_DT)
+		return snd_soc_register_component(dev,
+				&sunxi_soc_platform_no_residue, NULL, 0);
+	else
+		return snd_soc_register_component(dev,
+				&sunxi_soc_platform, NULL, 0);
+}
+EXPORT_SYMBOL_GPL(asoc_dma_platform_register);
+
+void asoc_dma_platform_unregister(struct device *dev)
+{
+	snd_soc_unregister_component(dev);
+}
+EXPORT_SYMBOL_GPL(asoc_dma_platform_unregister);
+
+MODULE_AUTHOR("huangxin, liushaohua");
+MODULE_DESCRIPTION("sunxi ASoC DMA Driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/sunxi_v2/ahub/sunxi-pcm.h b/sound/soc/sunxi_v2/ahub/sunxi-pcm.h
new file mode 100644
index 000000000..468351323
--- /dev/null
+++ b/sound/soc/sunxi_v2/ahub/sunxi-pcm.h
@@ -0,0 +1,34 @@
+/* sound\soc\sunxi\sunxi-pcm.h
+ * (C) Copyright 2014-2017
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Wolfgang Huang <huangjinhui@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#ifndef __SUNXI_PCM_H_
+#define __SUNXI_PCM_H_
+
+#define SUNXI_DMAENGINE_PCM_DRV_NAME "sunxi_dmaengine_pcm"
+
+struct sunxi_dma_params {
+	char *name;
+	dma_addr_t dma_addr;
+	u8 src_maxburst;
+	u8 dst_maxburst;
+	u8 dma_drq_type_num;
+};
+
+struct sndhdmi_priv {
+	unsigned int hdmi_format;
+};
+
+extern int asoc_dma_platform_register(struct device *dev, unsigned int flags);
+extern void asoc_dma_platform_unregister(struct device *dev);
+extern int sunxi_ahub_get_rawflag(void);
+#endif /* __SUNXI_PCM_H_ */
diff --git a/sound/soc/sunxi_v2/ahub/sunxi-sndahub.c b/sound/soc/sunxi_v2/ahub/sunxi-sndahub.c
new file mode 100644
index 000000000..1c5727336
--- /dev/null
+++ b/sound/soc/sunxi_v2/ahub/sunxi-sndahub.c
@@ -0,0 +1,443 @@
+/*
+ * sound\soc\sunxi\sunxi-sndhub.c
+ * (C) Copyright 2014-2018
+ * Allwinnertech Technology Co., Ltd. <www.allwinnertech.com>
+ * Wolfgang huang <huangjinhui@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <sound/soc-dapm.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/delay.h>
+
+#include "sunxi_ahub.h"
+#include "sunxi-pcm.h"
+//#include "../snd_sunxi_pcm.h"
+
+/* Configuration for a stream */
+struct pcm_config {
+	unsigned int channels;
+	unsigned int rate;
+	unsigned format;
+};
+
+#define AHUB_MAX_DEVICE		3
+static struct pcm_config pcm[AHUB_MAX_DEVICE][2];
+
+static int event_bind_id;
+static struct sndhdmi_priv sunxi_ahubhdmi;
+
+static int sunxi_ahubhdmi_set_audio_mode(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	sunxi_ahubhdmi.hdmi_format = ucontrol->value.integer.value[0];
+	return 0;
+}
+
+static int sunxi_ahubhdmi_get_audio_mode(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = sunxi_ahubhdmi.hdmi_format;
+	return 0;
+}
+
+static const char *ahubhdmi_format_function[] = {"null", "pcm", "AC3",
+	"MPEG1", "MP3", "MPEG2", "AAC", "DTS", "ATRAC", "ONE_BIT_AUDIO",
+	"DOLBY_DIGITAL_PLUS", "DTS_HD", "MAT", "WMAPRO"};
+static const struct soc_enum ahubhdmi_format_enum[] = {
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(ahubhdmi_format_function),
+			ahubhdmi_format_function),
+};
+
+/* pcm dts ac3 Audio Mode Select */
+static const struct snd_kcontrol_new sunxi_ahubhdmi_controls[] = {
+	SOC_ENUM_EXT("ahub audio format Function", ahubhdmi_format_enum[0],
+		sunxi_ahubhdmi_get_audio_mode, sunxi_ahubhdmi_set_audio_mode),
+};
+
+
+
+static int sunxi_ahub_netlink_event(struct snd_soc_dapm_widget *w,
+			int stream, int event)
+{
+	struct snd_soc_card *card = w->dapm->card;
+	struct snd_soc_pcm_runtime *rtd;
+	struct snd_soc_dai *codec_dai;
+	int opt_open;
+
+	list_for_each_entry (rtd, &card->rtd_list, list) {
+		 if (rtd->codec_dai->id == event_bind_id)
+				break;
+	}
+	codec_dai = rtd->codec_dai;
+
+	switch (event) {
+	case	SND_SOC_DAPM_POST_PMU:
+		opt_open = 1;
+		break;
+	case	SND_SOC_DAPM_PRE_PMD:
+		opt_open = 0;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* FIXME, as for AudioHub designed has three runtime, those runtime will
+	 * done it mess for some complex usage. so we just make sure allthing
+	 * work fine, we cut down diff sample rate playback or capture
+	 * do it at one time
+	 */
+
+	sunxi_netlink_printd("sunxi ahub event :%s : %ld :config=%ld/%ld/%ld/\n",
+			   w->name, (unsigned long)opt_open,
+			   (unsigned long)pcm[codec_dai->id][stream].channels,
+			   (unsigned long)pcm[codec_dai->id][stream].rate,
+			   (unsigned long)pcm[codec_dai->id][stream].format);
+
+	return 0;
+}
+
+static int sunxi_ahub_playback_event(struct snd_soc_dapm_widget *w,
+			struct snd_kcontrol *k, int event)
+{
+	return sunxi_ahub_netlink_event(w, 0, event);
+}
+
+static int sunxi_ahub_capture_event(struct snd_soc_dapm_widget *w,
+			struct snd_kcontrol *k, int event)
+{
+	return sunxi_ahub_netlink_event(w, 1, event);
+}
+
+static const struct snd_kcontrol_new sunxi_ahub_card_controls[] = {
+	SOC_DAPM_PIN_SWITCH("I2S0IN"),
+	SOC_DAPM_PIN_SWITCH("I2S0OUT"),
+	SOC_DAPM_PIN_SWITCH("I2S1IN"),
+	SOC_DAPM_PIN_SWITCH("I2S1OUT"),
+	SOC_DAPM_PIN_SWITCH("I2S2IN"),
+	SOC_DAPM_PIN_SWITCH("I2S2OUT"),
+	SOC_DAPM_PIN_SWITCH("I2S3IN"),
+	SOC_DAPM_PIN_SWITCH("I2S3OUT"),
+	SOC_DAPM_PIN_SWITCH("DAM0IN"),
+	SOC_DAPM_PIN_SWITCH("DAM1IN"),
+	SOC_DAPM_PIN_SWITCH("DAM0OUT"),
+	SOC_DAPM_PIN_SWITCH("DAM1OUT"),
+};
+
+/* the input & output dir depends on view of audio hub */
+static const struct snd_soc_dapm_widget sunxi_ahub_card_dapm_widgets[] = {
+	SND_SOC_DAPM_LINE("I2S0IN", sunxi_ahub_capture_event),
+	SND_SOC_DAPM_LINE("I2S0OUT", sunxi_ahub_playback_event),
+	SND_SOC_DAPM_LINE("I2S1IN", sunxi_ahub_capture_event),
+	SND_SOC_DAPM_LINE("I2S1OUT", sunxi_ahub_playback_event),
+	SND_SOC_DAPM_LINE("I2S2IN", sunxi_ahub_capture_event),
+	SND_SOC_DAPM_LINE("I2S2OUT", sunxi_ahub_playback_event),
+	SND_SOC_DAPM_LINE("I2S3IN", sunxi_ahub_capture_event),
+	SND_SOC_DAPM_LINE("I2S3OUT", sunxi_ahub_playback_event),
+	SND_SOC_DAPM_LINE("DAM0IN", NULL),
+	SND_SOC_DAPM_LINE("DAM1IN", NULL),
+	SND_SOC_DAPM_LINE("DAM0OUT", NULL),
+	SND_SOC_DAPM_LINE("DAM1OUT", NULL),
+};
+
+/* the input & output dir depends on view of audio hub */
+static const struct snd_soc_dapm_route sunxi_ahub_card_routes[] = {
+	{"I2S0 DAC", NULL, "I2S0IN"},
+	{"I2S1 DAC", NULL, "I2S1IN"},
+	{"I2S2 DAC", NULL, "I2S2IN"},
+	{"I2S3 DAC", NULL, "I2S3IN"},
+	{"I2S0OUT", NULL, "I2S0 ADC"},
+	{"I2S1OUT", NULL, "I2S1 ADC"},
+	{"I2S2OUT", NULL, "I2S2 ADC"},
+	{"I2S3OUT", NULL, "I2S3 ADC"},
+	{"DAM0 INPUT", NULL, "DAM0IN"},
+	{"DAM1 INPUT", NULL, "DAM1IN"},
+	{"DAM0OUT", NULL, "DAM0 OUTPUT"},
+	{"DAM1OUT", NULL, "DAM1 OUTPUT"},
+};
+
+static int sunxi_ahub_card_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_component *component = rtd->codec_dai->component;
+	struct snd_soc_dapm_context *dapm = &component->dapm;
+
+	snd_soc_dapm_disable_pin(dapm, "I2S0IN");
+	snd_soc_dapm_disable_pin(dapm, "I2S0OUT");
+	snd_soc_dapm_disable_pin(dapm, "I2S1IN");
+	snd_soc_dapm_disable_pin(dapm, "I2S1OUT");
+	snd_soc_dapm_disable_pin(dapm, "I2S2IN");
+	snd_soc_dapm_disable_pin(dapm, "I2S2OUT");
+	snd_soc_dapm_disable_pin(dapm, "I2S3IN");
+	snd_soc_dapm_disable_pin(dapm, "I2S3OUT");
+	snd_soc_dapm_disable_pin(dapm, "DAM0IN");
+	snd_soc_dapm_disable_pin(dapm, "DAM1IN");
+	snd_soc_dapm_disable_pin(dapm, "DAM0OUT");
+	snd_soc_dapm_disable_pin(dapm, "DAM1OUT");
+
+	snd_soc_dapm_sync(dapm);
+	return 0;
+}
+
+static int sunxi_sndahub_hw_params(struct snd_pcm_substream *substream,
+					struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_card *card = rtd->card;
+	unsigned int freq;
+	int ret;
+
+	switch (params_rate(params)) {
+	case 8000:
+	case 16000:
+	case 32000:
+	case 64000:
+	case 128000:
+	case 12000:
+	case 24000:
+	case 48000:
+	case 96000:
+	case 192000:
+//#ifdef CONFIG_AHUB_FREQ_REQ
+#ifdef CONFIG_SND_SOC_SUNXI_AHUB_TMP
+		freq = 98304000;
+#else
+		freq = 24576000;
+#endif
+		break;
+	case	11025:
+	case	22050:
+	case	44100:
+	case	88200:
+	case	176400:
+//#ifdef CONFIG_AHUB_FREQ_REQ
+#ifdef CONFIG_SND_SOC_SUNXI_AHUB_TMP
+		freq = 90316800;
+#else
+		freq = 22579200;
+#endif
+		break;
+	default:
+		dev_err(card->dev, "unsupport freq\n");
+		return -EINVAL;
+	}
+
+	/*set system clock source freq and set the mode as i2s0 or pcm*/
+	ret = snd_soc_dai_set_sysclk(codec_dai, 0, freq, 0);
+	if (ret < 0)
+		return ret;
+
+	/*FIXME used for event send to observer process */
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		pcm[codec_dai->id][0].channels = params_channels(params);
+		pcm[codec_dai->id][0].rate = params_rate(params);
+		/* for HDMI raw_data, no residue mode, just make it double */
+		if (sunxi_ahub_get_rawflag() > 1)
+			pcm[codec_dai->id][0].format = SNDRV_PCM_FORMAT_S32_LE;
+		else
+			pcm[codec_dai->id][0].format = params_format(params);
+	} else {
+		pcm[codec_dai->id][1].channels = params_channels(params);
+		pcm[codec_dai->id][1].rate = params_rate(params);
+		if (sunxi_ahub_get_rawflag() > 1)
+			pcm[codec_dai->id][1].format = SNDRV_PCM_FORMAT_S32_LE;
+		else
+			pcm[codec_dai->id][1].format = params_format(params);
+	}
+
+	event_bind_id = codec_dai->id;
+
+	return 0;
+}
+
+static int sunxi_ahubhdmi_probe(struct snd_soc_card *card)
+{
+	int ret;
+
+	ret = snd_soc_add_card_controls(card, sunxi_ahubhdmi_controls,
+				ARRAY_SIZE(sunxi_ahubhdmi_controls));
+	if (ret)
+		dev_warn(card->dev, "Failed to register hdmi mode kcontrol\n");
+	return 0;
+}
+
+
+static struct snd_soc_ops sunxi_sndahub_ops = {
+	.hw_params	= sunxi_sndahub_hw_params,
+};
+
+SND_SOC_DAILINK_DEFS(ahub_dai_link1,
+	DAILINK_COMP_ARRAY(COMP_CPU("sunxi-ahub-cpudai")),
+	DAILINK_COMP_ARRAY(COMP_CODEC("sunxi-ahub", "sunxi-ahub-aif1")),
+	DAILINK_COMP_ARRAY(COMP_PLATFORM("sunxi-ahub-cpudai")));
+SND_SOC_DAILINK_DEFS(ahub_dai_link2,
+	DAILINK_COMP_ARRAY(COMP_CPU("sunxi-ahub-cpudai")),
+	DAILINK_COMP_ARRAY(COMP_CODEC("sunxi-ahub", "sunxi-ahub-aif2")),
+	DAILINK_COMP_ARRAY(COMP_PLATFORM("sunxi-ahub-cpudai")));
+SND_SOC_DAILINK_DEFS(ahub_dai_link3,
+	DAILINK_COMP_ARRAY(COMP_CPU("sunxi-ahub-cpudai")),
+	DAILINK_COMP_ARRAY(COMP_CODEC("sunxi-ahub", "sunxi-ahub-aif3")),
+	DAILINK_COMP_ARRAY(COMP_PLATFORM("sunxi-ahub-cpudai")));
+
+static struct snd_soc_dai_link sunxi_sndahub_dai_link[] = {
+	{
+		.name = "Primary",
+		.stream_name = "Media Stream",
+		.init = sunxi_ahub_card_init,
+		.ops = &sunxi_sndahub_ops,
+		SND_SOC_DAILINK_REG(ahub_dai_link1),
+	},
+	{
+		.name = "Sec",
+		.stream_name = "System Stream",
+		.ops = &sunxi_sndahub_ops,
+		SND_SOC_DAILINK_REG(ahub_dai_link2),
+	},
+	{
+		.name = "Thr",
+		.stream_name = "Accompany Stream",
+		.ops = &sunxi_sndahub_ops,
+		SND_SOC_DAILINK_REG(ahub_dai_link3),
+	},
+};
+/*
+static struct snd_soc_dai_link sunxi_sndahub_dai_link[] = {
+	{
+		.name = "Primary",
+		.stream_name = "Media Stream",
+		.codec_dai_name = "sunxi-ahub-aif1",
+		.init = sunxi_ahub_card_init,
+		.ops = &sunxi_sndahub_ops,
+	},
+	{
+		.name = "Sec",
+		.stream_name = "System Stream",
+		.codec_dai_name = "sunxi-ahub-aif2",
+		.ops = &sunxi_sndahub_ops,
+	},
+	{
+		.name = "Thr",
+		.stream_name = "Accompany Stream",
+		.codec_dai_name = "sunxi-ahub-aif3",
+		.ops = &sunxi_sndahub_ops,
+	},
+};
+*/
+
+static struct snd_soc_card snd_soc_sunxi_sndahub = {
+	.name			= "sndahub",
+	.owner			= THIS_MODULE,
+	.controls		= sunxi_ahub_card_controls,
+	.num_controls		= ARRAY_SIZE(sunxi_ahub_card_controls),
+	.probe				= sunxi_ahubhdmi_probe,
+	.dapm_widgets       = sunxi_ahub_card_dapm_widgets,
+	.num_dapm_widgets   = ARRAY_SIZE(sunxi_ahub_card_dapm_widgets),
+	.dapm_routes        = sunxi_ahub_card_routes,
+	.num_dapm_routes    = ARRAY_SIZE(sunxi_ahub_card_routes),
+	.dai_link		= sunxi_sndahub_dai_link,
+	.num_links		= ARRAY_SIZE(sunxi_sndahub_dai_link),
+};
+
+static int sunxi_sndahub_dev_probe(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = &snd_soc_sunxi_sndahub;
+	struct device_node *np = pdev->dev.of_node;
+	int ret;
+	int i;
+
+	card->dev = &pdev->dev;
+
+	sunxi_sndahub_dai_link[0].cpus->dai_name = NULL;
+	sunxi_sndahub_dai_link[0].cpus->of_node = of_parse_phandle(np,
+					"sunxi,cpudai-controller0", 0);
+	if (!sunxi_sndahub_dai_link[0].cpus->of_node) {
+		dev_err(&pdev->dev, "Property 'sunxi,cpudai-controller0' missing or invalid\n");
+		return -EINVAL;
+	} else {
+		sunxi_sndahub_dai_link[0].platforms->name = NULL;
+		sunxi_sndahub_dai_link[0].platforms->of_node =
+				sunxi_sndahub_dai_link[0].cpus->of_node;
+	}
+
+	sunxi_sndahub_dai_link[1].cpus->dai_name = NULL;
+	sunxi_sndahub_dai_link[1].cpus->of_node = of_parse_phandle(np,
+					"sunxi,cpudai-controller1", 0);
+	if (!sunxi_sndahub_dai_link[1].cpus->of_node) {
+		dev_err(&pdev->dev, "Property 'sunxi,cpudai-controller1' missing or invalid\n");
+		return -EINVAL;
+	} else {
+		sunxi_sndahub_dai_link[1].platforms->name = NULL;
+		sunxi_sndahub_dai_link[1].platforms->of_node =
+				sunxi_sndahub_dai_link[1].cpus->of_node;
+	}
+
+	sunxi_sndahub_dai_link[2].cpus->dai_name = NULL;
+	sunxi_sndahub_dai_link[2].cpus->of_node = of_parse_phandle(np,
+					"sunxi,cpudai-controller2", 0);
+	if (!sunxi_sndahub_dai_link[2].cpus->of_node) {
+		dev_err(&pdev->dev, "Property 'sunxi,cpudai-controller0' missing or invalid\n");
+		return -EINVAL;
+	} else {
+		sunxi_sndahub_dai_link[2].platforms->name = NULL;
+		sunxi_sndahub_dai_link[2].platforms->of_node =
+				sunxi_sndahub_dai_link[2].cpus->of_node;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(sunxi_sndahub_dai_link); i++) {
+		sunxi_sndahub_dai_link[i].codecs->name = NULL;
+		sunxi_sndahub_dai_link[i].codecs->of_node = of_parse_phandle(np,
+							"sunxi,audio-codec", 0);
+	}
+
+	snd_soc_card_set_drvdata(card, &sunxi_ahubhdmi);
+	ret = snd_soc_register_card(card);
+	if (ret) {
+		dev_err(&pdev->dev, "snd_soc_register_card() failed: %d\n",
+			ret);
+	}
+	return ret;
+}
+
+static int __exit sunxi_sndahub_dev_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+
+	snd_soc_unregister_card(card);
+	return 0;
+}
+
+static const struct of_device_id sunxi_ahub_of_match[] = {
+	{ .compatible = "allwinner,sunxi-ahub-machine", },
+	{},
+};
+
+static struct platform_driver sunxi_ahubaudio_driver = {
+	.driver = {
+		.name = "sndahub",
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_ahub_of_match,
+		.pm = &snd_soc_pm_ops,
+	},
+	.probe = sunxi_sndahub_dev_probe,
+	.remove = __exit_p(sunxi_sndahub_dev_remove),
+};
+
+module_platform_driver(sunxi_ahubaudio_driver);
+
+MODULE_AUTHOR("wolfgang huang <huangjinhui@allwinnertech.com>");
+MODULE_DESCRIPTION("SUNXI Audio Hub ASoC Machine driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/sunxi_v2/ahub/sunxi-snddaudio.c b/sound/soc/sunxi_v2/ahub/sunxi-snddaudio.c
new file mode 100644
index 000000000..f7545d72f
--- /dev/null
+++ b/sound/soc/sunxi_v2/ahub/sunxi-snddaudio.c
@@ -0,0 +1,560 @@
+/*
+ * sound\soc\sunxi\sunxi_snddaudio.c
+ * (C) Copyright 2014-2016
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Wolfgang Huang <huangjinhui@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <sound/soc-dapm.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#ifdef CONFIG_SND_SUNXI_MAD
+#include "sunxi-mad.h"
+static struct sunxi_mad_priv sunxi_daudio_priv;
+#endif
+
+static atomic_t daudio_count = ATOMIC_INIT(-1);
+
+struct platform_data {
+	unsigned int audio_format;
+	unsigned int signal_inversion;
+	unsigned int daudio_master;
+};
+
+struct sunxi_snddaudio_priv {
+	struct snd_soc_card *card;
+	struct platform_data pdata;
+};
+
+static int sunxi_snddaudio_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_card *card = rtd->card;
+	struct sunxi_snddaudio_priv *snddaudio_priv =
+				snd_soc_card_get_drvdata(card);
+	struct platform_data *pdata = &(snddaudio_priv->pdata);
+	unsigned int freq, clk_div;
+	int ret;
+
+	switch (params_rate(params)) {
+	case 8000:
+	case 16000:
+	case 32000:
+	case 64000:
+	case 128000:
+	case 24000:
+	case 48000:
+	case 96000:
+	case 192000:
+//#ifdef CONFIG_AHUB_FREQ_REQ
+#ifdef CONFIG_SND_SOC_SUNXI_AHUB_TMP
+	freq = 98304000;
+#else
+	freq = 24576000;
+#endif
+		break;
+	case 11025:
+	case 22050:
+	case 44100:
+	case 88200:
+	case 176400:
+//#ifdef CONFIG_AHUB_FREQ_REQ
+#ifdef CONFIG_SND_SOC_SUNXI_AHUB_TMP
+	freq = 90316800;
+#else
+		freq = 22579200;
+#endif
+		break;
+	default:
+		dev_err(card->dev, "unsupport params rate\n");
+		return -EINVAL;
+	}
+
+	/* set platform clk source freq and set the mode as daudio or pcm */
+	ret = snd_soc_dai_set_sysclk(cpu_dai, 0, freq, 0);
+	if (ret < 0)
+		return ret;
+
+	/* set codec clk source freq and set the mode as daudio or pcm */
+	ret = snd_soc_dai_set_sysclk(codec_dai, 0, freq, 0);
+	if (ret < 0)
+		dev_warn(card->dev, "codec_dai set sysclk failed\n");
+
+	ret = snd_soc_dai_set_pll(codec_dai, 0, 0, freq, freq);
+	if (ret < 0)
+		dev_warn(card->dev, "codec_dai set set_pll failed.\n");
+
+	/* set codec dai fmt */
+	ret = snd_soc_dai_set_fmt(codec_dai, pdata->audio_format
+			| (pdata->signal_inversion << 8)
+			| (pdata->daudio_master << 12));
+	if (ret < 0)
+		dev_warn(card->dev, "codec dai set fmt failed\n");
+
+	/* set cpu dai fmt */
+	ret = snd_soc_dai_set_fmt(cpu_dai, pdata->audio_format
+			| (pdata->signal_inversion << 8)
+			| (pdata->daudio_master << 12));
+	if (ret < 0)
+		dev_warn(card->dev, "cpu dai set fmt failed\n");
+
+	/* set system clk div */
+	clk_div = freq / params_rate(params);
+	ret = snd_soc_dai_set_clkdiv(cpu_dai, 0, clk_div);
+	if (ret < 0) {
+		dev_warn(card->dev, "cpu_dai set clkdiv failed\n");
+		return ret;
+	}
+
+	ret = snd_soc_dai_set_clkdiv(codec_dai, 0, clk_div);
+	if (ret < 0)
+		dev_warn(card->dev, "codec_dai set clkdiv failed\n");
+
+	return 0;
+}
+
+/* sunxi card initialization */
+static int sunxi_snddaudio_init(struct snd_soc_pcm_runtime *rtd)
+{
+	return 0;
+}
+
+#ifdef CONFIG_SND_SUNXI_MAD
+/*enable the snddaudio suspend */
+static int sunxi_snddaudio_startup(struct snd_pcm_substream *substream)
+{
+    struct snd_soc_pcm_runtime *rtd = substream->private_data;
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		if (sunxi_daudio_priv.mad_bind == 1)
+			rtd->dai_link->ignore_suspend = 1;
+	}
+
+    return 0;
+}
+
+/*disable the snddaudio suspend */
+static void sunxi_snddaudio_shutdown(struct snd_pcm_substream *substream)
+{
+    struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		if (sunxi_daudio_priv.mad_bind == 1)
+			rtd->dai_link->ignore_suspend = 0;
+	}
+}
+
+/*mad_bind config*/
+static int sunxi_daudio_set_mad_bind(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	sunxi_daudio_priv.mad_bind = ucontrol->value.integer.value[0];
+	return 0;
+}
+
+static int sunxi_daudio_get_mad_bind(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = sunxi_daudio_priv.mad_bind;
+	return 0;
+}
+
+static const char *mad_bind_function[] = {"mad_unbind", "mad_bind"};
+
+static const struct soc_enum mad_bind_enum[] = {
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(mad_bind_function),
+			mad_bind_function),
+};
+
+/* daudio machine kcontrols */
+static const struct snd_kcontrol_new sunxi_snddaudio_controls[] = {
+	SOC_ENUM_EXT("daudio bind mad Function", mad_bind_enum[0],
+		sunxi_daudio_get_mad_bind, sunxi_daudio_set_mad_bind),
+};
+#endif
+
+static struct snd_soc_ops sunxi_snddaudio_ops = {
+	.hw_params      = sunxi_snddaudio_hw_params,
+#ifdef CONFIG_SND_SUNXI_MAD
+	.startup = sunxi_snddaudio_startup,
+	.shutdown = sunxi_snddaudio_shutdown,
+#endif
+};
+
+SND_SOC_DAILINK_DEFS(daudio_dai_link,
+	DAILINK_COMP_ARRAY(COMP_CPU("sunxi-daudio")),
+	DAILINK_COMP_ARRAY(COMP_CODEC("snd-soc-dummy", "snd-soc-dummy-dai")),
+	DAILINK_COMP_ARRAY(COMP_PLATFORM("sunxi-daudio")));
+
+static struct snd_soc_dai_link sunxi_snddaudio_dai_link = {
+	.name           = "sysvoice",
+	.stream_name    = "SUNXI-AUDIO",
+	/*
+	.cpu_dai_name   = "sunxi-daudio",
+	.platform_name  = "sunxi-daudio",
+	.codec_dai_name = "snd-soc-dummy-dai",
+	.codec_name     = "snd-soc-dummy",
+	*/
+	.init           = sunxi_snddaudio_init,
+	.ops            = &sunxi_snddaudio_ops,
+	SND_SOC_DAILINK_REG(daudio_dai_link),
+};
+
+static struct snd_soc_card snd_soc_sunxi_snddaudio = {
+	.name           = "snddaudio",
+	.owner          = THIS_MODULE,
+	.dai_link       = &sunxi_snddaudio_dai_link,
+	.num_links      = 1,
+#ifdef CONFIG_SND_SUNXI_MAD
+	.controls = sunxi_snddaudio_controls,
+	.num_controls = ARRAY_SIZE(sunxi_snddaudio_controls),
+#endif
+};
+
+#ifdef CONFIG_SND_SOC_SUNXI_AHUB_TMP
+static int sunxi_snddaudio_dev_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct snd_soc_dai_link	*dai_link;
+	struct snd_soc_card *card;
+	struct sunxi_snddaudio_priv *snddaudio_priv;
+	char name[30] = "snddaudio";
+	unsigned int temp_val;
+	int ret = 0;
+
+	snddaudio_priv = devm_kzalloc(&pdev->dev,
+			sizeof(struct sunxi_snddaudio_priv), GFP_KERNEL);
+	if (!snddaudio_priv) {
+		dev_err(&pdev->dev, "Can't malloc the sunxi_snddaudio_priv!\n");
+		return -ENOMEM;
+	}
+
+	snddaudio_priv->card = devm_kzalloc(&pdev->dev,
+					sizeof(struct snd_soc_card),
+					GFP_KERNEL);
+	if (!snddaudio_priv->card) {
+		dev_err(&pdev->dev, "Can't malloc the snd_soc_card!\n");
+		goto err_kfree_sndaudio_priv;
+	}
+
+	card = snddaudio_priv->card;
+	memcpy(card, &snd_soc_sunxi_snddaudio, sizeof(struct snd_soc_card));
+
+	card->dev = &pdev->dev;
+
+	dai_link = devm_kzalloc(&pdev->dev,
+			sizeof(struct snd_soc_dai_link), GFP_KERNEL);
+	if (!dai_link) {
+		ret = -ENOMEM;
+		goto err_kfree_card;
+	}
+	memcpy(dai_link, &sunxi_snddaudio_dai_link,
+			sizeof(struct snd_soc_dai_link));
+	card->dai_link = dai_link;
+	card->num_links = 1;
+
+	ret = of_property_read_u32(np, "audio_format", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "audio_format config missing or invalid\n");
+		snddaudio_priv->pdata.audio_format = 1;
+	} else {
+		snddaudio_priv->pdata.audio_format = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "signal_inversion", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "signal_inversion config missing or invalid\n");
+		snddaudio_priv->pdata.signal_inversion = 1;
+	} else {
+		snddaudio_priv->pdata.signal_inversion = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "daudio_master", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "daudio_master config missing or invalid\n");
+		/*
+		 * default setting SND_SOC_DAIFMT_CBS_CFS mode
+		 * codec clk & FRM slave
+		 */
+		snddaudio_priv->pdata.daudio_master = 4;
+	} else {
+		snddaudio_priv->pdata.daudio_master = temp_val;
+	}
+
+	pr_err("[%s] audio_format: %d, signal_inversion: %d, daudio_master: %d\n",
+		__func__, snddaudio_priv->pdata.audio_format,
+		snddaudio_priv->pdata.signal_inversion,
+		snddaudio_priv->pdata.daudio_master);
+
+	dai_link->cpus->dai_name = NULL;
+	dai_link->cpus->of_node = of_parse_phandle(np,
+					"sunxi,cpudai-controller", 0);
+	if (!dai_link->cpus->of_node) {
+		dev_err(&pdev->dev,
+			"Property 'sunxi,cpudai-controller' invalid\n");
+		ret = -EINVAL;
+		goto err_kfree_link;
+	}
+	dai_link->platforms->name = "snd-soc-dummy";
+
+	ret = of_property_read_string(np, "sunxi,snddaudio-codec",
+			&dai_link->codecs->name);
+	/*
+	 * As we setting codec & codec_dai in dtb, we just setting the
+	 * codec & codec_dai in the dai_link. But if we just not setting,
+	 * we then using the snd-soc-dummy as the codec & codec_dai to
+	 * construct the snd-card for audio playback & capture.
+	 */
+	if (!ret) {
+		ret = of_property_read_string(np, "sunxi,snddaudio-codec-dai",
+				&dai_link->codecs->dai_name);
+		if (ret < 0) {
+			dev_err(card->dev, "codec_dai name invaild in dtb\n");
+			ret = -EINVAL;
+			goto err_kfree_link;
+		}
+		sprintf(name+3, "%s", dai_link->codecs->name);
+	} else {
+		if (dai_link->cpus->of_node && of_property_read_u32(
+			dai_link->cpus->of_node, "tdm_num", &temp_val) >= 0)
+			sprintf(name+9, "%u", temp_val);
+		else
+			sprintf(name+9, "%d", atomic_inc_return(&daudio_count));
+	}
+
+	card->name = name;
+	dev_info(card->dev, "codec: %s, codec_dai: %s.\n",
+			dai_link->codecs->name,
+			dai_link->codecs->dai_name);
+
+	snd_soc_card_set_drvdata(card, snddaudio_priv);
+
+	ret = snd_soc_register_card(card);
+	if (ret) {
+		dev_err(card->dev, "snd_soc_register_card failed\n");
+		goto err_kfree_link;
+	}
+
+	return ret;
+err_kfree_link:
+	devm_kfree(&pdev->dev, card->dai_link);
+err_kfree_card:
+	devm_kfree(&pdev->dev, card);
+err_kfree_sndaudio_priv:
+	devm_kfree(&pdev->dev, snddaudio_priv);
+	return ret;
+}
+#else
+static int sunxi_snddaudio_dev_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct snd_soc_dai_link	*dai_link;
+	struct snd_soc_card *card;
+	struct sunxi_snddaudio_priv *snddaudio_priv;
+	char name[30] = "snddaudio";
+	unsigned int temp_val;
+	int ret = 0;
+
+	snddaudio_priv = devm_kzalloc(&pdev->dev,
+			sizeof(struct sunxi_snddaudio_priv), GFP_KERNEL);
+	if (!snddaudio_priv) {
+		dev_err(&pdev->dev, "Can't malloc the sunxi_snddaudio_priv!\n");
+		return -ENOMEM;
+	}
+
+	snddaudio_priv->card = devm_kzalloc(&pdev->dev,
+					sizeof(struct snd_soc_card),
+					GFP_KERNEL);
+	if (!snddaudio_priv->card) {
+		dev_err(&pdev->dev, "Can't malloc the snd_soc_card!\n");
+		goto err_kfree_sndaudio_priv;
+	}
+
+	card = snddaudio_priv->card;
+	memcpy(card, &snd_soc_sunxi_snddaudio, sizeof(struct snd_soc_card));
+
+	card->dev = &pdev->dev;
+
+	dai_link = devm_kzalloc(&pdev->dev,
+			sizeof(struct snd_soc_dai_link), GFP_KERNEL);
+	if (!dai_link) {
+		ret = -ENOMEM;
+		goto err_kfree_card;
+	}
+	memcpy(dai_link, &sunxi_snddaudio_dai_link,
+			sizeof(struct snd_soc_dai_link));
+	card->dai_link = dai_link;
+	card->num_links = 1;
+
+	ret = of_property_read_u32(np, "audio_format", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "audio_format config missing or invalid\n");
+		snddaudio_priv->pdata.audio_format = 1;
+	} else {
+		snddaudio_priv->pdata.audio_format = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "signal_inversion", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "signal_inversion config missing or invalid\n");
+		snddaudio_priv->pdata.signal_inversion = 1;
+	} else {
+		snddaudio_priv->pdata.signal_inversion = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "daudio_master", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "daudio_master config missing or invalid\n");
+		/*
+		 * default setting SND_SOC_DAIFMT_CBS_CFS mode
+		 * codec clk & FRM slave
+		 */
+		snddaudio_priv->pdata.daudio_master = 4;
+	} else {
+		snddaudio_priv->pdata.daudio_master = temp_val;
+	}
+
+	pr_err("[%s] audio_format: %d, signal_inversion: %d, daudio_master: %d\n",
+		__func__, snddaudio_priv->pdata.audio_format,
+		snddaudio_priv->pdata.signal_inversion,
+		snddaudio_priv->pdata.daudio_master);
+
+	dai_link->cpu_dai_name = NULL;
+	dai_link->cpu_of_node = of_parse_phandle(np,
+			"sunxi,daudio0-controller", 0);
+	if (dai_link->cpu_of_node)
+		goto cpu_node_find;
+
+	dai_link->cpu_of_node = of_parse_phandle(np,
+			"sunxi,daudio1-controller", 0);
+	if (dai_link->cpu_of_node)
+		goto cpu_node_find;
+
+	dai_link->cpu_of_node = of_parse_phandle(np,
+			"sunxi,daudio-controller", 0);
+	if (dai_link->cpu_of_node)
+		goto cpu_node_find;
+
+	dev_err(card->dev, "Perperty 'sunxi,daudio-controller' missing\n");
+
+	goto err_kfree_link;
+
+cpu_node_find:
+	dai_link->platform_name = NULL;
+	dai_link->platform_of_node =
+				dai_link->cpu_of_node;
+
+	ret = of_property_read_string(np, "sunxi,snddaudio-codec",
+			&dai_link->codec_name);
+	/*
+	 * As we setting codec & codec_dai in dtb, we just setting the
+	 * codec & codec_dai in the dai_link. But if we just not setting,
+	 * we then using the snd-soc-dummy as the codec & codec_dai to
+	 * construct the snd-card for audio playback & capture.
+	 */
+	if (!ret) {
+		ret = of_property_read_string(np, "sunxi,snddaudio-codec-dai",
+				&dai_link->codec_dai_name);
+		if (ret < 0) {
+			dev_err(card->dev, "codec_dai name invaild in dtb\n");
+			ret = -EINVAL;
+			goto err_kfree_link;
+		}
+		sprintf(name+3, "%s", dai_link->codec_name);
+	} else {
+		if (dai_link->cpu_of_node && of_property_read_u32(
+			dai_link->cpu_of_node, "tdm_num", &temp_val) >= 0)
+			sprintf(name+9, "%u", temp_val);
+		else
+			sprintf(name+9, "%d", atomic_inc_return(&daudio_count));
+	}
+
+	card->name = name;
+	dev_info(card->dev, "codec: %s, codec_dai: %s.\n",
+			dai_link->codec_name,
+			dai_link->codec_dai_name);
+
+#ifdef CONFIG_SND_SUNXI_MAD
+    sunxi_daudio_priv.mad_bind = 0;
+	snd_soc_card_set_drvdata(card, &sunxi_daudio_priv);
+#endif
+
+	snd_soc_card_set_drvdata(card, snddaudio_priv);
+	ret = snd_soc_register_card(card);
+	if (ret) {
+		dev_err(card->dev, "snd_soc_register_card failed\n");
+		goto err_kfree_link;
+	}
+
+	return ret;
+
+err_kfree_link:
+	devm_kfree(&pdev->dev, card->dai_link);
+err_kfree_card:
+	devm_kfree(&pdev->dev, card);
+err_kfree_sndaudio_priv:
+	devm_kfree(&pdev->dev, snddaudio_priv);
+	return ret;
+}
+#endif
+static int sunxi_snddaudio_dev_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+
+	devm_kfree(&pdev->dev, card->dai_link);
+	snd_soc_unregister_card(card);
+	devm_kfree(&pdev->dev, card);
+	return 0;
+}
+
+static const struct of_device_id sunxi_snddaudio_of_match[] = {
+	{ .compatible = "allwinner,sunxi-daudio0-machine", },
+	{ .compatible = "allwinner,sunxi-daudio1-machine", },
+	{ .compatible = "allwinner,sunxi-daudio2-machine", },
+	{ .compatible = "allwinner,sunxi-daudio3-machine", },
+	{},
+};
+
+static struct platform_driver sunxi_snddaudio_driver = {
+	.driver = {
+		.name   = "snddaudio",
+		.owner  = THIS_MODULE,
+		.pm     = &snd_soc_pm_ops,
+		.of_match_table = sunxi_snddaudio_of_match,
+	},
+	.probe  = sunxi_snddaudio_dev_probe,
+	.remove = sunxi_snddaudio_dev_remove,
+};
+
+static int __init sunxi_snddaudio_driver_init(void)
+{
+	return platform_driver_register(&sunxi_snddaudio_driver);
+}
+
+static void __exit sunxi_snddaudio_driver_exit(void)
+{
+	platform_driver_unregister(&sunxi_snddaudio_driver);
+}
+
+late_initcall(sunxi_snddaudio_driver_init);
+module_exit(sunxi_snddaudio_driver_exit);
+
+MODULE_AUTHOR("Wolfgang Huang");
+MODULE_DESCRIPTION("SUNXI snddaudio ALSA SoC Audio Card Driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/sunxi_v2/ahub/sunxi-sndhdmi.c b/sound/soc/sunxi_v2/ahub/sunxi-sndhdmi.c
new file mode 100644
index 000000000..e109c6ae0
--- /dev/null
+++ b/sound/soc/sunxi_v2/ahub/sunxi-sndhdmi.c
@@ -0,0 +1,274 @@
+/*
+ * sound\soc\sunxi\sunxi-sndhdmi.c
+ * (C) Copyright 2014-2016
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * huangxin <huangxin@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <sound/soc-dapm.h>
+#include <linux/io.h>
+#include <linux/of.h>
+
+#include "sunxi-pcm.h"
+
+static struct sndhdmi_priv sunxi_tdmhdmi;
+
+/*
+ * sun8iw6 sound machine:
+ * i2s0 -> sndi2s0, i2s1 -> snddi2s1,
+ * i2s2 -> sndhdmi, tdm -> snddaudio0.
+ */
+
+static int sunxi_hdmiaudio_set_audio_mode(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	sunxi_tdmhdmi.hdmi_format = ucontrol->value.integer.value[0];
+	return 0;
+}
+
+static int sunxi_hdmiaudio_get_audio_mode(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = sunxi_tdmhdmi.hdmi_format;
+	return 0;
+}
+
+static const char *hdmiaudio_format_function[] = {"null", "pcm", "AC3",
+		"MPEG1", "MP3", "MPEG2", "AAC", "DTS", "ATRAC", "ONE_BIT_AUDIO",
+		"DOLBY_DIGITAL_PLUS", "DTS_HD", "MAT", "WMAPRO"};
+
+static const struct soc_enum hdmiaudio_format_enum[] = {
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(hdmiaudio_format_function),
+			hdmiaudio_format_function),
+};
+
+/* pcm dts ac3 Audio Mode Select */
+static const struct snd_kcontrol_new sunxi_hdmiaudio_controls[] = {
+	SOC_ENUM_EXT("hdmi audio format Function", hdmiaudio_format_enum[0],
+		sunxi_hdmiaudio_get_audio_mode, sunxi_hdmiaudio_set_audio_mode),
+};
+
+static int sunxi_sndhdmi_hw_params(struct snd_pcm_substream *substream,
+					struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_card *card = rtd->card;
+	unsigned int freq;
+	unsigned int clk_div;
+	int ret;
+#ifdef CONFIG_ARCH_SUN8IW6
+	unsigned long sample_rate = params_rate(params);
+#endif
+	switch (params_rate(params)) {
+	case 8000:
+	case 16000:
+	case 32000:
+	case 64000:
+	case 128000:
+	case 12000:
+	case 24000:
+	case 48000:
+	case 96000:
+	case 192000:
+//#ifdef CONFIG_AHUB_FREQ_REQ
+#ifdef CONFIG_SND_SOC_SUNXI_AHUB_TMP
+		freq = 98304000;
+#else
+		freq = 24576000;
+#endif
+		break;
+	case	11025:
+	case	22050:
+	case	44100:
+	case	88200:
+	case	176400:
+//#ifdef CONFIG_AHUB_FREQ_REQ
+#ifdef CONFIG_SND_SOC_SUNXI_AHUB_TMP
+		freq = 90316800;
+#else
+		freq = 22579200;
+#endif
+		break;
+	default:
+		dev_err(card->dev, "unsupport freq\n");
+		return -EINVAL;
+	}
+
+	/*set system clock source freq and set the mode as i2s0 or pcm*/
+	ret = snd_soc_dai_set_sysclk(cpu_dai, 0, freq, 0);
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * I2S mode normal bit clock + frame\codec clk & FRM slave
+	 */
+	ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
+			SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+	if (ret < 0)
+		return ret;
+
+	clk_div = freq / params_rate(params);
+#ifdef CONFIG_ARCH_SUN8IW6
+	ret = snd_soc_dai_set_clkdiv(cpu_dai, 0, sample_rate);
+#else
+	ret = snd_soc_dai_set_clkdiv(cpu_dai, 0, clk_div);
+#endif
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static struct snd_soc_ops sunxi_sndhdmi_ops = {
+	.hw_params	= sunxi_sndhdmi_hw_params,
+};
+
+static int sunxi_sndhdmi_probe(struct snd_soc_card *card)
+{
+	int ret;
+
+	ret = snd_soc_add_card_controls(card, sunxi_hdmiaudio_controls,
+				ARRAY_SIZE(sunxi_hdmiaudio_controls));
+	if (ret)
+		dev_warn(card->dev,
+			"Failed to register audio mode control.\n");
+	return 0;
+}
+
+SND_SOC_DAILINK_DEFS(sndhdmi_dai_link,
+	DAILINK_COMP_ARRAY(COMP_CPU("sunxi-hdmiaudio")),
+	DAILINK_COMP_ARRAY(COMP_CODEC("sunxi-hdmiaudio-codec.0", "audiohdmi-dai")),
+	DAILINK_COMP_ARRAY(COMP_PLATFORM("snd-soc-dummy")));
+
+static struct snd_soc_dai_link sunxi_sndhdmi_dai_link = {
+	.name		= "HDMIAUDIO",
+	.stream_name	= "SUNXI-HDMIAUDIO",
+	.ops		= &sunxi_sndhdmi_ops,
+	SND_SOC_DAILINK_REG(sndhdmi_dai_link),
+};
+
+/*
+static struct snd_soc_dai_link sunxi_sndhdmi_dai_link = {
+	.name		= "HDMIAUDIO",
+	.stream_name	= "SUNXI-HDMIAUDIO",
+	.cpu_dai_name	= "sunxi-hdmiaudio.0",
+	.codec_dai_name	= "audiohdmi-dai",
+	.platform_name	= "sunxi-hdmiaudio-pcm-audio.0",
+	.codec_name	= "sunxi-hdmiaudio-codec.0",
+	.ops		= &sunxi_sndhdmi_ops,
+};
+*/
+
+static struct snd_soc_card snd_soc_sunxi_sndhdmi = {
+	.name		= "sndhdmi",
+	.owner		= THIS_MODULE,
+	.probe		= sunxi_sndhdmi_probe,
+	.dai_link	= &sunxi_sndhdmi_dai_link,
+	.num_links	= 1,
+};
+
+static int sunxi_sndhdmi_dev_probe(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = &snd_soc_sunxi_sndhdmi;
+	struct device_node *np = pdev->dev.of_node;
+	int ret;
+
+	card->dev = &pdev->dev;
+	sunxi_tdmhdmi.hdmi_format = 1;
+
+#ifdef CONFIG_SND_SOC_SUNXI_AHUB_TMP
+	sunxi_sndhdmi_dai_link.cpus->dai_name = NULL;
+	sunxi_sndhdmi_dai_link.cpus->of_node = of_parse_phandle(np,
+					"sunxi,cpudai-controller", 0);
+	if (!sunxi_sndhdmi_dai_link.cpus->of_node) {
+		dev_err(&pdev->dev, "Property 'sunxi,cpudai-controller' missing or invalid\n");
+		return -EINVAL;
+	}
+	sunxi_sndhdmi_dai_link.platforms->name = "snd-soc-dummy";
+#else
+	if (np) {
+		sunxi_sndhdmi_dai_link.cpus->dai_name = NULL;
+		sunxi_sndhdmi_dai_link.cpus->of_node = of_parse_phandle(np,
+					"sunxi,hdmi-controller", 0);
+		if (!sunxi_sndhdmi_dai_link.cpus->of_node) {
+			dev_err(&pdev->dev,
+				"Property 'sunxi,hdmi-controller' missing\n");
+			ret = -EINVAL;
+		}
+		sunxi_sndhdmi_dai_link.platforms->name = NULL;
+		sunxi_sndhdmi_dai_link.platforms->of_node =
+				sunxi_sndhdmi_dai_link.cpus->of_node;
+	} else {
+		dev_err(&pdev->dev, "hdmi dt node missing or invalid\n");
+		ret = -EINVAL;
+	}
+#endif
+	snd_soc_card_set_drvdata(card, &sunxi_tdmhdmi);
+	ret = snd_soc_register_card(card);
+	if (ret) {
+		dev_err(&pdev->dev, "snd_soc_register_card() failed: %d\n",
+			ret);
+	}
+	return ret;
+}
+
+static int __exit sunxi_sndhdmi_dev_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+
+	snd_soc_unregister_card(card);
+	return 0;
+}
+
+static const struct of_device_id sunxi_hdmi_of_match[] = {
+	{ .compatible = "allwinner,sunxi-hdmi-machine", },
+	{},
+};
+
+static struct platform_driver sunxi_hdmiaudio_driver = {
+	.driver = {
+		.name = "sndhdmi",
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_hdmi_of_match,
+		.pm = &snd_soc_pm_ops,
+	},
+	.probe = sunxi_sndhdmi_dev_probe,
+	.remove = __exit_p(sunxi_sndhdmi_dev_remove),
+};
+
+#ifdef CONFIG_ARCH_SUN50IW6
+static int __init sunxi_hdmiaudio_driver_init(void)
+{
+	return platform_driver_register(&sunxi_hdmiaudio_driver);
+}
+
+static void __exit sunxi_hdmiaudio_driver_exit(void)
+{
+	platform_driver_unregister(&sunxi_hdmiaudio_driver);
+}
+
+late_initcall(sunxi_hdmiaudio_driver_init);
+module_exit(sunxi_hdmiaudio_driver_exit);
+#else
+module_platform_driver(sunxi_hdmiaudio_driver);
+#endif
+
+MODULE_AUTHOR("wolfgang huang <huangjinhui@allwinnertech.com>");
+MODULE_DESCRIPTION("SUNXI HDMI ASoC Machine driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/sunxi_v2/ahub/sunxi_ahub.c b/sound/soc/sunxi_v2/ahub/sunxi_ahub.c
new file mode 100644
index 000000000..4ebf54725
--- /dev/null
+++ b/sound/soc/sunxi_v2/ahub/sunxi_ahub.c
@@ -0,0 +1,1111 @@
+/*
+ * sound\soc\sunxi\sunxi_ahub.c
+ * (C) Copyright 2015-2017
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Wolfgang huang <huangjinhui@allwinnertechtech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/gpio.h>
+#include <linux/io.h>
+#include <linux/regulator/consumer.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/pm.h>
+#include <linux/of_gpio.h>
+#include <linux/workqueue.h>
+#include <linux/reset.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <sound/tlv.h>
+
+#include "sunxi_ahub.h"
+#include "sunxi-pcm.h"
+//#include "../snd_sunxi_pcm.h"
+
+#define DRV_NAME	"sunxi-ahub"
+
+struct sunxi_ahub_priv {
+	struct device *dev;
+	void __iomem *membase;
+	struct regmap *regmap;
+	struct clk *pllclk;
+#ifdef AHUB_PLL_AUDIO_X4
+	struct clk *pllclkx4;
+#endif
+	struct clk *moduleclk;
+	struct clk *ahub_clk_bus;
+	struct reset_control *ahub_clk_rst;
+} sunxi_ahub_dev;
+
+static struct sunxi_ahub_priv *sunxi_ahub = &sunxi_ahub_dev;
+
+static const struct regmap_config sunxi_ahub_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = SUNXI_AHUB_DAM_GAIN_CTL7(1),
+	.cache_type = REGCACHE_NONE,
+};
+
+unsigned int sunxi_ahub_read(unsigned int reg)
+{
+	return readl(sunxi_ahub->membase + reg);
+}
+
+/* reslove conflict with regmap_update_bits using spin_lock */
+int sunxi_ahub_update_bits(
+					unsigned int reg,
+			       unsigned int mask, unsigned int val)
+{
+	unsigned int tmp, orig;
+
+	orig = readl(sunxi_ahub->membase + reg);
+
+	tmp = orig & ~mask;
+	tmp |= val & mask;
+
+	if (tmp != orig)
+		writel(tmp, sunxi_ahub->membase + reg);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sunxi_ahub_update_bits);
+
+struct regmap *sunxi_ahub_regmap_init(struct platform_device *pdev)
+{
+	struct resource res, *memregion;
+	struct device_node *np = pdev->dev.of_node;
+	int ret;
+
+	if (!sunxi_ahub->regmap) {
+		ret = of_address_to_resource(np, 0, &res);
+		if (ret)
+			return NULL;
+
+		memregion = devm_request_mem_region(&pdev->dev, res.start,
+						resource_size(&res), DRV_NAME);
+		if (!memregion)
+			return NULL;
+
+		sunxi_ahub->membase = ioremap(res.start, resource_size(&res));
+		if (!sunxi_ahub->membase)
+			return NULL;
+
+		sunxi_ahub->regmap = devm_regmap_init_mmio(&pdev->dev,
+						sunxi_ahub->membase,
+						&sunxi_ahub_regmap_config);
+		if (IS_ERR_OR_NULL(sunxi_ahub->regmap)) {
+			ret = PTR_ERR(sunxi_ahub->regmap);
+			return NULL;
+		}
+	}
+	return sunxi_ahub->regmap;
+}
+EXPORT_SYMBOL_GPL(sunxi_ahub_regmap_init);
+static const char * const apbif_mux_text[] = {
+	"NONE",
+	"APBIF_TXDIF0",
+	"APBIF_TXDIF1",
+	"APBIF_TXDIF2",
+	"I2S0_TXDIF",
+	"I2S1_TXDIF",
+	"I2S2_TXDIF",
+	"I2S3_TXDIF",
+	"DAM0_TXDIF",
+	"DAM1_TXDIF",
+};
+static const unsigned int apbif_mux_values[] = {
+	0,
+	1<<I2S_RX_APBIF_TXDIF0,
+	1<<I2S_RX_APBIF_TXDIF1,
+	1<<I2S_RX_APBIF_TXDIF2,
+	1<<I2S_RX_I2S0_TXDIF,
+	1<<I2S_RX_I2S1_TXDIF,
+	1<<I2S_RX_I2S2_TXDIF,
+	1<<I2S_RX_I2S3_TXDIF,
+	1<<I2S_RX_DAM0_TXDIF,
+	1<<I2S_RX_DAM1_TXDIF,
+};
+
+#define AHUB_MUX_ENUM_DECL(name, reg)	\
+	SOC_VALUE_ENUM_SINGLE_DECL(name, reg, 0, 0xffffffff,	\
+			apbif_mux_text, apbif_mux_values)
+
+static AHUB_MUX_ENUM_DECL(apbif0, SUNXI_AHUB_APBIF_RXFIFO_CONT(0));
+static AHUB_MUX_ENUM_DECL(apbif1, SUNXI_AHUB_APBIF_RXFIFO_CONT(1));
+static AHUB_MUX_ENUM_DECL(apbif2, SUNXI_AHUB_APBIF_RXFIFO_CONT(2));
+static AHUB_MUX_ENUM_DECL(i2s0, SUNXI_AHUB_I2S_RXCONT(0));
+static AHUB_MUX_ENUM_DECL(i2s1, SUNXI_AHUB_I2S_RXCONT(1));
+static AHUB_MUX_ENUM_DECL(i2s2, SUNXI_AHUB_I2S_RXCONT(2));
+static AHUB_MUX_ENUM_DECL(i2s3, SUNXI_AHUB_I2S_RXCONT(3));
+static AHUB_MUX_ENUM_DECL(dam0chan0, SUNXI_AHUB_DAM_RX0_SRC(0));
+static AHUB_MUX_ENUM_DECL(dam0chan1, SUNXI_AHUB_DAM_RX1_SRC(0));
+static AHUB_MUX_ENUM_DECL(dam0chan2, SUNXI_AHUB_DAM_RX2_SRC(0));
+static AHUB_MUX_ENUM_DECL(dam1chan0, SUNXI_AHUB_DAM_RX0_SRC(1));
+static AHUB_MUX_ENUM_DECL(dam1chan1, SUNXI_AHUB_DAM_RX1_SRC(1));
+static AHUB_MUX_ENUM_DECL(dam1chan2, SUNXI_AHUB_DAM_RX2_SRC(1));
+
+
+#define APBIF_RX_MUX_CONTROLS(num)					\
+static const struct snd_kcontrol_new apbif##num##_rx_mux =		\
+	SOC_DAPM_ENUM("APBIF##num Rx Mux", apbif##num);
+
+#define I2S_RX_MUX_CONTROLS(num)					\
+static const struct snd_kcontrol_new i2s##num##_rx_mux =		\
+	SOC_DAPM_ENUM("I2S##num RX Mux", i2s##num);
+
+#define DAM0_RX_MUX_CONTROLS(chan)					\
+static const struct snd_kcontrol_new  dam0chan##chan##_rx_mux =		\
+	SOC_DAPM_ENUM("DAM0 Chan##chan Rx Mux", dam0chan##chan);
+#define DAM1_RX_MUX_CONTROLS(chan)                                       \
+static const struct snd_kcontrol_new dam1chan##chan##_rx_mux =           \
+	SOC_DAPM_ENUM("DAM1 Chan##chan Rx Mux", dam1chan##chan);
+
+#define AHUB_MUX(name, ctrl) \
+	SND_SOC_DAPM_MUX(name, SND_SOC_NOPM, 0, 0, &ctrl)
+
+#define AHUB_MUX_DAM0(name, ctrl, ch) \
+	SND_SOC_DAPM_MUX(name, \
+	SUNXI_AHUB_DAM_CTL(0), DAM_CTL_RX0EN+ch, 0, &ctrl)
+
+#define AHUB_MUX_DAM1(name, ctrl, ch) \
+	SND_SOC_DAPM_MUX(name, \
+	SUNXI_AHUB_DAM_CTL(1), DAM_CTL_RX0EN+ch, 0, &ctrl)
+
+/*three apbif dev group */
+APBIF_RX_MUX_CONTROLS(0)
+APBIF_RX_MUX_CONTROLS(1)
+APBIF_RX_MUX_CONTROLS(2)
+/* four i2s dev group */
+I2S_RX_MUX_CONTROLS(0)
+I2S_RX_MUX_CONTROLS(1)
+I2S_RX_MUX_CONTROLS(2)
+I2S_RX_MUX_CONTROLS(3)
+/* two digital audio mux & three chan dev group */
+DAM0_RX_MUX_CONTROLS(0)
+DAM0_RX_MUX_CONTROLS(1)
+DAM0_RX_MUX_CONTROLS(2)
+DAM1_RX_MUX_CONTROLS(0)
+DAM1_RX_MUX_CONTROLS(1)
+DAM1_RX_MUX_CONTROLS(2)
+
+struct str_conv {
+	char *str;
+	int regbit;
+};
+
+/* I2S module usage control by cpu_dai */
+static struct str_conv mod_str_conv[] = {
+	{"APBIF0 DAC", 31},
+	{"APBIF1 DAC", 30},
+	{"APBIF2 DAC", 29},
+	{"APBIF0 ADC", 27},
+	{"APBIF1 ADC", 26},
+	{"APBIF2 ADC", 25},
+	{"DAM0 Mixer", 15},
+	{"DAM1 Mixer", 14},
+};
+
+static int sunxi_ahub_mod_event(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *k, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct sunxi_ahub_priv *sunxi_ahub = snd_soc_component_get_drvdata(component);
+	int reg_bit = 0;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(mod_str_conv); i++)
+		if (!strncmp(mod_str_conv[i].str, w->name,
+					strlen(mod_str_conv[i].str))) {
+			reg_bit = mod_str_conv[i].regbit;
+			break;
+		}
+
+	switch (event) {
+	case SND_SOC_DAPM_PRE_PMU:
+		regmap_update_bits(sunxi_ahub->regmap, SUNXI_AHUB_RST,
+				(0x1<<reg_bit), (0x1<<reg_bit));
+		regmap_update_bits(sunxi_ahub->regmap, SUNXI_AHUB_GAT,
+				(0x1<<reg_bit), (0x1<<reg_bit));
+		break;
+	case SND_SOC_DAPM_POST_PMD:
+		regmap_update_bits(sunxi_ahub->regmap, SUNXI_AHUB_GAT,
+				(0x1<<reg_bit), (0x0<<reg_bit));
+		regmap_update_bits(sunxi_ahub->regmap, SUNXI_AHUB_RST,
+				(0x1<<reg_bit), (0x0<<reg_bit));
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static const struct snd_kcontrol_new ahub_controls[] = {
+	SOC_SINGLE("I2S0 SD0 to SDI0 Loopback Debug", SUNXI_AHUB_I2S_CTL(0), I2S_CTL_LOOP0, 1, 0),
+	SOC_SINGLE("I2S1 SD0 to SDI0 Loopback Debug", SUNXI_AHUB_I2S_CTL(1), I2S_CTL_LOOP0, 1, 0),
+	SOC_SINGLE("I2S2 SD0 to SDI0 Loopback Debug", SUNXI_AHUB_I2S_CTL(2), I2S_CTL_LOOP0, 1, 0),
+	SOC_SINGLE("I2S3 SD0 to SDI0 Loopback Debug", SUNXI_AHUB_I2S_CTL(3), I2S_CTL_LOOP0, 1, 0),
+#ifdef LOOPBACK_FOR_DAUDIO
+	//Loopback test:SDO0 --> SDI0 1 2 3 --> Enable
+	SOC_SINGLE("I2S0 SD0 to SDI1 Loopback Debug", SUNXI_AHUB_I2S_CTL(0), I2S_CTL_LOOP1, 1, 0),
+	SOC_SINGLE("I2S0 SD0 to SDI2 Loopback Debug", SUNXI_AHUB_I2S_CTL(0), I2S_CTL_LOOP2, 1, 0),
+	SOC_SINGLE("I2S0 SD0 to SDI3 Loopback Debug", SUNXI_AHUB_I2S_CTL(0), I2S_CTL_LOOP3, 1, 0),
+	SOC_SINGLE("I2S0 SDI1 Enable", SUNXI_AHUB_I2S_CTL(0), I2S_CTL_SDI1_EN, 1, 0),
+	SOC_SINGLE("I2S0 SDI2 Enable", SUNXI_AHUB_I2S_CTL(0), I2S_CTL_SDI2_EN, 1, 0),
+	SOC_SINGLE("I2S0 SDI3 Enable", SUNXI_AHUB_I2S_CTL(0), I2S_CTL_SDI3_EN, 1, 0),
+	//Loopback test:SDO0 --> SDI0 1 2 3 --> Enable
+	SOC_SINGLE("I2S1 SD0 to SDI1 Loopback Debug", SUNXI_AHUB_I2S_CTL(1), I2S_CTL_LOOP1, 1, 0),
+	SOC_SINGLE("I2S1 SD0 to SDI2 Loopback Debug", SUNXI_AHUB_I2S_CTL(1), I2S_CTL_LOOP2, 1, 0),
+	SOC_SINGLE("I2S1 SD0 to SDI3 Loopback Debug", SUNXI_AHUB_I2S_CTL(1), I2S_CTL_LOOP3, 1, 0),
+	SOC_SINGLE("I2S1 SDI1 Enable", SUNXI_AHUB_I2S_CTL(1), I2S_CTL_SDI1_EN, 1, 0),
+	SOC_SINGLE("I2S1 SDI2 Enable", SUNXI_AHUB_I2S_CTL(1), I2S_CTL_SDI2_EN, 1, 0),
+	SOC_SINGLE("I2S1 SDI3 Enable", SUNXI_AHUB_I2S_CTL(1), I2S_CTL_SDI3_EN, 1, 0),
+	//Loopback test:SDO0 --> SDI0 1 2 3 --> Enable
+	SOC_SINGLE("I2S2 SD0 to SDI1 Loopback Debug", SUNXI_AHUB_I2S_CTL(2), I2S_CTL_LOOP1, 1, 0),
+	SOC_SINGLE("I2S2 SD0 to SDI2 Loopback Debug", SUNXI_AHUB_I2S_CTL(2), I2S_CTL_LOOP2, 1, 0),
+	SOC_SINGLE("I2S2 SD0 to SDI3 Loopback Debug", SUNXI_AHUB_I2S_CTL(2), I2S_CTL_LOOP3, 1, 0),
+	SOC_SINGLE("I2S2 SDI1 Enable", SUNXI_AHUB_I2S_CTL(2), I2S_CTL_SDI1_EN, 1, 0),
+	SOC_SINGLE("I2S2 SDI2 Enable", SUNXI_AHUB_I2S_CTL(2), I2S_CTL_SDI2_EN, 1, 0),
+	SOC_SINGLE("I2S2 SDI3 Enable", SUNXI_AHUB_I2S_CTL(2), I2S_CTL_SDI3_EN, 1, 0),
+	//Loopback test:SDO0 --> SDI0 1 2 3 --> Enable
+	SOC_SINGLE("I2S3 SD0 to SDI1 Loopback Debug", SUNXI_AHUB_I2S_CTL(3), I2S_CTL_LOOP1, 1, 0),
+	SOC_SINGLE("I2S3 SD0 to SDI2 Loopback Debug", SUNXI_AHUB_I2S_CTL(3), I2S_CTL_LOOP2, 1, 0),
+	SOC_SINGLE("I2S3 SD0 to SDI3 Loopback Debug", SUNXI_AHUB_I2S_CTL(3), I2S_CTL_LOOP3, 1, 0),
+	SOC_SINGLE("I2S3 SDI1 Enable", SUNXI_AHUB_I2S_CTL(3), I2S_CTL_SDI1_EN, 1, 0),
+	SOC_SINGLE("I2S3 SDI2 Enable", SUNXI_AHUB_I2S_CTL(3), I2S_CTL_SDI2_EN, 1, 0),
+	SOC_SINGLE("I2S3 SDI3 Enable", SUNXI_AHUB_I2S_CTL(3), I2S_CTL_SDI3_EN, 1, 0),
+#elif defined(CONFIG_ARCH_SUN50IW6)
+	SOC_SINGLE("I2S0 Loopback Debug", SUNXI_AHUB_I2S_CTL(0), I2S_CTL_LOOP, 1, 0),
+	SOC_SINGLE("I2S1 Loopback Debug", SUNXI_AHUB_I2S_CTL(1), I2S_CTL_LOOP, 1, 0),
+	SOC_SINGLE("I2S2 Loopback Debug", SUNXI_AHUB_I2S_CTL(2), I2S_CTL_LOOP, 1, 0),
+	SOC_SINGLE("I2S3 Loopback Debug", SUNXI_AHUB_I2S_CTL(3), I2S_CTL_LOOP, 1, 0),
+#endif
+};
+
+static const struct snd_soc_dapm_widget sunxi_ahub_codec_dapm_widgets[] = {
+	/* APBIF module output & input widgets */
+	SND_SOC_DAPM_AIF_IN_E("APBIF0 DAC", "AIF1 Playback", 0,
+			SND_SOC_NOPM, 0, 0,
+			sunxi_ahub_mod_event,
+			SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_AIF_OUT_E("APBIF0 ADC", "AIF1 Capture", 0,
+			SND_SOC_NOPM, 0, 0,
+			sunxi_ahub_mod_event,
+			SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_AIF_IN_E("APBIF1 DAC", "AIF2 Playback", 0,
+			SND_SOC_NOPM, 0, 0,
+			sunxi_ahub_mod_event,
+			SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_AIF_OUT_E("APBIF1 ADC", "AIF2 Capture", 0,
+			SND_SOC_NOPM, 0, 0,
+			sunxi_ahub_mod_event,
+			SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_AIF_IN_E("APBIF2 DAC", "AIF3 Playback", 0,
+			SND_SOC_NOPM, 0, 0,
+			sunxi_ahub_mod_event,
+			SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_AIF_OUT_E("APBIF2 ADC", "AIF3 Capture", 0,
+			SND_SOC_NOPM, 0, 0,
+			sunxi_ahub_mod_event,
+			SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+
+	AHUB_MUX("APBIF0 Src Select", apbif0_rx_mux),
+	AHUB_MUX("APBIF1 Src Select", apbif1_rx_mux),
+	AHUB_MUX("APBIF2 Src Select", apbif2_rx_mux),
+	AHUB_MUX("I2S0 Src Select", i2s0_rx_mux),
+	AHUB_MUX("I2S1 Src Select", i2s1_rx_mux),
+	AHUB_MUX("I2S2 Src Select", i2s2_rx_mux),
+	AHUB_MUX("I2S3 Src Select", i2s3_rx_mux),
+	AHUB_MUX_DAM0("DAM0Chan0 Src Select", dam0chan0_rx_mux, 0),
+	AHUB_MUX_DAM0("DAM0Chan1 Src Select", dam0chan1_rx_mux, 1),
+	AHUB_MUX_DAM0("DAM0Chan2 Src Select", dam0chan2_rx_mux, 2),
+	AHUB_MUX_DAM1("DAM1Chan0 Src Select", dam1chan0_rx_mux, 0),
+	AHUB_MUX_DAM1("DAM1Chan1 Src Select", dam1chan1_rx_mux, 1),
+	AHUB_MUX_DAM1("DAM1Chan2 Src Select", dam1chan2_rx_mux, 2),
+
+
+	SND_SOC_DAPM_OUT_DRV_E("DAM0 Mixer", SUNXI_AHUB_DAM_CTL(0),
+			DAM_CTL_TXEN, 0, NULL, 0, sunxi_ahub_mod_event,
+			SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_OUT_DRV_E("DAM1 Mixer", SUNXI_AHUB_DAM_CTL(1),
+			DAM_CTL_TXEN, 0, NULL, 0, sunxi_ahub_mod_event,
+			SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+
+	SND_SOC_DAPM_INPUT("I2S0 DAC"),
+	SND_SOC_DAPM_INPUT("I2S1 DAC"),
+	SND_SOC_DAPM_INPUT("I2S2 DAC"),
+	SND_SOC_DAPM_INPUT("I2S3 DAC"),
+	SND_SOC_DAPM_OUTPUT("I2S0 ADC"),
+	SND_SOC_DAPM_OUTPUT("I2S1 ADC"),
+	SND_SOC_DAPM_OUTPUT("I2S2 ADC"),
+	SND_SOC_DAPM_OUTPUT("I2S3 ADC"),
+	/*build some virt widget for dam*/
+	SND_SOC_DAPM_OUTPUT("DAM0 OUTPUT"),
+	SND_SOC_DAPM_OUTPUT("DAM1 OUTPUT"),
+	SND_SOC_DAPM_INPUT("DAM0 INPUT"),
+	SND_SOC_DAPM_INPUT("DAM1 INPUT"),
+};
+
+static const struct snd_soc_dapm_route sunxi_ahub_codec_dapm_routes[] = {
+	/* APBIF0 from DMA to RX Mux routes */
+	{"APBIF0 Src Select", "APBIF_TXDIF0", "APBIF0 DAC"},
+	{"APBIF1 Src Select", "APBIF_TXDIF0", "APBIF0 DAC"},
+	{"APBIF2 Src Select", "APBIF_TXDIF0", "APBIF0 DAC"},
+
+	{"I2S0 Src Select", "APBIF_TXDIF0", "APBIF0 DAC"},
+	{"I2S1 Src Select", "APBIF_TXDIF0", "APBIF0 DAC"},
+	{"I2S2 Src Select", "APBIF_TXDIF0", "APBIF0 DAC"},
+	{"I2S3 Src Select", "APBIF_TXDIF0", "APBIF0 DAC"},
+
+	{"DAM0Chan0 Src Select", "APBIF_TXDIF0", "APBIF0 DAC"},
+	{"DAM0Chan1 Src Select", "APBIF_TXDIF0", "APBIF0 DAC"},
+	{"DAM0Chan2 Src Select", "APBIF_TXDIF0", "APBIF0 DAC"},
+	{"DAM1Chan0 Src Select", "APBIF_TXDIF0", "APBIF0 DAC"},
+	{"DAM1Chan1 Src Select", "APBIF_TXDIF0", "APBIF0 DAC"},
+	{"DAM1Chan2 Src Select", "APBIF_TXDIF0", "APBIF0 DAC"},
+
+	/* APBIF1 from DMA to RX Mux routes */
+	{"APBIF0 Src Select", "APBIF_TXDIF1", "APBIF1 DAC"},
+	{"APBIF1 Src Select", "APBIF_TXDIF1", "APBIF1 DAC"},
+	{"APBIF2 Src Select", "APBIF_TXDIF1", "APBIF1 DAC"},
+
+	{"I2S0 Src Select", "APBIF_TXDIF1", "APBIF1 DAC"},
+	{"I2S1 Src Select", "APBIF_TXDIF1", "APBIF1 DAC"},
+	{"I2S2 Src Select", "APBIF_TXDIF1", "APBIF1 DAC"},
+	{"I2S3 Src Select", "APBIF_TXDIF1", "APBIF1 DAC"},
+
+	{"DAM0Chan0 Src Select", "APBIF_TXDIF1", "APBIF1 DAC"},
+	{"DAM0Chan1 Src Select", "APBIF_TXDIF1", "APBIF1 DAC"},
+	{"DAM0Chan2 Src Select", "APBIF_TXDIF1", "APBIF1 DAC"},
+	{"DAM1Chan0 Src Select", "APBIF_TXDIF1", "APBIF1 DAC"},
+	{"DAM1Chan1 Src Select", "APBIF_TXDIF1", "APBIF1 DAC"},
+	{"DAM1Chan2 Src Select", "APBIF_TXDIF1", "APBIF1 DAC"},
+
+	/* APBIF2 from DMA to RX Mux routes */
+	{"APBIF0 Src Select", "APBIF_TXDIF2", "APBIF2 DAC"},
+	{"APBIF1 Src Select", "APBIF_TXDIF2", "APBIF2 DAC"},
+	{"APBIF2 Src Select", "APBIF_TXDIF2", "APBIF2 DAC"},
+
+	{"I2S0 Src Select", "APBIF_TXDIF2", "APBIF2 DAC"},
+	{"I2S1 Src Select", "APBIF_TXDIF2", "APBIF2 DAC"},
+	{"I2S2 Src Select", "APBIF_TXDIF2", "APBIF2 DAC"},
+	{"I2S3 Src Select", "APBIF_TXDIF2", "APBIF2 DAC"},
+
+	{"DAM0Chan0 Src Select", "APBIF_TXDIF2", "APBIF2 DAC"},
+	{"DAM0Chan1 Src Select", "APBIF_TXDIF2", "APBIF2 DAC"},
+	{"DAM0Chan2 Src Select", "APBIF_TXDIF2", "APBIF2 DAC"},
+	{"DAM1Chan0 Src Select", "APBIF_TXDIF2", "APBIF2 DAC"},
+	{"DAM1Chan1 Src Select", "APBIF_TXDIF2", "APBIF2 DAC"},
+	{"DAM1Chan2 Src Select", "APBIF_TXDIF2", "APBIF2 DAC"},
+
+	/* I2S0 to RX Mux routes */
+	{"APBIF0 Src Select", "I2S0_TXDIF", "I2S0 DAC"},
+	{"APBIF1 Src Select", "I2S0_TXDIF", "I2S0 DAC"},
+	{"APBIF2 Src Select", "I2S0_TXDIF", "I2S0 DAC"},
+
+	{"I2S0 Src Select", "I2S0_TXDIF", "I2S0 DAC"},
+	{"I2S1 Src Select", "I2S0_TXDIF", "I2S0 DAC"},
+	{"I2S2 Src Select", "I2S0_TXDIF", "I2S0 DAC"},
+	{"I2S3 Src Select", "I2S0_TXDIF", "I2S0 DAC"},
+
+	{"DAM0Chan0 Src Select", "I2S0_TXDIF", "I2S0 DAC"},
+	{"DAM0Chan1 Src Select", "I2S0_TXDIF", "I2S0 DAC"},
+	{"DAM0Chan2 Src Select", "I2S0_TXDIF", "I2S0 DAC"},
+	{"DAM1Chan0 Src Select", "I2S0_TXDIF", "I2S0 DAC"},
+	{"DAM1Chan1 Src Select", "I2S0_TXDIF", "I2S0 DAC"},
+	{"DAM1Chan2 Src Select", "I2S0_TXDIF", "I2S0 DAC"},
+
+	/* I2S1 to RX Mux routes */
+	{"APBIF0 Src Select", "I2S1_TXDIF", "I2S1 DAC"},
+	{"APBIF1 Src Select", "I2S1_TXDIF", "I2S1 DAC"},
+	{"APBIF2 Src Select", "I2S1_TXDIF", "I2S1 DAC"},
+
+	{"I2S0 Src Select", "I2S1_TXDIF", "I2S1 DAC"},
+	{"I2S1 Src Select", "I2S1_TXDIF", "I2S1 DAC"},
+	{"I2S2 Src Select", "I2S1_TXDIF", "I2S1 DAC"},
+	{"I2S3 Src Select", "I2S1_TXDIF", "I2S1 DAC"},
+
+	{"DAM0Chan0 Src Select", "I2S1_TXDIF", "I2S1 DAC"},
+	{"DAM0Chan1 Src Select", "I2S1_TXDIF", "I2S1 DAC"},
+	{"DAM0Chan2 Src Select", "I2S1_TXDIF", "I2S1 DAC"},
+	{"DAM1Chan0 Src Select", "I2S1_TXDIF", "I2S1 DAC"},
+	{"DAM1Chan1 Src Select", "I2S1_TXDIF", "I2S1 DAC"},
+	{"DAM1Chan2 Src Select", "I2S1_TXDIF", "I2S1 DAC"},
+
+	/* I2S2 to RX Mux routes */
+	{"APBIF0 Src Select", "I2S2_TXDIF", "I2S2 DAC"},
+	{"APBIF1 Src Select", "I2S2_TXDIF", "I2S2 DAC"},
+	{"APBIF2 Src Select", "I2S2_TXDIF", "I2S2 DAC"},
+
+	{"I2S0 Src Select", "I2S2_TXDIF", "I2S2 DAC"},
+	{"I2S1 Src Select", "I2S2_TXDIF", "I2S2 DAC"},
+	{"I2S2 Src Select", "I2S2_TXDIF", "I2S2 DAC"},
+	{"I2S3 Src Select", "I2S2_TXDIF", "I2S2 DAC"},
+
+	{"DAM0Chan0 Src Select", "I2S2_TXDIF", "I2S2 DAC"},
+	{"DAM0Chan1 Src Select", "I2S2_TXDIF", "I2S2 DAC"},
+	{"DAM0Chan2 Src Select", "I2S2_TXDIF", "I2S2 DAC"},
+	{"DAM1Chan0 Src Select", "I2S2_TXDIF", "I2S2 DAC"},
+	{"DAM1Chan1 Src Select", "I2S2_TXDIF", "I2S2 DAC"},
+	{"DAM1Chan2 Src Select", "I2S2_TXDIF", "I2S2 DAC"},
+
+	/* I2S3 to RX Mux routes */
+	{"APBIF0 Src Select", "I2S3_TXDIF", "I2S3 DAC"},
+	{"APBIF1 Src Select", "I2S3_TXDIF", "I2S3 DAC"},
+	{"APBIF2 Src Select", "I2S3_TXDIF", "I2S3 DAC"},
+
+	{"I2S0 Src Select", "I2S3_TXDIF", "I2S3 DAC"},
+	{"I2S1 Src Select", "I2S3_TXDIF", "I2S3 DAC"},
+	{"I2S2 Src Select", "I2S3_TXDIF", "I2S3 DAC"},
+	{"I2S3 Src Select", "I2S3_TXDIF", "I2S3 DAC"},
+
+	{"DAM0Chan0 Src Select", "I2S3_TXDIF", "I2S3 DAC"},
+	{"DAM0Chan1 Src Select", "I2S3_TXDIF", "I2S3 DAC"},
+	{"DAM0Chan2 Src Select", "I2S3_TXDIF", "I2S3 DAC"},
+	{"DAM1Chan0 Src Select", "I2S3_TXDIF", "I2S3 DAC"},
+	{"DAM1Chan1 Src Select", "I2S3_TXDIF", "I2S3 DAC"},
+	{"DAM1Chan2 Src Select", "I2S3_TXDIF", "I2S3 DAC"},
+#if 0
+	/* DAM0 Audio Mixer output route */
+	{"DAM0 Mixer", NULL, "DAM0Chan0 Src Select"},
+	{"DAM0 Mixer", NULL, "DAM0Chan1 Src Select"},
+	{"DAM0 Mixer", NULL, "DAM0Chan2 Src Select"},
+	{"DAM1 Mixer", NULL, "DAM1Chan0 Src Select"},
+	{"DAM1 Mixer", NULL, "DAM1Chan1 Src Select"},
+	{"DAM1 Mixer", NULL, "DAM1Chan2 Src Select"},
+#endif
+	/* DAM0 Audio Mixer output route */
+	{"APBIF0 Src Select", "DAM0_TXDIF", "DAM0 Mixer"},
+	{"APBIF1 Src Select", "DAM0_TXDIF", "DAM0 Mixer"},
+	{"APBIF2 Src Select", "DAM0_TXDIF", "DAM0 Mixer"},
+
+	{"I2S0 Src Select", "DAM0_TXDIF", "DAM0 Mixer"},
+	{"I2S1 Src Select", "DAM0_TXDIF", "DAM0 Mixer"},
+	{"I2S2 Src Select", "DAM0_TXDIF", "DAM0 Mixer"},
+	{"I2S3 Src Select", "DAM0_TXDIF", "DAM0 Mixer"},
+
+	{"DAM0Chan0 Src Select", "DAM0_TXDIF", "DAM0 Mixer"},
+	{"DAM0Chan1 Src Select", "DAM0_TXDIF", "DAM0 Mixer"},
+	{"DAM0Chan2 Src Select", "DAM0_TXDIF", "DAM0 Mixer"},
+	{"DAM1Chan0 Src Select", "DAM0_TXDIF", "DAM0 Mixer"},
+	{"DAM1Chan1 Src Select", "DAM0_TXDIF", "DAM0 Mixer"},
+	{"DAM1Chan2 Src Select", "DAM0_TXDIF", "DAM0 Mixer"},
+
+	/* DAM1 Audio Mixer output route */
+	{"APBIF0 Src Select", "DAM1_TXDIF", "DAM1 Mixer"},
+	{"APBIF1 Src Select", "DAM1_TXDIF", "DAM1 Mixer"},
+	{"APBIF2 Src Select", "DAM1_TXDIF", "DAM1 Mixer"},
+
+	{"I2S0 Src Select", "DAM1_TXDIF", "DAM1 Mixer"},
+	{"I2S1 Src Select", "DAM1_TXDIF", "DAM1 Mixer"},
+	{"I2S2 Src Select", "DAM1_TXDIF", "DAM1 Mixer"},
+	{"I2S3 Src Select", "DAM1_TXDIF", "DAM1 Mixer"},
+
+	{"DAM0Chan0 Src Select", "DAM1_TXDIF", "DAM1 Mixer"},
+	{"DAM0Chan1 Src Select", "DAM1_TXDIF", "DAM1 Mixer"},
+	{"DAM0Chan2 Src Select", "DAM1_TXDIF", "DAM1 Mixer"},
+	{"DAM1Chan0 Src Select", "DAM1_TXDIF", "DAM1 Mixer"},
+	{"DAM1Chan1 Src Select", "DAM1_TXDIF", "DAM1 Mixer"},
+	{"DAM1Chan2 Src Select", "DAM1_TXDIF", "DAM1 Mixer"},
+
+	/* Mixer to APBIF Capture */
+	{"APBIF0 ADC", NULL, "APBIF0 Src Select"},
+	{"APBIF1 ADC", NULL, "APBIF1 Src Select"},
+	{"APBIF2 ADC", NULL, "APBIF2 Src Select"},
+
+	/* Mixer to I2S OUT(as ahub side says) */
+	{"I2S0 ADC", NULL, "I2S0 Src Select"},
+	{"I2S1 ADC", NULL, "I2S1 Src Select"},
+	{"I2S2 ADC", NULL, "I2S2 Src Select"},
+	{"I2S3 ADC", NULL, "I2S3 Src Select"},
+
+	{"DAM0 Mixer", NULL, "DAM0 INPUT"},
+	{"DAM1 Mixer", NULL, "DAM1 INPUT"},
+
+	{"DAM0 OUTPUT", NULL, "DAM0Chan0 Src Select"},
+	{"DAM0 OUTPUT", NULL, "DAM0Chan1 Src Select"},
+	{"DAM0 OUTPUT", NULL, "DAM0Chan2 Src Select"},
+
+	{"DAM1 OUTPUT", NULL, "DAM1Chan0 Src Select"},
+	{"DAM1 OUTPUT", NULL, "DAM1Chan1 Src Select"},
+	{"DAM1 OUTPUT", NULL, "DAM1Chan2 Src Select"},
+};
+
+static void sunxi_ahub_codec_init(struct snd_soc_component *component)
+{
+	struct sunxi_ahub_priv *sunxi_ahub = snd_soc_component_get_drvdata(component);
+	int i;
+
+	/* if we used the audio hub, so we default setting HDMI clk from ahub */
+	regmap_write(sunxi_ahub->regmap, SUNXI_AHUB_CTL, 1<<HDMI_SRC_SEL);
+
+	for (i = 0; i < 2; i++) {
+		/* setting audio hub default channel line configure */
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_MIX_CTL0(i), 0x01110000);
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_MIX_CTL1(i), 0x03330222);
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_MIX_CTL2(i), 0x05550444);
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_MIX_CTL3(i), 0x07770666);
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_MIX_CTL4(i), 0x09990888);
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_MIX_CTL5(i), 0x0bbb0aaa);
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_MIX_CTL6(i), 0x0ddd0ccc);
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_MIX_CTL7(i), 0x0fff0eee);
+		/* setting default audio hub volume */
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_GAIN_CTL0(i), 0x01110111);
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_GAIN_CTL1(i), 0x01110111);
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_GAIN_CTL2(i), 0x01110111);
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_GAIN_CTL3(i), 0x01110111);
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_GAIN_CTL4(i), 0x01110111);
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_GAIN_CTL5(i), 0x01110111);
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_GAIN_CTL6(i), 0x01110111);
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_DAM_GAIN_CTL7(i), 0x01110111);
+	}
+}
+
+static int sunxi_ahub_codec_dai_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct sunxi_ahub_priv *sunxi_ahub =
+				snd_soc_component_get_drvdata(dai->component);
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_card *card = rtd->card;
+	struct sndhdmi_priv *sunxi_hdmi = snd_soc_card_get_drvdata(card);
+
+	switch (params_format(params)) {
+	case	SNDRV_PCM_FORMAT_S16_LE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			/* special handle for HDMI rawdata mode */
+			if (sunxi_hdmi->hdmi_format > 1) {
+				regmap_update_bits(sunxi_ahub->regmap,
+					SUNXI_AHUB_APBIF_TX_CTL(dai->id),
+					(7<<APBIF_TX_WS), (7<<APBIF_TX_WS));
+				regmap_update_bits(sunxi_ahub->regmap,
+					SUNXI_AHUB_APBIF_TXFIFO_CTL(dai->id),
+					(1<<APBIF_TX_TXIM), (0<<APBIF_TX_TXIM));
+			} else {
+				regmap_update_bits(sunxi_ahub->regmap,
+					SUNXI_AHUB_APBIF_TX_CTL(dai->id),
+					(7<<APBIF_TX_WS), (3<<APBIF_TX_WS));
+				regmap_update_bits(sunxi_ahub->regmap,
+					SUNXI_AHUB_APBIF_TXFIFO_CTL(dai->id),
+					(1<<APBIF_TX_TXIM), (1<<APBIF_TX_TXIM));
+			}
+		} else {
+			regmap_update_bits(sunxi_ahub->regmap,
+					SUNXI_AHUB_APBIF_RX_CTL(dai->id),
+					(7<<APBIF_RX_WS), (3<<APBIF_RX_WS));
+			regmap_update_bits(sunxi_ahub->regmap,
+				SUNXI_AHUB_APBIF_RXFIFO_CTL(dai->id),
+				(3<<APBIF_RX_RXOM), (1<<APBIF_RX_RXOM));
+		}
+		break;
+	case	SNDRV_PCM_FORMAT_S24_LE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			regmap_update_bits(sunxi_ahub->regmap,
+					SUNXI_AHUB_APBIF_TX_CTL(dai->id),
+					(7<<APBIF_TX_WS), (5<<APBIF_TX_WS));
+			regmap_update_bits(sunxi_ahub->regmap,
+				SUNXI_AHUB_APBIF_TXFIFO_CTL(dai->id),
+				(1<<APBIF_TX_TXIM), (1<<APBIF_TX_TXIM));
+		} else {
+			regmap_update_bits(sunxi_ahub->regmap,
+					SUNXI_AHUB_APBIF_RX_CTL(dai->id),
+					(7<<APBIF_RX_WS), (5<<APBIF_RX_WS));
+			regmap_update_bits(sunxi_ahub->regmap,
+				SUNXI_AHUB_APBIF_RXFIFO_CTL(dai->id),
+				(3<<APBIF_RX_RXOM), (1<<APBIF_RX_RXOM));
+		}
+		break;
+	case	SNDRV_PCM_FORMAT_S32_LE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			regmap_update_bits(sunxi_ahub->regmap,
+					SUNXI_AHUB_APBIF_TX_CTL(dai->id),
+					(7<<APBIF_TX_WS), (7<<APBIF_TX_WS));
+			regmap_update_bits(sunxi_ahub->regmap,
+				SUNXI_AHUB_APBIF_TXFIFO_CTL(dai->id),
+				(1<<APBIF_TX_TXIM), (1<<APBIF_TX_TXIM));
+		} else {
+			regmap_update_bits(sunxi_ahub->regmap,
+					SUNXI_AHUB_APBIF_RX_CTL(dai->id),
+					(7<<APBIF_RX_WS), (7<<APBIF_RX_WS));
+			regmap_update_bits(sunxi_ahub->regmap,
+				SUNXI_AHUB_APBIF_RXFIFO_CTL(dai->id),
+				(3<<APBIF_RX_RXOM), (1<<APBIF_RX_RXOM));
+		}
+		break;
+	default:
+		dev_info(sunxi_ahub->dev, "unsupport format");
+		return -EINVAL;
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		regmap_update_bits(sunxi_ahub->regmap,
+			SUNXI_AHUB_APBIF_TX_CTL(dai->id),
+			(0xf<<APBIF_TX_CHAN_NUM),
+			((params_channels(params)-1)<<APBIF_TX_CHAN_NUM));
+	else
+		regmap_update_bits(sunxi_ahub->regmap,
+			SUNXI_AHUB_APBIF_RX_CTL(dai->id),
+			(0xf<<APBIF_RX_CHAN_NUM),
+			((params_channels(params)-1)<<APBIF_RX_CHAN_NUM));
+
+	/*
+	 * we should using this as the demand chans, but we can't distinguish
+	 * stream type(playback or capture). so we can't make it done on demand,
+	 * so we just make all dam rx channel number as the sunxi_ahub->channel.
+	 */
+
+	regmap_update_bits(sunxi_ahub->regmap, SUNXI_AHUB_DAM_CTL(0),
+			(0xf<<DAM_CTL_RX0_NUM),
+			((params_channels(params)-1)<<DAM_CTL_RX0_NUM));
+	regmap_update_bits(sunxi_ahub->regmap, SUNXI_AHUB_DAM_CTL(0),
+			(0xf<<DAM_CTL_RX1_NUM),
+			((params_channels(params)-1)<<DAM_CTL_RX1_NUM));
+	regmap_update_bits(sunxi_ahub->regmap, SUNXI_AHUB_DAM_CTL(0),
+			(0xf<<DAM_CTL_RX2_NUM),
+			((params_channels(params)-1)<<DAM_CTL_RX2_NUM));
+	regmap_update_bits(sunxi_ahub->regmap, SUNXI_AHUB_DAM_CTL(0),
+			(0xf<<DAM_CTL_TX_NUM),
+			((params_channels(params)-1)<<DAM_CTL_TX_NUM));
+	regmap_update_bits(sunxi_ahub->regmap, SUNXI_AHUB_DAM_CTL(1),
+			(0xf<<DAM_CTL_RX0_NUM),
+			((params_channels(params)-1)<<DAM_CTL_RX0_NUM));
+	regmap_update_bits(sunxi_ahub->regmap, SUNXI_AHUB_DAM_CTL(1),
+			(0xf<<DAM_CTL_RX1_NUM),
+			((params_channels(params)-1)<<DAM_CTL_RX1_NUM));
+	regmap_update_bits(sunxi_ahub->regmap, SUNXI_AHUB_DAM_CTL(1),
+			(0xf<<DAM_CTL_RX2_NUM),
+			((params_channels(params)-1)<<DAM_CTL_RX2_NUM));
+	regmap_update_bits(sunxi_ahub->regmap, SUNXI_AHUB_DAM_CTL(1),
+			(0xf<<DAM_CTL_TX_NUM),
+			((params_channels(params)-1)<<DAM_CTL_TX_NUM));
+
+	return 0;
+}
+
+static int sunxi_ahub_codec_dai_trigger(struct snd_pcm_substream *substream,
+				int cmd, struct snd_soc_dai *dai)
+{
+	switch (cmd) {
+	case	SNDRV_PCM_TRIGGER_START:
+	case	SNDRV_PCM_TRIGGER_RESUME:
+	case	SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			sunxi_ahub_update_bits(
+					SUNXI_AHUB_APBIF_TXFIFO_CTL(dai->id),
+					(1<<APBIF_TX_FTX), (1<<APBIF_TX_FTX));
+		}
+		break;
+	case	SNDRV_PCM_TRIGGER_STOP:
+	case	SNDRV_PCM_TRIGGER_SUSPEND:
+	case	SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int sunxi_ahub_codec_dai_set_sysclk(struct snd_soc_dai *dai,
+			int clk_id, unsigned int freq, int dir)
+{
+	struct sunxi_ahub_priv *sunxi_ahub = snd_soc_dai_get_drvdata(dai);
+
+#ifdef AHUB_PLL_AUDIO_X4
+	if (clk_set_rate(sunxi_ahub->pllclkx4, freq)) {
+		dev_err(sunxi_ahub->dev, "set pllclkx4 rate failed\n");
+		return -EINVAL;
+	}
+
+	if (clk_set_rate(sunxi_ahub->moduleclk, freq)) {
+		dev_err(sunxi_ahub->dev, "set moduleclk rate failed\n");
+		return -EINVAL;
+	}
+#else
+	if (clk_set_rate(sunxi_ahub->pllclk, freq)) {
+		dev_err(sunxi_ahub->dev, "set pllclk rate failed\n");
+		return -EINVAL;
+	}
+#endif
+
+	return 0;
+}
+
+static int sunxi_ahub_codec_dai_prepare(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	struct sunxi_ahub_priv *sunxi_ahub = snd_soc_dai_get_drvdata(dai);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		regmap_update_bits(sunxi_ahub->regmap,
+				SUNXI_AHUB_APBIF_TXFIFO_CTL(dai->id),
+				(1<<APBIF_TX_FTX), (1<<APBIF_TX_FTX));
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_APBIF_TX_IRQ_STA(dai->id),
+				(1<<APBIF_TX_OV_PEND|1<<APBIF_TX_EM_PEND));
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_APBIF_TXFIFO_CNT(dai->id), 0);
+	} else {
+		regmap_update_bits(sunxi_ahub->regmap,
+				SUNXI_AHUB_APBIF_RXFIFO_CTL(dai->id),
+				(1<<APBIF_RX_FRX), (1<<APBIF_RX_FRX));
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_APBIF_RX_IRQ_STA(dai->id),
+				(1<<APBIF_RX_UV_PEND|1<<APBIF_RX_AV_PEND));
+		regmap_write(sunxi_ahub->regmap,
+				SUNXI_AHUB_APBIF_RXFIFO_CNT(dai->id), 0);
+	}
+	return 0;
+}
+
+static const struct snd_soc_dai_ops sunxi_ahub_codec_dai_ops = {
+	.hw_params	= sunxi_ahub_codec_dai_hw_params,
+	.set_sysclk	= sunxi_ahub_codec_dai_set_sysclk,
+	.trigger	= sunxi_ahub_codec_dai_trigger,
+	.prepare	= sunxi_ahub_codec_dai_prepare,
+};
+
+/* ahub codec dai */
+static struct snd_soc_dai_driver sunxi_ahub_codec_dais[] = {
+	{
+		.name = "sunxi-ahub-aif1",
+		.id = 0,
+		.playback = {
+			.stream_name = "AIF1 Playback",
+			.channels_min = 1,
+			.channels_max = 16,
+			.rates = SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE
+				| SNDRV_PCM_FMTBIT_S32_LE,
+		},
+		.capture = {
+			.stream_name = "AIF1 Capture",
+			.channels_min = 1,
+			.channels_max = 16,
+			.rates = SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE
+				| SNDRV_PCM_FMTBIT_S32_LE,
+		 },
+		.ops = &sunxi_ahub_codec_dai_ops,
+	},
+	{
+		.name = "sunxi-ahub-aif2",
+		.id = 1,
+		.playback = {
+			.stream_name = "AIF2 Playback",
+			.channels_min = 1,
+			.channels_max = 16,
+			.rates = SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE
+				| SNDRV_PCM_FMTBIT_S32_LE,
+		},
+		.capture = {
+			.stream_name = "AIF2 Capture",
+			.channels_min = 1,
+			.channels_max = 16,
+			.rates = SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE
+				| SNDRV_PCM_FMTBIT_S32_LE,
+		},
+		.ops = &sunxi_ahub_codec_dai_ops,
+	},
+	{
+		.name = "sunxi-ahub-aif3",
+		.id = 2,
+		.playback = {
+			.stream_name = "AIF3 Playback",
+			.channels_min = 1,
+			.channels_max = 16,
+			.rates = SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE
+				| SNDRV_PCM_FMTBIT_S32_LE,
+		},
+		.capture = {
+			.stream_name = "AIF3 Capture",
+			.channels_min = 1,
+			.channels_max = 16,
+			.rates = SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE
+				| SNDRV_PCM_FMTBIT_S32_LE,
+		 },
+		.ops = &sunxi_ahub_codec_dai_ops,
+	}
+};
+
+static int sunxi_ahub_codec_probe(struct snd_soc_component *component)
+{
+	struct snd_soc_dapm_context *dapm = &component->dapm;
+	snd_soc_dapm_new_controls(dapm, sunxi_ahub_codec_dapm_widgets,
+					ARRAY_SIZE(sunxi_ahub_codec_dapm_widgets));
+	snd_soc_dapm_add_routes(dapm, sunxi_ahub_codec_dapm_routes,
+					ARRAY_SIZE(sunxi_ahub_codec_dapm_routes));
+	snd_soc_add_component_controls(component, ahub_controls,
+					ARRAY_SIZE(ahub_controls));
+
+	sunxi_ahub_codec_init(component);
+	return 0;
+}
+
+static int sunxi_ahub_codec_suspend(struct snd_soc_component *component)
+{
+	struct sunxi_ahub_priv *sunxi_ahub = snd_soc_component_get_drvdata(component);
+	pr_debug("Enter %s\n", __func__);
+
+	clk_disable_unprepare(sunxi_ahub->moduleclk);
+#ifdef AHUB_PLL_AUDIO_X4
+	clk_disable_unprepare(sunxi_ahub->pllclkx4);
+#endif
+	clk_disable_unprepare(sunxi_ahub->pllclk);
+
+	pr_debug("End %s\n", __func__);
+
+	return 0;
+}
+
+static int sunxi_ahub_codec_resume(struct snd_soc_component *component)
+{
+	struct sunxi_ahub_priv *sunxi_ahub = snd_soc_component_get_drvdata(component);
+
+	pr_debug("Enter %s\n", __func__);
+
+	if (clk_prepare_enable(sunxi_ahub->pllclk)) {
+		dev_err(sunxi_ahub->dev, "pllclk resume failed\n");
+		return -EBUSY;
+	}
+
+#ifdef AHUB_PLL_AUDIO_X4
+	if (clk_prepare_enable(sunxi_ahub->pllclkx4)) {
+		dev_err(sunxi_ahub->dev, "pllclkx4 resume failed\n");
+		return -EBUSY;
+	}
+#endif
+
+	if (clk_prepare_enable(sunxi_ahub->moduleclk)) {
+		dev_err(sunxi_ahub->dev, "moduleclk resume failed\n");
+		return -EBUSY;
+	}
+
+	sunxi_ahub_codec_init(component);
+	sunxi_ahub_cpudai_init();
+
+	pr_debug("End %s\n", __func__);
+
+	return 0;
+}
+
+static struct snd_soc_component_driver soc_ahub_dev_sunxi = {
+	.probe = sunxi_ahub_codec_probe,
+	.suspend = sunxi_ahub_codec_suspend,
+	.resume = sunxi_ahub_codec_resume,
+	/* .ignore_pmdown_time = 1, */
+};
+
+static int sunxi_ahub_dev_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	int ret;
+
+	dev_set_drvdata(&pdev->dev, sunxi_ahub);
+	sunxi_ahub->dev = &pdev->dev;
+
+	/*
+	sunxi_ahub->pllclk = of_clk_get(np, 0);
+	if (IS_ERR_OR_NULL(sunxi_ahub->pllclk)) {
+		dev_err(&pdev->dev, "pllclk get failed\n");
+		ret = PTR_ERR(sunxi_ahub->pllclk);
+		goto err_node_put;
+	}
+	*/
+	sunxi_ahub->pllclk = of_clk_get_by_name(np, "clk_pll_audio");
+	if (IS_ERR_OR_NULL(sunxi_ahub->pllclk)) {
+		dev_err(&pdev->dev, "pllclk get failed\n");
+		ret = PTR_ERR(sunxi_ahub->pllclk);
+		goto err_node_put;
+	}
+
+#ifdef AHUB_PLL_AUDIO_X4
+	/*
+	sunxi_ahub->pllclkx4 = of_clk_get(np, 1);
+	if (IS_ERR_OR_NULL(sunxi_ahub->pllclkx4)) {
+		dev_err(&pdev->dev, "pllclkx4 get failed\n");
+		ret = PTR_ERR(sunxi_ahub->pllclkx4);
+		goto err_node_put;
+	}
+
+	sunxi_ahub->moduleclk = of_clk_get(np, 2);
+	if (IS_ERR_OR_NULL(sunxi_ahub->moduleclk)) {
+		dev_err(&pdev->dev, "moduleclk get failed\n");
+		ret = PTR_ERR(sunxi_ahub->moduleclk);
+		goto err_pllclk_put;
+	}
+	*/
+	sunxi_ahub->pllclkx4 = of_clk_get_by_name(np, "clk_pll_audio_4x");
+	if (IS_ERR_OR_NULL(sunxi_ahub->pllclkx4)) {
+		dev_err(&pdev->dev, "pllclkx4 get failed\n");
+		ret = PTR_ERR(sunxi_ahub->pllclkx4);
+		goto err_pllclk_put;
+	}
+
+	sunxi_ahub->moduleclk = of_clk_get_by_name(np, "clk_audio_hub");
+	if (IS_ERR_OR_NULL(sunxi_ahub->moduleclk)) {
+		dev_err(&pdev->dev, "moduleclk get failed\n");
+		ret = PTR_ERR(sunxi_ahub->moduleclk);
+		goto err_pllclkx4_put;
+	}
+
+	sunxi_ahub->ahub_clk_bus = of_clk_get_by_name(np, "clk_bus_audio_hub");
+	if (IS_ERR_OR_NULL(sunxi_ahub->ahub_clk_bus)) {
+		dev_err(&pdev->dev, "ahub_clk_bus get failed\n");
+		ret = PTR_ERR(sunxi_ahub->ahub_clk_bus);
+		goto err_moduleclk_put;
+	}
+
+	sunxi_ahub->ahub_clk_rst = devm_reset_control_get(&pdev->dev, NULL);
+	if (reset_control_deassert(sunxi_ahub->ahub_clk_rst)) {
+		dev_err(&pdev->dev, "reset clk deassert failed");
+		goto err_busclk_put;
+	}
+
+	if (clk_set_parent(sunxi_ahub->moduleclk, sunxi_ahub->pllclkx4)) {
+		dev_err(&pdev->dev, "set parent of moduleclk to pllclkx4 fail\n");
+		ret = -EBUSY;
+		goto err_rst_put;
+	}
+
+	clk_prepare_enable(sunxi_ahub->ahub_clk_bus);
+	clk_prepare_enable(sunxi_ahub->pllclk);
+	clk_prepare_enable(sunxi_ahub->pllclkx4);
+	clk_prepare_enable(sunxi_ahub->moduleclk);
+#else
+	sunxi_ahub->moduleclk = of_clk_get(np, 1);
+	if (IS_ERR_OR_NULL(sunxi_ahub->moduleclk)) {
+		dev_err(&pdev->dev, "moduleclk get failed\n");
+		ret = PTR_ERR(sunxi_ahub->moduleclk);
+		goto err_pllclk_put;
+	}
+
+	if (clk_set_parent(sunxi_ahub->moduleclk, sunxi_ahub->pllclk)) {
+		dev_err(&pdev->dev, "set parent of moduleclk to pllclk fail\n");
+		ret = -EBUSY;
+		goto err_moduleclk_put;
+	}
+
+	clk_prepare_enable(sunxi_ahub->pllclk);
+	clk_prepare_enable(sunxi_ahub->moduleclk);
+#endif
+
+	sunxi_ahub->regmap = sunxi_ahub_regmap_init(pdev);
+	if (!sunxi_ahub->regmap) {
+		dev_err(&pdev->dev, "regmap not init ok\n");
+		ret = -ENOMEM;
+		goto err_moduleclk_put;
+	}
+
+	ret = snd_soc_register_component(&pdev->dev, &soc_ahub_dev_sunxi,
+				sunxi_ahub_codec_dais,
+				ARRAY_SIZE(sunxi_ahub_codec_dais));
+	if (ret) {
+		dev_err(&pdev->dev, "component register failed\n");
+		ret = -ENOMEM;
+		goto err_moduleclk_put;
+	}
+
+	return 0;
+
+err_rst_put:
+	reset_control_assert(sunxi_ahub->ahub_clk_rst);
+err_busclk_put:
+	clk_disable_unprepare(sunxi_ahub->ahub_clk_bus);
+	clk_put(sunxi_ahub->ahub_clk_bus);
+err_moduleclk_put:
+	clk_disable_unprepare(sunxi_ahub->moduleclk);
+	clk_put(sunxi_ahub->moduleclk);
+err_pllclkx4_put:
+	clk_disable_unprepare(sunxi_ahub->pllclkx4);
+	clk_put(sunxi_ahub->pllclkx4);
+err_pllclk_put:
+	clk_disable_unprepare(sunxi_ahub->pllclk);
+	clk_put(sunxi_ahub->pllclk);
+err_node_put:
+	of_node_put(np);
+	return ret;
+}
+
+static int __exit sunxi_ahub_dev_remove(struct platform_device *pdev)
+{
+	struct sunxi_ahub_priv *sunxi_ahub = dev_get_drvdata(&pdev->dev);
+
+	snd_soc_unregister_component(&pdev->dev);
+	clk_put(sunxi_ahub->moduleclk);
+#ifdef AHUB_PLL_AUDIO_X4
+	clk_put(sunxi_ahub->pllclkx4);
+#endif
+	clk_put(sunxi_ahub->pllclk);
+	return 0;
+}
+
+static const struct of_device_id sunxi_ahub_of_match[] = {
+	{ .compatible = "allwinner,sunxi-ahub", },
+	{},
+};
+
+static struct platform_driver sunxi_ahub_driver = {
+	.probe = sunxi_ahub_dev_probe,
+	.remove = __exit_p(sunxi_ahub_dev_remove),
+	.driver = {
+		.name = DRV_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_ahub_of_match,
+	},
+};
+
+module_platform_driver(sunxi_ahub_driver);
+
+MODULE_AUTHOR("wolfgang huang <huangjinhui@allwinnertech.com>");
+MODULE_DESCRIPTION("SUNXI Audio Hub Codec ASoC Interface");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:sunxi-ahub");
diff --git a/sound/soc/sunxi_v2/ahub/sunxi_ahub.h b/sound/soc/sunxi_v2/ahub/sunxi_ahub.h
new file mode 100644
index 000000000..172f3eed0
--- /dev/null
+++ b/sound/soc/sunxi_v2/ahub/sunxi_ahub.h
@@ -0,0 +1,320 @@
+/*
+ * sound\soc\sunxi\sunxi_ahub.h
+ * (C) Copyright 2015-2017
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Wolfgang huang <huangjinhui@allwinnertechtech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef _SUNXI_AHUB_H_
+#define _SUNXI_AHUB_H_
+
+#include <linux/of_device.h>
+#include <linux/regmap.h>
+#include <linux/module.h>
+
+/* select pll_audiox4 as clock source */
+#if defined(CONFIG_ARCH_SUN50IW9)
+#define AHUB_PLL_AUDIO_X4
+#else
+#undef AHUB_PLL_AUDIO_X4
+#endif
+
+/* ahub loopback func for sun50iw9 */
+#if defined(CONFIG_ARCH_SUN50IW9)
+//#define LOOPBACK_FOR_DAUDIO
+//#else
+#undef LOOPBACK_FOR_DAUDIO
+#endif
+
+/* SUNXI Audio Hub registers list */
+#define SUNXI_AHUB_CTL		0x00
+#define SUNXI_AHUB_VER		0x04
+#define SUNXI_AHUB_RST		0x08
+#define SUNXI_AHUB_GAT		0x0c
+/* Left blank */
+#define SUNXI_AHUB_APBIF_TX_CTL(n)		(0x10 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_TX_IRQ_CTL(n)		(0x14 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_TX_IRQ_STA(n)		(0x18 + ((n) * 0x30))
+/* Left Blank */
+#define SUNXI_AHUB_APBIF_TXFIFO_CTL(n)		(0x20 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_TXFIFO_STA(n)		(0x24 + ((n) * 0x30))
+/* Left Blank */
+#define SUNXI_AHUB_APBIF_TXFIFO(n)		(0x30 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_TXFIFO_CNT(n)		(0x34 + ((n) * 0x30))
+/* Left Blank */
+#define SUNXI_AHUB_APBIF_RX_CTL(n)		(0x100 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_RX_IRQ_CTL(n)		(0x104 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_RX_IRQ_STA(n)		(0x108 + ((n) * 0x30))
+/* Left Blank */
+#define SUNXI_AHUB_APBIF_RXFIFO_CTL(n)		(0x110 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_RXFIFO_STA(n)		(0x114 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_RXFIFO_CONT(n)		(0x118 + ((n) * 0x30))
+/* Left Blank */
+#define SUNXI_AHUB_APBIF_RXFIFO(n)		(0x120 + ((n) * 0x30))
+#define SUNXI_AHUB_APBIF_RXFIFO_CNT(n)		(0x124 + ((n) * 0x30))
+
+#define SUNXI_AHUB_I2S_CTL(n)			(0x200 + ((n) << 8))
+#define SUNXI_AHUB_I2S_FMT0(n)			(0x204 + ((n) << 8))
+#define SUNXI_AHUB_I2S_FMT1(n)			(0x208 + ((n) << 8))
+#define SUNXI_AHUB_I2S_CLKD(n)			(0x20c + ((n) << 8))
+/* Left Blank */
+#define SUNXI_AHUB_I2S_RXCONT(n)		(0x220 + ((n) << 8))
+#define SUNXI_AHUB_I2S_CHCFG(n)			(0x224 + ((n) << 8))
+#define SUNXI_AHUB_I2S_IRQ_CTL(n)		(0x228 + ((n) << 8))
+#define SUNXI_AHUB_I2S_IRQ_STA(n)		(0x22C + ((n) << 8))
+#define SUNXI_AHUB_I2S_OUT_SLOT0(n)		(0x230 + ((n) << 8) + (0 << 4))
+#define SUNXI_AHUB_I2S_OUT_SLOT1(n)		(0x230 + ((n) << 8) + (1 << 4))
+#define SUNXI_AHUB_I2S_OUT_SLOT2(n)		(0x230 + ((n) << 8) + (2 << 4))
+#define SUNXI_AHUB_I2S_OUT_SLOT3(n)		(0x230 + ((n) << 8) + (3 << 4))
+#define SUNXI_AHUB_I2S_OUT_CH0MAP0(n)		(0x234 + ((n) << 8) + (0 << 4))
+#define SUNXI_AHUB_I2S_OUT_CH1MAP0(n)		(0x234 + ((n) << 8) + (1 << 4))
+#define SUNXI_AHUB_I2S_OUT_CH2MAP0(n)		(0x234 + ((n) << 8) + (2 << 4))
+#define SUNXI_AHUB_I2S_OUT_CH3MAP0(n)		(0x234 + ((n) << 8) + (3 << 4))
+#define SUNXI_AHUB_I2S_OUT_CH0MAP1(n)		(0x238 + ((n) << 8) + (0 << 4))
+#define SUNXI_AHUB_I2S_OUT_CH1MAP1(n)		(0x238 + ((n) << 8) + (1 << 4))
+#define SUNXI_AHUB_I2S_OUT_CH2MAP1(n)		(0x238 + ((n) << 8) + (2 << 4))
+#define SUNXI_AHUB_I2S_OUT_CH3MAP1(n)		(0x238 + ((n) << 8) + (3 << 4))
+
+
+
+
+/* Left Blank */
+#define SUNXI_AHUB_I2S_IN_SLOT(n)		(0x270 + ((n) << 8))
+#define SUNXI_AHUB_I2S_IN_CHMAP0(n)		(0x274 + ((n) << 8))
+#define SUNXI_AHUB_I2S_IN_CHMAP1(n)		(0x278 + ((n) << 8))
+/* Left Blank */
+#define SUNXI_AHUB_DAM_CTL(n)			(0xA00 + ((n) << 7))
+/* Left Blank */
+#define SUNXI_AHUB_DAM_RX0_SRC(n)		(0xA10 + ((n) << 7))
+#define SUNXI_AHUB_DAM_RX1_SRC(n)		(0xA14 + ((n) << 7))
+#define SUNXI_AHUB_DAM_RX2_SRC(n)		(0xA18 + ((n) << 7))
+/* Left Blank */
+#define SUNXI_AHUB_DAM_MIX_CTL0(n)		(0xA30 + ((n) << 7))
+#define SUNXI_AHUB_DAM_MIX_CTL1(n)		(0xA34 + ((n) << 7))
+#define SUNXI_AHUB_DAM_MIX_CTL2(n)		(0xA38 + ((n) << 7))
+#define SUNXI_AHUB_DAM_MIX_CTL3(n)		(0xA3C + ((n) << 7))
+#define SUNXI_AHUB_DAM_MIX_CTL4(n)		(0xA40 + ((n) << 7))
+#define SUNXI_AHUB_DAM_MIX_CTL5(n)		(0xA44 + ((n) << 7))
+#define SUNXI_AHUB_DAM_MIX_CTL6(n)		(0xA48 + ((n) << 7))
+#define SUNXI_AHUB_DAM_MIX_CTL7(n)		(0xA4C + ((n) << 7))
+#define SUNXI_AHUB_DAM_GAIN_CTL0(n)		(0xA50 + ((n) << 7))
+#define SUNXI_AHUB_DAM_GAIN_CTL1(n)		(0xA54 + ((n) << 7))
+#define SUNXI_AHUB_DAM_GAIN_CTL2(n)		(0xA58 + ((n) << 7))
+#define SUNXI_AHUB_DAM_GAIN_CTL3(n)		(0xA5C + ((n) << 7))
+#define SUNXI_AHUB_DAM_GAIN_CTL4(n)		(0xA60 + ((n) << 7))
+#define SUNXI_AHUB_DAM_GAIN_CTL5(n)		(0xA64 + ((n) << 7))
+#define SUNXI_AHUB_DAM_GAIN_CTL6(n)		(0xA68 + ((n) << 7))
+#define SUNXI_AHUB_DAM_GAIN_CTL7(n)		(0xA6C + ((n) << 7))
+
+/* SUNXI_AHUB_CTL */
+#define HDMI_SRC_SEL		0x04
+
+/* SUNXI_AHUB_RST */
+#define APBIF_TXDIF0_RST	31
+#define APBIF_TXDIF1_RST	30
+#define APBIF_TXDIF2_RST	29
+#define APBIF_RXDIF0_RST	27
+#define APBIF_RXDIF1_RST	26
+#define APBIF_RXDIF2_RST	25
+#define I2S0_RST		23
+#define I2S1_RST		22
+#define I2S2_RST		21
+#define I2S3_RST		20
+#define DAM0_RST		15
+#define DAM1_RST		14
+
+/* SUNXI_AHUB_GAT */
+#define APBIF_TXDIF0_GAT	31
+#define APBIF_TXDIF1_GAT	30
+#define APBIF_TXDIF2_GAT	29
+#define APBIF_RXDIF0_GAT	27
+#define APBIF_RXDIF1_GAT	26
+#define APBIF_RXDIF2_GAT	25
+#define I2S0_GAT		23
+#define I2S1_GAT		22
+#define I2S2_GAT		21
+#define I2S3_GAT		20
+#define DAM0_GAT		15
+#define DAM1_GAT		14
+
+/* SUNXI_AHUB_APBIF_TX_CTL */
+#define APBIF_TX_WS		16
+#define APBIF_TX_CHAN_NUM	8
+#define	APBIF_TX_START		4
+
+/* SUNXI_AHUB_APBIF_TX_IRQ_CTL */
+#define APBIF_TX_DRQ		3
+#define APBIF_TX_OVEN		1
+#define APBIF_TX_EMEN		0
+
+/* SUNXI_AHUB_APBIF_TX_IRQ_STA */
+#define APBIF_TX_OV_PEND	1
+#define APBIF_TX_EM_PEND	0
+
+/* SUNXI_AHUB_APBIF_TXFIFO_CTL */
+#define APBIF_TX_FTX		12
+#define APBIF_TX_LEVEL		4
+#define APBIF_TX_TXIM		0
+
+/* SUNXI_AHUB_APBIF_TXFIFO_STA */
+#define APBIF_TX_EMPTY		8
+#define APBIF_TX_EMCNT		0
+
+/* SUNXI_AHUB_APBIF_RX_CTL */
+#define APBIF_RX_WS		16
+#define APBIF_RX_CHAN_NUM	8
+#define	APBIF_RX_START		4
+
+/* SUNXI_AHUB_APBIF_RX_IRQ_CTL */
+#define APBIF_RX_DRQ		3
+#define APBIF_RX_UVEN		2
+#define APBIF_RX_AVEN		0
+
+/* SUNXI_AHUB_APBIF_RX_IRQ_STA */
+#define APBIF_RX_UV_PEND	1
+#define APBIF_RX_AV_PEND	0
+
+/* SUNXI_AHUB_APBIF_RXFIFO_CTL */
+#define APBIF_RX_FRX		12
+#define APBIF_RX_LEVEL		4
+#define APBIF_RX_RXOM		0
+
+/* SUNXI_AHUB_APBIF_RXFIFO_STA */
+#define APBIF_RX_AVAIL		8
+#define APBIF_RX_AVCNT		0
+
+/* SUNXI_AHUB_APBIF_RXFIFO_CONT */
+#define APBIF_RX_APBIF_TXDIF0		31
+#define APBIF_RX_APBIF_TXDIF1		30
+#define APBIF_RX_APBIF_TXDIF2		29
+#define APBIF_RX_I2S0_TXDIF		27
+#define APBIF_RX_I2S1_TXDIF		26
+#define APBIF_RX_I2S2_TXDIF		25
+#define APBIF_RX_I2S3_TXDIF		23
+#define APBIF_RX_DAM0_TXDIF		19
+#define APBIF_RX_DAM1_TXDIF		15
+
+/* SUNXI_AHUB_I2S_CTL */
+//sun50iw9 change loopback bit and SDI_EN
+#ifdef CONFIG_ARCH_SUN50IW9
+#define I2S_CTL_LOOP3			23
+#define I2S_CTL_LOOP2			22
+#define I2S_CTL_LOOP1			21
+#define I2S_CTL_LOOP0			20
+#define I2S_CTL_SDI3_EN			15
+#define I2S_CTL_SDI2_EN			14
+#define I2S_CTL_SDI1_EN			13
+#define I2S_CTL_SDI0_EN			12
+#else
+#define I2S_CTL_LOOP			3
+#endif
+#define I2S_CTL_CLK_OUT			18
+#define I2S_CTL_SDO3_EN			11
+#define I2S_CTL_SDO2_EN			10
+#define I2S_CTL_SDO1_EN			9
+#define I2S_CTL_SDO0_EN			8
+#define I2S_CTL_OUT_MUTE		6
+#define I2S_CTL_MODE			4
+#define I2S_CTL_TXEN			2
+#define I2S_CTL_RXEN			1
+#define I2S_CTL_GEN			0
+
+/* SUNXI_AHUB_I2S_FMT0 */
+#define I2S_FMT0_LRCK_WIDTH		30
+#define I2S_FMT0_LRCK_POLARITY		19
+#define I2S_FMT0_LRCK_PERIOD		8
+#define I2S_FMT0_BCLK_POLARITY		7
+#define I2S_FMT0_SR			4
+#define I2S_FMT0_EDGE			3
+#define I2S_FMT0_SW			0
+
+/* SUNXI_AHUB_I2S_FMT1 */
+#define I2S_FMT1_RX_LSB			7
+#define I2S_FMT1_TX_LSB			6
+#define I2S_FMT1_EXT			4
+#define I2S_FMT1_RX_PDM			2
+#define I2S_FMT1_TX_PDM			0
+
+/* SUNXI_AHUB_I2S_CLKD */
+#define I2S_CLKD_MCLK			8
+#define	I2S_CLKD_BCLKDIV		4
+#define I2S_CLKD_MCLKDIV		0
+
+/* SUNXI_AHUB_I2S_RXCONT */
+#define I2S_RX_APBIF_TXDIF0		31
+#define I2S_RX_APBIF_TXDIF1		30
+#define I2S_RX_APBIF_TXDIF2		29
+#define I2S_RX_I2S0_TXDIF		27
+#define I2S_RX_I2S1_TXDIF		26
+#define I2S_RX_I2S2_TXDIF		25
+#define I2S_RX_I2S3_TXDIF		23
+#define I2S_RX_DAM0_TXDIF		19
+#define I2S_RX_DAM1_TXDIF		15
+
+/* SUNXI_AHUB_I2S_CHCFG */
+#define I2S_CHCFG_HIZ			9
+#define	I2S_CHCFG_TX_STATE		8
+#define I2S_CHCFG_RX_CHANNUM		4
+#define I2S_CHCFG_TX_CHANNUM		0
+
+/* SUNXI_AHUB_I2S_IRQ_CTL */
+#define I2S_IRQ_RXOV_EN			1
+#define I2S_IRQ_TXUV_EN			0
+
+/* SUNXI_AHUB_I2S_IRQ_STA */
+#define I2S_IRQ_RXOV_PEND		1
+#define I2S_IRQ_TXUV_PEND		0
+
+/* SUNXI_AHUB_I2S_OUT_SLOT */
+#define I2S_OUT_OFFSET			20
+#define I2S_OUT_SLOT_NUM		16
+#define I2S_OUT_SLOT_EN			0
+
+/* SUNXI_AHUB_I2S_IN_SLOT */
+#define I2S_IN_OFFSET			20
+#define I2S_IN_SLOT_NUM			16
+
+/* SUNXI_AHUB_DAM_CTL */
+#define DAM_CTL_RX2_NUM			24
+#define DAM_CTL_RX1_NUM			20
+#define DAM_CTL_RX0_NUM			16
+#define DAM_CTL_TX_NUM			8
+#define DAM_CTL_RX2EN			6
+#define DAM_CTL_RX1EN			5
+#define DAM_CTL_RX0EN			4
+#define DAM_CTL_TXEN			0
+
+/* SUNXI_AHUB_DAM_RX##chan##_SRC */
+#define DAM_RX_APBIF_TXDIF0		31
+#define DAM_RX_APBIF_TXDIF1		30
+#define DAM_RX_APBIF_TXDIF2		29
+#define DAM_RX_I2S0_TXDIF		27
+#define DAM_RX_I2S1_TXDIF		26
+#define DAM_RX_I2S2_TXDIF		25
+#define DAM_RX_I2S3_TXDIF		23
+#define DAM_RX_DAM0_TXDIF		19
+#define DAM_RX_DAM1_TXDIF		15
+
+/* For sun50iw6, if others should redefine */
+#define SUNXI_AHUB_I2S0_ID			0
+#define SUNXI_AHUB_HDMI_ID			1
+#define SUNXI_AHUB_I2S2_ID			2
+#define SUNXI_AHUB_I2S3_ID			3
+
+extern struct regmap *sunxi_ahub_regmap_init(struct platform_device *pdev);
+extern unsigned int sunxi_ahub_read(unsigned int reg);
+extern int sunxi_ahub_update_bits(unsigned int reg, unsigned int mask,
+				unsigned int val);
+extern int sunxi_ahub_cpudai_init(void);
+
+/* used for sunxi netlink to auto open others card */
+extern void sunxi_netlink_printd(const char *fmt, ...);
+#endif
diff --git a/sound/soc/sunxi_v2/ahub/sunxi_ahub_cpudai.c b/sound/soc/sunxi_v2/ahub/sunxi_ahub_cpudai.c
new file mode 100644
index 000000000..58d3714a9
--- /dev/null
+++ b/sound/soc/sunxi_v2/ahub/sunxi_ahub_cpudai.c
@@ -0,0 +1,546 @@
+/*
+ * sound\soc\sunxi\sunxi_ahub_cpudai.c
+ * (C) Copyright 2014-2018
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Wolfgang huang <huangjinhui@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+//#include <linux/dma/sunxi-dma.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+
+#include "sunxi_ahub.h"
+#include "sunxi-pcm.h"
+//#include "../snd_sunxi_pcm.h"
+
+#define DRV_NAME "sunxi-ahub-cpudai"
+
+struct sunxi_ahub_cpudai_priv {
+	unsigned int id;
+	int karaoke_mode;
+	struct regmap *regmap;
+	struct sunxi_dma_params playback_dma_param;
+	struct sunxi_dma_params capture_dma_param;
+};
+
+static int startup_playback_cnt;
+static int startup_capture_cnt;
+static int karaoke_cnt;
+
+int sunxi_ahub_cpudai_init(void)
+{
+	startup_playback_cnt = 0;
+	startup_capture_cnt = 0;
+	karaoke_cnt = 0;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sunxi_ahub_cpudai_init);
+
+
+static int sunxi_ahub_i2s_playback_route_enable(
+		struct sunxi_ahub_cpudai_priv *sunxi_ahub_cpudai)
+{
+	int i, reg_bit;
+	unsigned int reg_val;
+
+	/* first check it's on karaoke mode? */
+	reg_val = sunxi_ahub_read(SUNXI_AHUB_DAM_RX0_SRC(0));
+	if (!reg_val) {
+		reg_val = sunxi_ahub_read(
+				SUNXI_AHUB_DAM_RX1_SRC(0));
+		if (!reg_val)
+			goto no_karaook_handle;
+	}
+	for (i = 0; i < 4; i++) {
+		reg_val = sunxi_ahub_read(
+				SUNXI_AHUB_I2S_RXCONT(i));
+		if (reg_val & (1<<19)) {
+			/* I2S0...HDMI...I2S2...CVBS... */
+			reg_bit = 23 - i;
+			/* setting the rst & gating register for I2S module */
+			sunxi_ahub_update_bits(
+					SUNXI_AHUB_RST,
+					(1<<reg_bit), (1<<reg_bit));
+			sunxi_ahub_update_bits(
+				SUNXI_AHUB_GAT,
+				(1<<reg_bit), (1<<reg_bit));
+			sunxi_ahub_update_bits(
+				SUNXI_AHUB_I2S_CTL(i),
+				(1<<I2S_CTL_TXEN), (1<<I2S_CTL_TXEN));
+		}
+	}
+	sunxi_ahub_cpudai->karaoke_mode = 1;
+	karaoke_cnt++;
+	return 0;
+
+no_karaook_handle:
+	switch (sunxi_ahub_cpudai->id) {
+	case 0:
+		/* operation HDMI I2S module */
+		sunxi_ahub_update_bits(SUNXI_AHUB_RST,
+				(1<<I2S1_RST), (1<<I2S1_RST));
+		sunxi_ahub_update_bits(SUNXI_AHUB_GAT,
+				(1<<I2S1_GAT), (1<<I2S1_GAT));
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(1),
+				(1<<I2S_CTL_TXEN), (1<<I2S_CTL_TXEN));
+
+		sunxi_ahub_update_bits(SUNXI_AHUB_RST,
+				(1<<I2S0_RST), (1<<I2S0_RST));
+		sunxi_ahub_update_bits(SUNXI_AHUB_GAT,
+				(1<<I2S0_GAT), (1<<I2S0_GAT));
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(0),
+				(1<<I2S_CTL_TXEN), (1<<I2S_CTL_TXEN));
+		break;
+	case 1:
+		/* operation CVBS module */
+		sunxi_ahub_update_bits(SUNXI_AHUB_RST,
+				(1<<I2S3_RST), (1<<I2S3_RST));
+		sunxi_ahub_update_bits(SUNXI_AHUB_GAT,
+				(1<<I2S3_GAT), (1<<I2S3_GAT));
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(3),
+				(1<<I2S_CTL_TXEN), (1<<I2S_CTL_TXEN));
+		break;
+	case 2:
+		/* operation I2S2 for bluetooth */
+		sunxi_ahub_update_bits(SUNXI_AHUB_RST,
+				(1<<I2S2_RST), (1<<I2S2_RST));
+		sunxi_ahub_update_bits(SUNXI_AHUB_GAT,
+				(1<<I2S2_GAT), (1<<I2S2_GAT));
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(2),
+				(1<<I2S_CTL_TXEN), (1<<I2S_CTL_TXEN));
+		break;
+	default:
+		break;
+	}
+	sunxi_ahub_cpudai->karaoke_mode = 0;
+	return 0;
+}
+
+static int sunxi_ahub_i2s_playback_route_disable(
+		struct sunxi_ahub_cpudai_priv *sunxi_ahub_cpudai)
+{
+	unsigned int reg_val;
+	int i;
+
+	if (sunxi_ahub_cpudai->karaoke_mode) {
+		if (--karaoke_cnt == 0) {
+			for (i = 0; i < 4; i++) {
+				reg_val = sunxi_ahub_read(
+					SUNXI_AHUB_I2S_CTL(i));
+				if (reg_val & (1 << I2S_CTL_TXEN))
+					/* I2S0...HDMI...I2S2...CVBS... */
+					sunxi_ahub_update_bits(
+						SUNXI_AHUB_I2S_CTL(i),
+						(1<<I2S_CTL_TXEN),
+						(0<<I2S_CTL_TXEN));
+			}
+		}
+	} else {
+		switch (sunxi_ahub_cpudai->id) {
+		case 0:
+			/* operation HDMI I2S module */
+			sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(1),
+					(1<<I2S_CTL_TXEN), (0<<I2S_CTL_TXEN));
+			sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(0),
+					(1<<I2S_CTL_TXEN), (0<<I2S_CTL_TXEN));
+			break;
+		case 1:
+			/* operation CVBS module */
+			sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(3),
+					(1<<I2S_CTL_TXEN), (0<<I2S_CTL_TXEN));
+			break;
+		case 2:
+			/* operation I2S2 for bluetooth */
+			sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(2),
+					(1<<I2S_CTL_TXEN), (0<<I2S_CTL_TXEN));
+			break;
+		default:
+			break;
+		}
+	}
+	return 0;
+}
+
+
+static int sunxi_ahub_i2s_capture_route_enable(
+		struct sunxi_ahub_cpudai_priv *sunxi_ahub_cpudai)
+{
+	int i2s0_cap_bit = 27;
+	/* HDMI just for support debug */
+	int i2s1_cap_bit = 26;
+	int i2s2_cap_bit = 25;
+	int i2s3_cap_bit = 23;
+	unsigned int reg_val;
+
+	reg_val = sunxi_ahub_read(
+		SUNXI_AHUB_APBIF_RXFIFO_CONT(sunxi_ahub_cpudai->id));
+	if (reg_val == (1<<i2s0_cap_bit)) {
+		sunxi_ahub_update_bits(SUNXI_AHUB_RST,
+			(1<<I2S0_RST), (1<<I2S0_RST));
+		sunxi_ahub_update_bits(SUNXI_AHUB_GAT,
+			(1<<I2S0_GAT), (1<<I2S0_GAT));
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(0),
+			(1<<I2S_CTL_RXEN), (1<<I2S_CTL_RXEN));
+
+		/* special enable the i2s0 SDI0 for ac107 capture success */
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(0),
+				(1<<I2S_CTL_SDI0_EN), (1<<I2S_CTL_SDI0_EN));
+	}
+
+	if (reg_val == (1 << i2s1_cap_bit)) {
+		sunxi_ahub_update_bits(SUNXI_AHUB_RST,
+			(1 << I2S1_RST), (1 << I2S1_RST));
+		sunxi_ahub_update_bits(SUNXI_AHUB_GAT,
+			(1 << I2S1_GAT), (1 << I2S1_GAT));
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(1),
+			(1 << I2S_CTL_RXEN), (1 << I2S_CTL_RXEN));
+
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(1),
+				(1<<I2S_CTL_SDI0_EN), (1<<I2S_CTL_SDI0_EN));
+	}
+
+	if (reg_val == (1<<i2s2_cap_bit)) {
+		sunxi_ahub_update_bits(SUNXI_AHUB_RST,
+			(1<<I2S2_RST), (1<<I2S2_RST));
+		sunxi_ahub_update_bits(SUNXI_AHUB_GAT,
+			(1<<I2S2_GAT), (1<<I2S2_GAT));
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(2),
+			(1<<I2S_CTL_RXEN), (1<<I2S_CTL_RXEN));
+
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(2),
+				(1<<I2S_CTL_SDI0_EN), (1<<I2S_CTL_SDI0_EN));
+	}
+
+	if (reg_val == (1<<i2s3_cap_bit)) {
+		sunxi_ahub_update_bits(SUNXI_AHUB_RST,
+			(1<<I2S3_RST), (1<<I2S3_RST));
+		sunxi_ahub_update_bits(SUNXI_AHUB_GAT,
+			(1<<I2S3_GAT), (1<<I2S3_GAT));
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(3),
+			(1<<I2S_CTL_RXEN), (1<<I2S_CTL_RXEN));
+
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(3),
+				(1<<I2S_CTL_SDI0_EN), (1<<I2S_CTL_SDI0_EN));
+	}
+	return 0;
+}
+
+static int sunxi_ahub_i2s_capture_route_disable(
+		struct sunxi_ahub_cpudai_priv *sunxi_ahub_cpudai)
+{
+	int i2s0_cap_bit = 27;
+	/* HDMI just for support debug */
+	int i2s1_cap_bit = 26;
+	int i2s2_cap_bit = 25;
+	int i2s3_cap_bit = 23;
+	unsigned int reg_val;
+
+	reg_val = sunxi_ahub_read(
+		SUNXI_AHUB_APBIF_RXFIFO_CONT(sunxi_ahub_cpudai->id));
+	if (reg_val == (1<<i2s0_cap_bit)) {
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(0),
+			(1<<I2S_CTL_RXEN), (0<<I2S_CTL_RXEN));
+
+		/* special enable the i2s0 SDI0 for ac107 capture success */
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(0),
+				(1<<I2S_CTL_SDI0_EN), (0<<I2S_CTL_SDI0_EN));
+
+	}
+
+	if (reg_val == (1 << i2s1_cap_bit)) {
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(1),
+			(1 << I2S_CTL_RXEN), (0 << I2S_CTL_RXEN));
+
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(1),
+				(1<<I2S_CTL_SDI0_EN), (0<<I2S_CTL_SDI0_EN));
+	}
+
+	if (reg_val == (1<<i2s2_cap_bit)) {
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(2),
+			(1<<I2S_CTL_RXEN), (0<<I2S_CTL_RXEN));
+
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(2),
+				(1<<I2S_CTL_SDI0_EN), (0<<I2S_CTL_SDI0_EN));
+
+	}
+
+	if (reg_val == (1<<i2s3_cap_bit)) {
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(3),
+			(1<<I2S_CTL_RXEN), (0<<I2S_CTL_RXEN));
+
+		sunxi_ahub_update_bits(SUNXI_AHUB_I2S_CTL(3),
+				(1<<I2S_CTL_SDI0_EN), (0<<I2S_CTL_SDI0_EN));
+	}
+	return 0;
+}
+
+static int sunxi_ahub_cpudai_startup(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	struct sunxi_ahub_cpudai_priv *sunxi_ahub_cpudai =
+					snd_soc_dai_get_drvdata(dai);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		snd_soc_dai_set_dma_data(dai, substream,
+					&sunxi_ahub_cpudai->playback_dma_param);
+	else
+		snd_soc_dai_set_dma_data(dai, substream,
+					&sunxi_ahub_cpudai->capture_dma_param);
+
+	return 0;
+}
+
+static int sunxi_ahub_cpudai_trigger(struct snd_pcm_substream *substream,
+				int cmd, struct snd_soc_dai *dai)
+{
+	struct sunxi_ahub_cpudai_priv *sunxi_ahub_cpudai =
+					snd_soc_dai_get_drvdata(dai);
+	switch (cmd) {
+	case	SNDRV_PCM_TRIGGER_START:
+	case	SNDRV_PCM_TRIGGER_RESUME:
+	case	SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			if (startup_playback_cnt++ == 0)
+				sunxi_ahub_i2s_playback_route_enable(
+						sunxi_ahub_cpudai);
+			mdelay(1);
+			sunxi_ahub_update_bits(
+				SUNXI_AHUB_APBIF_TX_CTL(sunxi_ahub_cpudai->id),
+				(1<<APBIF_TX_START), (1<<APBIF_TX_START));
+			sunxi_ahub_update_bits(
+				SUNXI_AHUB_APBIF_TX_IRQ_CTL(
+					sunxi_ahub_cpudai->id),
+				(1<<APBIF_TX_DRQ), (1<<APBIF_TX_DRQ));
+			if (startup_playback_cnt++ > 1)
+				sunxi_ahub_i2s_playback_route_enable(
+						sunxi_ahub_cpudai);
+		} else {
+				sunxi_ahub_update_bits(
+					SUNXI_AHUB_APBIF_RX_CTL(
+					sunxi_ahub_cpudai->id),
+					(1<<APBIF_RX_START),
+					(1<<APBIF_RX_START));
+				sunxi_ahub_update_bits(
+					SUNXI_AHUB_APBIF_RX_IRQ_CTL(
+					sunxi_ahub_cpudai->id),
+					(1<<APBIF_RX_DRQ),
+					(1<<APBIF_RX_DRQ));
+				sunxi_ahub_i2s_capture_route_enable(
+						sunxi_ahub_cpudai);
+		}
+		break;
+	case	SNDRV_PCM_TRIGGER_STOP:
+	case	SNDRV_PCM_TRIGGER_SUSPEND:
+	case	SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			sunxi_ahub_i2s_playback_route_disable(
+				sunxi_ahub_cpudai);
+			sunxi_ahub_update_bits(
+				SUNXI_AHUB_APBIF_TX_IRQ_CTL(
+				sunxi_ahub_cpudai->id),
+				(1<<APBIF_TX_DRQ), (0<<APBIF_TX_DRQ));
+			mdelay(2);
+			sunxi_ahub_update_bits(
+				SUNXI_AHUB_APBIF_TX_CTL(sunxi_ahub_cpudai->id),
+				(1<<APBIF_TX_START), (0<<APBIF_TX_START));
+		} else {
+				sunxi_ahub_update_bits(
+					SUNXI_AHUB_APBIF_RX_CTL(
+					sunxi_ahub_cpudai->id),
+					(1<<APBIF_RX_START),
+					(0<<APBIF_RX_START));
+				sunxi_ahub_update_bits(
+					SUNXI_AHUB_APBIF_RX_IRQ_CTL(
+					sunxi_ahub_cpudai->id),
+					(1<<APBIF_RX_DRQ),
+					(0<<APBIF_RX_DRQ));
+			sunxi_ahub_i2s_capture_route_disable(
+					sunxi_ahub_cpudai);
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static struct snd_soc_dai_ops sunxi_ahub_cpudai_dai_ops = {
+	.startup = sunxi_ahub_cpudai_startup,
+	.trigger = sunxi_ahub_cpudai_trigger,
+};
+
+static struct snd_soc_dai_driver sunxi_ahub_cpudai_dai = {
+	.playback = {
+		.channels_min = 1,
+		.channels_max = 16,
+		.rates = SNDRV_PCM_RATE_8000_192000 | SNDRV_PCM_RATE_KNOT,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE
+			| SNDRV_PCM_FMTBIT_S32_LE,
+	},
+	.capture = {
+		.channels_min = 1,
+		.channels_max = 16,
+		.rates = SNDRV_PCM_RATE_8000_192000 | SNDRV_PCM_RATE_KNOT,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE
+			| SNDRV_PCM_FMTBIT_S32_LE,
+	},
+	.ops	= &sunxi_ahub_cpudai_dai_ops,
+
+};
+
+static const struct snd_soc_component_driver sunxi_ahub_cpudai_component = {
+	.name		= DRV_NAME,
+};
+static const struct of_device_id sunxi_ahub_cpudai_of_match[] = {
+	{ .compatible = "allwinner,sunxi-ahub-cpudai", },
+	{},
+};
+
+static int  sunxi_ahub_cpudai_dev_probe(struct platform_device *pdev)
+{
+	struct resource res;
+	struct sunxi_ahub_cpudai_priv *sunxi_ahub_cpudai;
+	struct device_node *np = pdev->dev.of_node;
+	unsigned int temp_val;
+	int ret;
+
+	sunxi_ahub_cpudai = devm_kzalloc(&pdev->dev,
+			sizeof(struct sunxi_ahub_cpudai_priv), GFP_KERNEL);
+	if (!sunxi_ahub_cpudai) {
+		dev_err(&pdev->dev, "Can't allocate sunxi_cpudai\n");
+		ret = -ENOMEM;
+		goto err_node_put;
+	}
+	dev_set_drvdata(&pdev->dev, sunxi_ahub_cpudai);
+
+	ret = of_property_read_u32(np, "id", &temp_val);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "id configuration missing or invalid\n");
+		goto err_devm_kfree;
+	} else {
+		sunxi_ahub_cpudai->id = temp_val;
+	}
+
+	ret = of_address_to_resource(np, 0, &res);
+	if (ret) {
+		dev_err(&pdev->dev, "Can't parse device node resource\n");
+		ret = -ENODEV;
+		goto err_devm_kfree;
+	}
+
+	/*
+	switch (sunxi_ahub_cpudai->id) {
+	case 0:
+		sunxi_ahub_cpudai->playback_dma_param.dma_drq_type_num =
+							DRQDST_AHUB0_TX;
+		sunxi_ahub_cpudai->capture_dma_param.dma_drq_type_num =
+							DRQSRC_AHUB0_RX;
+		break;
+	case 1:
+		sunxi_ahub_cpudai->playback_dma_param.dma_drq_type_num =
+							DRQDST_AHUB1_TX;
+		sunxi_ahub_cpudai->capture_dma_param.dma_drq_type_num =
+							DRQSRC_AHUB1_RX;
+		break;
+	case 2:
+		sunxi_ahub_cpudai->playback_dma_param.dma_drq_type_num =
+							DRQDST_AHUB2_TX;
+		sunxi_ahub_cpudai->capture_dma_param.dma_drq_type_num =
+							DRQSRC_AHUB2_RX;
+		break;
+	default:
+		dev_err(&pdev->dev, "ahub cpudai id invalid\n");
+		ret = -EINVAL;
+		goto err_devm_kfree;
+	}
+	*/
+	sunxi_ahub_cpudai->playback_dma_param.dma_addr =
+		res.start + SUNXI_AHUB_APBIF_TXFIFO(sunxi_ahub_cpudai->id);
+	sunxi_ahub_cpudai->playback_dma_param.dst_maxburst = 4;
+	sunxi_ahub_cpudai->playback_dma_param.src_maxburst = 4;
+
+	sunxi_ahub_cpudai->capture_dma_param.dma_addr =
+		res.start + SUNXI_AHUB_APBIF_RXFIFO(sunxi_ahub_cpudai->id);
+	sunxi_ahub_cpudai->capture_dma_param.src_maxburst = 4;
+	sunxi_ahub_cpudai->capture_dma_param.dst_maxburst = 4;
+
+	sunxi_ahub_cpudai->regmap = sunxi_ahub_regmap_init(pdev);
+	if (!sunxi_ahub_cpudai->regmap) {
+		dev_err(&pdev->dev, "regmap not init ok\n");
+		ret = -ENOMEM;
+		goto err_devm_kfree;
+	}
+	sunxi_ahub_cpudai_init();
+
+	ret = snd_soc_register_component(&pdev->dev,
+			&sunxi_ahub_cpudai_component,
+			&sunxi_ahub_cpudai_dai, 1);
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register DAI: %d\n", ret);
+		ret = -EBUSY;
+		goto err_devm_kfree;
+	}
+
+	ret = asoc_dma_platform_register(&pdev->dev, SND_DMAENGINE_PCM_FLAG_NO_DT);
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register PCM: %d\n", ret);
+		goto err_unregister_component;
+	}
+
+	return 0;
+
+err_unregister_component:
+	snd_soc_unregister_component(&pdev->dev);
+err_devm_kfree:
+	devm_kfree(&pdev->dev, sunxi_ahub_cpudai);
+err_node_put:
+	of_node_put(np);
+	return ret;
+}
+
+static int __exit sunxi_ahub_cpudai_dev_remove(struct platform_device *pdev)
+{
+	struct sunxi_ahub_cpudai_priv *sunxi_ahub_cpudai =
+					dev_get_drvdata(&pdev->dev);
+
+	snd_soc_unregister_component(&pdev->dev);
+	devm_kfree(&pdev->dev, sunxi_ahub_cpudai);
+
+	return 0;
+}
+
+static struct platform_driver sunxi_ahub_cpudai_driver = {
+	.driver = {
+		.name = DRV_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_ahub_cpudai_of_match,
+	},
+	.probe = sunxi_ahub_cpudai_dev_probe,
+	.remove = __exit_p(sunxi_ahub_cpudai_dev_remove),
+};
+
+module_platform_driver(sunxi_ahub_cpudai_driver);
+
+MODULE_AUTHOR("wolfgang huang <huangjinhui@allwinnertech.com>");
+MODULE_DESCRIPTION("SUNXI Audio Hub cpudai ASoC Interface");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DRV_NAME);
diff --git a/sound/soc/sunxi_v2/ahub/sunxi_ahub_daudio.c b/sound/soc/sunxi_v2/ahub/sunxi_ahub_daudio.c
new file mode 100644
index 000000000..ee8b6c779
--- /dev/null
+++ b/sound/soc/sunxi_v2/ahub/sunxi_ahub_daudio.c
@@ -0,0 +1,1063 @@
+/*
+ * sound\soc\sunxi\sunxi_ahub_daudio.c
+ * (C) Copyright 2015-2017
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Wolfgang huang <huangjinhui@allwinnertechtech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/gpio.h>
+#include <linux/io.h>
+#include <linux/regulator/consumer.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/pm.h>
+#include <linux/of_gpio.h>
+#include <linux/workqueue.h>
+#include <linux/reset.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <sound/tlv.h>
+
+#include "sunxi_ahub.h"
+#include "sunxi-pcm.h"
+//#include "../snd_sunxi_pcm.h"
+
+#define DRV_NAME	"sunxi-ahub-daudio"
+
+struct sunxi_ahub_daudio_priv {
+	struct device *dev;
+	struct regmap *regmap;
+	struct clk *pllclk;
+#ifdef AHUB_PLL_AUDIO_X4
+	struct clk *pllclkx4;
+#endif
+	struct clk *moduleclk;
+	struct clk *ahub_clk_bus;
+	struct reset_control *ahub_clk_rst;
+	struct pinctrl *pinctrl;
+	struct pinctrl_state *pinstate;
+	struct pinctrl_state *pinstate_sleep;
+	struct snd_soc_dai_driver *cpudai;
+	char cpudai_name[20];
+	struct mutex mutex;
+	int used_cnt;
+	unsigned int pinconfig;
+	unsigned int frame_type;
+	unsigned int pcm_lrck_period;
+	unsigned int slot_width_select;
+	unsigned int tdm_config;
+	unsigned int tdm_num;
+	unsigned int mclk_div;
+};
+
+static int sunxi_ahub_daudio_global_enable(struct sunxi_ahub_daudio_priv
+		*sunxi_ahub_daudio, int enable, unsigned int id)
+{
+	if (enable) {
+		regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CTL(id),
+				(1<<I2S_CTL_SDO0_EN), (1<<I2S_CTL_SDO0_EN));
+		/* Special processing for HDMI hub playback module */
+		if (sunxi_ahub_daudio->tdm_num	== SUNXI_AHUB_HDMI_ID) {
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CTL(sunxi_ahub_daudio->tdm_num),
+				(1<<I2S_CTL_SDO1_EN), (1<<I2S_CTL_SDO1_EN));
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CTL(sunxi_ahub_daudio->tdm_num),
+				(1<<I2S_CTL_SDO2_EN), (1<<I2S_CTL_SDO2_EN));
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CTL(sunxi_ahub_daudio->tdm_num),
+				(1<<I2S_CTL_SDO3_EN), (1<<I2S_CTL_SDO3_EN));
+		}
+		regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CTL(id),
+				(1<<I2S_CTL_GEN), (1<<I2S_CTL_GEN));
+	} else {
+		regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CTL(id),
+				(1<<I2S_CTL_GEN), (0<<I2S_CTL_GEN));
+		regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CTL(id),
+				(1<<I2S_CTL_SDO0_EN), (0<<I2S_CTL_SDO0_EN));
+		/* Special processing for HDMI hub playback module */
+		if (sunxi_ahub_daudio->tdm_num	== SUNXI_AHUB_HDMI_ID) {
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CTL(sunxi_ahub_daudio->tdm_num),
+				(1<<I2S_CTL_SDO1_EN), (0<<I2S_CTL_SDO1_EN));
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CTL(sunxi_ahub_daudio->tdm_num),
+				(1<<I2S_CTL_SDO2_EN), (0<<I2S_CTL_SDO2_EN));
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CTL(sunxi_ahub_daudio->tdm_num),
+				(1<<I2S_CTL_SDO3_EN), (0<<I2S_CTL_SDO3_EN));
+		}
+	}
+	return 0;
+}
+
+static int sunxi_ahub_daudio_mclk_setting(struct sunxi_ahub_daudio_priv
+				*sunxi_ahub_daudio, unsigned int id)
+{
+	unsigned int mclk_div;
+
+	if (sunxi_ahub_daudio->mclk_div) {
+		switch (sunxi_ahub_daudio->mclk_div) {
+		case	1:
+			mclk_div = 1;
+			break;
+		case	2:
+			mclk_div = 2;
+			break;
+		case	4:
+			mclk_div = 3;
+			break;
+		case	6:
+			mclk_div = 4;
+			break;
+		case	8:
+			mclk_div = 5;
+			break;
+		case	12:
+			mclk_div = 6;
+			break;
+		case	16:
+			mclk_div = 7;
+			break;
+		case	24:
+			mclk_div = 8;
+			break;
+		case	32:
+			mclk_div = 9;
+			break;
+		case	48:
+			mclk_div = 10;
+			break;
+		case	64:
+			mclk_div = 11;
+			break;
+		case	96:
+			mclk_div = 12;
+			break;
+		case	128:
+			mclk_div = 13;
+			break;
+		case	176:
+			mclk_div = 14;
+			break;
+		case	192:
+			mclk_div = 15;
+			break;
+		default:
+			dev_err(sunxi_ahub_daudio->dev,
+					"unsupport  mclk_div\n");
+			return -EINVAL;
+		}
+		/* setting Mclk as external codec input clk */
+		regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CLKD(id),
+				(0xf<<I2S_CLKD_MCLKDIV),
+				(mclk_div<<I2S_CLKD_MCLKDIV));
+		regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CLKD(id),
+				(0x1<<I2S_CLKD_MCLK), (1<<I2S_CLKD_MCLK));
+	} else {
+		regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CLKD(id),
+				(0x1<<I2S_CLKD_MCLK), (0<<I2S_CLKD_MCLK));
+	}
+	return 0;
+}
+
+static int sunxi_ahub_daudio_init_fmt(struct sunxi_ahub_daudio_priv
+		*sunxi_ahub_daudio, unsigned int fmt, unsigned int id)
+{
+	unsigned int offset, mode;
+	unsigned int lrck_polarity = 0;
+	unsigned int brck_polarity;
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case	SND_SOC_DAIFMT_CBM_CFM:
+		regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CTL(id),
+				(1<<I2S_CTL_CLK_OUT), (0<<I2S_CTL_CLK_OUT));
+		break;
+	case	SND_SOC_DAIFMT_CBS_CFS:
+		regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_CTL(id),
+				(1<<I2S_CTL_CLK_OUT), (1<<I2S_CTL_CLK_OUT));
+		break;
+	default:
+		dev_err(sunxi_ahub_daudio->dev, "unknown maser/slave format\n");
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case	SND_SOC_DAIFMT_I2S:
+		offset = 1;
+		mode = 1;
+		break;
+	case	SND_SOC_DAIFMT_RIGHT_J:
+		offset = 0;
+		mode = 2;
+		break;
+	case	SND_SOC_DAIFMT_LEFT_J:
+		offset = 0;
+		mode = 1;
+		break;
+	case	SND_SOC_DAIFMT_DSP_A:
+		offset = 1;
+		mode = 0;
+		break;
+	case	SND_SOC_DAIFMT_DSP_B:
+		offset = 0;
+		mode = 0;
+		break;
+	default:
+		dev_err(sunxi_ahub_daudio->dev, "format setting failed\n");
+		return -EINVAL;
+	}
+	regmap_update_bits(sunxi_ahub_daudio->regmap, SUNXI_AHUB_I2S_CTL(id),
+			(0x3<<I2S_CTL_MODE), (mode<<I2S_CTL_MODE));
+	regmap_update_bits(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_OUT_SLOT0(id),
+			(0x1<<I2S_OUT_OFFSET), (offset<<I2S_OUT_OFFSET));
+	regmap_update_bits(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_OUT_SLOT1(id),
+			(0x1<<I2S_OUT_OFFSET), (offset<<I2S_OUT_OFFSET));
+	regmap_update_bits(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_OUT_SLOT2(id),
+			(0x1<<I2S_OUT_OFFSET), (offset<<I2S_OUT_OFFSET));
+	regmap_update_bits(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_OUT_SLOT3(id),
+			(0x1<<I2S_OUT_OFFSET), (offset<<I2S_OUT_OFFSET));
+	regmap_update_bits(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_IN_SLOT(id),
+			(0x1<<I2S_IN_OFFSET), (offset<<I2S_IN_OFFSET));
+
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case	SND_SOC_DAIFMT_NB_NF:
+		lrck_polarity = 0;
+		brck_polarity = 0;
+		break;
+	case	SND_SOC_DAIFMT_NB_IF:
+		lrck_polarity = 1;
+		brck_polarity = 0;
+		break;
+	case	SND_SOC_DAIFMT_IB_NF:
+		lrck_polarity = 0;
+		brck_polarity = 1;
+		break;
+	case	SND_SOC_DAIFMT_IB_IF:
+		lrck_polarity = 1;
+		brck_polarity = 1;
+		break;
+	default:
+		dev_err(sunxi_ahub_daudio->dev,
+				"clk fmt setting failed\n");
+		return -EINVAL;
+	}
+
+	regmap_update_bits(sunxi_ahub_daudio->regmap, SUNXI_AHUB_I2S_FMT0(id),
+			(1<<I2S_FMT0_LRCK_POLARITY),
+			(lrck_polarity<<I2S_FMT0_LRCK_POLARITY));
+
+	regmap_update_bits(sunxi_ahub_daudio->regmap, SUNXI_AHUB_I2S_FMT0(id),
+			(1<<I2S_FMT0_BCLK_POLARITY),
+			(brck_polarity<<I2S_FMT0_BCLK_POLARITY));
+	return 0;
+}
+
+static int sunxi_ahub_daudio_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+{
+	struct sunxi_ahub_daudio_priv *sunxi_ahub_daudio =
+				snd_soc_dai_get_drvdata(dai);
+
+	sunxi_ahub_daudio_init_fmt(sunxi_ahub_daudio, fmt,
+					(sunxi_ahub_daudio->tdm_num));
+	return 0;
+}
+
+static int sunxi_ahub_daudio_init(
+		struct sunxi_ahub_daudio_priv *sunxi_ahub_daudio, int id)
+{
+
+	sunxi_ahub_daudio_global_enable(sunxi_ahub_daudio, 1, id);
+
+	regmap_write(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_OUT_CH0MAP0(id), 0x76543210);
+	regmap_write(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_OUT_CH0MAP1(id), 0xFEDCBA98);
+	regmap_write(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_OUT_CH1MAP0(id), 0x76543210);
+	regmap_write(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_OUT_CH1MAP1(id), 0xFEDCBA98);
+	regmap_write(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_OUT_CH2MAP0(id), 0x76543210);
+	regmap_write(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_OUT_CH2MAP1(id), 0xFEDCBA98);
+	regmap_write(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_OUT_CH3MAP0(id), 0x76543210);
+	regmap_write(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_OUT_CH3MAP1(id), 0xFEDCBA98);
+#ifdef CONFIG_ARCH_SUN50IW9
+	/* change the I2S CHMAP for ac107 and td100 capture success */
+	regmap_write(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_IN_CHMAP0(id), 0x03020100);
+	regmap_write(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_IN_CHMAP1(id), 0x00000000);
+#else
+	regmap_write(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_IN_CHMAP0(id), 0x76543210);
+	regmap_write(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_IN_CHMAP1(id), 0xFEDCBA98);
+#endif
+	regmap_update_bits(sunxi_ahub_daudio->regmap, SUNXI_AHUB_I2S_FMT0(id),
+			(1<<I2S_FMT0_LRCK_WIDTH),
+			(sunxi_ahub_daudio->frame_type<<I2S_FMT0_LRCK_WIDTH));
+	regmap_update_bits(sunxi_ahub_daudio->regmap, SUNXI_AHUB_I2S_FMT0(id),
+		(0x1ff<<I2S_FMT0_LRCK_PERIOD),
+		((sunxi_ahub_daudio->pcm_lrck_period-1)<<I2S_FMT0_LRCK_PERIOD));
+
+	regmap_update_bits(sunxi_ahub_daudio->regmap, SUNXI_AHUB_I2S_FMT0(id),
+		(0x7<<I2S_FMT0_SW),
+		(((sunxi_ahub_daudio->slot_width_select>>2) - 1)<<I2S_FMT0_SW));
+
+	/*
+	 * MSB on the transmit format, always be first.
+	 * default using Linear-PCM, without no companding.
+	 * A-law<Eourpean standard> or U-law<US-Japan> not working ok.
+	 */
+	regmap_write(sunxi_ahub_daudio->regmap, SUNXI_AHUB_I2S_FMT1(id), 0x30);
+
+	sunxi_ahub_daudio_mclk_setting(sunxi_ahub_daudio, id);
+
+	return 0;
+}
+
+static int sunxi_ahub_daudio_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct sunxi_ahub_daudio_priv *sunxi_ahub_daudio =
+					snd_soc_dai_get_drvdata(dai);
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_card *card = rtd->card;
+	struct sndhdmi_priv *sunxi_hdmi = snd_soc_card_get_drvdata(card);
+
+	switch (params_format(params)) {
+	case	SNDRV_PCM_FORMAT_S16_LE:
+		/*
+		 * Special procesing for hdmi, HDMI card name is
+		 * "sndhdmi" or sndhdmiraw. if card not HDMI,
+		 * strstr func just return NULL, jump to right section.
+		 * Not HDMI card, sunxi_hdmi maybe a NULL pointer.
+		 */
+		if (sunxi_ahub_daudio->tdm_num == SUNXI_AHUB_HDMI_ID) {
+			if (sunxi_hdmi->hdmi_format > 1)
+				regmap_update_bits(sunxi_ahub_daudio->regmap,
+					SUNXI_AHUB_I2S_FMT0(
+					sunxi_ahub_daudio->tdm_num),
+					(7<<I2S_FMT0_SR), (5<<I2S_FMT0_SR));
+			else
+				regmap_update_bits(sunxi_ahub_daudio->regmap,
+					SUNXI_AHUB_I2S_FMT0(
+					sunxi_ahub_daudio->tdm_num),
+					(7<<I2S_FMT0_SR), (3<<I2S_FMT0_SR));
+		} else {
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_FMT0(sunxi_ahub_daudio->tdm_num),
+					(7<<I2S_FMT0_SR), (3<<I2S_FMT0_SR));
+		}
+		break;
+	case	SNDRV_PCM_FORMAT_S24_LE:
+		regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_FMT0(sunxi_ahub_daudio->tdm_num),
+				(7<<I2S_FMT0_SR), (5<<I2S_FMT0_SR));
+		break;
+	case	SNDRV_PCM_FORMAT_S32_LE:
+		regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_FMT0(sunxi_ahub_daudio->tdm_num),
+				(7<<I2S_FMT0_SR), (7<<I2S_FMT0_SR));
+		break;
+	default:
+		dev_err(sunxi_ahub_daudio->dev, "unrecognized format\n");
+		return -EINVAL;
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		regmap_update_bits(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_CHCFG(sunxi_ahub_daudio->tdm_num),
+			(0xf<<I2S_CHCFG_TX_CHANNUM),
+			((params_channels(params)-1)<<I2S_CHCFG_TX_CHANNUM));
+
+		if (sunxi_ahub_daudio->tdm_num == SUNXI_AHUB_HDMI_ID) {
+			regmap_write(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_OUT_CH0MAP0(
+				sunxi_ahub_daudio->tdm_num),
+				0x10);
+			if (sunxi_hdmi->hdmi_format > 1) {
+				regmap_write(sunxi_ahub_daudio->regmap,
+					SUNXI_AHUB_I2S_OUT_CH1MAP0(
+					sunxi_ahub_daudio->tdm_num),
+					0x32);
+				regmap_write(sunxi_ahub_daudio->regmap,
+					SUNXI_AHUB_I2S_OUT_CH2MAP0(
+					sunxi_ahub_daudio->tdm_num),
+					0x54);
+				regmap_write(sunxi_ahub_daudio->regmap,
+					SUNXI_AHUB_I2S_OUT_CH3MAP0(
+					sunxi_ahub_daudio->tdm_num),
+					0x76);
+			} else {
+				if (params_channels(params) > 2) {
+					regmap_write(sunxi_ahub_daudio->regmap,
+						SUNXI_AHUB_I2S_OUT_CH1MAP0(
+						sunxi_ahub_daudio->tdm_num),
+						0x23);
+				/* only 5.1 & 7.1 */
+				if (params_channels(params) > 4) {
+					if (params_channels(params) == 6)
+						/* 5.1 hit this */
+						regmap_write(
+						sunxi_ahub_daudio->regmap,
+						SUNXI_AHUB_I2S_OUT_CH2MAP0(
+						sunxi_ahub_daudio->tdm_num),
+						0x54);
+					else
+						/* 7.1 hit this */
+						regmap_write(
+						sunxi_ahub_daudio->regmap,
+						SUNXI_AHUB_I2S_OUT_CH2MAP0(
+						sunxi_ahub_daudio->tdm_num),
+						0x76);
+				}
+				if (params_channels(params)  > 6)
+					regmap_write(sunxi_ahub_daudio->regmap,
+						SUNXI_AHUB_I2S_OUT_CH3MAP0(
+						sunxi_ahub_daudio->tdm_num),
+						0x54);
+				}
+			}
+
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_OUT_SLOT0(
+				sunxi_ahub_daudio->tdm_num),
+				(0x0f<<I2S_OUT_SLOT_NUM),
+				(0x01<<I2S_OUT_SLOT_NUM));
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_OUT_SLOT0(
+				sunxi_ahub_daudio->tdm_num),
+				(0xffff<<I2S_OUT_SLOT_EN),
+				(0x03<<I2S_OUT_SLOT_EN));
+
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_OUT_SLOT1(
+				sunxi_ahub_daudio->tdm_num),
+				(0x0f<<I2S_OUT_SLOT_NUM),
+				(0x01<<I2S_OUT_SLOT_NUM));
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_OUT_SLOT1(
+				sunxi_ahub_daudio->tdm_num),
+				(0xffff<<I2S_OUT_SLOT_EN),
+				(0x03<<I2S_OUT_SLOT_EN));
+
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_OUT_SLOT2(
+				sunxi_ahub_daudio->tdm_num),
+				(0x0f<<I2S_OUT_SLOT_NUM),
+				(0x01<<I2S_OUT_SLOT_NUM));
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_OUT_SLOT2(
+				sunxi_ahub_daudio->tdm_num),
+				(0xffff<<I2S_OUT_SLOT_EN),
+				(0x03<<I2S_OUT_SLOT_EN));
+
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_OUT_SLOT3(
+				sunxi_ahub_daudio->tdm_num),
+				(0x0f<<I2S_OUT_SLOT_NUM),
+				(0x01<<I2S_OUT_SLOT_NUM));
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_OUT_SLOT3(
+				sunxi_ahub_daudio->tdm_num),
+				(0xffff<<I2S_OUT_SLOT_EN),
+				(0x03<<I2S_OUT_SLOT_EN));
+		} else {
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_OUT_SLOT0(
+				sunxi_ahub_daudio->tdm_num),
+				(0x0f<<I2S_OUT_SLOT_NUM),
+			((params_channels(params)-1)<<I2S_OUT_SLOT_NUM));
+			regmap_update_bits(sunxi_ahub_daudio->regmap,
+				SUNXI_AHUB_I2S_OUT_SLOT0(
+				sunxi_ahub_daudio->tdm_num),
+				(0xffff<<I2S_OUT_SLOT_EN),
+			(((1<<params_channels(params))-1)<<I2S_OUT_SLOT_EN));
+		}
+	} else {
+		regmap_update_bits(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_CHCFG(sunxi_ahub_daudio->tdm_num),
+			(0xf<<I2S_CHCFG_RX_CHANNUM),
+			((params_channels(params)-1)<<I2S_CHCFG_RX_CHANNUM));
+		regmap_update_bits(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_IN_SLOT(sunxi_ahub_daudio->tdm_num),
+			(0xf<<I2S_IN_SLOT_NUM),
+			((params_channels(params)-1)<<I2S_IN_SLOT_NUM));
+	}
+
+	return 0;
+}
+
+static int sunxi_ahub_daudio_set_sysclk(struct snd_soc_dai *dai,
+			int clk_id, unsigned int freq, int dir)
+{
+	struct sunxi_ahub_daudio_priv *sunxi_ahub_daudio =
+					snd_soc_dai_get_drvdata(dai);
+
+#ifdef AHUB_PLL_AUDIO_X4
+	if (clk_set_rate(sunxi_ahub_daudio->pllclkx4, freq)) {
+		dev_err(sunxi_ahub_daudio->dev, "set pllclkx4 rate failed\n");
+		return -EBUSY;
+	}
+
+	if (clk_set_rate(sunxi_ahub_daudio->moduleclk, freq)) {
+		dev_err(sunxi_ahub_daudio->dev, "set moduleclk rate failed\n");
+		return -EBUSY;
+	}
+#else
+	if (clk_set_rate(sunxi_ahub_daudio->pllclk, freq)) {
+		dev_err(sunxi_ahub_daudio->dev, "set pllclk rate failed\n");
+		return -EBUSY;
+	}
+#endif
+
+	return 0;
+}
+
+static int sunxi_ahub_daudio_set_clkdiv(struct snd_soc_dai *dai,
+				int clk_id, int clk_div)
+{
+	struct sunxi_ahub_daudio_priv *sunxi_ahub_daudio =
+					snd_soc_dai_get_drvdata(dai);
+	unsigned int bclk_div, div_ratio;
+
+	if (sunxi_ahub_daudio->tdm_config)
+		/* I2S/TDM two channel mode */
+		div_ratio = clk_div / (sunxi_ahub_daudio->pcm_lrck_period * 2);
+	else
+		/* PCM mode */
+		div_ratio = clk_div / sunxi_ahub_daudio->pcm_lrck_period;
+
+	switch (div_ratio) {
+	case	1:
+		bclk_div = 1;
+		break;
+	case	2:
+		bclk_div = 2;
+		break;
+	case	4:
+		bclk_div = 3;
+		break;
+	case	6:
+		bclk_div = 4;
+		break;
+	case	8:
+		bclk_div = 5;
+		break;
+	case	12:
+		bclk_div = 6;
+		break;
+	case	16:
+		bclk_div = 7;
+		break;
+	case	24:
+		bclk_div = 8;
+		break;
+	case	32:
+		bclk_div = 9;
+		break;
+	case	48:
+		bclk_div = 10;
+		break;
+	case	64:
+		bclk_div = 11;
+		break;
+	case	96:
+		bclk_div = 12;
+		break;
+	case	128:
+		bclk_div = 13;
+		break;
+	case	176:
+		bclk_div = 14;
+		break;
+	case	192:
+		bclk_div = 15;
+		break;
+	default:
+		dev_err(sunxi_ahub_daudio->dev, "unsupport clk_div\n");
+		return -EINVAL;
+	}
+
+	/* setting bclk to driver external codec bit clk */
+	regmap_update_bits(sunxi_ahub_daudio->regmap,
+			SUNXI_AHUB_I2S_CLKD(sunxi_ahub_daudio->tdm_num),
+			(0xf<<I2S_CLKD_BCLKDIV), (bclk_div<<I2S_CLKD_BCLKDIV));
+	return 0;
+}
+
+static int sunxi_ahub_daudio_trigger(struct snd_pcm_substream *substream,
+				int cmd, struct snd_soc_dai *dai)
+{
+	switch (cmd) {
+	case	SNDRV_PCM_TRIGGER_START:
+	case	SNDRV_PCM_TRIGGER_RESUME:
+	case	SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		break;
+	case	SNDRV_PCM_TRIGGER_STOP:
+	case	SNDRV_PCM_TRIGGER_SUSPEND:
+	case	SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+			/* HMID module, we just keep this clk */
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int sunxi_ahub_daudio_startup(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static void sunxi_ahub_daudio_shutdown(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+}
+
+static struct snd_soc_dai_ops sunxi_ahub_cpu_dai_ops = {
+	.hw_params = sunxi_ahub_daudio_hw_params,
+	.set_sysclk = sunxi_ahub_daudio_set_sysclk,
+	.set_clkdiv = sunxi_ahub_daudio_set_clkdiv,
+	.set_fmt = sunxi_ahub_daudio_set_fmt,
+	.startup = sunxi_ahub_daudio_startup,
+	.trigger = sunxi_ahub_daudio_trigger,
+	.shutdown = sunxi_ahub_daudio_shutdown,
+};
+
+static int sunxi_ahub_daudio_probe(struct snd_soc_dai *dai)
+{
+	struct sunxi_ahub_daudio_priv *sunxi_ahub_daudio =
+					snd_soc_dai_get_drvdata(dai);
+	int ret;
+
+	mutex_init(&sunxi_ahub_daudio->mutex);
+	sunxi_ahub_daudio_init(sunxi_ahub_daudio, (sunxi_ahub_daudio->tdm_num));
+
+	if (sunxi_ahub_daudio->pinconfig) {
+		sunxi_ahub_daudio->pinctrl =
+				devm_pinctrl_get(sunxi_ahub_daudio->dev);
+		if (IS_ERR_OR_NULL(sunxi_ahub_daudio->pinctrl)) {
+			dev_err(sunxi_ahub_daudio->dev, "pinctrl get failed\n");
+			return -ENODEV;
+		}
+	}
+
+	if (sunxi_ahub_daudio->pinconfig) {
+		sunxi_ahub_daudio->pinstate =
+			pinctrl_lookup_state(sunxi_ahub_daudio->pinctrl,
+					"default");
+		if (IS_ERR_OR_NULL(sunxi_ahub_daudio->pinstate)) {
+			dev_err(sunxi_ahub_daudio->dev,
+					"pinctrl default state get failed\n");
+			return -ENODEV;
+		}
+		sunxi_ahub_daudio->pinstate_sleep =
+			pinctrl_lookup_state(sunxi_ahub_daudio->pinctrl,
+					"sleep");
+		if (IS_ERR_OR_NULL(sunxi_ahub_daudio->pinstate_sleep)) {
+			dev_err(sunxi_ahub_daudio->dev,
+					"pinctrl sleep state get failed\n");
+			return -ENODEV;
+		}
+		ret = pinctrl_select_state(sunxi_ahub_daudio->pinctrl,
+						sunxi_ahub_daudio->pinstate);
+		if (ret) {
+			dev_warn(sunxi_ahub_daudio->dev,
+					"select default state failed\n");
+			return -EBUSY;
+		}
+	}
+
+	return 0;
+}
+
+static int sunxi_ahub_daudio_remove(struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static int sunxi_ahub_daudio_suspend(struct snd_soc_dai *dai)
+{
+	struct sunxi_ahub_daudio_priv *sunxi_ahub_daudio =
+					snd_soc_dai_get_drvdata(dai);
+	int ret;
+
+	pr_debug("Enter %s\n", __func__);
+
+	clk_disable_unprepare(sunxi_ahub_daudio->moduleclk);
+#ifdef AHUB_PLL_AUDIO_X4
+	clk_disable_unprepare(sunxi_ahub_daudio->pllclkx4);
+#endif
+	clk_disable_unprepare(sunxi_ahub_daudio->pllclk);
+
+	if (sunxi_ahub_daudio->pinconfig) {
+		ret = pinctrl_select_state(sunxi_ahub_daudio->pinctrl,
+				sunxi_ahub_daudio->pinstate_sleep);
+		if (ret) {
+			dev_warn(sunxi_ahub_daudio->dev,
+					"select i2s0-default state failed\n");
+			return -EBUSY;
+		}
+	}
+
+	/* Global disable I2S/TDM module */
+	sunxi_ahub_daudio_global_enable(sunxi_ahub_daudio, 0,
+				(sunxi_ahub_daudio->tdm_num));
+
+	pr_debug("End %s\n", __func__);
+
+	return 0;
+}
+
+static int sunxi_ahub_daudio_resume(struct snd_soc_dai *dai)
+{
+	struct sunxi_ahub_daudio_priv *sunxi_ahub_daudio =
+				snd_soc_dai_get_drvdata(dai);
+	int ret;
+
+	pr_debug("Enter %s\n", __func__);
+
+	if (clk_prepare_enable(sunxi_ahub_daudio->pllclk)) {
+		dev_err(sunxi_ahub_daudio->dev, "pllclk resume failed\n");
+		return -EBUSY;
+	}
+
+#ifdef AHUB_PLL_AUDIO_X4
+	if (clk_prepare_enable(sunxi_ahub_daudio->pllclkx4)) {
+		dev_err(sunxi_ahub_daudio->dev, "pllclkx4 resume failed\n");
+		return -EBUSY;
+	}
+#endif
+
+	if (clk_prepare_enable(sunxi_ahub_daudio->moduleclk)) {
+		dev_err(sunxi_ahub_daudio->dev, "moduleclk resume failed\n");
+		return -EBUSY;
+	}
+
+	if (sunxi_ahub_daudio->pinconfig) {
+		ret = pinctrl_select_state(sunxi_ahub_daudio->pinctrl,
+						sunxi_ahub_daudio->pinstate);
+		if (ret) {
+			dev_warn(sunxi_ahub_daudio->dev,
+					"select default state failed\n");
+			return -EBUSY;
+		}
+	}
+
+	sunxi_ahub_daudio_init(sunxi_ahub_daudio, sunxi_ahub_daudio->tdm_num);
+
+	pr_debug("End %s\n", __func__);
+
+	return 0;
+}
+
+static struct snd_soc_dai_driver sunxi_ahub_daudio_mod = {
+	.probe = sunxi_ahub_daudio_probe,
+	.remove = sunxi_ahub_daudio_remove,
+	.suspend = sunxi_ahub_daudio_suspend,
+	.resume = sunxi_ahub_daudio_resume,
+	.playback = {
+		.channels_min = 1,
+		.channels_max = 16,
+		.rates = SNDRV_PCM_RATE_8000_192000 | SNDRV_PCM_RATE_KNOT,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE
+			| SNDRV_PCM_FMTBIT_S24_LE
+			| SNDRV_PCM_FMTBIT_S32_LE,
+	},
+	.capture = {
+		.channels_min = 1,
+		.channels_max = 16,
+		.rates = SNDRV_PCM_RATE_8000_192000 | SNDRV_PCM_RATE_KNOT,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE
+			| SNDRV_PCM_FMTBIT_S24_LE
+			| SNDRV_PCM_FMTBIT_S32_LE,
+	 },
+	.ops = &sunxi_ahub_cpu_dai_ops,
+};
+
+static const struct snd_soc_component_driver sunxi_ahub_daudio_component = {
+	.name		= DRV_NAME,
+};
+
+static int sunxi_ahub_daudio_dev_probe(struct platform_device *pdev)
+{
+	struct sunxi_ahub_daudio_priv *sunxi_ahub_daudio;
+	struct device_node *np = pdev->dev.of_node;
+	unsigned int temp_val;
+	int ret;
+
+	sunxi_ahub_daudio = devm_kzalloc(&pdev->dev,
+			sizeof(struct sunxi_ahub_daudio_priv), GFP_KERNEL);
+	if (!sunxi_ahub_daudio) {
+		ret = -ENOMEM;
+		goto err_node_put;
+	}
+	dev_set_drvdata(&pdev->dev, sunxi_ahub_daudio);
+	sunxi_ahub_daudio->dev = &pdev->dev;
+
+	sunxi_ahub_daudio->cpudai = devm_kzalloc(&pdev->dev,
+			sizeof(struct snd_soc_dai_driver), GFP_KERNEL);
+	if (!sunxi_ahub_daudio->cpudai) {
+		ret = -ENOMEM;
+		goto err_devm_kfree;
+	} else {
+		memcpy(sunxi_ahub_daudio->cpudai, &sunxi_ahub_daudio_mod,
+			sizeof(struct snd_soc_dai_driver));
+	}
+
+	/*
+	sunxi_ahub_daudio->pllclk = of_clk_get(np, 0);
+	if (IS_ERR_OR_NULL(sunxi_ahub_daudio->pllclk)) {
+		dev_err(&pdev->dev, "pllclk get failed\n");
+		ret = PTR_ERR(sunxi_ahub_daudio->pllclk);
+		goto err_cpudai_kfree;
+	}
+	*/
+	sunxi_ahub_daudio->pllclk = of_clk_get_by_name(np, "clk_pll_audio");
+	if (IS_ERR_OR_NULL(sunxi_ahub_daudio->pllclk)) {
+		dev_err(&pdev->dev, "pllclk get failed\n");
+		ret = PTR_ERR(sunxi_ahub_daudio->pllclk);
+		goto err_cpudai_kfree;
+	}
+
+#ifdef AHUB_PLL_AUDIO_X4
+	/*
+	sunxi_ahub_daudio->pllclkx4 = of_clk_get(np, 1);
+	if (IS_ERR_OR_NULL(sunxi_ahub_daudio->pllclkx4)) {
+		dev_err(&pdev->dev, "pllclkx4 get failed\n");
+		ret = PTR_ERR(sunxi_ahub_daudio->pllclkx4);
+		goto err_cpudai_kfree;
+	}
+
+	sunxi_ahub_daudio->moduleclk = of_clk_get(np, 2);
+	if (IS_ERR_OR_NULL(sunxi_ahub_daudio->moduleclk)) {
+		dev_err(&pdev->dev, "moduleclk get failed\n");
+		ret = PTR_ERR(sunxi_ahub_daudio->moduleclk);
+		goto err_pllclk_put;
+	}
+	*/
+	sunxi_ahub_daudio->pllclkx4 = of_clk_get_by_name(np, "clk_pll_audio_4x");
+	if (IS_ERR_OR_NULL(sunxi_ahub_daudio->pllclkx4)) {
+		dev_err(&pdev->dev, "pllclkx4 get failed\n");
+		ret = PTR_ERR(sunxi_ahub_daudio->pllclkx4);
+		goto err_pllclk_put;
+	}
+
+	sunxi_ahub_daudio->moduleclk = of_clk_get_by_name(np, "clk_audio_hub");
+	if (IS_ERR_OR_NULL(sunxi_ahub_daudio->moduleclk)) {
+		dev_err(&pdev->dev, "moduleclk get failed\n");
+		ret = PTR_ERR(sunxi_ahub_daudio->moduleclk);
+		goto err_pllclkx4_put;
+	}
+
+	sunxi_ahub_daudio->ahub_clk_bus = of_clk_get_by_name(np, "clk_bus_audio_hub");
+	if (IS_ERR_OR_NULL(sunxi_ahub_daudio->ahub_clk_bus)) {
+		dev_err(&pdev->dev, "ahub_clk_bus get failed\n");
+		ret = PTR_ERR(sunxi_ahub_daudio->ahub_clk_bus);
+		goto err_moduleclk_put;
+	}
+
+	/*
+	sunxi_ahub_daudio->ahub_clk_rst = devm_reset_control_get(&pdev->dev, NULL);
+	*/
+
+	if (clk_set_parent(sunxi_ahub_daudio->moduleclk,
+				sunxi_ahub_daudio->pllclkx4)) {
+		dev_err(&pdev->dev, "set parent of moduleclk to pllclkx4 fail\n");
+		ret = -EBUSY;
+		goto err_busclk_put;
+	}
+
+	clk_prepare_enable(sunxi_ahub_daudio->ahub_clk_bus);
+	clk_prepare_enable(sunxi_ahub_daudio->pllclk);
+	clk_prepare_enable(sunxi_ahub_daudio->pllclkx4);
+	clk_prepare_enable(sunxi_ahub_daudio->moduleclk);
+#else
+	sunxi_ahub_daudio->moduleclk = of_clk_get(np, 1);
+	if (IS_ERR_OR_NULL(sunxi_ahub_daudio->moduleclk)) {
+		dev_err(&pdev->dev, "moduleclk get failed\n");
+		ret = PTR_ERR(sunxi_ahub_daudio->moduleclk);
+		goto err_pllclk_put;
+	}
+
+	if (clk_set_parent(sunxi_ahub_daudio->moduleclk,
+				sunxi_ahub_daudio->pllclk)) {
+		dev_err(&pdev->dev, "set parent of moduleclk to pllclk fail\n");
+		ret = -EBUSY;
+		goto err_moduleclk_put;
+	}
+	clk_prepare_enable(sunxi_ahub_daudio->pllclk);
+	clk_prepare_enable(sunxi_ahub_daudio->moduleclk);
+#endif
+
+	ret = of_property_read_u32(np, "tdm_num", &temp_val);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "tdm_num configuration invalid\n");
+		goto err_moduleclk_put;
+	} else {
+		sunxi_ahub_daudio->tdm_num = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "pinconfig", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "pinconfig configuration invalid\n");
+		sunxi_ahub_daudio->pinconfig = 0;
+	} else {
+		sunxi_ahub_daudio->pinconfig = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "frametype", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "frametype configuration invalid\n");
+		sunxi_ahub_daudio->frame_type = 0;
+	} else {
+		sunxi_ahub_daudio->frame_type = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "pcm_lrck_period", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "pcm_lrck_period configuration invalid\n");
+		sunxi_ahub_daudio->pcm_lrck_period = 0;
+	} else {
+		sunxi_ahub_daudio->pcm_lrck_period = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "slot_width_select", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "slot_width_select configuration inval\n");
+		sunxi_ahub_daudio->slot_width_select = 0;
+	} else {
+		sunxi_ahub_daudio->slot_width_select = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "tdm_config", &temp_val);
+	if (ret < 0) {
+		dev_warn(&pdev->dev, "tdm_config configuration invalid\n");
+		sunxi_ahub_daudio->tdm_config = 1;
+	} else {
+		sunxi_ahub_daudio->tdm_config = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "mclk_div", &temp_val);
+	if (ret < 0)
+		sunxi_ahub_daudio->mclk_div = 0;
+	else
+		sunxi_ahub_daudio->mclk_div = temp_val;
+
+	sunxi_ahub_daudio->regmap = sunxi_ahub_regmap_init(pdev);
+	if (!sunxi_ahub_daudio->regmap) {
+		dev_err(&pdev->dev, "regmap not init ok\n");
+		ret = -ENOMEM;
+		goto err_moduleclk_put;
+	}
+
+	/* diff handle for dais  even we use tdm_num as dai id	----->roy */
+	sunxi_ahub_daudio->cpudai->id = sunxi_ahub_daudio->tdm_num;
+	sprintf(sunxi_ahub_daudio->cpudai_name, "sunxi-ahub-cpu-aif%d",
+					sunxi_ahub_daudio->tdm_num);
+	sunxi_ahub_daudio->cpudai->name = sunxi_ahub_daudio->cpudai_name;
+
+	ret = snd_soc_register_component(&pdev->dev,
+			&sunxi_ahub_daudio_component,
+			sunxi_ahub_daudio->cpudai, 1);
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register DAI: %d\n", ret);
+		ret = -EBUSY;
+		goto err_moduleclk_put;
+	}
+	return 0;
+
+err_busclk_put:
+	clk_disable_unprepare(sunxi_ahub_daudio->ahub_clk_bus);
+	clk_put(sunxi_ahub_daudio->ahub_clk_bus);
+err_moduleclk_put:
+	clk_disable_unprepare(sunxi_ahub_daudio->moduleclk);
+	clk_put(sunxi_ahub_daudio->moduleclk);
+err_pllclkx4_put:
+	clk_disable_unprepare(sunxi_ahub_daudio->pllclkx4);
+	clk_put(sunxi_ahub_daudio->pllclkx4);
+err_pllclk_put:
+	clk_disable_unprepare(sunxi_ahub_daudio->pllclk);
+	clk_put(sunxi_ahub_daudio->pllclk);
+err_cpudai_kfree:
+	kfree(sunxi_ahub_daudio->cpudai);
+err_devm_kfree:
+	devm_kfree(&pdev->dev, sunxi_ahub_daudio);
+err_node_put:
+	of_node_put(np);
+	return ret;
+}
+
+static int __exit sunxi_ahub_daudio_dev_remove(struct platform_device *pdev)
+{
+	struct sunxi_ahub_daudio_priv *sunxi_ahub_daudio =
+				dev_get_drvdata(&pdev->dev);
+
+	snd_soc_unregister_component(&pdev->dev);
+	clk_put(sunxi_ahub_daudio->moduleclk);
+#ifdef AHUB_PLL_AUDIO_X4
+	clk_put(sunxi_ahub_daudio->pllclkx4);
+#endif
+	clk_put(sunxi_ahub_daudio->pllclk);
+	return 0;
+}
+
+static const struct of_device_id sunxi_ahub_daudio_of_match[] = {
+	{ .compatible = "allwinner,sunxi-ahub-daudio", },
+	{},
+};
+
+static struct platform_driver sunxi_ahub_daudio_driver = {
+	.probe = sunxi_ahub_daudio_dev_probe,
+	.remove = __exit_p(sunxi_ahub_daudio_dev_remove),
+	.driver = {
+		.name = DRV_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_ahub_daudio_of_match,
+	},
+};
+
+module_platform_driver(sunxi_ahub_daudio_driver);
+
+MODULE_AUTHOR("wolfgang huang <huangjinhui@allwinnertech.com>");
+MODULE_DESCRIPTION("SUNXI Audio Hub ASoC Interface");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:sunxi-ahub");
diff --git a/sound/soc/sunxi_v2/ahub/sunxi_netlink.c b/sound/soc/sunxi_v2/ahub/sunxi_netlink.c
new file mode 100644
index 000000000..6d46ab7dd
--- /dev/null
+++ b/sound/soc/sunxi_v2/ahub/sunxi_netlink.c
@@ -0,0 +1,266 @@
+/*
+ * Copyright (c) 2016 AllWinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/module.h>
+#include <linux/etherdevice.h>
+#include <linux/netdevice.h>
+#include <net/netlink.h>
+#include <net/sock.h>
+#include <linux/workqueue.h>
+#include <linux/types.h>
+
+#define	EVT_MAX_SIZE		256
+#define	NETLINK_PCM_SUNXI	31
+
+#undef	SUNXI_NETLINK_TEST
+
+enum {
+	SNDRV_PCM_NETLINK_CLOSE,
+	SNDRV_PCM_NETLINK_START,
+	SNDRV_PCM_NETLINK_NOUSE,
+};
+
+#ifdef	SUNXI_NETLINK_TEST
+static void sunxi_netlink_period(struct work_struct *ws);
+DECLARE_DELAYED_WORK(writer_work, sunxi_netlink_period);
+#endif
+
+struct evt_entry {
+	struct list_head list;
+	char evt_data[EVT_MAX_SIZE];
+	int size;
+};
+
+struct xrun_event {
+	int ref_cnt;
+	struct sock *sock;
+	struct list_head evtq;
+	spinlock_t evt_lock;
+	struct list_head freeq;
+	struct work_struct ws;
+};
+
+struct pcm_netlink_status {
+	int pid;
+	int status;
+	struct mutex mutex_lock;
+};
+
+static struct xrun_event pcm_event;
+static struct pcm_netlink_status pcm_netlink;
+
+static void free_event_entry(struct evt_entry *e)
+{
+	kfree(e);
+}
+
+static inline struct evt_entry *alloc_evt_entry(void)
+{
+	return kmalloc(sizeof(struct evt_entry), GFP_ATOMIC);
+}
+
+static struct evt_entry *get_evt_entry(void)
+{
+	struct evt_entry *e;
+
+	if (list_empty(&pcm_event.freeq))
+		e = alloc_evt_entry();
+	else {
+		e = list_entry(pcm_event.freeq.next, struct evt_entry, list);
+		list_del(&e->list);
+	}
+
+	return e;
+}
+
+static void put_evt_entry(struct evt_entry *e)
+{
+	list_add_tail(&e->list, &pcm_event.freeq);
+}
+
+static int netlink_send(struct sock *sock, int group,
+		u16 type, void *msg, int len)
+{
+	struct sk_buff *skb = NULL;
+	struct nlmsghdr *nlh;
+	int ret = 0;
+
+	skb = nlmsg_new(len, GFP_ATOMIC);
+	if (!skb) {
+		kfree_skb(skb);
+		return -EMSGSIZE;
+	}
+
+	nlh = nlmsg_put(skb, 0, 0, type, len, 0);
+	if (!nlh) {
+		kfree_skb(skb);
+		return -EMSGSIZE;
+	}
+	memcpy(nlmsg_data(nlh), msg, len);
+
+	NETLINK_CB(skb).portid = 0;
+	NETLINK_CB(skb).dst_group = 0;
+
+	if (pcm_netlink.status > SNDRV_PCM_NETLINK_CLOSE) {
+		ret = netlink_unicast(sock, skb, pcm_netlink.pid, GFP_ATOMIC);
+		if (ret < 0)
+			pcm_netlink.status = SNDRV_PCM_NETLINK_CLOSE;
+	}
+	return ret;
+}
+
+static void _pcm_event_send(struct work_struct *work)
+{
+	unsigned long flags;
+	struct evt_entry *e;
+
+	spin_lock_irqsave(&pcm_event.evt_lock, flags);
+
+	while (!list_empty(&pcm_event.evtq)) {
+		e = list_entry(pcm_event.evtq.next, struct evt_entry, list);
+		spin_unlock_irqrestore(&pcm_event.evt_lock, flags);
+		netlink_send(pcm_event.sock, 0, 0, e->evt_data, e->size);
+		spin_lock_irqsave(&pcm_event.evt_lock, flags);
+		list_del(&e->list);
+		put_evt_entry(e);
+	}
+
+	spin_unlock_irqrestore(&pcm_event.evt_lock, flags);
+}
+
+static void netlink_rcv(struct sk_buff *skb)
+{
+	struct nlmsghdr *nlh;
+	int pid;
+
+	nlh = (struct nlmsghdr *)skb->data;
+	pid = nlh->nlmsg_pid; /*pid of sending process */
+
+	/* user start capture? */
+	if (!strncmp(nlmsg_data(nlh), "start", 5)) {
+		pcm_netlink.pid = pid;
+		pcm_netlink.status = SNDRV_PCM_NETLINK_START;
+	}
+	if (!strncmp(nlmsg_data(nlh), "close", 5))
+		pcm_netlink.status = SNDRV_PCM_NETLINK_CLOSE;
+
+#ifdef	SUNXI_NETLINK_TEST
+	if (pcm_netlink.status)
+		schedule_delayed_work(&writer_work, 5 * HZ);
+#endif
+}
+
+static void printk_convert(struct evt_entry *e, const char *fmt, va_list args)
+{
+	e->size = vscnprintf(e->evt_data, EVT_MAX_SIZE, fmt, args);
+
+	/* mark and strip a trailing newline */
+	if (e->size && e->evt_data[e->size - 1] == '\n')
+		e->size--;
+}
+
+void sunxi_netlink_printd(const char *fmt, ...)
+{
+	va_list args;
+	struct evt_entry *e;
+	unsigned long flags;
+
+	spin_lock_irqsave(&pcm_event.evt_lock, flags);
+	e = get_evt_entry();
+	if (!e) {
+		pr_err("pcm netlink memory not available\n");
+		spin_unlock_irqrestore(&pcm_event.evt_lock, flags);
+		return;
+	}
+	va_start(args, fmt);
+
+	printk_convert(e, fmt, args);
+
+	va_end(args);
+
+	list_add_tail(&e->list, &pcm_event.evtq);
+	spin_unlock_irqrestore(&pcm_event.evt_lock, flags);
+
+	schedule_work(&pcm_event.ws);
+}
+
+#ifdef	SUNXI_NETLINK_TEST
+static void sunxi_netlink_period(struct work_struct *ws)
+{
+	static int count = 1;
+	sunxi_netlink_printd("hello form the pcm netlink test: %d\n", count);
+	schedule_delayed_work(&writer_work, msecs_to_jiffies(10));
+}
+#endif
+
+int sunxi_netlink_init(void)
+{
+	struct netlink_kernel_cfg cfg = {
+		.input = netlink_rcv,
+	};
+
+	if (!pcm_event.ref_cnt) {
+		pcm_event.sock = netlink_kernel_create(&init_net,
+					NETLINK_PCM_SUNXI, &cfg);
+		if (!pcm_event.sock) {
+			pr_err("netlink create failed\n");
+			return -EMSGSIZE;
+		}
+		if (pcm_event.sock) {
+			INIT_LIST_HEAD(&pcm_event.evtq);
+			INIT_LIST_HEAD(&pcm_event.freeq);
+			INIT_WORK(&pcm_event.ws, _pcm_event_send);
+			spin_lock_init(&pcm_event.evt_lock);
+		}
+		pcm_netlink.status = SNDRV_PCM_NETLINK_CLOSE;
+	}
+
+	if (pcm_event.sock) {
+		pcm_event.ref_cnt++;
+		pr_debug("Creating PCM netlink successfully\n");
+		return 0;
+	}
+
+	pr_debug("Creating PCM netlink is failed\n");
+	return -EBUSY;
+}
+
+static void sunxi_netlink_exit(void)
+{
+	struct evt_entry *e, *temp;
+	unsigned long flags;
+	if (pcm_event.sock && --pcm_event.ref_cnt == 0) {
+		spin_lock_irqsave(&pcm_event.evt_lock, flags);
+
+		list_for_each_entry_safe(e, temp, &pcm_event.evtq, list) {
+			list_del(&e->list);
+			free_event_entry(e);
+		}
+		list_for_each_entry_safe(e, temp, &pcm_event.freeq, list) {
+			list_del(&e->list);
+			free_event_entry(e);
+		}
+
+		spin_unlock_irqrestore(&pcm_event.evt_lock, flags);
+		netlink_kernel_release(pcm_event.sock);
+		pcm_event.sock = NULL;
+	}
+}
+
+module_init(sunxi_netlink_init);
+module_exit(sunxi_netlink_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("wolfgang huang <huangjinhui@allwinnertech.com>");
+MODULE_DESCRIPTION("sunxi netlink interface");
+MODULE_ALIAS("sunxi_netlink");
diff --git a/sound/soc/sunxi_v2/snd_sun50iw9_codec.c b/sound/soc/sunxi_v2/snd_sun50iw9_codec.c
new file mode 100644
index 000000000..d66a33a5b
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sun50iw9_codec.c
@@ -0,0 +1,765 @@
+/*
+ * sound\soc\sunxi\snd_sun50iw9_codec.c
+ * (C) Copyright 2021-2025
+ * AllWinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <sound/tlv.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include "snd_sunxi_log.h"
+#include "snd_sunxi_common.h"
+#include "snd_sunxi_adapter.h"
+#include "snd_sun50iw9_codec.h"
+
+#define HLOG		"CODEC"
+
+/* for sunxi_internal_codec_dev_probe */
+static int sunxi_codec_regulator_init(struct regulator_cntlr *rglt,
+				      struct sunxi_codec_info *codec_info)
+{
+	int ret;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	if (!rglt) {
+		SND_LOG_ERR(HLOG, "regulator cntlr is NULL\n");
+		return ADAPT_FAILURE;
+        }
+
+	/* regulator about */
+	codec_info->avcc = rglt->ops->request(rglt, "avcc");
+	if (!codec_info->avcc) {
+		SND_LOG_ERR(HLOG, "request avcc failed\n");
+		goto err;
+        }
+	codec_info->dvcc = rglt->ops->request(rglt, "dvcc");
+	if (!codec_info->dvcc) {
+		SND_LOG_ERR(HLOG, "request dvcc failed\n");
+		goto err;
+        }
+
+	ret = rglt->ops->enable(rglt, codec_info->avcc);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "avcc enable failed\n");
+		goto err;
+	}
+	ret = rglt->ops->enable(rglt, codec_info->dvcc);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "dvcc enable failed\n");
+		goto err;
+	}
+
+	return ADAPT_SUCCESS;
+err:
+	rglt->ops->disable(rglt, codec_info->avcc);
+	rglt->ops->release(rglt, codec_info->avcc);
+	rglt->ops->disable(rglt, codec_info->dvcc);
+	rglt->ops->release(rglt, codec_info->dvcc);
+
+	return ADAPT_FAILURE;
+}
+
+static int sunxi_codec_clk_init(struct clk_cntlr *clk,
+				struct sunxi_codec_info *codec_info)
+{
+	int ret;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	if (!clk) {
+		SND_LOG_ERR(HLOG, "clk cntlr is NULL\n");
+		return ADAPT_FAILURE;
+	}
+
+	/* deassert ret clk */
+	codec_info->clk_rst = clk->ops->get_rst(clk, NULL);
+	if (!codec_info->clk_rst) {
+		SND_LOG_ERR(HLOG, "request clk rst failed\n");
+		goto err;
+	}
+	ret = clk->ops->deassert_rst(clk, codec_info->clk_rst);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "deassert clk rst failed\n");
+		goto err;
+	}
+
+	/* clk about */
+	codec_info->clk_bus_audio = clk->ops->request(clk, "clk_bus_audio");
+	if (!codec_info->clk_bus_audio) {
+		SND_LOG_ERR(HLOG, "request clk bus audio failed\n");
+		goto err;
+	}
+	codec_info->clk_pll_audio = clk->ops->request(clk, "clk_pll_audio");
+	if (!codec_info->clk_pll_audio) {
+		SND_LOG_ERR(HLOG, "request clk pll audio failed\n");
+		goto err;
+	}
+	codec_info->clk_audio = clk->ops->request(clk, "clk_audio");
+	if (!codec_info->clk_audio) {
+		SND_LOG_ERR(HLOG, "request clk audio failed\n");
+		goto err;
+	}
+
+	ret = clk->ops->set_parent(clk,
+				   codec_info->clk_audio,
+				   codec_info->clk_pll_audio);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "set clk audio parent failed\n");
+		goto err;
+	}
+
+	ret = clk->ops->set_rate(clk, codec_info->clk_pll_audio, 24576000);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "set rate clk pll audio failed\n");
+		goto err;
+	}
+
+	ret = clk->ops->enable_prepare(clk, codec_info->clk_bus_audio);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "enable clk bus audio failed\n");
+		goto err;
+	}
+
+	ret = clk->ops->enable_prepare(clk, codec_info->clk_pll_audio);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "enable clk pll audio failed\n");
+		goto err;
+	}
+	ret = clk->ops->enable_prepare(clk, codec_info->clk_audio);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "enable clk audio failed\n");
+		goto err;
+	}
+
+	return ADAPT_SUCCESS;
+err:
+	clk->ops->disable_unprepare(clk, codec_info->clk_audio);
+	clk->ops->disable_unprepare(clk, codec_info->clk_pll_audio);
+	clk->ops->disable_unprepare(clk, codec_info->clk_bus_audio);
+	clk->ops->release(clk, codec_info->clk_audio);
+	clk->ops->release(clk, codec_info->clk_pll_audio);
+	clk->ops->release(clk, codec_info->clk_bus_audio);
+	clk->ops->assert_rst(clk, codec_info->clk_rst);
+	clk->ops->put_rst(clk, codec_info->clk_rst);
+
+	return ADAPT_FAILURE;
+}
+
+static void sunxi_codec_parse_params(struct parse_cntlr *parse,
+				     struct sunxi_codec_info *codec_info)
+{
+	int ret;
+	u32 temp_val;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	codec_info->digital_vol = 0;
+	codec_info->lineout_vol = 0;
+
+	if (!parse) {
+		SND_LOG_ERR(HLOG, "parse cntlr is NULL\n");
+		return;
+	}
+
+	ret = parse->ops->read_u32(parse, "digital_vol", &temp_val);
+	if (ret < 0) {
+		SND_LOG_ERR(HLOG, "digital volume get failed, use default\n");
+	} else {
+		codec_info->digital_vol = temp_val;
+	}
+
+	ret = parse->ops->read_u32(parse, "lineout_vol", &temp_val);
+	if (ret < 0) {
+		SND_LOG_ERR(HLOG, "lineout volume get failed, use default\n");
+	} else {
+		codec_info->lineout_vol = temp_val;
+	}
+
+	SND_LOG_INFO(HLOG, "digital volume: %u\n", codec_info->digital_vol);
+	SND_LOG_INFO(HLOG, "lineout volume: %u\n", codec_info->lineout_vol);
+}
+
+int internal_codec_probe(struct adapter_cntlr *cntlr,
+			 struct sunxi_codec_info *codec_info)
+{
+	int ret;
+	struct reg_cntlr *reg = NULL;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	if (!cntlr) {
+		SND_LOG_ERR(HLOG, "adapter handle is NULL\n");
+		return ADAPT_FAILURE;
+
+	}
+	reg = cntlr->reg;
+
+	/* regulator init */
+	ret = sunxi_codec_regulator_init(cntlr->regulator, codec_info);
+	if (ret)
+		return ADAPT_FAILURE;
+
+	/* clk init */
+	ret = sunxi_codec_clk_init(cntlr->clk, codec_info);
+	if (ret)
+		return ADAPT_FAILURE;
+
+	/* regmap request */
+	codec_info->regmap = reg->ops->request(reg, SUNXI_AUDIO_MAX_REG);
+	if (!codec_info->regmap) {
+		SND_LOG_ERR(HLOG, "regmap request failed\n");
+		return ADAPT_FAILURE;
+	}
+
+	/* of params parse */
+	sunxi_codec_parse_params(cntlr->parse, codec_info);
+
+	/* gpio mute for peripheral circuit */
+	codec_info->pa_cfg = pa_pin_init(cntlr, &codec_info->pa_pin_max);
+	if (codec_info->pa_pin_max > 0) {
+		SND_LOG_INFO(HLOG, "use pa pin, num is %u\n",
+			     codec_info->pa_pin_max);
+	}
+
+	return ADAPT_SUCCESS;
+}
+
+/* for sunxi_internal_codec_dev_remove */
+int internal_codec_remove(struct adapter_cntlr *cntlr,
+			  struct sunxi_codec_info *codec_info)
+{
+	struct regulator_cntlr *rglt = NULL;
+	struct clk_cntlr *clk = NULL;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	if (!cntlr) {
+		SND_LOG_ERR(HLOG, "adapter handle is NULL\n");
+		return ADAPT_FAILURE;
+
+	}
+	rglt = cntlr->regulator;
+	clk = cntlr->clk;
+
+	/* gpio mute for peripheral circuit */
+	pa_pin_exit(cntlr, codec_info->pa_cfg, codec_info->pa_pin_max);
+
+	/* clk about */
+	clk->ops->disable_unprepare(clk, codec_info->clk_audio);
+	clk->ops->disable_unprepare(clk, codec_info->clk_pll_audio);
+	clk->ops->disable_unprepare(clk, codec_info->clk_bus_audio);
+	clk->ops->release(clk, codec_info->clk_audio);
+	clk->ops->release(clk, codec_info->clk_pll_audio);
+	clk->ops->release(clk, codec_info->clk_bus_audio);
+	clk->ops->assert_rst(clk, codec_info->clk_rst);
+	clk->ops->put_rst(clk, codec_info->clk_rst);
+
+	/* regulator about */
+	rglt->ops->disable(rglt, codec_info->avcc);
+	rglt->ops->release(rglt, codec_info->avcc);
+	rglt->ops->disable(rglt, codec_info->dvcc);
+	rglt->ops->release(rglt, codec_info->dvcc);
+
+	/* others about */
+
+	return ADAPT_SUCCESS;
+}
+
+/* for sunxi_internal_codec_probe() */
+int internal_codec_init(struct adapter_cntlr *cntlr,
+			struct sunxi_codec_info *codec_info)
+{
+	REG_HANDLE regmap = NULL;
+	struct reg_cntlr *reg = NULL;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	if (!cntlr) {
+		SND_LOG_ERR(HLOG, "adapter handle is NULL\n");
+		return ADAPT_FAILURE;
+
+	}
+	reg = cntlr->reg;
+	regmap = codec_info->regmap;
+
+	/* Disable DRC function for playback */
+	reg->ops->write(reg, regmap, SUNXI_DAC_DAP_CTL, 0);
+
+	/* set digital vol */
+	reg->ops->update_bits(reg, regmap, SUNXI_DAC_DPC,
+			      0x3f << DVOL,
+			      codec_info->digital_vol << DVOL);
+
+	/* set lineout vol */
+	reg->ops->update_bits(reg, regmap, AC_DAC_REG,
+			      0x1f << LINEOUT_VOL,
+			      codec_info->lineout_vol << LINEOUT_VOL);
+	reg->ops->update_bits(reg, regmap, AC_DAC_REG,
+			      0x1 << LMUTE, 0x1 << LMUTE);
+	reg->ops->update_bits(reg, regmap, AC_DAC_REG,
+			      0x1 << RMUTE, 0x1 << RMUTE);
+
+	/* enable rampen to avoid pop */
+	reg->ops->update_bits(reg, regmap, AC_RAMP_REG,
+			      0x7 << RAMP_STEP, 0x1 << RAMP_STEP);
+	reg->ops->update_bits(reg, regmap, AC_DAC_REG,
+			      0x1 << RSWITCH, 0x0 << RSWITCH);
+	reg->ops->update_bits(reg, regmap, AC_DAC_REG,
+			      0x1 << RAMPEN, 0x1 << RAMPEN);
+
+	return ADAPT_SUCCESS;
+}
+
+static int sunxi_codec_playback_event(struct snd_soc_dapm_widget *w,
+				      struct snd_kcontrol *k, int event)
+{
+	REG_HANDLE regmap = NULL;
+	struct reg_cntlr *reg = NULL;
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct sunxi_codec_info *codec_info = snd_soc_component_get_drvdata(component);
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	regmap = codec_info->regmap;
+	reg = codec_info->cntlr->reg;
+
+	switch (event) {
+	case SND_SOC_DAPM_POST_PMU:
+		reg->ops->update_bits(reg, regmap, SUNXI_DAC_DPC,
+				      0x1 << EN_DA, 0x1 << EN_DA);
+		break;
+
+	case SND_SOC_DAPM_POST_PMD:
+		reg->ops->update_bits(reg, regmap, SUNXI_DAC_DPC,
+				      0x1 << EN_DA, 0x0 << EN_DA);
+		break;
+
+	default:
+		break;
+	}
+	return 0;
+}
+
+static int sunxi_lineout_event(struct snd_soc_dapm_widget *w,
+			       struct snd_kcontrol *k, int event)
+{
+	REG_HANDLE regmap = NULL;
+	struct reg_cntlr *reg = NULL;
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct sunxi_codec_info *codec_info = snd_soc_component_get_drvdata(component);
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	regmap = codec_info->regmap;
+	reg = codec_info->cntlr->reg;
+
+	switch (event) {
+	case SND_SOC_DAPM_POST_PMU:
+		reg->ops->update_bits(reg, regmap, AC_DAC_REG,
+				      (0x1 << LINEOUTL_EN) | (0x1 << LINEOUTR_EN),
+				      (0x1 << LINEOUTL_EN) | (0x1 << LINEOUTR_EN));
+
+		reg->ops->update_bits(reg, regmap, AC_RAMP_REG,
+				      0x1 << RDEN, 0x1 << RDEN);
+
+		pa_pin_enable(codec_info->cntlr, codec_info->pa_cfg, codec_info->pa_pin_max);
+
+		break;
+
+	case SND_SOC_DAPM_PRE_PMD:
+		reg->ops->update_bits(reg, regmap, AC_RAMP_REG,
+				      0x1 << RDEN, 0x0 << RDEN);
+
+		reg->ops->update_bits(reg, regmap, AC_DAC_REG,
+				      (0x1 << LINEOUTL_EN) | (0x1 << LINEOUTR_EN),
+				      (0x0 << LINEOUTL_EN) | (0x0 << LINEOUTR_EN));
+
+		pa_pin_disable(codec_info->cntlr, codec_info->pa_cfg, codec_info->pa_pin_max);
+
+		break;
+
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static const DECLARE_TLV_DB_SCALE(digital_tlv, 0, -116, -7424);
+
+static const unsigned int lineout_tlv[] = {
+	TLV_DB_RANGE_HEAD(2),
+	0, 0, TLV_DB_SCALE_ITEM(0, 0, 1),
+	1, 31, TLV_DB_SCALE_ITEM(-4350, 150, 1),
+};
+
+const char * const left_lineoutl_text[] = {
+	"LOMixer", "LROMixer",
+};
+
+static const struct soc_enum left_lineout_enum =
+	SOC_ENUM_SINGLE(AC_DAC_REG, LINEOUTL_SEL,
+			ARRAY_SIZE(left_lineoutl_text), left_lineoutl_text);
+static const struct snd_kcontrol_new left_lineout_mux =
+	SOC_DAPM_ENUM("Left LINEOUT Mux", left_lineout_enum);
+
+const char * const right_lineoutr_text[] = {
+	"ROMixer", "LROMixer",
+};
+
+static const struct soc_enum right_lineout_enum =
+	SOC_ENUM_SINGLE(AC_DAC_REG, LINEOUTR_SEL,
+			ARRAY_SIZE(right_lineoutr_text), right_lineoutr_text);
+
+static const struct snd_kcontrol_new right_lineout_mux =
+	SOC_DAPM_ENUM("Right LINEOUT Mux", right_lineout_enum);
+
+struct snd_kcontrol_new sunxi_codec_controls[] = {
+	SOC_SINGLE("hub mode switch", SUNXI_DAC_DPC, DAC_HUB_EN, 0x1, 0),
+	SOC_SINGLE_TLV("digital volume", SUNXI_DAC_DPC, DVOL, 0x3F, 1, digital_tlv),
+	SOC_SINGLE_TLV("lineout volume", AC_DAC_REG, LINEOUT_VOL, 0x1F, 0, lineout_tlv),
+};
+
+static const struct snd_kcontrol_new left_output_mixer[] = {
+	SOC_DAPM_SINGLE("DACL Switch", AC_MIXER_REG, LMIX_LDAC, 1, 0),
+	SOC_DAPM_SINGLE("DACR Switch", AC_MIXER_REG, LMIX_RDAC, 1, 0),
+};
+
+static const struct snd_kcontrol_new right_output_mixer[] = {
+	SOC_DAPM_SINGLE("DACL Switch", AC_MIXER_REG, RMIX_LDAC, 1, 0),
+	SOC_DAPM_SINGLE("DACR Switch", AC_MIXER_REG, RMIX_RDAC, 1, 0),
+};
+
+static const struct snd_soc_dapm_widget sunxi_codec_dapm_widgets[] = {
+	SND_SOC_DAPM_AIF_IN_E("DACL", "Playback", 0, AC_DAC_REG, DACLEN, 0,
+			      sunxi_codec_playback_event,
+			      SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_AIF_IN_E("DACR", "Playback", 0, AC_DAC_REG, DACREN, 0,
+			      sunxi_codec_playback_event,
+			      SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
+
+	SND_SOC_DAPM_MIXER("Left Output Mixer", AC_MIXER_REG, LMIXEN, 0,
+			   left_output_mixer, ARRAY_SIZE(left_output_mixer)),
+	SND_SOC_DAPM_MIXER("Right Output Mixer", AC_MIXER_REG, RMIXEN, 0,
+			   right_output_mixer, ARRAY_SIZE(right_output_mixer)),
+
+	SND_SOC_DAPM_MUX("Left LINEOUT Mux", SND_SOC_NOPM,
+			 0, 0, &left_lineout_mux),
+	SND_SOC_DAPM_MUX("Right LINEOUT Mux", SND_SOC_NOPM,
+			 0, 0, &right_lineout_mux),
+
+	SND_SOC_DAPM_OUTPUT("LINEOUTL"),
+	SND_SOC_DAPM_OUTPUT("LINEOUTR"),
+
+	SND_SOC_DAPM_LINE("LINEOUT", sunxi_lineout_event),
+};
+
+static const struct snd_soc_dapm_route sunxi_codec_dapm_routes[] = {
+	{"Left Output Mixer", "DACR Switch", "DACR"},
+	{"Left Output Mixer", "DACL Switch", "DACL"},
+
+	{"Right Output Mixer", "DACL Switch", "DACL"},
+	{"Right Output Mixer", "DACR Switch", "DACR"},
+
+	{"Left LINEOUT Mux", "LOMixer", "Left Output Mixer"},
+	{"Left LINEOUT Mux", "LROMixer", "Right Output Mixer"},
+	{"Right LINEOUT Mux", "ROMixer", "Right Output Mixer"},
+	{"Right LINEOUT Mux", "LROMixer", "Left Output Mixer"},
+
+	{"LINEOUTL", NULL, "Left LINEOUT Mux"},
+	{"LINEOUTR", NULL, "Right LINEOUT Mux"},
+};
+
+/* for sunxi_internal_codec_probe() */
+int internal_codec_controls_add(struct snd_soc_component *component)
+{
+	int ret;
+	struct snd_soc_dapm_context *dapm = &component->dapm;
+
+	ret = snd_soc_add_component_controls(component, sunxi_codec_controls,
+					     ARRAY_SIZE(sunxi_codec_controls));
+	if (ret) {
+		SND_LOG_ERR(HLOG, "register codec kcontrols failed\n");
+		return ADAPT_FAILURE;
+	}
+
+	ret = snd_soc_dapm_new_controls(dapm, sunxi_codec_dapm_widgets,
+					ARRAY_SIZE(sunxi_codec_dapm_widgets));
+	if (ret) {
+		SND_LOG_ERR(HLOG, "register codec dapm_widgets failed\n");
+		return ADAPT_FAILURE;
+	}
+
+	ret = snd_soc_dapm_add_routes(dapm, sunxi_codec_dapm_routes,
+				      ARRAY_SIZE(sunxi_codec_dapm_routes));
+	if (ret) {
+		SND_LOG_ERR(HLOG, "register codec dapm_routes failed\n");
+		return ADAPT_FAILURE;
+	}
+
+	return ADAPT_SUCCESS;
+}
+
+/* for sunxi_internal_codec_suspend() */
+static struct reg_label reg_labels[] = {
+	REG_LABEL(SUNXI_DAC_DPC),
+	REG_LABEL(SUNXI_DAC_FIFO_CTL),
+	REG_LABEL(SUNXI_DAC_FIFO_STA),
+	REG_LABEL(SUNXI_DAC_CNT),
+	REG_LABEL(SUNXI_DAC_DG_REG),
+	REG_LABEL(AC_DAC_REG),
+	REG_LABEL(AC_MIXER_REG),
+	REG_LABEL(AC_RAMP_REG),
+	REG_LABEL_END,
+};
+
+int internal_codec_suspend(struct adapter_cntlr *cntlr,
+			   struct sunxi_codec_info *codec_info)
+{
+	struct reg_cntlr *reg = cntlr->reg;
+	struct regulator_cntlr *rglt = cntlr->regulator;
+	struct clk_cntlr *clk =cntlr->clk;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	save_audio_reg(reg, codec_info->regmap, reg_labels);
+
+	/* regulator about */
+	rglt->ops->disable(rglt, codec_info->avcc);
+	rglt->ops->disable(rglt, codec_info->dvcc);
+
+	/* clk about */
+	clk->ops->disable_unprepare(clk, codec_info->clk_audio);
+	clk->ops->disable_unprepare(clk, codec_info->clk_pll_audio);
+	clk->ops->disable_unprepare(clk, codec_info->clk_bus_audio);
+	clk->ops->assert_rst(clk, codec_info->clk_rst);
+
+	return ADAPT_SUCCESS;
+}
+
+/* for sunxi_internal_codec_resume() */
+int internal_codec_resume(struct adapter_cntlr *cntlr,
+			  struct sunxi_codec_info *codec_info)
+{
+	int ret;
+	struct reg_cntlr *reg = cntlr->reg;
+	struct regulator_cntlr *rglt = cntlr->regulator;
+	struct clk_cntlr *clk =cntlr->clk;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	/* regulator about */
+	rglt->ops->enable(rglt, codec_info->avcc);
+	rglt->ops->enable(rglt, codec_info->dvcc);
+
+	/* clk about */
+	ret = clk->ops->deassert_rst(clk, codec_info->clk_rst);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "deassert clk rst failed\n");
+		return ADAPT_FAILURE;
+	}
+	ret = clk->ops->set_rate(clk, codec_info->clk_pll_audio, 24576000);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "set rate clk pll audio failed\n");
+		return ADAPT_FAILURE;
+	}
+
+	ret = clk->ops->enable_prepare(clk, codec_info->clk_bus_audio);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "enable clk bus audio failed\n");
+		return ADAPT_FAILURE;
+	}
+
+	ret = clk->ops->enable_prepare(clk, codec_info->clk_pll_audio);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "enable clk pll audio failed\n");
+		return ADAPT_FAILURE;
+	}
+	ret = clk->ops->enable_prepare(clk, codec_info->clk_audio);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "enable clk audio failed\n");
+		return ADAPT_FAILURE;
+	}
+
+	internal_codec_init(cntlr, codec_info);
+	echo_audio_reg(reg, codec_info->regmap, reg_labels);
+
+	return ADAPT_SUCCESS;
+}
+
+/* for sunxi_internal_codec_dai_hw_params() */
+static const struct sample_rate sample_rate_conv[] = {
+	{44100, 0},
+	{48000, 0},
+	{8000, 5},
+	{32000, 1},
+	{22050, 2},
+	{24000, 2},
+	{16000, 3},
+	{11025, 4},
+	{12000, 4},
+	{192000, 6},
+	{96000, 7},
+	RATE_CONV_END,
+};
+
+int internal_codec_hw_params(struct adapter_cntlr *cntlr,
+			     struct sunxi_codec_info *codec_info,
+			     int stream, int format, unsigned int rate,
+			     unsigned int channels)
+
+{
+	int i;
+	REG_HANDLE regmap = codec_info->regmap;
+	struct reg_cntlr *reg = cntlr->reg;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	if (stream == PCM_STREAM_PLAYBACK)
+		goto playback;
+	else
+		goto capture;
+
+playback:
+	switch (format) {
+	case PCM_FORMAT_S16_LE:
+		reg->ops->update_bits(reg, regmap, SUNXI_DAC_FIFO_CTL,
+				      0x3 << DAC_FIFO_MODE, 0x3 << DAC_FIFO_MODE);
+		reg->ops->update_bits(reg, regmap, SUNXI_DAC_FIFO_CTL,
+				      0x1 << TX_SAMPLE_BITS, 0x0 << TX_SAMPLE_BITS);
+	break;
+	case PCM_FORMAT_S24_LE:
+		reg->ops->update_bits(reg, regmap, SUNXI_DAC_FIFO_CTL,
+				      0x3 << DAC_FIFO_MODE, 0x0 << DAC_FIFO_MODE);
+		reg->ops->update_bits(reg, regmap, SUNXI_DAC_FIFO_CTL,
+				      0x1 << TX_SAMPLE_BITS, 0x1 << TX_SAMPLE_BITS);
+	break;
+	default:
+		SND_LOG_ERR(HLOG, "unsupport format\n");
+		break;
+	}
+
+	i = 0;
+	while(sample_rate_conv[i].samplerate != 0) {
+		if (sample_rate_conv[i].samplerate == rate)
+			break;
+		i++;
+	}
+	reg->ops->update_bits(reg, regmap, SUNXI_DAC_FIFO_CTL,
+			      0x7 << DAC_FS,
+			      sample_rate_conv[i].rate_bit << DAC_FS);
+
+	switch (channels) {
+	case 1:
+		reg->ops->update_bits(reg, regmap, SUNXI_DAC_FIFO_CTL,
+				      0x1 << DAC_MONO_EN, 0x1 << DAC_MONO_EN);
+	break;
+	case 2:
+		reg->ops->update_bits(reg, regmap, SUNXI_DAC_FIFO_CTL,
+				      0x1 << DAC_MONO_EN, 0x0 << DAC_MONO_EN);
+	break;
+	default:
+		SND_LOG_ERR(HLOG, "unsupport channel\n");
+		return -EINVAL;
+	}
+
+	return ADAPT_SUCCESS;
+
+capture:
+	return ADAPT_SUCCESS;
+}
+
+/* for sunxi_internal_codec_dai_set_sysclk() */
+int internal_codec_set_sysclk(struct adapter_cntlr *cntlr,
+			      struct sunxi_codec_info *codec_info,
+			      unsigned int freq)
+
+{
+	int ret;
+	struct clk_cntlr *clk = cntlr->clk;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	ret = clk->ops->set_rate(clk, codec_info->clk_pll_audio, freq);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "set rate clk pll audio failed\n");
+		return ADAPT_FAILURE;
+	}
+	ret = clk->ops->set_rate(clk, codec_info->clk_audio, freq);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "set rate clk audio failed\n");
+		return ADAPT_FAILURE;
+	}
+
+	return ADAPT_SUCCESS;
+}
+
+/* for sunxi_internal_codec_dai_prepare() */
+int internal_codec_prepare(struct adapter_cntlr *cntlr,
+			   struct sunxi_codec_info *codec_info,
+			   int stream)
+
+{
+	REG_HANDLE regmap = codec_info->regmap;
+	struct reg_cntlr *reg = cntlr->reg;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	if (stream == PCM_STREAM_PLAYBACK)
+		goto playback;
+	else
+		goto capture;
+
+playback:
+	reg->ops->update_bits(reg, regmap, SUNXI_DAC_FIFO_CTL,
+			      0x1 << DAC_FIFO_FLUSH,
+			      0x1 << DAC_FIFO_FLUSH);
+	reg->ops->write(reg, regmap, SUNXI_DAC_FIFO_STA,
+			0x1 << DAC_TXE_INT | 1 << DAC_TXU_INT | 0x1 << DAC_TXO_INT);
+	reg->ops->write(reg, regmap, SUNXI_DAC_CNT, 0);
+
+	return ADAPT_SUCCESS;
+
+capture:
+	return ADAPT_SUCCESS;
+}
+
+/* for sunxi_internal_codec_dai_trigger() */
+int internal_codec_trigger(struct adapter_cntlr *cntlr,
+			   struct sunxi_codec_info *codec_info,
+			   int stream, int drq_en)
+{
+	REG_HANDLE regmap = codec_info->regmap;
+	struct reg_cntlr *reg = cntlr->reg;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	if (stream == PCM_STREAM_PLAYBACK)
+		goto playback;
+	else
+		goto capture;
+
+playback:
+	if (drq_en) {
+		reg->ops->update_bits(reg, regmap, SUNXI_DAC_FIFO_CTL,
+				      0x1 << DAC_DRQ_EN,
+				      0x1 << DAC_DRQ_EN);
+	} else {
+		reg->ops->update_bits(reg, regmap, SUNXI_DAC_FIFO_CTL,
+				      0x1 << DAC_DRQ_EN,
+				      0x0 << DAC_DRQ_EN);
+	}
+
+	return ADAPT_SUCCESS;
+
+capture:
+	return ADAPT_SUCCESS;
+}
diff --git a/sound/soc/sunxi_v2/snd_sun50iw9_codec.h b/sound/soc/sunxi_v2/snd_sun50iw9_codec.h
new file mode 100644
index 000000000..bc920bd6c
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sun50iw9_codec.h
@@ -0,0 +1,185 @@
+/* sound\soc\sunxi\snd_sun50iw9_codec.h
+ * (C) Copyright 2021-2025
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#ifndef __SND_SUN50IW9_CODEC_H
+#define __SND_SUN50IW9_CODEC_H
+
+#define SUNXI_DAC_DPC		0x00
+#define SUNXI_DAC_FIFO_CTL	0x10
+#define SUNXI_DAC_FIFO_STA	0x14
+
+/* left blank */
+#define SUNXI_DAC_TXDATA	0X20
+#define SUNXI_DAC_CNT		0x24
+#define SUNXI_DAC_DG_REG	0x28
+
+#define	SUNXI_ADC_FIFO_CTL	0x30
+#define SUNXI_ADC_FIFO_STA	0x34
+#define SUNXI_ADC_RXDATA	0x40
+#define SUNXI_ADC_CNT		0x44
+#define SUNXI_ADC_DG_REG	0x4C
+
+/*left blank */
+#define SUNXI_DAC_DAP_CTL	0xf0
+#define SUNXI_ADC_DAP_CTL	0xf8
+
+/* DAC */
+#define AC_DAC_REG		0x310
+#define AC_MIXER_REG		0x314
+#define AC_RAMP_REG		0x31c
+#define SUNXI_AUDIO_MAX_REG	AC_RAMP_REG
+
+/* SUNXI_DAC_DPC:0x00 */
+#define EN_DA			31
+#define MODQU			25
+#define DWA_EN			24
+#define HPF_EN			18
+#define DVOL			12
+#define DAC_HUB_EN		0
+
+/* SUNXI_DAC_FIFO_CTL:0x10 */
+#define DAC_FS			29
+#define FIR_VER			28
+#define SEND_LASAT		26
+#define DAC_FIFO_MODE		24
+#define DAC_DRQ_CLR_CNT		21
+#define TX_TRIG_LEVEL		8
+#define DAC_MONO_EN		6
+#define TX_SAMPLE_BITS		5
+#define DAC_DRQ_EN		4
+#define DAC_IRQ_EN		3
+#define DAC_FIFO_UNDERRUN_IRQ_EN	2
+#define DAC_FIFO_OVERRUN_IRQ_EN	1
+#define DAC_FIFO_FLUSH		0
+
+/* SUNXI_DAC_FIFO_STA:0x14 */
+#define	DAC_TX_EMPTY		23
+#define	DAC_TXE_CNT			8
+#define	DAC_TXE_INT			3
+#define	DAC_TXU_INT			2
+#define	DAC_TXO_INT			1
+
+/* SUNXI_DAC_DG_REG:0x28 */
+#define	DAC_MODU_SELECT		11
+#define	DAC_PATTERN_SEL		9
+#define	CODEC_CLK_SEL		8
+#define	DA_SWP			6
+#define	ADDA_LOOP_MODE		0
+
+/* SUNXI_ADC_FIFO_CTL:0x30 */
+#define ADC_FS			29
+#define EN_AD			28
+#define ADCFDT			26
+#define ADCDFEN			25
+#define RX_FIFO_MODE		24
+#define RX_SAMPLE_BITS		16
+#define ADCY_EN			15
+#define ADCX_EN			14
+#define ADCR_EN			13
+#define ADCL_EN			12
+#define ADC_CHAN_SEL		12
+#define RX_FIFO_TRG_LEVEL	4
+#define ADC_DRQ_EN		3
+#define ADC_IRQ_EN		2
+#define ADC_OVERRUN_IRQ_EN	1
+#define ADC_FIFO_FLUSH		0
+
+/* SUNXI_ADC_FIFO_STA:0x38 */
+#define	ADC_RXA			23
+#define	ADC_RXA_CNT		8
+#define	ADC_RXA_INT		3
+#define	ADC_RXO_INT		1
+
+/* SUNXI_ADC_DG_REG:0x4c */
+#define	ADXY_SWP		25
+#define	ADLR_SWP		24
+
+/* DAC */
+/* AC_DAC_REG */
+#define CURRENT_TEST_SEL	23
+#define IOPVRS			20
+#define ILINEOUTAMPS		18
+#define IOPDACS			16
+#define DACLEN			15
+#define DACREN			14
+#define LINEOUTL_EN		13
+#define LMUTE			12
+#define LINEOUTR_EN		11
+#define RMUTE			10
+#define RSWITCH			9
+#define RAMPEN			8
+#define LINEOUTL_SEL		6
+#define LINEOUTR_SEL		5
+#define LINEOUT_VOL		0
+
+/* AC_MIXER_REG	*/
+#define LMIX_LDAC		21
+#define LMIX_RDAC		20
+#define LMIXMUTE		20
+#define RMIX_RDAC		17
+#define RMIX_LDAC		16
+#define RMIXMUTE		16
+#define LMIXEN			11
+#define RMIXEN			10
+#define IOPMIXS			8
+
+/* AC_RAMP_REG */
+#define RAMP_STEP		4
+#define RMDEN			3
+#define RMUEN			2
+#define RMCEN			1
+#define RDEN			0
+
+struct sunxi_codec_info {
+	/* regulator about */
+	RGLT_HANDLE avcc;
+	RGLT_HANDLE dvcc;
+
+	/* clk about */
+	CLK_HANDLE clk_rst;
+	CLK_HANDLE clk_bus_audio;
+	CLK_HANDLE clk_pll_audio;
+	CLK_HANDLE clk_audio;
+
+	/* regmap about */
+	REG_HANDLE regmap;
+
+	/* gpio mute for peripheral circuit about */
+	u32 pa_pin_max;
+	struct pa_config *pa_cfg;
+
+	/* parse params about */
+	u32 digital_vol;
+	u32 lineout_vol;
+
+	/* others about */
+	struct adapter_cntlr *cntlr;
+};
+
+int internal_codec_probe(struct adapter_cntlr *cntlr, struct sunxi_codec_info *codec_info);
+int internal_codec_remove(struct adapter_cntlr *cntlr, struct sunxi_codec_info *codec_info);
+int internal_codec_init(struct adapter_cntlr *cntlr, struct sunxi_codec_info *codec_info);
+
+int internal_codec_controls_add(struct snd_soc_component *component);
+
+int internal_codec_suspend(struct adapter_cntlr *cntlr, struct sunxi_codec_info *codec_info);
+int internal_codec_resume(struct adapter_cntlr *cntlr, struct sunxi_codec_info *codec_info);
+
+int internal_codec_hw_params(struct adapter_cntlr *cntlr, struct sunxi_codec_info *codec_info,
+			     int stream, int format, unsigned int  rate, unsigned int channels);
+int internal_codec_set_sysclk(struct adapter_cntlr *cntlr, struct sunxi_codec_info *codec_info,
+			      unsigned int freq);
+int internal_codec_prepare(struct adapter_cntlr *cntlr, struct sunxi_codec_info *codec_info,
+			   int stream);
+int internal_codec_trigger(struct adapter_cntlr *cntlr, struct sunxi_codec_info *codec_info,
+			   int stream, int drq_en);
+
+#endif /* __SND_SUN50IW9_CODEC_H */
diff --git a/sound/soc/sunxi_v2/snd_sunxi_aaudio.c b/sound/soc/sunxi_v2/snd_sunxi_aaudio.c
new file mode 100644
index 000000000..b5eb6da71
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_aaudio.c
@@ -0,0 +1,236 @@
+/*
+ * sound\soc\sunxi\snd_sunxi_aaudio.c
+ * (C) Copyright 2021-2025
+ * AllWinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <sound/soc.h>
+
+#include "snd_sunxi_log.h"
+#include "snd_sunxi_pcm.h"
+
+#define HLOG		"CPUDAI"
+#define DRV_NAME	"sunxi-snd-plat-aaudio"
+
+struct sunxi_cpudai_info {
+	struct sunxi_dma_params playback_dma_param;
+	struct sunxi_dma_params capture_dma_param;
+};
+
+static int sunxi_aaudio_dai_startup(struct snd_pcm_substream *substream,
+					struct snd_soc_dai *dai)
+{
+	struct sunxi_cpudai_info *sunxi_cpudai = snd_soc_dai_get_drvdata(dai);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		snd_soc_dai_set_dma_data(dai, substream,
+					 &sunxi_cpudai->playback_dma_param);
+	else
+		snd_soc_dai_set_dma_data(dai, substream,
+					 &sunxi_cpudai->capture_dma_param);
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops sunxi_aaudio_dai_ops = {
+	.startup	= sunxi_aaudio_dai_startup,
+};
+
+static struct snd_soc_dai_driver sunxi_aaudio_dai[] = {
+	{
+		.playback = {
+			.stream_name	= "Playback",
+			.channels_min	= 1,
+			.channels_max	= 2,
+			.rates		= SNDRV_PCM_RATE_8000_192000
+					| SNDRV_PCM_RATE_KNOT,
+			.formats	= SNDRV_PCM_FMTBIT_S16_LE
+					| SNDRV_PCM_FMTBIT_S24_LE
+					| SNDRV_PCM_FMTBIT_S32_LE,
+		},
+		.capture = {
+			.stream_name	= "Capture",
+			.channels_min	= 1,
+			.channels_max	= 3,
+			.rates		= SNDRV_PCM_RATE_8000_192000
+					| SNDRV_PCM_RATE_KNOT,
+			.formats	= SNDRV_PCM_FMTBIT_S16_LE
+					| SNDRV_PCM_FMTBIT_S24_LE
+					| SNDRV_PCM_FMTBIT_S32_LE,
+		},
+		.ops = &sunxi_aaudio_dai_ops,
+	},
+};
+
+static struct snd_soc_component_driver sunxi_aaudio_dev = {
+	.name		= DRV_NAME,
+};
+
+static int sunxi_aaudio_parse_dma_param(struct device_node *np,
+					struct sunxi_cpudai_info *sunxi_cpudai)
+{
+	int ret;
+	unsigned int temp_val;
+
+	/* set dma max buffer */
+	ret = of_property_read_u32(np, "playback_cma", &temp_val);
+	if (ret < 0) {
+		sunxi_cpudai->playback_dma_param.cma_kbytes = SUNXI_AUDIO_CMA_MAX_KBYTES;
+		SND_LOG_WARN(HLOG, "playback_cma missing, using default value\n");
+	} else {
+		if (temp_val		> SUNXI_AUDIO_CMA_MAX_KBYTES)
+			temp_val	= SUNXI_AUDIO_CMA_MAX_KBYTES;
+		else if (temp_val	< SUNXI_AUDIO_CMA_MIN_KBYTES)
+			temp_val	= SUNXI_AUDIO_CMA_MIN_KBYTES;
+
+		sunxi_cpudai->playback_dma_param.cma_kbytes = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "capture_cma", &temp_val);
+	if (ret != 0) {
+		sunxi_cpudai->capture_dma_param.cma_kbytes = SUNXI_AUDIO_CMA_MAX_KBYTES;
+		SND_LOG_WARN(HLOG, "capture_cma missing, using default value\n");
+	} else {
+		if (temp_val		> SUNXI_AUDIO_CMA_MAX_KBYTES)
+			temp_val	= SUNXI_AUDIO_CMA_MAX_KBYTES;
+		else if (temp_val	< SUNXI_AUDIO_CMA_MIN_KBYTES)
+			temp_val	= SUNXI_AUDIO_CMA_MIN_KBYTES;
+
+		sunxi_cpudai->capture_dma_param.cma_kbytes = temp_val;
+	}
+
+	/* set fifo size */
+	ret = of_property_read_u32(np, "tx_fifo_size", &temp_val);
+	if (ret != 0) {
+		sunxi_cpudai->playback_dma_param.fifo_size = SUNXI_AUDIO_FIFO_SIZE;
+		SND_LOG_WARN(HLOG, "tx_fifo_size miss, using default value\n");
+	} else {
+		sunxi_cpudai->playback_dma_param.fifo_size = temp_val;
+	}
+
+	ret = of_property_read_u32(np, "rx_fifo_size", &temp_val);
+	if (ret != 0) {
+		sunxi_cpudai->capture_dma_param.fifo_size = SUNXI_AUDIO_FIFO_SIZE;
+		SND_LOG_WARN(HLOG, "rx_fifo_size miss,using default value\n");
+	} else {
+		sunxi_cpudai->capture_dma_param.fifo_size = temp_val;
+	}
+
+	/* set data register */
+	ret = of_property_read_u32(np, "dac_txdata", &temp_val);
+	if (ret != 0) {
+		SND_LOG_ERR(HLOG, "dac_txdata miss, no aaudio platform\n");
+		return -1;
+	} else
+		sunxi_cpudai->playback_dma_param.dma_addr = temp_val; /* SUNXI_DAC_TXDATA */
+	sunxi_cpudai->playback_dma_param.dst_maxburst = 4;
+	sunxi_cpudai->playback_dma_param.src_maxburst = 4;
+
+	ret = of_property_read_u32(np, "adc_txdata", &temp_val);
+	if (ret != 0) {
+		SND_LOG_ERR(HLOG, "adc_txdata miss, no aaudio platform\n");
+		return -1;
+	} else
+		sunxi_cpudai->capture_dma_param.dma_addr = temp_val; /* SUNXI_ADC_RXDATA */
+	sunxi_cpudai->capture_dma_param.src_maxburst = 4;
+	sunxi_cpudai->capture_dma_param.dst_maxburst = 4;
+
+	SND_LOG_INFO(HLOG, "playback_cma : %u\n", sunxi_cpudai->playback_dma_param.cma_kbytes);
+	SND_LOG_INFO(HLOG, "capture_cma  : %u\n", sunxi_cpudai->capture_dma_param.cma_kbytes);
+	SND_LOG_INFO(HLOG, "tx_fifo_size : %u\n", sunxi_cpudai->playback_dma_param.fifo_size);
+	SND_LOG_INFO(HLOG, "rx_fifo_size : %u\n", sunxi_cpudai->capture_dma_param.fifo_size);
+	SND_LOG_INFO(HLOG, "dac_txdata   : 0x%llx\n", sunxi_cpudai->playback_dma_param.dma_addr);
+	SND_LOG_INFO(HLOG, "adc_txdata   : 0x%llx\n", sunxi_cpudai->capture_dma_param.dma_addr);
+
+	return 0;
+}
+
+static int sunxi_aaudio_dev_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct device_node *np = pdev->dev.of_node;
+	struct sunxi_cpudai_info *sunxi_cpudai;
+
+	sunxi_cpudai = devm_kzalloc(&pdev->dev,
+				    sizeof(struct sunxi_cpudai_info),
+				    GFP_KERNEL);
+	if (!sunxi_cpudai) {
+		ret = -ENOMEM;
+		SND_LOG_ERR(HLOG, "devm_kzalloc failed\n");
+		goto err_node_put;
+	}
+	dev_set_drvdata(&pdev->dev, sunxi_cpudai);
+
+	ret = sunxi_aaudio_parse_dma_param(np, sunxi_cpudai);
+	if (ret < 0) {
+		SND_LOG_ERR(HLOG, "parse dma param failed\n");
+		goto err_devm_kfree;
+	}
+
+	ret = snd_soc_register_component(&pdev->dev,
+					 &sunxi_aaudio_dev,
+					 sunxi_aaudio_dai,
+					 ARRAY_SIZE(sunxi_aaudio_dai));
+	if (ret) {
+		SND_LOG_ERR(HLOG, "component register failed\n");
+		ret = -ENOMEM;
+		goto err_devm_kfree;
+	}
+
+	ret = snd_soc_sunxi_dma_platform_register(&pdev->dev);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "register ASoC platform failed\n");
+		ret = -ENOMEM;
+		goto err_unregister_component;
+	}
+
+	SND_LOG_INFO(HLOG, "register aaudio platform success\n");
+
+	return 0;
+
+err_unregister_component:
+	snd_soc_unregister_component(&pdev->dev);
+err_devm_kfree:
+	devm_kfree(&pdev->dev, sunxi_cpudai);
+err_node_put:
+	of_node_put(np);
+	return ret;
+}
+
+static int sunxi_aaudio_dev_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_component(&pdev->dev);
+
+	SND_LOG_INFO(HLOG, "unregister aaudio platform success\n");
+
+	return 0;
+}
+
+static const struct of_device_id sunxi_aaudio_of_match[] = {
+	{ .compatible = "allwinner," DRV_NAME, },
+	{},
+};
+MODULE_DEVICE_TABLE(of, sunxi_aaudio_of_match);
+
+static struct platform_driver sunxi_aaudio_driver = {
+	.driver	= {
+		.name		= DRV_NAME,
+		.owner		= THIS_MODULE,
+		.of_match_table	= sunxi_aaudio_of_match,
+	},
+	.probe	= sunxi_aaudio_dev_probe,
+	.remove	= sunxi_aaudio_dev_remove,
+};
+
+module_platform_driver(sunxi_aaudio_driver);
+
+MODULE_AUTHOR("Dby@allwinnertech.com");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("sunxi soundcard platform of aaudio");
diff --git a/sound/soc/sunxi_v2/snd_sunxi_adapter.c b/sound/soc/sunxi_v2/snd_sunxi_adapter.c
new file mode 100644
index 000000000..1df77a5b6
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_adapter.c
@@ -0,0 +1,603 @@
+/*
+ * sound\soc\sunxi\snd_sunxi_adapter.c
+ * (C) Copyright 2021-2025
+ * AllWinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/regulator/consumer.h>
+#include <linux/of.h>
+#include <linux/clk.h>
+#include <linux/reset.h>
+#include <linux/device.h>
+#include <linux/ioport.h>
+#include <linux/regmap.h>
+#include <linux/of_address.h>
+#include <linux/of_gpio.h>
+
+#include "snd_sunxi_log.h"
+#include "snd_sunxi_adapter.h"
+
+#define HLOG		"ADAPTER"
+
+/* regulator adapter */
+static RGLT_HANDLE ada_regulator_request(struct regulator_cntlr *cntlr,
+					 const char *id)
+{
+	RGLT_HANDLE handle = NULL;
+
+	handle = regulator_get(cntlr->dev, id);
+	if (IS_ERR_OR_NULL(handle)) {
+		SND_LOG_ERR(HLOG, "regulator get failed\n");
+		return NULL;
+	}
+
+	return handle;
+}
+
+static void ada_regulator_release(struct regulator_cntlr *cntlr,
+				  RGLT_HANDLE handle)
+{
+	if (IS_ERR_OR_NULL(handle)) {
+		SND_LOG_ERR(HLOG, "regulator handle is err\n");
+		return;
+	}
+	regulator_put((struct regulator *)handle);
+}
+
+static int ada_regulator_set_voltage(struct regulator_cntlr *cntlr,
+				     RGLT_HANDLE handle,
+				     int min_uv, int max_uv)
+{
+	int ret;
+
+	if (IS_ERR_OR_NULL(handle)) {
+		SND_LOG_ERR(HLOG, "regulator handle is err\n");
+		return ADAPT_FAILURE;
+	}
+
+	ret = regulator_set_voltage((struct regulator *)handle, min_uv, max_uv);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "regulator set voltage failed\n");
+		return ADAPT_FAILURE;
+	}
+
+	return ADAPT_SUCCESS;
+}
+
+static int ada_regulator_enable(struct regulator_cntlr *cntlr,
+				RGLT_HANDLE handle)
+{
+	int ret;
+
+	if (IS_ERR_OR_NULL(handle)) {
+		SND_LOG_ERR(HLOG, "regulator handle is err\n");
+		return ADAPT_FAILURE;
+	}
+
+	ret = regulator_enable((struct regulator *)handle);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "regulator enable failed\n");
+		return ADAPT_FAILURE;
+	}
+
+	return ADAPT_SUCCESS;
+}
+
+static void ada_regulator_disable(struct regulator_cntlr *cntlr,
+				  RGLT_HANDLE handle)
+{
+	if (IS_ERR_OR_NULL(handle)) {
+		SND_LOG_ERR(HLOG, "regulator handle is err\n");
+		return;
+	}
+
+	regulator_disable((struct regulator *)handle);
+}
+
+static struct regulator_method g_rglt_method = {
+	.request	= ada_regulator_request,
+	.release	= ada_regulator_release,
+	.set_voltage	= ada_regulator_set_voltage,
+	.enable		= ada_regulator_enable,
+	.disable	= ada_regulator_disable,
+};
+
+int regulator_adapter_probe(struct regulator_cntlr **cntlr, struct device *dev)
+{
+	struct regulator_cntlr *rglt = NULL;
+
+	rglt = kzalloc(sizeof(struct regulator_cntlr), GFP_KERNEL);
+	if (!rglt) {
+		SND_LOG_ERR(HLOG, "regulator kmalloc faild\n");
+		goto err;
+	}
+
+	rglt->dev = dev;
+	rglt->ops = &g_rglt_method;
+	*cntlr = rglt;
+
+	return ADAPT_SUCCESS;
+err:
+	if (rglt)
+		kfree(rglt);
+
+	return ADAPT_FAILURE;
+}
+
+void regulator_adapter_remove(struct regulator_cntlr **cntlr)
+{
+	if (*cntlr) {
+		(*cntlr)->ops = NULL;
+		kfree(*cntlr);
+	}
+}
+
+/* clk adapter */
+static CLK_HANDLE ada_clk_get_rst(struct clk_cntlr *cntlr, const char *name)
+{
+	CLK_HANDLE handle = NULL;
+
+	handle = of_reset_control_get(cntlr->np, name);
+	if (IS_ERR_OR_NULL(handle)) {
+		SND_LOG_ERR(HLOG, "clk rst get failed\n");
+		return NULL;
+	}
+
+	return handle;
+}
+
+static void ada_clk_put_rst(struct clk_cntlr *cntlr, CLK_HANDLE handle)
+{
+	if (IS_ERR_OR_NULL(handle)) {
+		SND_LOG_ERR(HLOG, "clk rst handle is err\n");
+		return;
+	}
+	reset_control_put((struct reset_control *)handle);
+}
+
+static int ada_clk_deassert_rst(struct clk_cntlr *cntlr, CLK_HANDLE handle)
+{
+	if (IS_ERR_OR_NULL(handle)) {
+		SND_LOG_ERR(HLOG, "clk handle is err\n");
+		return ADAPT_FAILURE;
+	}
+
+	if (reset_control_deassert((struct reset_control *)handle)) {
+		SND_LOG_ERR(HLOG, "deassert the reset clk failed\n");
+		return ADAPT_FAILURE;
+	}
+
+	return ADAPT_SUCCESS;
+}
+
+static int ada_clk_assert_rst(struct clk_cntlr *cntlr, CLK_HANDLE handle)
+{
+	if (IS_ERR_OR_NULL(handle)) {
+		SND_LOG_ERR(HLOG, "clk handle is err\n");
+		return ADAPT_FAILURE;
+	}
+
+	if (reset_control_assert((struct reset_control *)handle)) {
+		SND_LOG_ERR(HLOG, "assert the reset clk failed\n");
+		return ADAPT_FAILURE;
+	}
+
+	return ADAPT_SUCCESS;
+}
+
+static CLK_HANDLE ada_clk_request(struct clk_cntlr *cntlr, const char *name)
+{
+	CLK_HANDLE handle = NULL;
+
+	handle = of_clk_get_by_name(cntlr->np, name);
+	if (IS_ERR_OR_NULL(handle)) {
+		SND_LOG_ERR(HLOG, "clk get failed\n");
+		return NULL;
+	}
+
+	return handle;
+}
+
+static void ada_clk_release(struct clk_cntlr *cntlr, CLK_HANDLE handle)
+{
+	if (IS_ERR_OR_NULL(handle)) {
+		SND_LOG_ERR(HLOG, "clk handle is err\n");
+		return;
+	}
+	clk_put((struct clk *)handle);
+}
+
+static int ada_clk_set_parent(struct clk_cntlr *cntlr,
+			      CLK_HANDLE handle1, CLK_HANDLE handle2)
+{
+	if (IS_ERR_OR_NULL(handle1) || IS_ERR_OR_NULL(handle2)) {
+		SND_LOG_ERR(HLOG, "clk handle is err\n");
+		return ADAPT_FAILURE;
+	}
+
+	if (clk_set_parent((struct clk *)handle1, (struct clk *)handle2)) {
+		SND_LOG_ERR(HLOG, "clk set parent failed\n");
+		return ADAPT_FAILURE;
+	}
+
+	return ADAPT_SUCCESS;
+}
+
+static int ada_clk_set_rate(struct clk_cntlr *cntlr, CLK_HANDLE handle,
+			    unsigned long rate)
+{
+	if (IS_ERR_OR_NULL(handle)) {
+		SND_LOG_ERR(HLOG, "clk handle is err\n");
+		return ADAPT_FAILURE;
+	}
+
+	if (clk_set_rate((struct clk *)handle, rate)) {
+		SND_LOG_ERR(HLOG, "clk set rate failed\n");
+		return ADAPT_FAILURE;
+	}
+
+	return ADAPT_SUCCESS;
+}
+
+static int ada_clk_enable_prepare(struct clk_cntlr *cntlr, CLK_HANDLE handle)
+{
+	if (IS_ERR_OR_NULL(handle)) {
+		SND_LOG_ERR(HLOG, "clk handle is err\n");
+		return ADAPT_FAILURE;
+	}
+
+	if (clk_prepare_enable((struct clk *)handle)) {
+		SND_LOG_ERR(HLOG, "clk prepare enable failed\n");
+		return ADAPT_FAILURE;
+	}
+
+	return ADAPT_SUCCESS;
+}
+
+static void ada_clk_disable_unprepare(struct clk_cntlr *cntlr,
+				      CLK_HANDLE handle)
+{
+	if (IS_ERR_OR_NULL(handle)) {
+		SND_LOG_ERR(HLOG, "clk handle is err\n");
+		return;
+	}
+
+	clk_disable_unprepare((struct clk *)handle);
+}
+
+static struct clk_method g_clk_method = {
+	.get_rst		= ada_clk_get_rst,
+	.put_rst		= ada_clk_put_rst,
+	.deassert_rst		= ada_clk_deassert_rst,
+	.assert_rst		= ada_clk_assert_rst,
+
+	.request		= ada_clk_request,
+	.release		= ada_clk_release,
+	.set_parent		= ada_clk_set_parent,
+	.set_rate		= ada_clk_set_rate,
+	.enable_prepare		= ada_clk_enable_prepare,
+	.disable_unprepare	= ada_clk_disable_unprepare,
+};
+
+int clk_adapter_probe(struct clk_cntlr **cntlr, struct device_node *np)
+{
+	struct clk_cntlr *clk = NULL;
+
+	clk = kzalloc(sizeof(struct clk_cntlr), GFP_KERNEL);
+	if (!clk) {
+		SND_LOG_ERR(HLOG, "clk kmalloc faild\n");
+		goto err;
+	}
+
+	clk->np = np;
+	clk->ops = &g_clk_method;
+	*cntlr = clk;
+
+	return ADAPT_SUCCESS;
+
+err:
+	if (clk)
+		kfree(clk);
+
+	return ADAPT_FAILURE;
+}
+
+void clk_adapter_remove(struct clk_cntlr **cntlr)
+{
+	if (*cntlr) {
+		(*cntlr)->ops = NULL;
+		kfree(*cntlr);
+	}
+
+	return;
+}
+
+/* regmap adapter */
+static REG_HANDLE ada_regmap_request(struct reg_cntlr *cntlr,
+				     unsigned int max_reg)
+{
+	int ret;
+	REG_HANDLE handle = NULL;
+
+	struct resource res;
+	struct resource *memregion = NULL;
+	void __iomem *digital_base = NULL;
+	struct regmap_config sunxi_regmap_config = {
+		.reg_bits = 32,
+		.reg_stride = 4,
+		.val_bits = 32,
+		.max_register = max_reg,
+		.cache_type = REGCACHE_NONE,
+	};
+
+	ret = of_address_to_resource(cntlr->dev->of_node, 0, &res);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "get resource failed\n");
+		return NULL;
+	}
+
+	memregion = devm_request_mem_region(cntlr->dev, res.start,
+					    resource_size(&res),
+					    cntlr->name);
+	if (!memregion) {
+		SND_LOG_ERR(HLOG, "memory region already claimed\n");
+		return NULL;
+	}
+
+	digital_base = devm_ioremap(cntlr->dev, res.start, resource_size(&res));
+	if (!digital_base) {
+		SND_LOG_ERR(HLOG, "digital_base ioremap failed\n");
+		return NULL;
+	}
+
+	handle = devm_regmap_init_mmio(cntlr->dev, digital_base,
+				       &sunxi_regmap_config);
+	if (IS_ERR_OR_NULL(handle)) {
+		SND_LOG_ERR(HLOG, "regmap init failed\n");
+		return NULL;
+	}
+
+	return handle;
+}
+
+static void ada_regmap_release(struct reg_cntlr *cntlr, REG_HANDLE handle)
+{
+	return;
+}
+
+static int ada_regmap_write(struct reg_cntlr *cntlr, REG_HANDLE handle,
+			    unsigned int reg, unsigned int val)
+{
+	regmap_write((struct regmap *)handle, reg, val);
+
+	return ADAPT_SUCCESS;
+}
+
+static int ada_regmap_read(struct reg_cntlr *cntlr, REG_HANDLE handle,
+			   unsigned int reg, unsigned int *val)
+{
+	regmap_read((struct regmap *)handle, reg, val);
+
+	return ADAPT_SUCCESS;
+}
+
+static int ada_regmap_update_bits(struct reg_cntlr *cntlr, REG_HANDLE handle,
+				  unsigned int reg, unsigned int mask,
+				  unsigned int val)
+{
+	regmap_update_bits((struct regmap *)handle, reg, mask, val);
+
+	return ADAPT_SUCCESS;
+}
+
+static struct reg_method g_regmap_method = {
+	.request		= ada_regmap_request,
+	.release		= ada_regmap_release,
+	.write			= ada_regmap_write,
+	.read			= ada_regmap_read,
+	.update_bits		= ada_regmap_update_bits,
+};
+
+int reg_adapter_probe(struct reg_cntlr **cntlr, struct device *dev)
+{
+	struct reg_cntlr *regmap = NULL;
+
+	regmap = kzalloc(sizeof(struct reg_cntlr), GFP_KERNEL);
+	if (!regmap) {
+		SND_LOG_ERR(HLOG, "regmap kmalloc faild\n");
+		goto err;
+	}
+
+	regmap->dev = dev;
+	regmap->ops = &g_regmap_method;
+	*cntlr = regmap;
+
+	return ADAPT_SUCCESS;
+
+err:
+	if (regmap)
+		kfree(regmap);
+
+	return ADAPT_FAILURE;
+}
+
+void reg_adapter_remove(struct reg_cntlr **cntlr)
+{
+	if (*cntlr) {
+		(*cntlr)->ops = NULL;
+		kfree(*cntlr);
+	}
+
+	return;
+}
+
+/* parse params adapter */
+static int ada_parse_read_u32(struct parse_cntlr *cntlr, char *name, u32 *value)
+{
+	int ret;
+
+	ret = of_property_read_u32(cntlr->np, name, value);
+	if (ret < 0) {
+		SND_LOG_ERR(HLOG, "params read faild\n");
+		return ADAPT_FAILURE;
+	}
+
+	return ADAPT_SUCCESS;
+}
+
+static struct parse_method g_parse_method = {
+	.read_u32		= ada_parse_read_u32,
+};
+
+int parse_adapter_probe(struct parse_cntlr **cntlr, struct device_node *np)
+{
+	struct parse_cntlr *parse = NULL;
+
+	parse = kzalloc(sizeof(struct parse_cntlr), GFP_KERNEL);
+	if (!parse) {
+		SND_LOG_ERR(HLOG, "parse kmalloc faild\n");
+		goto err;
+	}
+
+	parse->np = np;
+	parse->ops = &g_parse_method;
+	*cntlr = parse;
+
+	return ADAPT_SUCCESS;
+
+err:
+	if (parse)
+		kfree(parse);
+
+	return ADAPT_FAILURE;
+}
+
+void parse_adapter_remove(struct parse_cntlr **cntlr)
+{
+	if (*cntlr) {
+		(*cntlr)->ops = NULL;
+		kfree(*cntlr);
+	}
+
+	return;
+}
+
+/* gpio adapter */
+static int ada_gpio_request(struct gpio_cntlr *cntlr, char *name, u32 *gpio)
+{
+	int ret;
+	u32 gpio_tmp;
+
+	if (!name) {
+		SND_LOG_ERR(HLOG, "gpio name is NULL\n");
+		return ADAPT_FAILURE;
+	}
+
+	ret = of_get_named_gpio(cntlr->dev->of_node, name, 0);
+	if (ret < 0) {
+		SND_LOG_ERR(HLOG, "gpio get failed\n");
+		return ADAPT_FAILURE;
+	}
+
+	gpio_tmp = ret;
+	if (!gpio_is_valid(gpio_tmp)) {
+		SND_LOG_ERR(HLOG, "gpio %u is invalid\n", gpio_tmp);
+		return ADAPT_FAILURE;
+	}
+
+	ret = devm_gpio_request(cntlr->dev, gpio_tmp, name);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "gpio %u request failed\n", gpio_tmp);
+		return ADAPT_FAILURE;
+	}
+
+	*gpio = gpio_tmp;
+
+	return ADAPT_SUCCESS;
+}
+
+static void ada_gpio_release(struct gpio_cntlr *cntlr, u32 gpio)
+{
+	return;
+}
+
+static int ada_gpio_setdir(struct gpio_cntlr *cntlr, u32 gpio, int value)
+{
+	if (value > 0)
+		gpio_direction_output(gpio, 1);
+	else
+		gpio_direction_input(gpio);
+
+	return ADAPT_SUCCESS;
+}
+
+static int ada_gpio_write(struct gpio_cntlr *cntlr, u32 gpio, int value)
+{
+	gpio_set_value(gpio, value);
+
+	return ADAPT_SUCCESS;
+}
+
+static int ada_gpio_read(struct gpio_cntlr *cntlr, u32 gpio, int *value)
+{
+	*value = gpio_get_value(gpio);
+
+	return ADAPT_SUCCESS;
+}
+
+static struct gpio_method g_gpio_method = {
+	.request		= ada_gpio_request,
+	.release		= ada_gpio_release,
+	.setdir			= ada_gpio_setdir,
+	.write			= ada_gpio_write,
+	.read			= ada_gpio_read,
+};
+
+int gpio_adapter_probe(struct gpio_cntlr **cntlr, struct device *dev)
+{
+	struct gpio_cntlr *gpio = NULL;
+
+	gpio = kzalloc(sizeof(struct gpio_cntlr), GFP_KERNEL);
+	if (!gpio) {
+		SND_LOG_ERR(HLOG, "gpio kmalloc faild\n");
+		goto err;
+	}
+
+	gpio->dev = dev;
+	gpio->ops = &g_gpio_method;
+	*cntlr = gpio;
+
+	return ADAPT_SUCCESS;
+
+err:
+	if (gpio)
+		kfree(gpio);
+
+	return ADAPT_FAILURE;
+}
+
+void gpio_adapter_remove(struct gpio_cntlr **cntlr)
+{
+	if (*cntlr) {
+		(*cntlr)->ops = NULL;
+		kfree(*cntlr);
+	}
+
+	return;
+}
+
+/* ALSA api adapter */
+
+/* others adapter */
+
+MODULE_AUTHOR("Dby@allwinnertech.com");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("sunxi soundcard platform of ahub");
diff --git a/sound/soc/sunxi_v2/snd_sunxi_adapter.h b/sound/soc/sunxi_v2/snd_sunxi_adapter.h
new file mode 100644
index 000000000..4de58f4ef
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_adapter.h
@@ -0,0 +1,163 @@
+/* sound\soc\sunxi\snd_sunxi_adapter.h
+ * (C) Copyright 2021-2025
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#ifndef __SND_SUNXI_ADAPTER_H
+#define __SND_SUNXI_ADAPTER_H
+
+typedef unsigned int	u32;
+
+typedef enum {
+	ADAPT_SUCCESS	= 0,
+	ADAPT_FAILURE	= -1,
+} ADAPT_STA;
+
+/* linux platform api adapter */
+struct regulator_method;
+struct regulator_cntlr;
+
+struct clk_method;
+struct clk_cntlr;
+
+struct parse_method;
+struct parse_cntlr;
+
+struct reg_method;
+struct reg_cntlr;
+
+struct gpio_method;
+struct gpio_cntlr;
+
+struct adapter_cntlr {
+	struct regulator_cntlr *regulator;
+	struct clk_cntlr *clk;
+	struct parse_cntlr *parse;
+	struct reg_cntlr *reg;
+	struct gpio_cntlr *gpio;
+};
+
+/* regulator adapter */
+typedef void* RGLT_HANDLE;
+
+struct regulator_cntlr {
+	struct device *dev;
+	struct regulator_method *ops;
+};
+
+struct regulator_method {
+	RGLT_HANDLE (*request)(struct regulator_cntlr*, const char*);
+	void (*release)(struct regulator_cntlr*, RGLT_HANDLE);
+	int (*set_voltage)(struct regulator_cntlr*, RGLT_HANDLE, int, int);
+	int (*enable)(struct regulator_cntlr*, RGLT_HANDLE);
+	void (*disable)(struct regulator_cntlr*, RGLT_HANDLE);
+};
+
+int regulator_adapter_probe(struct regulator_cntlr **cntlr, struct device *dev);
+void regulator_adapter_remove(struct regulator_cntlr **cntlr);
+
+/* clk adapter */
+typedef void* CLK_HANDLE;
+
+struct clk_cntlr {
+	struct device_node *np;
+	struct clk_method *ops;
+};
+
+struct clk_method {
+	CLK_HANDLE (*get_rst)(struct clk_cntlr*, const char*);
+	void (*put_rst)(struct clk_cntlr*, CLK_HANDLE);
+	int (*deassert_rst)(struct clk_cntlr*, CLK_HANDLE);
+	int (*assert_rst)(struct clk_cntlr*, CLK_HANDLE);
+
+	CLK_HANDLE (*request)(struct clk_cntlr*, const char*);
+	void (*release)(struct clk_cntlr*, CLK_HANDLE);
+	int (*set_parent)(struct clk_cntlr*, CLK_HANDLE, CLK_HANDLE);
+	int (*set_rate)(struct clk_cntlr*, CLK_HANDLE, unsigned long);
+	int (*enable_prepare)(struct clk_cntlr*, CLK_HANDLE);
+	void (*disable_unprepare)(struct clk_cntlr*, CLK_HANDLE);
+};
+
+int clk_adapter_probe(struct clk_cntlr **cntlr, struct device_node *np);
+void clk_adapter_remove(struct clk_cntlr **cntlr);
+
+/* regmap adapter */
+typedef void* REG_HANDLE;
+
+struct reg_cntlr {
+	struct device *dev;
+	const char *name;
+	struct reg_method *ops;
+};
+
+struct reg_method {
+	REG_HANDLE (*request)(struct reg_cntlr*, unsigned int);
+	void (*release)(struct reg_cntlr*, REG_HANDLE);
+	int (*write)(struct reg_cntlr*, REG_HANDLE, unsigned int, unsigned int);
+	int (*read)(struct reg_cntlr*, REG_HANDLE, unsigned int, unsigned int*);
+	int (*update_bits)(struct reg_cntlr*, REG_HANDLE, unsigned int,
+			   unsigned int, unsigned int);
+};
+
+int reg_adapter_probe(struct reg_cntlr **cntlr, struct device *dev);
+void reg_adapter_remove(struct reg_cntlr **cntlr);
+
+/* parse params adapter */
+struct parse_cntlr {
+	struct device_node *np;
+	struct parse_method *ops;
+};
+
+struct parse_method {
+	int (*read_u32)(struct parse_cntlr*, char*, u32*);
+};
+
+int parse_adapter_probe(struct parse_cntlr **cntlr, struct device_node *np);
+void parse_adapter_remove(struct parse_cntlr **cntlr);
+
+/* gpio adapter */
+struct gpio_cntlr {
+	struct device *dev;
+	struct gpio_method *ops;
+};
+
+struct gpio_method {
+	int (*request)(struct gpio_cntlr*, char*, u32*);
+	void (*release)(struct gpio_cntlr*, u32);
+	int (*setdir)(struct gpio_cntlr*, u32, int);
+	int (*write)(struct gpio_cntlr*, u32, int);
+	int (*read)(struct gpio_cntlr*, u32, int*);
+};
+
+int gpio_adapter_probe(struct gpio_cntlr **cntlr, struct device *dev);
+void gpio_adapter_remove(struct gpio_cntlr **cntlr);
+
+/* ALSA api adapter */
+enum {
+	PCM_STREAM_PLAYBACK = 0,
+	PCM_STREAM_CAPTURE,
+	PCM_STREAM_LAST = PCM_STREAM_CAPTURE,
+};
+
+#define	PCM_FORMAT_S8		0
+#define	PCM_FORMAT_U8		1
+#define	PCM_FORMAT_S16_LE	2
+#define	PCM_FORMAT_S16_BE	3
+#define	PCM_FORMAT_U16_LE	4
+#define	PCM_FORMAT_U16_BE	5
+#define	PCM_FORMAT_S24_LE	6
+#define	PCM_FORMAT_S24_BE	7
+#define	PCM_FORMAT_U24_LE	8
+#define	PCM_FORMAT_U24_BE	9
+#define	PCM_FORMAT_S32_LE	10
+#define	PCM_FORMAT_S32_BE	11
+#define	PCM_FORMAT_U32_LE	12
+#define	PCM_FORMAT_U32_BE	13
+
+#endif /* __SND_SUNXI_ADAPTER_H */
diff --git a/sound/soc/sunxi_v2/snd_sunxi_ahub.c b/sound/soc/sunxi_v2/snd_sunxi_ahub.c
new file mode 100644
index 000000000..8202fac38
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_ahub.c
@@ -0,0 +1,235 @@
+/*
+ * sound\soc\sunxi\snd_sunxi_ahub.c
+ * (C) Copyright 2021-2025
+ * AllWinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <sound/soc.h>
+
+#include "snd_sunxi_log.h"
+#include "snd_sunxi_pcm.h"
+#include "snd_sunxi_ahub.h"
+
+static int sunxi_ahub_dai_hw_params(struct snd_pcm_substream *substream,
+				    struct snd_pcm_hw_params *params,
+				    struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static int sunxi_ahub_dai_set_sysclk(struct snd_soc_dai *dai,
+				     int clk_id,
+				     unsigned int freq,
+				     int dir)
+{
+	return 0;
+}
+
+static int sunxi_ahub_dai_trigger(struct snd_pcm_substream *substream,
+				  int cmd,
+				  struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static int sunxi_ahub_dai_prepare(struct snd_pcm_substream *substream,
+				  struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static const struct snd_soc_dai_ops sunxi_ahub_dai_ops = {
+	.hw_params	= sunxi_ahub_dai_hw_params,
+	.set_sysclk	= sunxi_ahub_dai_set_sysclk,
+	.trigger	= sunxi_ahub_dai_trigger,
+	.prepare	= sunxi_ahub_dai_prepare,
+};
+
+static struct snd_soc_dai_driver sunxi_ahub_dai[] = {
+	{
+		.name = "ahub_daudio0",
+		.playback = {
+			.stream_name	= "Playback",
+			.channels_min	= 1,
+			.channels_max	= 16,
+			.rates		= SNDRV_PCM_RATE_8000_192000
+					| SNDRV_PCM_RATE_KNOT,
+			.formats	= SNDRV_PCM_FMTBIT_S16_LE
+					| SNDRV_PCM_FMTBIT_S24_LE
+					| SNDRV_PCM_FMTBIT_S32_LE,
+		},
+		.capture = {
+			.stream_name	= "Capture",
+			.channels_min	= 1,
+			.channels_max	= 16,
+			.rates		= SNDRV_PCM_RATE_8000_192000
+					| SNDRV_PCM_RATE_KNOT,
+			.formats	= SNDRV_PCM_FMTBIT_S16_LE
+					| SNDRV_PCM_FMTBIT_S24_LE
+					| SNDRV_PCM_FMTBIT_S32_LE,
+		},
+		.ops = &sunxi_ahub_dai_ops,
+	},
+	{
+		.name = "ahub_daudio1",
+		.playback = {
+			.stream_name	= "Playback",
+			.channels_min	= 1,
+			.channels_max	= 16,
+			.rates		= SNDRV_PCM_RATE_8000_192000
+					| SNDRV_PCM_RATE_KNOT,
+			.formats	= SNDRV_PCM_FMTBIT_S16_LE
+					| SNDRV_PCM_FMTBIT_S24_LE
+					| SNDRV_PCM_FMTBIT_S32_LE,
+		},
+		.capture = {
+			.stream_name	= "Capture",
+			.channels_min	= 1,
+			.channels_max	= 16,
+			.rates		= SNDRV_PCM_RATE_8000_192000
+					| SNDRV_PCM_RATE_KNOT,
+			.formats	= SNDRV_PCM_FMTBIT_S16_LE
+					| SNDRV_PCM_FMTBIT_S24_LE
+					| SNDRV_PCM_FMTBIT_S32_LE,
+		},
+		.ops = &sunxi_ahub_dai_ops,
+	},
+	{
+		.name = "ahub_daudio2",
+		.playback = {
+			.stream_name	= "Playback",
+			.channels_min	= 1,
+			.channels_max	= 16,
+			.rates		= SNDRV_PCM_RATE_8000_192000
+					| SNDRV_PCM_RATE_KNOT,
+			.formats	= SNDRV_PCM_FMTBIT_S16_LE
+					| SNDRV_PCM_FMTBIT_S24_LE
+					| SNDRV_PCM_FMTBIT_S32_LE,
+		},
+		.capture = {
+			.stream_name	= "Capture",
+			.channels_min	= 1,
+			.channels_max	= 16,
+			.rates		= SNDRV_PCM_RATE_8000_192000
+					| SNDRV_PCM_RATE_KNOT,
+			.formats	= SNDRV_PCM_FMTBIT_S16_LE
+					| SNDRV_PCM_FMTBIT_S24_LE
+					| SNDRV_PCM_FMTBIT_S32_LE,
+		},
+		.ops = &sunxi_ahub_dai_ops,
+	},
+	{
+		.name = "ahub_daudio3",
+		.playback = {
+			.stream_name	= "Playback",
+			.channels_min	= 1,
+			.channels_max	= 16,
+			.rates		= SNDRV_PCM_RATE_8000_192000
+					| SNDRV_PCM_RATE_KNOT,
+			.formats	= SNDRV_PCM_FMTBIT_S16_LE
+					| SNDRV_PCM_FMTBIT_S24_LE
+					| SNDRV_PCM_FMTBIT_S32_LE,
+		},
+		.capture = {
+			.stream_name	= "Capture",
+			.channels_min	= 1,
+			.channels_max	= 16,
+			.rates		= SNDRV_PCM_RATE_8000_192000
+					| SNDRV_PCM_RATE_KNOT,
+			.formats	= SNDRV_PCM_FMTBIT_S16_LE
+					| SNDRV_PCM_FMTBIT_S24_LE
+					| SNDRV_PCM_FMTBIT_S32_LE,
+		},
+		.ops = &sunxi_ahub_dai_ops,
+	},
+};
+
+static int sunxi_ahub_probe(struct snd_soc_component *component)
+{
+	return 0;
+}
+
+static int sunxi_ahub_suspend(struct snd_soc_component *component)
+{
+	return 0;
+}
+
+static int sunxi_ahub_resume(struct snd_soc_component *component)
+{
+	return 0;
+}
+
+static struct snd_soc_component_driver sunxi_ahub_dev = {
+	.probe		= sunxi_ahub_probe,
+	.suspend	= sunxi_ahub_suspend,
+	.resume		= sunxi_ahub_resume,
+};
+
+static int sunxi_ahub_dev_probe(struct platform_device *pdev)
+{
+	int ret;
+
+	ret = snd_soc_register_component(&pdev->dev,
+					 &sunxi_ahub_dev,
+					 sunxi_ahub_dai,
+					 ARRAY_SIZE(sunxi_ahub_dai));
+	if (ret) {
+		SND_LOG_ERR("component register failed\n");
+		ret = -ENOMEM;
+		goto err_snd_soc_register_component;
+	}
+
+	ret = snd_soc_sunxi_dma_platform_register(&pdev->dev);
+	if (ret) {
+		SND_LOG_ERR("register ASoC platform failed\n");
+		ret = -ENOMEM;
+		goto err_snd_soc_sunxi_dma_platform_register;
+	}
+
+	SND_LOG_INFO("register ahub platform success\n");
+
+	return 0;
+
+err_snd_soc_sunxi_dma_platform_register:
+	snd_soc_unregister_component(&pdev->dev);
+err_snd_soc_register_component:
+	return ret;
+}
+
+static int sunxi_ahub_dev_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_component(&pdev->dev);
+
+	SND_LOG_INFO("unregister ahub platform success\n");
+
+	return 0;
+}
+
+static const struct of_device_id sunxi_ahub_of_match[] = {
+	{ .compatible = "allwinner,sunxi-snd-plat-ahub", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, sunxi_ahub_of_match);
+
+static struct platform_driver sunxi_ahub_driver = {
+	.driver	= {
+		.name		= "sunxi-snd-plat-ahub",
+		.owner		= THIS_MODULE,
+		.of_match_table	= sunxi_ahub_of_match,
+	},
+	.probe	= sunxi_ahub_dev_probe,
+	.remove	= sunxi_ahub_dev_remove,
+};
+
+module_platform_driver(sunxi_ahub_driver);
+
+MODULE_AUTHOR("Dby@allwinnertech.com");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("sunxi soundcard platform of ahub");
diff --git a/sound/soc/sunxi_v2/snd_sunxi_ahub.h b/sound/soc/sunxi_v2/snd_sunxi_ahub.h
new file mode 100644
index 000000000..ed833447d
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_ahub.h
@@ -0,0 +1,16 @@
+/* sound\soc\sunxi\snd_sunxi_ahub.h
+ * (C) Copyright 2021-2025
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#ifndef __SND_SUNXI_AHUB_H
+#define __SND_SUNXI_AHUB_H
+
+
+#endif /* __SND_SUNXI_AHUB_H */
diff --git a/sound/soc/sunxi_v2/snd_sunxi_common.c b/sound/soc/sunxi_v2/snd_sunxi_common.c
new file mode 100644
index 000000000..0d92f3e16
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_common.c
@@ -0,0 +1,214 @@
+/*
+ * sound\soc\sunxi\snd_sunxi_common.c
+ * (C) Copyright 2021-2025
+ * AllWinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <stddef.h>
+#include <linux/slab.h>
+
+#include "snd_sunxi_log.h"
+#include "snd_sunxi_common.h"
+#include "snd_sunxi_adapter.h"
+
+#define HLOG		"COMMON"
+
+/* for REG LABEL */
+int save_audio_reg(struct reg_cntlr *reg, REG_HANDLE regmap,
+		   struct reg_label *reg_labels)
+{
+	int i = 0;
+
+	while (reg_labels[i].name != NULL) {
+		reg->ops->read(reg, regmap,
+			       reg_labels[i].address, &(reg_labels[i].value));
+		i++;
+	}
+
+	return i;
+}
+
+int echo_audio_reg(struct reg_cntlr *reg, REG_HANDLE regmap,
+		   struct reg_label *reg_labels)
+{
+	int i = 0;
+
+	while (reg_labels[i].name != NULL) {
+		reg->ops->write(reg, regmap,
+			        reg_labels[i].address, reg_labels[i].value);
+		i++;
+	}
+
+	return i;
+}
+
+/* for pa config */
+struct pa_config* pa_pin_init(struct adapter_cntlr *cntlr, u32 *pa_pin_max)
+{
+	int ret, i;
+	u32 pin_max;
+	u32 temp_val;
+	char str[20] = {0};
+	struct pa_config *pa_cfg = NULL;
+	struct gpio_cntlr *gpio = NULL;
+	struct parse_cntlr *parse = NULL;
+
+	if (!cntlr) {
+		SND_LOG_ERR(HLOG, "handles or pa_cfg is NULL\n");
+		return NULL;
+	}
+	if (!cntlr->gpio || !cntlr->parse) {
+		SND_LOG_ERR(HLOG, "handle NULL\n");
+		return NULL;
+	}
+	gpio = cntlr->gpio;
+	parse = cntlr->parse;
+
+	ret = parse->ops->read_u32(parse, "pa_pin_max", &temp_val);
+	if (ret < 0) {
+		SND_LOG_WARN(HLOG, "pa_pin_max get failed, default 0\n");
+		*pa_pin_max = 0;
+		return NULL;
+	} else {
+		pin_max = temp_val;
+	}
+	*pa_pin_max = pin_max;
+
+	pa_cfg = kzalloc(sizeof(struct pa_config) * pin_max, GFP_KERNEL);
+	if (!pa_cfg) {
+		SND_LOG_ERR(HLOG, "can't pa_config memory\n");
+		return NULL;
+	}
+
+	for (i = 0; i < pin_max; i++) {
+		sprintf(str, "pa_pin_%d", i);
+		ret = gpio->ops->request(gpio, str, &temp_val);
+		if (ret < 0) {
+			SND_LOG_WARN(HLOG, "pa_pin_%u request failed\n", i);
+			pa_cfg[i].pin = 0;
+			pa_cfg[i].used = 0;
+			continue;
+		} else {
+			pa_cfg[i].pin = temp_val;
+			pa_cfg[i].used = 1;
+		}
+		sprintf(str, "pa_pin_level_%d", i);
+		ret = parse->ops->read_u32(parse, str, &temp_val);
+		if (ret < 0) {
+			SND_LOG_WARN(HLOG, "%s get failed, default low\n", str);
+			pa_cfg[i].level = 0;
+		} else {
+			if (temp_val > 0)
+				pa_cfg[i].level = 1;
+		}
+		sprintf(str, "pa_pin_msleep_%d", i);
+		ret = parse->ops->read_u32(parse, str, &temp_val);
+		if (ret < 0) {
+			SND_LOG_WARN(HLOG, "%s get failed, default 0\n", str);
+			pa_cfg[i].msleep = 0;
+		} else {
+			pa_cfg[i].msleep = temp_val;
+		}
+	}
+
+	pa_pin_disable(cntlr, pa_cfg, pin_max);
+
+	return pa_cfg;
+}
+
+void pa_pin_exit(struct adapter_cntlr *cntlr, struct pa_config *pa_cfg,
+		 u32 pa_pin_max)
+{
+	int i;
+	struct gpio_cntlr *gpio = NULL;
+
+	if (pa_pin_max < 1) {
+		SND_LOG_DEBUG(HLOG, "no pa pin config\n");
+		return;
+	}
+	if (!cntlr) {
+		SND_LOG_ERR(HLOG, "handles or pa_cfg is NULL\n");
+		return;
+	}
+	if (!cntlr->gpio) {
+		SND_LOG_ERR(HLOG, "handle NULL\n");
+		return;
+	}
+	gpio = cntlr->gpio;
+
+	pa_pin_disable(cntlr, pa_cfg, pa_pin_max);
+
+	for (i = 0; i < pa_pin_max; i++)
+		gpio->ops->release(gpio, pa_cfg[i].pin);
+
+	if (pa_cfg)
+		kfree(pa_cfg);
+}
+
+int pa_pin_enable(struct adapter_cntlr *cntlr, struct pa_config *pa_cfg,
+		  u32 pa_pin_max)
+{
+	int i;
+	struct gpio_cntlr *gpio = NULL;
+
+	if (pa_pin_max < 1) {
+		SND_LOG_DEBUG(HLOG, "no pa pin config\n");
+		return 0;
+	}
+	if (!cntlr) {
+		SND_LOG_ERR(HLOG, "handles or pa_cfg is NULL\n");
+		return -1;
+	}
+	if (!cntlr->gpio) {
+		SND_LOG_ERR(HLOG, "handle NULL\n");
+		return -1;
+	}
+	gpio = cntlr->gpio;
+
+	for (i = 0; i < pa_pin_max; i++) {
+		if (!pa_cfg[i].used)
+			continue;
+
+		gpio->ops->setdir(gpio, pa_cfg[i].pin, 1);
+		gpio->ops->write(gpio, pa_cfg[i].pin, pa_cfg[i].level);
+	}
+
+	return 0;
+}
+
+int pa_pin_disable(struct adapter_cntlr *cntlr, struct pa_config *pa_cfg,
+		   u32 pa_pin_max)
+{
+	int i;
+	struct gpio_cntlr *gpio = NULL;
+
+	if (pa_pin_max < 1) {
+		SND_LOG_DEBUG(HLOG, "no pa pin config\n");
+		return 0;
+	}
+	if (!cntlr) {
+		SND_LOG_ERR(HLOG, "handles or pa_cfg is NULL\n");
+		return -1;
+	}
+	if (!cntlr->gpio) {
+		SND_LOG_ERR(HLOG, "handle NULL\n");
+		return -1;
+	}
+	gpio = cntlr->gpio;
+
+	for (i = 0; i < pa_pin_max; i++) {
+		if (!pa_cfg[i].used)
+			continue;
+
+		gpio->ops->setdir(gpio, pa_cfg[i].pin, 1);
+		gpio->ops->write(gpio, pa_cfg[i].pin, !pa_cfg[i].level);
+	}
+
+	return 0;
+}
\ No newline at end of file
diff --git a/sound/soc/sunxi_v2/snd_sunxi_common.h b/sound/soc/sunxi_v2/snd_sunxi_common.h
new file mode 100644
index 000000000..df221ecab
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_common.h
@@ -0,0 +1,53 @@
+/* sound\soc\sunxi\snd_sunxi_common.h
+ * (C) Copyright 2021-2025
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#ifndef __SND_SUNXI_COMMON_H
+#define __SND_SUNXI_COMMON_H
+
+#include "snd_sunxi_adapter.h"
+
+/* for REG LABEL */
+#define REG_LABEL(constant)	{#constant, constant, 0}
+#define REG_LABEL_END		{NULL, 0, 0}
+
+struct reg_label {
+	const char *name;
+	const unsigned int address;
+	unsigned int value;
+};
+
+int save_audio_reg(struct reg_cntlr *reg, REG_HANDLE regmap,
+		   struct reg_label *reg_labels);
+int echo_audio_reg(struct reg_cntlr *reg, REG_HANDLE regmap,
+		   struct reg_label *reg_labels);
+
+/* for rate conversion */
+#define RATE_CONV_END		{0, 0}
+
+struct sample_rate {
+	unsigned int samplerate;
+	unsigned int rate_bit;
+};
+
+/* for pa config */
+struct pa_config {
+	u32 pin;
+	u32 msleep;
+	bool used;
+	bool level;
+};
+
+struct pa_config* pa_pin_init(struct adapter_cntlr *cntlr, u32 *pa_pin_max);
+void pa_pin_exit(struct adapter_cntlr *cntlr, struct pa_config *pa_cfg, u32 pa_pin_max);
+int pa_pin_enable(struct adapter_cntlr *cntlr, struct pa_config *pa_cfg, u32 pa_pin_max);
+int pa_pin_disable(struct adapter_cntlr *cntlr, struct pa_config *pa_cfg, u32 pa_pin_max);
+
+#endif /* __SND_SUNXI_COMMON_H */
diff --git a/sound/soc/sunxi_v2/snd_sunxi_dmic.c b/sound/soc/sunxi_v2/snd_sunxi_dmic.c
new file mode 100644
index 000000000..5b6ed3ba3
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_dmic.c
@@ -0,0 +1,148 @@
+/*
+ * sound\soc\sunxi\snd_sunxi_dmic.c
+ * (C) Copyright 2021-2025
+ * AllWinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <sound/soc.h>
+
+#include "snd_sunxi_log.h"
+#include "snd_sunxi_pcm.h"
+#include "snd_sunxi_dmic.h"
+
+static int sunxi_dmic_dai_hw_params(struct snd_pcm_substream *substream,
+				    struct snd_pcm_hw_params *params,
+				    struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static int sunxi_dmic_dai_set_sysclk(struct snd_soc_dai *dai,
+				     int clk_id,
+				     unsigned int freq,
+				     int dir)
+{
+	return 0;
+}
+
+static int sunxi_dmic_dai_trigger(struct snd_pcm_substream *substream,
+				  int cmd,
+				  struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static int sunxi_dmic_dai_prepare(struct snd_pcm_substream *substream,
+				  struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static const struct snd_soc_dai_ops sunxi_dmic_dai_ops = {
+	.hw_params	= sunxi_dmic_dai_hw_params,
+	.set_sysclk	= sunxi_dmic_dai_set_sysclk,
+	.trigger	= sunxi_dmic_dai_trigger,
+	.prepare	= sunxi_dmic_dai_prepare,
+};
+
+static struct snd_soc_dai_driver sunxi_dmic_dai = {
+	.capture = {
+		.stream_name	= "Capture",
+		.channels_min	= 1,
+		.channels_max	= 8,
+		.rates		= SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+		.formats	= SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE
+	},
+	.ops = &sunxi_dmic_dai_ops,
+};
+
+static int sunxi_dmic_probe(struct snd_soc_component *component)
+{
+	return 0;
+}
+
+static int sunxi_dmic_suspend(struct snd_soc_component *component)
+{
+	return 0;
+}
+
+static int sunxi_dmic_resume(struct snd_soc_component *component)
+{
+	return 0;
+}
+
+static struct snd_soc_component_driver sunxi_dmic_dev = {
+	.probe		= sunxi_dmic_probe,
+	.suspend	= sunxi_dmic_suspend,
+	.resume		= sunxi_dmic_resume,
+};
+
+static int sunxi_dmic_dev_probe(struct platform_device *pdev)
+{
+	int ret;
+
+	ret = snd_soc_register_component(&pdev->dev,
+					 &sunxi_dmic_dev,
+					 &sunxi_dmic_dai, 1);
+	if (ret) {
+		SND_LOG_ERR("component register failed\n");
+		ret = -ENOMEM;
+		goto err_snd_soc_register_component;
+	}
+
+	ret = snd_soc_sunxi_dma_platform_register(&pdev->dev);
+	if (ret) {
+		SND_LOG_ERR("register ASoC platform failed\n");
+		ret = -ENOMEM;
+		goto err_snd_soc_sunxi_dma_platform_register;
+	}
+
+	SND_LOG_INFO("register dmic platform success\n");
+
+	return 0;
+
+err_snd_soc_sunxi_dma_platform_register:
+	snd_soc_unregister_component(&pdev->dev);
+err_snd_soc_register_component:
+	return ret;
+}
+
+static int sunxi_dmic_dev_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_component(&pdev->dev);
+
+	SND_LOG_INFO("unregister dmic platform success\n");
+
+	return 0;
+}
+
+static const struct of_device_id sunxi_dmic_of_match[] = {
+	{ .compatible = "allwinner,sunxi-snd-plat-dmic", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, sunxi_dmic_of_match);
+
+static struct platform_driver sunxi_dmic_driver = {
+	.driver	= {
+		.name		= "sunxi-snd-plat-dmic",
+		.owner		= THIS_MODULE,
+		.of_match_table	= sunxi_dmic_of_match,
+	},
+	.probe	= sunxi_dmic_dev_probe,
+	.remove	= sunxi_dmic_dev_remove,
+};
+
+module_platform_driver(sunxi_dmic_driver);
+
+MODULE_AUTHOR("Dby@allwinnertech.com");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("sunxi soundcard platform of dmic");
\ No newline at end of file
diff --git a/sound/soc/sunxi_v2/snd_sunxi_dmic.h b/sound/soc/sunxi_v2/snd_sunxi_dmic.h
new file mode 100644
index 000000000..f7fc7cc32
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_dmic.h
@@ -0,0 +1,18 @@
+/* sound\soc\sunxi\snd_sunxi_dmic.h
+ * (C) Copyright 2021-2025
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#ifndef __SND_SUNXI_DMIC_H
+#define __SND_SUNXI_DMIC_H
+
+
+#endif /* __SND_SUNXI_DMIC_H */
diff --git a/sound/soc/sunxi_v2/snd_sunxi_dummy_codec.c b/sound/soc/sunxi_v2/snd_sunxi_dummy_codec.c
new file mode 100644
index 000000000..15052ad54
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_dummy_codec.c
@@ -0,0 +1,116 @@
+/*
+ * sound\soc\sunxi\snd_sunxi_dummy_codec.c
+ * (C) Copyright 2021-2025
+ * AllWinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <sound/soc.h>
+
+#include "snd_sunxi_log.h"
+
+#define DUMMY_CARD_NAME		"sunxi-dummy-codec"
+#define DUMMY_CARD_DAI_NAME	"sunxi-dummy-codec-dai"
+
+static const struct snd_soc_component_driver sunxi_dummy_codec = {
+};
+
+/*
+ * The dummy CODEC is only meant to be used in situations where there is no
+ * actual hardware.
+ *
+ * If there is actual hardware even if it does not have a control bus
+ * the hardware will still have constraints like supported samplerates, etc.
+ * which should be modelled. And the data flow graph also should be modelled
+ * using DAPM.
+ */
+static struct snd_soc_dai_driver sunxi_dummy_codec_dai = {
+	.name = DUMMY_CARD_DAI_NAME,
+	.playback = {
+		.stream_name	= "Playback",
+		.channels_min	= 1,
+		.channels_max	= 16,
+		.rates		= SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+		.formats	= SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE
+				| SNDRV_PCM_FMTBIT_S32_LE,
+	},
+	.capture = {
+		.stream_name	= "Capture",
+		.channels_min	= 1,
+		.channels_max	= 16,
+		.rates		= SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+		.formats	= SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE
+				| SNDRV_PCM_FMTBIT_S32_LE,
+	},
+};
+
+static int sunxi_dummy_codec_probe(struct platform_device *pdev)
+{
+	int ret;
+
+	ret = devm_snd_soc_register_component(&pdev->dev,
+					      &sunxi_dummy_codec,
+					      &sunxi_dummy_codec_dai, 1);
+
+	if (ret) {
+		SND_LOG_ERR("dummy-codec component register failed\n");
+		return ret;
+	}
+
+	SND_LOG_INFO("register dummy-codec codec success\n");
+
+	return 0;
+}
+
+static struct platform_driver sunxi_dummy_codec_driver = {
+	.driver = {
+		.name = DUMMY_CARD_NAME,
+	},
+	.probe = sunxi_dummy_codec_probe,
+};
+
+static struct platform_device *sunxi_dummy_codec_dev;
+
+int __init sunxi_dummy_codec_util_init(void)
+{
+	int ret;
+
+	sunxi_dummy_codec_dev =
+		platform_device_register_simple(DUMMY_CARD_NAME, -1, NULL, 0);
+	if (IS_ERR(sunxi_dummy_codec_dev)) {
+		SND_LOG_ERR("platform device register simple failed\n");
+		return PTR_ERR(sunxi_dummy_codec_dev);
+	}
+
+	ret = platform_driver_register(&sunxi_dummy_codec_driver);
+	if (ret != 0) {
+		platform_device_unregister(sunxi_dummy_codec_dev);
+		SND_LOG_ERR("platform driver register failed\n");
+	}
+
+	return ret;
+}
+
+void __exit sunxi_dummy_codec_util_exit(void)
+{
+	platform_driver_unregister(&sunxi_dummy_codec_driver);
+	platform_device_unregister(sunxi_dummy_codec_dev);
+}
+
+module_init(sunxi_dummy_codec_util_init);
+module_exit(sunxi_dummy_codec_util_exit);
+
+MODULE_AUTHOR("Dby@allwinnertech.com");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("sunxi soundcard codec of dummy-codec");
diff --git a/sound/soc/sunxi_v2/snd_sunxi_internal_codec.c b/sound/soc/sunxi_v2/snd_sunxi_internal_codec.c
new file mode 100644
index 000000000..d2f3af580
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_internal_codec.c
@@ -0,0 +1,332 @@
+/*
+ * sound\soc\sunxi\snd_sunxi_internal_codec.c
+ * (C) Copyright 2021-2025
+ * AllWinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <sound/soc.h>
+#include <sound/tlv.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+
+#include "snd_sunxi_log.h"
+#include "snd_sunxi_pcm.h"
+#include "snd_sunxi_adapter.h"
+#include "snd_sunxi_internal_codec.h"
+
+#define HLOG		"CODECDAI"
+#define DRV_NAME	"sunxi-snd-codec"
+
+struct adapter_cntlr g_adapter_cntlr;
+
+static int sunxi_internal_codec_dai_hw_params(struct snd_pcm_substream *substream,
+					      struct snd_pcm_hw_params *params,
+					      struct snd_soc_dai *dai)
+{
+	int ret;
+	struct snd_soc_component *component = dai->component;
+	struct sunxi_codec_info *codec_info = snd_soc_component_get_drvdata(component);
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	ret = internal_codec_hw_params(&g_adapter_cntlr, codec_info,
+				       substream->stream,
+				       params_format(params),
+				       params_rate(params),
+				       params_channels(params));
+	if (ret) {
+		SND_LOG_ERR(HLOG, "internal codec set hw_params failed\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static int sunxi_internal_codec_dai_set_sysclk(struct snd_soc_dai *dai,
+					       int clk_id,
+					       unsigned int freq,
+					       int dir)
+{
+	int ret;
+	struct snd_soc_component *component = dai->component;
+	struct sunxi_codec_info *codec_info = snd_soc_component_get_drvdata(component);
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	ret = internal_codec_set_sysclk(&g_adapter_cntlr, codec_info, freq);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "internal codec set sysclk failed\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+
+static int sunxi_internal_codec_dai_prepare(struct snd_pcm_substream *substream,
+					    struct snd_soc_dai *dai)
+{
+	int ret;
+	struct snd_soc_component *component = dai->component;
+	struct sunxi_codec_info *codec_info = snd_soc_component_get_drvdata(component);
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	ret = internal_codec_prepare(&g_adapter_cntlr, codec_info, substream->stream);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "internal codec set prepare failed\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static int sunxi_internal_codec_dai_trigger(struct snd_pcm_substream *substream,
+					    int cmd,
+					    struct snd_soc_dai *dai)
+{
+	int ret, drq_en;
+	struct snd_soc_component *component = dai->component;
+	struct sunxi_codec_info *codec_info = snd_soc_component_get_drvdata(component);
+
+	SND_LOG_DEBUG(HLOG, "cmd -> %d\n", cmd);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		drq_en = 1;
+	break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		drq_en = 0;
+	break;
+	default:
+		return -EINVAL;
+	}
+
+	ret = internal_codec_trigger(&g_adapter_cntlr, codec_info,
+				     substream->stream, drq_en);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "internal codec set trigger failed\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops sunxi_internal_codec_dai_ops = {
+	.hw_params	= sunxi_internal_codec_dai_hw_params,
+	.set_sysclk	= sunxi_internal_codec_dai_set_sysclk,
+	.prepare	= sunxi_internal_codec_dai_prepare,
+	.trigger	= sunxi_internal_codec_dai_trigger,
+};
+
+static struct snd_soc_dai_driver sunxi_internal_codec_dai = {
+	.playback = {
+		.stream_name	= "Playback",
+		.channels_min	= 1,
+		.channels_max	= 2,
+		.rates		= SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+		.formats	= SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE
+				| SNDRV_PCM_FMTBIT_S32_LE,
+	},
+	.ops = &sunxi_internal_codec_dai_ops,
+};
+
+static int sunxi_internal_codec_probe(struct snd_soc_component *component)
+{
+	int ret;
+	struct sunxi_codec_info *codec_info = snd_soc_component_get_drvdata(component);
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	internal_codec_init(&g_adapter_cntlr, codec_info);
+
+	/* add controls */
+	ret = internal_codec_controls_add(component);
+	if (ret)
+		SND_LOG_ERR(HLOG, "register codec controls failed\n");
+
+	return 0;
+}
+
+static int sunxi_internal_codec_suspend(struct snd_soc_component *component)
+{
+	int ret;
+	struct sunxi_codec_info *codec_info = snd_soc_component_get_drvdata(component);
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	ret = internal_codec_suspend(&g_adapter_cntlr, codec_info);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "internal codec suspend failed\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static int sunxi_internal_codec_resume(struct snd_soc_component *component)
+{
+	int ret;
+	struct sunxi_codec_info *codec_info = snd_soc_component_get_drvdata(component);
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	ret = internal_codec_resume(&g_adapter_cntlr, codec_info);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "internal codec resume failed\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static struct snd_soc_component_driver sunxi_internal_codec_dev = {
+	.probe		= sunxi_internal_codec_probe,
+	.suspend	= sunxi_internal_codec_suspend,
+	.resume		= sunxi_internal_codec_resume,
+};
+
+static int sunxi_internal_codec_dev_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = pdev->dev.of_node;
+	struct sunxi_codec_info *codec_info;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	/* sunxi codec info */
+	codec_info = kzalloc(sizeof(struct sunxi_codec_info), GFP_KERNEL);
+	if (!codec_info) {
+		SND_LOG_ERR(HLOG, "can't allocate sunxi codec memory\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+	dev_set_drvdata(dev, codec_info);
+	codec_info->cntlr = &g_adapter_cntlr;
+
+	/* sunxi adapter probe */
+	ret = regulator_adapter_probe(&g_adapter_cntlr.regulator, dev);
+	if(ret) {
+		SND_LOG_ERR(HLOG, "regulator adapter failed\n");
+		goto err;
+	}
+	ret = clk_adapter_probe(&g_adapter_cntlr.clk, np);
+	if(ret) {
+		SND_LOG_ERR(HLOG, "clk adapter failed\n");
+		goto err;
+	}
+	ret = reg_adapter_probe(&g_adapter_cntlr.reg, dev);
+	if(ret) {
+		SND_LOG_ERR(HLOG, "regmap adapter failed\n");
+		goto err;
+	}
+	ret = parse_adapter_probe(&g_adapter_cntlr.parse, np);
+	if(ret) {
+		SND_LOG_ERR(HLOG, "parse adapter failed\n");
+		goto err;
+	}
+	ret = gpio_adapter_probe(&g_adapter_cntlr.gpio, dev);
+	if(ret) {
+		SND_LOG_ERR(HLOG, "gpio adapter failed\n");
+		goto err;
+	}
+
+	/* sunxi internal codec probe */
+	ret = internal_codec_probe(&g_adapter_cntlr, codec_info);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "internal codec probe failed\n");
+		ret = -1;
+		goto err;
+	}
+
+	/* alsa component register */
+	ret = snd_soc_register_component(dev,
+					 &sunxi_internal_codec_dev,
+					 &sunxi_internal_codec_dai, 1);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "internal-codec component register failed\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	SND_LOG_INFO(HLOG, "register internal-codec codec success\n");
+
+	return 0;
+
+err:
+	regulator_adapter_remove(&g_adapter_cntlr.regulator);
+	clk_adapter_remove(&g_adapter_cntlr.clk);
+	reg_adapter_remove(&g_adapter_cntlr.reg);
+	parse_adapter_remove(&g_adapter_cntlr.parse);
+	if (codec_info)
+		kfree(codec_info);
+	of_node_put(np);
+
+	return ret;
+}
+
+static int sunxi_internal_codec_dev_remove(struct platform_device *pdev)
+{
+	struct sunxi_codec_info *codec_info = dev_get_drvdata(&pdev->dev);
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	/* alsa component unregister */
+	snd_soc_unregister_component(&pdev->dev);
+
+	/* sunxi internal codec remove */
+	internal_codec_remove(&g_adapter_cntlr, codec_info);
+
+	/* sunxi adapter remove */
+	regulator_adapter_remove(&g_adapter_cntlr.regulator);
+	clk_adapter_remove(&g_adapter_cntlr.clk);
+	reg_adapter_remove(&g_adapter_cntlr.reg);
+	parse_adapter_remove(&g_adapter_cntlr.parse);
+	gpio_adapter_remove(&g_adapter_cntlr.gpio);
+
+	/* sunxi codec custom info free */
+	if (codec_info)
+		kfree(codec_info);
+	of_node_put(pdev->dev.of_node);
+
+	SND_LOG_INFO(HLOG, "unregister internal-codec codec success\n");
+
+	return 0;
+}
+
+static const struct of_device_id sunxi_internal_codec_of_match[] = {
+	{ .compatible = "allwinner," DRV_NAME, },
+	{},
+};
+MODULE_DEVICE_TABLE(of, sunxi_internal_codec_of_match);
+
+static struct platform_driver sunxi_internal_codec_driver = {
+	.driver	= {
+		.name		= DRV_NAME,
+		.owner		= THIS_MODULE,
+		.of_match_table	= sunxi_internal_codec_of_match,
+	},
+	.probe	= sunxi_internal_codec_dev_probe,
+	.remove	= sunxi_internal_codec_dev_remove,
+};
+
+module_platform_driver(sunxi_internal_codec_driver);
+
+MODULE_AUTHOR("Dby@allwinnertech.com");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("sunxi soundcard codec of internal-codec");
diff --git a/sound/soc/sunxi_v2/snd_sunxi_internal_codec.h b/sound/soc/sunxi_v2/snd_sunxi_internal_codec.h
new file mode 100644
index 000000000..0f97501d0
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_internal_codec.h
@@ -0,0 +1,19 @@
+/* sound\soc\sunxi\snd_sunxi_internal_codec.h
+ * (C) Copyright 2021-2025
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#ifndef __SND_SUNXI_INTERNAL_CODEC_H
+#define __SND_SUNXI_INTERNAL_CODEC_H
+
+#if defined(CONFIG_ARCH_SUN50IW9)
+#include "snd_sun50iw9_codec.h"
+#endif
+
+#endif /* __SND_SUNXI_INTERNAL_CODEC_H */
diff --git a/sound/soc/sunxi_v2/snd_sunxi_log.h b/sound/soc/sunxi_v2/snd_sunxi_log.h
new file mode 100644
index 000000000..9e8f6ec39
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_log.h
@@ -0,0 +1,30 @@
+/*
+ * sound\soc\sunxi\snd_sunxi_log.h
+ * (C) Copyright 2021-2025
+ * allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#ifndef __SND_SUNXI_LOG_H
+#define __SND_SUNXI_LOG_H
+#include <linux/kernel.h>
+
+#define SND_LOG_ERR(head, fmt, arg...) \
+	pr_err("[sound %4d][" head " %s] " fmt, __LINE__, __func__, ##arg)
+
+#define SND_LOG_WARN(head, fmt, arg...) \
+	pr_warning("[sound %4d][" head " %s] " fmt, __LINE__, __func__, ##arg)
+
+#define SND_LOG_INFO(head, fmt, arg...) \
+	pr_info("[sound %4d][" head " %s] " fmt, __LINE__, __func__, ##arg)
+
+#define SND_LOG_DEBUG(head, fmt, arg...) \
+	pr_debug("[sound %4d][" head " %s] " fmt, __LINE__, __func__, ##arg)
+
+#endif /* __SND_SUNXI_LOG_H */
+
diff --git a/sound/soc/sunxi_v2/snd_sunxi_mach.c b/sound/soc/sunxi_v2/snd_sunxi_mach.c
new file mode 100644
index 000000000..89759c2eb
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_mach.c
@@ -0,0 +1,414 @@
+/*
+ * sound\soc\sunxi\snd_sunxi_mach.c
+ * (C) Copyright 2021-2025
+ * AllWinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * based on ${LINUX}/sound/soc/generic/simple-card.c
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <sound/soc.h>
+
+#include "snd_sunxi_log.h"
+#include "snd_sunxi_mach.h"
+
+#define HLOG	"MACH"
+#define DAI	"sound-dai"
+#define CELL	"#sound-dai-cells"
+#define PREFIX	"soundcard-mach,"
+
+#define DRV_NAME	"sunxi-snd-mach"
+
+static int asoc_simple_parse_dai(struct device_node *node,
+				 struct snd_soc_dai_link_component *dlc,
+				 int *is_single_link)
+{
+	struct of_phandle_args args;
+	int ret;
+
+	if (!node)
+		return 0;
+
+	/*
+	 * Get node via "sound-dai = <&phandle port>"
+	 * it will be used as xxx_of_node on soc_bind_dai_link()
+	 */
+	ret = of_parse_phandle_with_args(node, DAI, CELL, 0, &args);
+	if (ret)
+		return ret;
+
+	/*
+	 * FIXME
+	 *
+	 * Here, dlc->dai_name is pointer to CPU/Codec DAI name.
+	 * If user unbinded CPU or Codec driver, but not for Sound Card,
+	 * dlc->dai_name is keeping unbinded CPU or Codec
+	 * driver's pointer.
+	 *
+	 * If user re-bind CPU or Codec driver again, ALSA SoC will try
+	 * to rebind Card via snd_soc_try_rebind_card(), but because of
+	 * above reason, it might can't bind Sound Card.
+	 * Because Sound Card is pointing to released dai_name pointer.
+	 *
+	 * To avoid this rebind Card issue,
+	 * 1) It needs to alloc memory to keep dai_name eventhough
+	 *    CPU or Codec driver was unbinded, or
+	 * 2) user need to rebind Sound Card everytime
+	 *    if he unbinded CPU or Codec.
+	 */
+	ret = snd_soc_of_get_dai_name(node, &dlc->dai_name);
+	if (ret < 0)
+		return ret;
+
+	dlc->of_node = args.np;
+
+	if (is_single_link)
+		*is_single_link = !args.args_count;
+
+	return 0;
+}
+
+static void asoc_simple_card_shutdown(struct snd_pcm_substream *substream)
+{
+}
+
+static int asoc_simple_card_startup(struct snd_pcm_substream *substream)
+{
+	return 0;
+}
+
+static int asoc_simple_card_hw_params(struct snd_pcm_substream *substream,
+				      struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct asoc_simple_priv *priv = snd_soc_card_get_drvdata(rtd->card);
+	struct snd_soc_dai_link *dai_link = simple_priv_to_link(priv, rtd->num);
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	int ret, clk_div;
+	unsigned int freq;
+
+	switch (params_rate(params)) {
+	case 8000:
+	case 12000:
+	case 16000:
+	case 24000:
+	case 32000:
+	case 48000:
+	case 64000:
+	case 96000:
+	case 192000:
+		freq = 24576000;
+		break;
+	case 11025:
+	case 22050:
+	case 44100:
+	case 88200:
+	case 176400:
+		freq = 22579200;
+		break;
+	default:
+		SND_LOG_ERR(HLOG, "Invalid rate %d\n", params_rate(params));
+		return -EINVAL;
+	}
+
+	ret = snd_soc_dai_set_sysclk(codec_dai, 0, freq, SND_SOC_CLOCK_IN);
+	if (ret && ret != -ENOTSUPP) {
+		SND_LOG_ERR(HLOG, "cadec_dai set sysclk failed.\n");
+		return ret;
+	}
+	ret = snd_soc_dai_set_sysclk(cpu_dai, 0, freq, SND_SOC_CLOCK_OUT);
+	if (ret && ret != -ENOTSUPP) {
+		SND_LOG_ERR(HLOG, "cpu_dai set sysclk failed.\n");
+		return ret;
+	}
+
+	ret = snd_soc_dai_set_pll(codec_dai, 0, 0, freq, freq);
+	/* if (ret < 0) */
+	/* 	SND_LOG_WARN(HLOG, "codec_dai set set_pll failed.\n"); */
+
+	/* set codec dai fmt */
+	ret = snd_soc_dai_set_fmt(codec_dai, dai_link->dai_fmt);
+	if (ret && ret != -ENOTSUPP)
+		SND_LOG_WARN(HLOG, "codec dai set fmt failed\n");
+
+	/* set cpu dai fmt */
+	ret = snd_soc_dai_set_fmt(cpu_dai, dai_link->dai_fmt);
+	if (ret && ret != -ENOTSUPP)
+		SND_LOG_WARN(HLOG, "cpu dai set fmt failed\n");
+
+	clk_div = freq / params_rate(params);
+
+	if (cpu_dai->driver->ops->set_clkdiv) {
+		ret = snd_soc_dai_set_clkdiv(cpu_dai, 0, clk_div);
+		if (ret < 0) {
+			SND_LOG_ERR(HLOG, "set clkdiv failed.\n");
+			return ret;
+		}
+	}
+
+	if (codec_dai->driver->ops->set_clkdiv) {
+		ret = snd_soc_dai_set_clkdiv(codec_dai, 0, clk_div);
+		if (ret < 0) {
+			SND_LOG_ERR(HLOG, "codec_dai set clkdiv failed\n");
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static struct snd_soc_ops asoc_simple_card_ops = {
+	.startup = asoc_simple_card_startup,
+	.shutdown = asoc_simple_card_shutdown,
+	.hw_params = asoc_simple_card_hw_params,
+};
+
+static int asoc_simple_card_dai_init(struct snd_soc_pcm_runtime *rtd)
+{
+	return 0;
+}
+
+static int asoc_simple_card_dai_link_of(struct device_node *node,
+					struct asoc_simple_priv *priv,
+					int idx,
+					bool is_top_level_node)
+{
+	struct device *dev = simple_priv_to_dev(priv);
+	struct snd_soc_dai_link *dai_link = simple_priv_to_link(priv, idx);
+	struct device_node *cpu = NULL;
+	struct device_node *plat = NULL;
+	struct device_node *codec = NULL;
+	char prop[128];
+	char *prefix = "";
+	int ret, single_cpu;
+
+	/* For single DAI link & old style of DT node */
+	if (is_top_level_node) {
+		prefix = PREFIX;
+	}
+
+	snprintf(prop, sizeof(prop), "%scpu", prefix);
+	cpu = of_get_child_by_name(node, prop);
+	if (!cpu) {
+		ret = -EINVAL;
+		SND_LOG_ERR(HLOG, "Can't find %s DT node\n", prop);
+		goto dai_link_of_err;
+	}
+
+	snprintf(prop, sizeof(prop), "%splat", prefix);
+	plat = of_get_child_by_name(node, prop);
+
+	snprintf(prop, sizeof(prop), "%scodec", prefix);
+	codec = of_get_child_by_name(node, prop);
+	if (!codec) {
+		ret = -EINVAL;
+		SND_LOG_ERR(HLOG, "Can't find %s DT node\n", prop);
+		goto dai_link_of_err;
+	}
+
+	ret = asoc_simple_parse_daistream(dev, node, prefix, dai_link);
+	if (ret < 0)
+		goto dai_link_of_err;
+
+	ret = asoc_simple_parse_daifmt(dev, node, codec,
+				       prefix, &dai_link->dai_fmt);
+	if (ret < 0)
+		goto dai_link_of_err;
+
+	ret = asoc_simple_parse_cpu(cpu, dai_link, &single_cpu);
+	if (ret < 0)
+		goto dai_link_of_err;
+
+	ret = asoc_simple_parse_codec(codec, dai_link);
+	if (ret < 0) {
+		if (ret == -EPROBE_DEFER)
+			goto dai_link_of_err;
+		/*
+		dai_link->codecs->name = "snd-soc-dummy";
+		dai_link->codec_dai_name = "snd-soc-dummy-dai";
+		*/
+		dai_link->codecs->name = "sunxi-dummy-codec";
+		dai_link->codecs->dai_name = "sunxi-dummy-codec-dai";
+		SND_LOG_INFO(HLOG, "use dummy codec for simple card.\n");
+	}
+
+	ret = asoc_simple_parse_platform(plat, dai_link);
+	if (ret < 0)
+		goto dai_link_of_err;
+
+	ret = asoc_simple_set_dailink_name(dev, dai_link,
+					   "%s-%s",
+					   dai_link->cpus->dai_name,
+					   dai_link->codecs->dai_name);
+	if (ret < 0)
+		goto dai_link_of_err;
+
+	dai_link->ops = &asoc_simple_card_ops;
+	dai_link->init = asoc_simple_card_dai_init;
+
+	SND_LOG_INFO(HLOG, "name   : %s\n", dai_link->stream_name);
+	SND_LOG_INFO(HLOG, "format : %x\n", dai_link->dai_fmt);
+	SND_LOG_INFO(HLOG, "cpu    : %s\n", dai_link->cpus->name);
+	SND_LOG_INFO(HLOG, "codec  : %s\n", dai_link->codecs->name);
+
+	asoc_simple_canonicalize_cpu(dai_link, single_cpu);
+	asoc_simple_canonicalize_platform(dai_link);
+
+dai_link_of_err:
+	of_node_put(cpu);
+	of_node_put(codec);
+
+	return ret;
+}
+
+static int asoc_simple_card_parse_of(struct asoc_simple_priv *priv)
+{
+	struct device *dev = simple_priv_to_dev(priv);
+	struct device_node *dai_link;
+	struct device_node *node = dev->of_node;
+	int ret;
+
+	if (!node)
+		return -EINVAL;
+
+	/* The off-codec widgets */
+	ret = asoc_simple_parse_widgets(&priv->snd_card, PREFIX);
+	if (ret < 0)
+		return ret;
+
+	/* DAPM routes */
+	ret = asoc_simple_parse_routing(&priv->snd_card, PREFIX);
+	if (ret < 0)
+		return ret;
+
+	ret = asoc_simple_parse_pin_switches(&priv->snd_card, PREFIX);
+	if (ret < 0)
+		return ret;
+
+	dai_link = of_get_child_by_name(node, PREFIX "dai-link");
+	/* Single/Muti DAI link(s) & New style of DT node */
+	if (dai_link) {
+		struct device_node *np = NULL;
+		int i = 0;
+
+		for_each_child_of_node(node, np) {
+			SND_LOG_DEBUG(HLOG, "\tlink %d:\n", i);
+			ret = asoc_simple_card_dai_link_of(np, priv,
+							   i, false);
+			if (ret < 0) {
+				of_node_put(np);
+				goto card_parse_end;
+			}
+			i++;
+		}
+	} else {
+		/* For single DAI link & old style of DT node */
+		ret = asoc_simple_card_dai_link_of(node, priv, 0, true);
+		if (ret < 0)
+			goto card_parse_end;
+	}
+
+	ret = asoc_simple_parse_card_name(&priv->snd_card, PREFIX);
+
+card_parse_end:
+	of_node_put(dai_link);
+
+	return ret;
+}
+
+static int simple_soc_probe(struct snd_soc_card *card)
+{
+	return 0;
+}
+
+static int asoc_simple_card_probe(struct platform_device *pdev)
+{
+	struct asoc_simple_priv *priv;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct snd_soc_card *card;
+	struct link_info li;
+	int ret;
+
+	/* Allocate the private data and the DAI link array */
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	card = simple_priv_to_card(priv);
+	card->owner		= THIS_MODULE;
+	card->dev		= dev;
+	card->probe		= simple_soc_probe;
+
+	memset(&li, 0, sizeof(li));
+
+	/* Get the number of DAI links */
+	if (np && of_get_child_by_name(np, PREFIX "dai-link"))
+		li.link = of_get_child_count(np);
+	else
+		li.link = 1;
+
+	ret = asoc_simple_init_priv(priv, &li);
+	if (ret < 0)
+		return ret;
+
+	if (np && of_device_is_available(np)) {
+
+		ret = asoc_simple_card_parse_of(priv);
+		if (ret < 0) {
+			if (ret != -EPROBE_DEFER)
+				SND_LOG_ERR(HLOG, "parse error %d\n", ret);
+			goto err;
+		}
+
+	} else {
+		SND_LOG_ERR(HLOG, "simple card dts available\n");
+	}
+
+	snd_soc_card_set_drvdata(&priv->snd_card, priv);
+
+	/* asoc_simple_debug_info(priv); */
+	ret = devm_snd_soc_register_card(&pdev->dev, &priv->snd_card);
+	if (ret >= 0)
+		return ret;
+err:
+	asoc_simple_clean_reference(&priv->snd_card);
+
+	return ret;
+}
+
+static int asoc_simple_card_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+
+	return asoc_simple_clean_reference(card);
+}
+
+static const struct of_device_id snd_soc_sunxi_of_match[] = {
+	{ .compatible = "allwinner," DRV_NAME, },
+	{},
+};
+MODULE_DEVICE_TABLE(of, snd_soc_sunxi_of_match);
+
+static struct platform_driver sunxi_soundcard_machine_driver = {
+	.driver	= {
+		.name		= DRV_NAME,
+		.pm		= &snd_soc_pm_ops,
+		.of_match_table	= snd_soc_sunxi_of_match,
+	},
+	.probe	= asoc_simple_card_probe,
+	.remove	= asoc_simple_card_remove,
+};
+
+module_platform_driver(sunxi_soundcard_machine_driver);
+
+MODULE_AUTHOR("Dby@allwinnertech.com");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("sunxi soundcard machine");
diff --git a/sound/soc/sunxi_v2/snd_sunxi_mach.h b/sound/soc/sunxi_v2/snd_sunxi_mach.h
new file mode 100644
index 000000000..ab429c884
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_mach.h
@@ -0,0 +1,17 @@
+/* sound\soc\sunxi\snd_sunxi_mach.h
+ * (C) Copyright 2021-2025
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#ifndef __SND_SUNXI_MACH_H
+#define __SND_SUNXI_MACH_H
+
+#include "snd_sunxi_mach_utils.h"
+
+#endif /* __SND_SUNXI_MACH_H */
diff --git a/sound/soc/sunxi_v2/snd_sunxi_mach_utils.c b/sound/soc/sunxi_v2/snd_sunxi_mach_utils.c
new file mode 100644
index 000000000..2ac071500
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_mach_utils.c
@@ -0,0 +1,339 @@
+/*
+ * sound\soc\sunxi\snd_sunxi_mach_utils.c
+ * (C) Copyright 2021-2025
+ * AllWinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * based on ${LINUX}/sound/soc/generic/simple-card.c
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/of.h>
+#include <sound/soc.h>
+
+#include "snd_sunxi_log.h"
+#include "snd_sunxi_mach_utils.h"
+
+int asoc_simple_clean_reference(struct snd_soc_card *card)
+{
+	struct snd_soc_dai_link *dai_link;
+	int i;
+
+	for_each_card_prelinks(card, i, dai_link) {
+		of_node_put(dai_link->cpus->of_node);
+		of_node_put(dai_link->codecs->of_node);
+	}
+	return 0;
+}
+
+int asoc_simple_init_priv(struct asoc_simple_priv *priv,
+			  struct link_info *li)
+{
+	struct snd_soc_card *card = simple_priv_to_card(priv);
+	struct device *dev = simple_priv_to_dev(priv);
+	struct snd_soc_dai_link *dai_link;
+	struct simple_dai_props *dai_props;
+	struct asoc_simple_dai *dais;
+	struct snd_soc_codec_conf *cconf = NULL;
+	int i;
+
+	dai_props = devm_kcalloc(dev, li->link, sizeof(*dai_props), GFP_KERNEL);
+	dai_link  = devm_kcalloc(dev, li->link, sizeof(*dai_link),  GFP_KERNEL);
+	dais      = devm_kcalloc(dev, li->dais, sizeof(*dais),      GFP_KERNEL);
+	if (!dai_props || !dai_link || !dais)
+		return -ENOMEM;
+
+	if (li->conf) {
+		cconf = devm_kcalloc(dev, li->conf, sizeof(*cconf), GFP_KERNEL);
+		if (!cconf)
+			return -ENOMEM;
+	}
+
+	/*
+	 * Use snd_soc_dai_link_component instead of legacy style
+	 * It is codec only. but cpu/platform will be supported in the future.
+	 * see
+	 *	soc-core.c :: snd_soc_init_multicodec()
+	 *
+	 * "platform" might be removed
+	 * see
+	 *	simple-card-utils.c :: asoc_simple_canonicalize_platform()
+	 */
+	for (i = 0; i < li->link; i++) {
+		dai_link[i].cpus		= &dai_props[i].cpus;
+		dai_link[i].num_cpus		= 1;
+		dai_link[i].codecs		= &dai_props[i].codecs;
+		dai_link[i].num_codecs		= 1;
+		dai_link[i].platforms		= &dai_props[i].platforms;
+		dai_link[i].num_platforms	= 1;
+	}
+
+	priv->dai_props		= dai_props;
+	priv->dai_link		= dai_link;
+	priv->dais		= dais;
+	priv->codec_conf	= cconf;
+
+	card->dai_link		= priv->dai_link;
+	card->num_links		= li->link;
+	card->codec_conf	= cconf;
+	card->num_configs	= li->conf;
+
+	return 0;
+}
+
+int asoc_simple_parse_widgets(struct snd_soc_card *card,
+			      char *prefix)
+{
+	struct device_node *node = card->dev->of_node;
+	char prop[128];
+
+	if (!prefix)
+		prefix = "";
+
+	snprintf(prop, sizeof(prop), "%s%s", prefix, "widgets");
+
+	if (of_property_read_bool(node, prop))
+		return snd_soc_of_parse_audio_simple_widgets(card, prop);
+
+	/* no widgets is not error */
+	return 0;
+}
+
+int asoc_simple_parse_routing(struct snd_soc_card *card,
+			      char *prefix)
+{
+	struct device_node *node = card->dev->of_node;
+	char prop[128];
+
+	if (!prefix)
+		prefix = "";
+
+	snprintf(prop, sizeof(prop), "%s%s", prefix, "routing");
+
+	if (!of_property_read_bool(node, prop))
+		return 0;
+
+	return snd_soc_of_parse_audio_routing(card, prop);
+}
+
+int asoc_simple_parse_pin_switches(struct snd_soc_card *card,
+				   char *prefix)
+{
+	const unsigned int nb_controls_max = 16;
+	const char **strings, *control_name;
+	struct snd_kcontrol_new *controls;
+	struct device *dev = card->dev;
+	unsigned int i, nb_controls;
+	char prop[128];
+	int ret;
+
+	if (!prefix)
+		prefix = "";
+
+	snprintf(prop, sizeof(prop), "%s%s", prefix, "pin-switches");
+
+	if (!of_property_read_bool(dev->of_node, prop))
+		return 0;
+
+	strings = devm_kcalloc(dev, nb_controls_max,
+			       sizeof(*strings), GFP_KERNEL);
+	if (!strings)
+		return -ENOMEM;
+
+	ret = of_property_read_string_array(dev->of_node, prop,
+					    strings, nb_controls_max);
+	if (ret < 0)
+		return ret;
+
+	nb_controls = (unsigned int)ret;
+
+	controls = devm_kcalloc(dev, nb_controls,
+				sizeof(*controls), GFP_KERNEL);
+	if (!controls)
+		return -ENOMEM;
+
+	for (i = 0; i < nb_controls; i++) {
+		control_name = devm_kasprintf(dev, GFP_KERNEL,
+					      "%s Switch", strings[i]);
+		if (!control_name)
+			return -ENOMEM;
+
+		controls[i].iface = SNDRV_CTL_ELEM_IFACE_MIXER;
+		controls[i].name = control_name;
+		controls[i].info = snd_soc_dapm_info_pin_switch;
+		controls[i].get = snd_soc_dapm_get_pin_switch;
+		controls[i].put = snd_soc_dapm_put_pin_switch;
+		controls[i].private_value = (unsigned long)strings[i];
+	}
+
+	card->controls = controls;
+	card->num_controls = nb_controls;
+
+	return 0;
+}
+
+int asoc_simple_parse_daistream(struct device *dev,
+				struct device_node *node,
+				char *prefix,
+				struct snd_soc_dai_link *dai_link)
+{
+	char prop[128];
+	unsigned int dai_stream = 0;
+	unsigned int playback_only = BIT(0);
+	unsigned int capture_only = BIT(1);
+
+	if (!prefix)
+		prefix = "";
+
+	/* check "[prefix]playback_only" */
+	snprintf(prop, sizeof(prop), "%splayback_only", prefix);
+	if (of_property_read_bool(node, prop))
+		dai_stream |= playback_only;
+
+	/* check "[prefix]capture_only" */
+	snprintf(prop, sizeof(prop), "%scapture_only", prefix);
+	if (of_property_read_bool(node, prop))
+		dai_stream |= capture_only;
+
+	if (dai_stream == (playback_only | capture_only)) {
+		pr_err("unsupport stream\n");
+		dai_link->playback_only = 0;
+		dai_link->capture_only = 0;
+	} else if (dai_stream == playback_only) {
+		dai_link->playback_only = 1;
+	} else if (dai_stream == capture_only) {
+		dai_link->capture_only = 1;
+	} else {
+		dai_link->playback_only = 0;
+		dai_link->capture_only = 0;
+	}
+
+	return 0;
+}
+
+int asoc_simple_parse_daifmt(struct device *dev,
+			     struct device_node *node,
+			     struct device_node *codec,
+			     char *prefix,
+			     unsigned int *retfmt)
+{
+	struct device_node *bitclkmaster = NULL;
+	struct device_node *framemaster = NULL;
+	unsigned int daifmt;
+
+	daifmt = snd_soc_of_parse_daifmt(node, prefix,
+					 &bitclkmaster, &framemaster);
+	daifmt &= ~SND_SOC_DAIFMT_MASTER_MASK;
+
+	if (!bitclkmaster && !framemaster) {
+		/*
+		 * No dai-link level and master setting was not found from
+		 * sound node level, revert back to legacy DT parsing and
+		 * take the settings from codec node.
+		 */
+		dev_dbg(dev, "Revert to legacy daifmt parsing\n");
+
+		daifmt = snd_soc_of_parse_daifmt(codec, NULL, NULL, NULL) |
+			(daifmt & ~SND_SOC_DAIFMT_CLOCK_MASK);
+	} else {
+		if (codec == bitclkmaster)
+			daifmt |= (codec == framemaster) ?
+				SND_SOC_DAIFMT_CBM_CFM : SND_SOC_DAIFMT_CBM_CFS;
+		else
+			daifmt |= (codec == framemaster) ?
+				SND_SOC_DAIFMT_CBS_CFM : SND_SOC_DAIFMT_CBS_CFS;
+	}
+
+	of_node_put(bitclkmaster);
+	of_node_put(framemaster);
+
+	*retfmt = daifmt;
+
+	return 0;
+}
+
+int asoc_simple_parse_card_name(struct snd_soc_card *card,
+				char *prefix)
+{
+	int ret;
+
+	if (!prefix)
+		prefix = "";
+
+	/* Parse the card name from DT */
+	ret = snd_soc_of_parse_card_name(card, "label");
+	if (ret < 0 || !card->name) {
+		char prop[128];
+
+		snprintf(prop, sizeof(prop), "%sname", prefix);
+		ret = snd_soc_of_parse_card_name(card, prop);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (!card->name && card->dai_link)
+		card->name = card->dai_link->name;
+
+	return 0;
+}
+
+int asoc_simple_set_dailink_name(struct device *dev,
+				 struct snd_soc_dai_link *dai_link,
+				 const char *fmt, ...)
+{
+	va_list ap;
+	char *name = NULL;
+	int ret = -ENOMEM;
+
+	va_start(ap, fmt);
+	name = devm_kvasprintf(dev, GFP_KERNEL, fmt, ap);
+	va_end(ap);
+
+	if (name) {
+		ret = 0;
+
+		dai_link->name		= name;
+		dai_link->stream_name	= name;
+	}
+
+	return ret;
+}
+
+void asoc_simple_canonicalize_platform(struct snd_soc_dai_link *dai_link)
+{
+	/* Assumes platform == cpu */
+	if (!dai_link->platforms->of_node)
+		dai_link->platforms->of_node = dai_link->cpus->of_node;
+
+	/*
+	 * DPCM BE can be no platform.
+	 * Alloced memory will be waste, but not leak.
+	 */
+	if (!dai_link->platforms->of_node)
+		dai_link->num_platforms = 0;
+}
+
+void asoc_simple_canonicalize_cpu(struct snd_soc_dai_link *dai_link,
+				  int is_single_links)
+{
+	/*
+	 * In soc_bind_dai_link() will check cpu name after
+	 * of_node matching if dai_link has cpu_dai_name.
+	 * but, it will never match if name was created by
+	 * fmt_single_name() remove cpu_dai_name if cpu_args
+	 * was 0. See:
+	 *	fmt_single_name()
+	 *	fmt_multiple_name()
+	 */
+	if (is_single_links)
+		dai_link->cpus->dai_name = NULL;
+}
+
+MODULE_AUTHOR("Dby@allwinnertech.com");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("sunxi soundcard machine utils");
diff --git a/sound/soc/sunxi_v2/snd_sunxi_mach_utils.h b/sound/soc/sunxi_v2/snd_sunxi_mach_utils.h
new file mode 100644
index 000000000..4a11e266a
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_mach_utils.h
@@ -0,0 +1,113 @@
+/* sound\soc\sunxi\snd_sunxi_mach_utils.h
+ * (C) Copyright 2021-2025
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#ifndef __SND_SUNXI_MACH_UTILS_H
+#define __SND_SUNXI_MACH_UTILS_H
+
+#define simple_priv_to_card(priv)	(&(priv)->snd_card)
+#define simple_priv_to_props(priv, i)	((priv)->dai_props + (i))
+#define simple_priv_to_dev(priv)	(simple_priv_to_card(priv)->dev)
+#define simple_priv_to_link(priv, i)	(simple_priv_to_card(priv)->dai_link + (i))
+
+#define asoc_simple_parse_cpu(node, dai_link, is_single_link)	\
+	asoc_simple_parse_dai(node, dai_link->cpus, is_single_link)
+#define asoc_simple_parse_codec(node, dai_link)	\
+	asoc_simple_parse_dai(node, dai_link->codecs, NULL)
+#define asoc_simple_parse_platform(node, dai_link)	\
+	asoc_simple_parse_dai(node, dai_link->platforms, NULL)
+
+struct asoc_simple_dai {
+	const char *name;
+	unsigned int sysclk;
+	int clk_direction;
+	int slots;
+	int slot_width;
+	unsigned int tx_slot_mask;
+	unsigned int rx_slot_mask;
+	struct clk *clk;
+};
+
+struct asoc_simple_data {
+	u32 convert_rate;
+	u32 convert_channels;
+};
+
+struct asoc_simple_jack {
+	struct snd_soc_jack jack;
+	struct snd_soc_jack_pin pin;
+	struct snd_soc_jack_gpio gpio;
+};
+
+struct asoc_simple_priv {
+	struct snd_soc_card snd_card;
+	struct simple_dai_props {
+		struct asoc_simple_dai *cpu_dai;
+		struct asoc_simple_dai *codec_dai;
+		struct snd_soc_dai_link_component cpus;   /* single cpu */
+		struct snd_soc_dai_link_component codecs; /* single codec */
+		struct snd_soc_dai_link_component platforms;
+		struct asoc_simple_data adata;
+		struct snd_soc_codec_conf *codec_conf;
+		unsigned int mclk_fs;
+	} *dai_props;
+	struct asoc_simple_jack hp_jack;
+	struct asoc_simple_jack mic_jack;
+	struct snd_soc_dai_link *dai_link;
+	struct asoc_simple_dai *dais;
+	struct snd_soc_codec_conf *codec_conf;
+	struct gpio_desc *pa_gpio;
+};
+
+struct link_info {
+	int dais; /* number of dai  */
+	int link; /* number of link */
+	int conf; /* number of codec_conf */
+	int cpu;  /* turn for CPU / Codec */
+};
+
+int asoc_simple_clean_reference(struct snd_soc_card *card);
+int asoc_simple_init_priv(struct asoc_simple_priv *priv,
+			  struct link_info *li);
+
+int asoc_simple_parse_widgets(struct snd_soc_card *card,
+			      char *prefix);
+int asoc_simple_parse_routing(struct snd_soc_card *card,
+			      char *prefix);
+int asoc_simple_parse_pin_switches(struct snd_soc_card *card,
+				   char *prefix);
+
+int asoc_simple_parse_daistream(struct device *dev,
+				struct device_node *node,
+				char *prefix,
+				struct snd_soc_dai_link *dai_link);
+int asoc_simple_parse_daifmt(struct device *dev,
+			     struct device_node *node,
+			     struct device_node *codec,
+			     char *prefix,
+			     unsigned int *retfmt);
+int asoc_simple_card_parse_dai(struct device_node *node,
+			       struct device_node **dai_of_node,
+			       const char **dai_name,
+			       const char *list_name,
+			       const char *cells_name,
+			       int *is_single_link);
+
+int asoc_simple_parse_card_name(struct snd_soc_card *card,
+				char *prefix);
+int asoc_simple_set_dailink_name(struct device *dev,
+				 struct snd_soc_dai_link *dai_link,
+				 const char *fmt, ...);
+
+void asoc_simple_canonicalize_platform(struct snd_soc_dai_link *dai_link);
+void asoc_simple_canonicalize_cpu(struct snd_soc_dai_link *dai_link,
+				  int is_single_links);
+
+#endif /* __SND_SUNXI_MACH_UTILS_H */
diff --git a/sound/soc/sunxi_v2/snd_sunxi_pcm.c b/sound/soc/sunxi_v2/snd_sunxi_pcm.c
new file mode 100644
index 000000000..473021d05
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_pcm.c
@@ -0,0 +1,416 @@
+/*
+ * sound\soc\sunxi\snd_sunxi_pcm.c
+ * (C) Copyright 2021-2025
+ * AllWinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/dma-mapping.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/dmaengine_pcm.h>
+
+#include "snd_sunxi_log.h"
+#include "snd_sunxi_pcm.h"
+
+#define HLOG				"PCM"
+#define SUNXI_DMAENGINE_PCM_DRV_NAME	"sunxi_dmaengine_pcm"
+
+static u64 g_sunxi_pcm_mask = DMA_BIT_MASK(32);
+
+static struct snd_pcm_hardware sunxi_pcm_hardware = {
+	.info			= SNDRV_PCM_INFO_INTERLEAVED
+				| SNDRV_PCM_INFO_BLOCK_TRANSFER
+				| SNDRV_PCM_INFO_MMAP
+				| SNDRV_PCM_INFO_MMAP_VALID
+				| SNDRV_PCM_INFO_PAUSE
+				| SNDRV_PCM_INFO_RESUME,
+	.formats		= SNDRV_PCM_FMTBIT_S8
+				| SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S20_3LE
+				| SNDRV_PCM_FMTBIT_S24_LE
+				| SNDRV_PCM_FMTBIT_S32_LE,
+	.rates			= SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+	.rate_min		= 8000,
+	.rate_max		= 192000,
+	.channels_min		= 1,
+	.channels_max		= 8,
+	/* value must be (2^n)Kbyte */
+	.buffer_bytes_max	= SUNXI_AUDIO_CMA_MAX_BYTES,
+	.period_bytes_min	= 256,
+	.period_bytes_max	= SUNXI_AUDIO_CMA_MAX_BYTES / 2,
+	.periods_min		= 1,
+	.periods_max		= 8,
+	.fifo_size		= 128,
+};
+
+static const char * const dmaengine_pcm_dma_channel_names[] = {
+	[SNDRV_PCM_STREAM_PLAYBACK] = "tx",
+	[SNDRV_PCM_STREAM_CAPTURE] = "rx",
+};
+
+static int sunxi_pcm_open(struct snd_pcm_substream *substream)
+{
+	int ret = 0;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_component *component = snd_soc_rtdcom_lookup(rtd, SUNXI_DMAENGINE_PCM_DRV_NAME);
+	struct device *dev = component->dev;
+	struct sunxi_dma_params *dma_params = NULL;
+	struct dma_chan *chan;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	/* Set HW params now that initialization is complete */
+	dma_params = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
+	sunxi_pcm_hardware.buffer_bytes_max = dma_params->cma_kbytes * SUNXI_AUDIO_CMA_BLOCK_BYTES;
+	sunxi_pcm_hardware.period_bytes_max = sunxi_pcm_hardware.buffer_bytes_max / 2;
+	sunxi_pcm_hardware.fifo_size	    = dma_params->fifo_size;
+	snd_soc_set_runtime_hwparams(substream, &sunxi_pcm_hardware);
+	ret = snd_pcm_hw_constraint_integer(substream->runtime,
+					    SNDRV_PCM_HW_PARAM_PERIODS);
+	if (ret < 0) {
+		SND_LOG_ERR(HLOG, "constraint_integer failed, err %d\n", ret);
+		return ret;
+	}
+
+	chan = dma_request_chan(dev, dmaengine_pcm_dma_channel_names[substream->stream]);
+	if (IS_ERR(chan)) {
+		SND_LOG_ERR(HLOG, "DMA channels request %s failed, err -> %d.\n",
+			    dmaengine_pcm_dma_channel_names[substream->stream],
+			    IS_ERR(chan));
+		return -EINVAL;
+	}
+
+	ret = snd_dmaengine_pcm_open(substream, chan);
+	if (ret < 0) {
+		SND_LOG_ERR(HLOG, "dmaengine pcm open failed with err %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int sunxi_pcm_close(struct snd_pcm_substream *substream)
+{
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	return snd_dmaengine_pcm_close_release_chan(substream);
+}
+
+
+static int sunxi_pcm_ioctl(struct snd_pcm_substream *substream,
+			   unsigned int cmd, void *arg)
+{
+	SND_LOG_DEBUG(HLOG, "cmd -> %u\n", cmd);
+
+	return snd_pcm_lib_ioctl(substream, cmd, arg);
+}
+
+static int sunxi_pcm_hw_params(struct snd_pcm_substream *substream,
+			       struct snd_pcm_hw_params *params)
+{
+	struct sunxi_dma_params *dma_params;
+	struct dma_slave_config slave_config;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct dma_chan *chan;
+	int ret;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	dma_params = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);
+
+	ret = snd_hwparams_to_dma_slave_config(substream, params, &slave_config);
+	if (ret) {
+		SND_LOG_ERR(HLOG, "hw params config failed, err %d\n", ret);
+		return ret;
+	}
+
+	slave_config.dst_maxburst = dma_params->dst_maxburst;
+	slave_config.src_maxburst = dma_params->src_maxburst;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		slave_config.dst_addr = dma_params->dma_addr;
+		slave_config.src_addr_width = slave_config.dst_addr_width;
+	} else {
+		slave_config.src_addr =	dma_params->dma_addr;
+		slave_config.dst_addr_width = slave_config.src_addr_width;
+	}
+
+	chan = snd_dmaengine_pcm_get_chan(substream);
+	if (chan == NULL) {
+		SND_LOG_ERR(HLOG, "dma pcm get chan failed! chan is NULL\n");
+		return -EINVAL;
+	}
+	ret = dmaengine_slave_config(chan, &slave_config);
+	if (ret < 0) {
+		SND_LOG_ERR(HLOG, "dma slave config failed, err %d\n", ret);
+		return ret;
+	}
+
+	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+
+	return 0;
+}
+
+static int sunxi_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	snd_pcm_set_runtime_buffer(substream, NULL);
+
+	return 0;
+}
+
+static int sunxi_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	SND_LOG_DEBUG(HLOG, "cmd -> %d\n", cmd);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		switch (cmd) {
+		case SNDRV_PCM_TRIGGER_START:
+		case SNDRV_PCM_TRIGGER_RESUME:
+		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+			snd_dmaengine_pcm_trigger(substream,
+						  SNDRV_PCM_TRIGGER_START);
+		break;
+		case SNDRV_PCM_TRIGGER_SUSPEND:
+		case SNDRV_PCM_TRIGGER_STOP:
+		case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+			snd_dmaengine_pcm_trigger(substream,
+						  SNDRV_PCM_TRIGGER_STOP);
+		break;
+		default:
+			SND_LOG_ERR(HLOG, "unsupport trigger -> %d\n", cmd);
+			return -1;
+		break;
+		}
+	} else {
+		switch (cmd) {
+		case SNDRV_PCM_TRIGGER_START:
+		case SNDRV_PCM_TRIGGER_RESUME:
+		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+			snd_dmaengine_pcm_trigger(substream,
+						  SNDRV_PCM_TRIGGER_START);
+		break;
+		case SNDRV_PCM_TRIGGER_SUSPEND:
+		case SNDRV_PCM_TRIGGER_STOP:
+		case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+			snd_dmaengine_pcm_trigger(substream,
+						  SNDRV_PCM_TRIGGER_STOP);
+		break;
+		default:
+			SND_LOG_ERR(HLOG, "unsupport trigger -> %d\n", cmd);
+			return -1;
+		break;
+		}
+	}
+
+	return 0;
+}
+
+snd_pcm_uframes_t sunxi_pcm_pointer(struct snd_pcm_substream *substream)
+{
+	return snd_dmaengine_pcm_pointer(substream);
+}
+
+static int sunxi_pcm_mmap(struct snd_pcm_substream *substream,
+			  struct vm_area_struct *vma)
+{
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	if (substream->runtime == NULL) {
+		SND_LOG_ERR(HLOG, "substream->runtime is null\n");
+		return -EFAULT;
+	}
+
+	return dma_mmap_wc(substream->pcm->card->dev, vma,
+			   substream->runtime->dma_area,
+			   substream->runtime->dma_addr,
+			   substream->runtime->dma_bytes);
+}
+
+static struct snd_pcm_ops sunxi_pcm_ops = {
+	.open		= sunxi_pcm_open,
+	.close		= sunxi_pcm_close,
+	.ioctl		= sunxi_pcm_ioctl,
+	.hw_params	= sunxi_pcm_hw_params,
+	.hw_free	= sunxi_pcm_hw_free,
+	.trigger	= sunxi_pcm_trigger,
+	.pointer	= sunxi_pcm_pointer,
+	.mmap		= sunxi_pcm_mmap,
+};
+
+static int sunxi_pcm_preallocate_dma_buffer(struct snd_pcm *pcm,
+					    int stream,
+					    size_t buffer_bytes_max)
+{
+	struct snd_dma_buffer *buf = NULL;
+	struct snd_pcm_str *streams = NULL;
+	struct snd_pcm_substream *substream = NULL;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	streams = &pcm->streams[stream];
+	if (IS_ERR_OR_NULL(streams)) {
+		SND_LOG_ERR(HLOG, "stream=%d streams is null!\n", stream);
+		return -EFAULT;
+	}
+	substream = pcm->streams[stream].substream;
+	if (IS_ERR_OR_NULL(substream)) {
+		SND_LOG_ERR(HLOG, "stream=%d substreams is null!\n", stream);
+		return -EFAULT;
+	}
+
+	buf = &substream->dma_buffer;
+	buf->dev.type = SNDRV_DMA_TYPE_DEV;
+	buf->dev.dev = pcm->card->dev;
+	buf->private_data = NULL;
+	if (buffer_bytes_max > SUNXI_AUDIO_CMA_MAX_BYTES) {
+		buffer_bytes_max = SUNXI_AUDIO_CMA_MAX_BYTES;
+		SND_LOG_WARN(HLOG, "buffer_bytes_max too max, set %lu\n",
+			     buffer_bytes_max);
+	}
+	if (buffer_bytes_max < SUNXI_AUDIO_CMA_MIN_BYTES) {
+		buffer_bytes_max = SUNXI_AUDIO_CMA_MIN_BYTES;
+		SND_LOG_WARN(HLOG, "buffer_bytes_max too min, set %lu\n",
+			     buffer_bytes_max);
+	}
+
+	buf->area = dma_alloc_coherent(pcm->card->dev, buffer_bytes_max,
+				       &buf->addr, GFP_KERNEL);
+	if (!buf->area) {
+		SND_LOG_ERR(HLOG, "dmaengine alloc coherent failed.\n");
+		return -ENOMEM;
+	}
+	buf->bytes = buffer_bytes_max;
+
+	return 0;
+}
+
+static void sunxi_pcm_free_dma_buffer(struct snd_pcm *pcm, int stream)
+{
+	struct snd_dma_buffer *buf;
+	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	if (IS_ERR_OR_NULL(substream)) {
+		SND_LOG_WARN(HLOG, "stream=%d streams is null!\n", stream);
+		return;
+	}
+
+	buf = &substream->dma_buffer;
+	if (!buf->area) {
+		SND_LOG_WARN(HLOG, "stream=%d buf->area is null!\n", stream);
+		return;
+	}
+
+	dma_free_coherent(pcm->card->dev, buf->bytes, buf->area, buf->addr);
+	buf->area = NULL;
+}
+
+static int sunxi_pcm_new(struct snd_soc_pcm_runtime *rtd)
+{
+	int ret;
+
+	struct snd_pcm *pcm = rtd->pcm;
+	struct snd_card *card = rtd->card->snd_card;
+	struct snd_soc_dai_link *dai_link = rtd->dai_link;
+
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct sunxi_dma_params *capture_dma_data  = cpu_dai->capture_dma_data;
+	struct sunxi_dma_params *playback_dma_data = cpu_dai->playback_dma_data;
+	size_t capture_cma_bytes  = SUNXI_AUDIO_CMA_BLOCK_BYTES;
+	size_t playback_cma_bytes = SUNXI_AUDIO_CMA_BLOCK_BYTES;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &g_sunxi_pcm_mask;
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = 0xffffffff;
+
+	if (!IS_ERR_OR_NULL(capture_dma_data))
+		capture_cma_bytes *= capture_dma_data->cma_kbytes;
+	if (!IS_ERR_OR_NULL(playback_dma_data))
+		playback_cma_bytes *= playback_dma_data->cma_kbytes;
+
+	if (dai_link->capture_only) {
+		ret = sunxi_pcm_preallocate_dma_buffer(pcm,
+				SNDRV_PCM_STREAM_CAPTURE, capture_cma_bytes);
+		if (ret) {
+			SND_LOG_ERR(HLOG, "pcm new capture failed, err=%d\n", ret);
+			return ret;
+		}
+	} else if (dai_link->playback_only) {
+		ret = sunxi_pcm_preallocate_dma_buffer(pcm,
+				SNDRV_PCM_STREAM_PLAYBACK, playback_cma_bytes);
+		if (ret) {
+			SND_LOG_ERR(HLOG, "pcm new playback failed, err=%d\n", ret);
+			return ret;
+		}
+	} else {
+		ret = sunxi_pcm_preallocate_dma_buffer(pcm,
+				SNDRV_PCM_STREAM_CAPTURE, capture_cma_bytes);
+		if (ret) {
+			SND_LOG_ERR(HLOG, "pcm new capture failed, err=%d\n", ret);
+			goto err_pcm_prealloc_capture_buffer;
+		}
+		ret = sunxi_pcm_preallocate_dma_buffer(pcm,
+				SNDRV_PCM_STREAM_PLAYBACK, playback_cma_bytes);
+		if (ret) {
+			SND_LOG_ERR(HLOG, "pcm new playback failed, err=%d\n", ret);
+			goto err_pcm_prealloc_playback_buffer;
+		}
+	}
+
+	return 0;
+
+err_pcm_prealloc_playback_buffer:
+	sunxi_pcm_free_dma_buffer(pcm, SNDRV_PCM_STREAM_CAPTURE);
+err_pcm_prealloc_capture_buffer:
+	return ret;
+}
+
+static void sunxi_pcm_free(struct snd_pcm *pcm)
+{
+	int stream;
+
+	SND_LOG_DEBUG(HLOG, "\n");
+
+	for (stream = 0; stream < SNDRV_PCM_STREAM_LAST; stream++) {
+		sunxi_pcm_free_dma_buffer(pcm, stream);
+	}
+}
+
+static struct snd_soc_component_driver sunxi_soc_platform = {
+	.name		= SUNXI_DMAENGINE_PCM_DRV_NAME,
+	.ops		= &sunxi_pcm_ops,
+	.pcm_new	= sunxi_pcm_new,
+	.pcm_free	= sunxi_pcm_free,
+};
+
+int snd_soc_sunxi_dma_platform_register(struct device *dev)
+{
+	SND_LOG_DEBUG(HLOG, "\n");
+	return snd_soc_register_component(dev, &sunxi_soc_platform, NULL, 0);
+}
+EXPORT_SYMBOL_GPL(snd_soc_sunxi_dma_platform_register);
+
+void snd_soc_sunxi_dma_platform_unregister(struct device *dev)
+{
+	SND_LOG_DEBUG(HLOG, "\n");
+	snd_soc_unregister_component(dev);
+}
+EXPORT_SYMBOL_GPL(snd_soc_sunxi_dma_platform_unregister);
+
+MODULE_AUTHOR("Dby@allwinnertech.com");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("sunxi ASoC DMA driver");
diff --git a/sound/soc/sunxi_v2/snd_sunxi_pcm.h b/sound/soc/sunxi_v2/snd_sunxi_pcm.h
new file mode 100644
index 000000000..5e38ec4c8
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_pcm.h
@@ -0,0 +1,38 @@
+/* sound\soc\sunxi\snd_sunxi_pcm.h
+ * (C) Copyright 2021-2025
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#ifndef __SND_SUNXI_PCM_H
+#define __SND_SUNXI_PCM_H
+
+#define SUNXI_AUDIO_CMA_BLOCK_BYTES	1024
+#define SUNXI_AUDIO_CMA_MAX_KBYTES	1024
+#define SUNXI_AUDIO_CMA_MIN_KBYTES	64
+#define SUNXI_AUDIO_CMA_MAX_BYTES	(SUNXI_AUDIO_CMA_BLOCK_BYTES * SUNXI_AUDIO_CMA_MAX_KBYTES)
+#define SUNXI_AUDIO_CMA_MIN_BYTES	(SUNXI_AUDIO_CMA_BLOCK_BYTES * SUNXI_AUDIO_CMA_MIN_KBYTES)
+
+#define SUNXI_AUDIO_FIFO_SIZE		128
+
+struct sunxi_dma_params {
+	char *name;
+	dma_addr_t dma_addr;
+	u8 src_maxburst;
+	u8 dst_maxburst;
+	u8 dma_drq_type_num;
+
+	/* max buffer set (value must be (2^n)Kbyte) */
+	unsigned int cma_kbytes;
+	unsigned int fifo_size;
+};
+
+extern int snd_soc_sunxi_dma_platform_register(struct device *dev);
+extern void snd_soc_sunxi_dma_platform_unregister(struct device *dev);
+
+#endif /* __SND_SUNXI_PCM_H */
diff --git a/sound/soc/sunxi_v2/snd_sunxi_spdif.c b/sound/soc/sunxi_v2/snd_sunxi_spdif.c
new file mode 100644
index 000000000..099123320
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_spdif.c
@@ -0,0 +1,157 @@
+/*
+ * sound\soc\sunxi\snd_sunxi_spdif.c
+ * (C) Copyright 2021-2025
+ * AllWinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <sound/soc.h>
+
+#include "snd_sunxi_log.h"
+#include "snd_sunxi_pcm.h"
+#include "snd_sunxi_spdif.h"
+
+static int sunxi_spdif_dai_hw_params(struct snd_pcm_substream *substream,
+				     struct snd_pcm_hw_params *params,
+				     struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static int sunxi_spdif_dai_set_sysclk(struct snd_soc_dai *dai,
+				      int clk_id,
+				      unsigned int freq,
+				      int dir)
+{
+	return 0;
+}
+
+static int sunxi_spdif_dai_trigger(struct snd_pcm_substream *substream,
+				   int cmd,
+				   struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static int sunxi_spdif_dai_prepare(struct snd_pcm_substream *substream,
+				   struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static const struct snd_soc_dai_ops sunxi_spdif_dai_ops = {
+	.hw_params	= sunxi_spdif_dai_hw_params,
+	.set_sysclk	= sunxi_spdif_dai_set_sysclk,
+	.trigger	= sunxi_spdif_dai_trigger,
+	.prepare	= sunxi_spdif_dai_prepare,
+};
+
+static struct snd_soc_dai_driver sunxi_spdif_dai = {
+	.playback = {
+		.stream_name	= "Playback",
+		.channels_min	= 1,
+		.channels_max	= 2,
+		.rates		= SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+		.formats	= SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE,
+	},
+	.capture = {
+		.stream_name	= "Capture",
+		.channels_min	= 1,
+		.channels_max	= 2,
+		.rates		= SNDRV_PCM_RATE_8000_192000
+			| SNDRV_PCM_RATE_KNOT,
+		.formats	= SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE,
+	},
+	.ops = &sunxi_spdif_dai_ops,
+};
+
+static int sunxi_spdif_probe(struct snd_soc_component *component)
+{
+	return 0;
+}
+
+static int sunxi_spdif_suspend(struct snd_soc_component *component)
+{
+	return 0;
+}
+
+static int sunxi_spdif_resume(struct snd_soc_component *component)
+{
+	return 0;
+}
+
+static struct snd_soc_component_driver sunxi_spdif_dev = {
+	.probe		= sunxi_spdif_probe,
+	.suspend	= sunxi_spdif_suspend,
+	.resume		= sunxi_spdif_resume,
+};
+
+static int sunxi_spdif_dev_probe(struct platform_device *pdev)
+{
+	int ret;
+
+	ret = snd_soc_register_component(&pdev->dev,
+					 &sunxi_spdif_dev,
+					 &sunxi_spdif_dai, 1);
+	if (ret) {
+		SND_LOG_ERR("component register failed\n");
+		ret = -ENOMEM;
+		goto err_snd_soc_register_component;
+	}
+
+	ret = snd_soc_sunxi_dma_platform_register(&pdev->dev);
+	if (ret) {
+		SND_LOG_ERR("register ASoC platform failed\n");
+		ret = -ENOMEM;
+		goto err_snd_soc_sunxi_dma_platform_register;
+	}
+
+	SND_LOG_INFO("register spdif platform success\n");
+
+	return 0;
+
+err_snd_soc_sunxi_dma_platform_register:
+	snd_soc_unregister_component(&pdev->dev);
+err_snd_soc_register_component:
+	return ret;
+}
+
+static int sunxi_spdif_dev_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_component(&pdev->dev);
+
+	SND_LOG_INFO("unregister spdif platform success\n");
+
+	return 0;
+}
+
+static const struct of_device_id sunxi_spdif_of_match[] = {
+	{ .compatible = "allwinner,sunxi-snd-plat-spdif", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, sunxi_spdif_of_match);
+
+static struct platform_driver sunxi_spdif_driver = {
+	.driver	= {
+		.name		= "sunxi-snd-plat-spdif",
+		.owner		= THIS_MODULE,
+		.of_match_table	= sunxi_spdif_of_match,
+	},
+	.probe	= sunxi_spdif_dev_probe,
+	.remove	= sunxi_spdif_dev_remove,
+};
+
+module_platform_driver(sunxi_spdif_driver);
+
+MODULE_AUTHOR("Dby@allwinnertech.com");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("sunxi soundcard platform of spdif");
diff --git a/sound/soc/sunxi_v2/snd_sunxi_spdif.h b/sound/soc/sunxi_v2/snd_sunxi_spdif.h
new file mode 100644
index 000000000..7ddec2987
--- /dev/null
+++ b/sound/soc/sunxi_v2/snd_sunxi_spdif.h
@@ -0,0 +1,16 @@
+/* sound\soc\sunxi\snd_sunxi_spdif.h
+ * (C) Copyright 2021-2025
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Dby <dby@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#ifndef __SND_SUNXI_SPDIF_H
+#define __SND_SUNXI_SPDIF_H
+
+
+#endif /* __SND_SUNXI_SPDIF_H */
diff --git a/sound/usb/card.c b/sound/usb/card.c
index 230d862cf..416e49588 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -106,6 +106,185 @@ static DEFINE_MUTEX(register_mutex);
 static struct snd_usb_audio *usb_chip[SNDRV_CARDS];
 static struct usb_driver usb_audio_driver;
 
+static struct snd_usb_audio_vendor_ops *usb_vendor_ops;
+
+int snd_vendor_set_ops(struct snd_usb_audio_vendor_ops *ops)
+{
+	if ((!ops->connect) ||
+	    (!ops->disconnect) ||
+	    (!ops->set_interface) ||
+	    (!ops->set_rate) ||
+	    (!ops->set_pcm_buf) ||
+	    (!ops->set_pcm_intf) ||
+	    (!ops->set_pcm_connection) ||
+	    (!ops->set_pcm_binterval) ||
+	    (!ops->usb_add_ctls))
+		return -EINVAL;
+
+	usb_vendor_ops = ops;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_vendor_set_ops);
+
+struct snd_usb_audio_vendor_ops *snd_vendor_get_ops(void)
+{
+	return usb_vendor_ops;
+}
+
+static int snd_vendor_connect(struct usb_interface *intf)
+{
+	struct snd_usb_audio_vendor_ops *ops = snd_vendor_get_ops();
+
+	if (ops)
+		return ops->connect(intf);
+	return 0;
+}
+
+static void snd_vendor_disconnect(struct usb_interface *intf)
+{
+	struct snd_usb_audio_vendor_ops *ops = snd_vendor_get_ops();
+
+	if (ops)
+		ops->disconnect(intf);
+}
+
+int snd_vendor_set_interface(struct usb_device *udev,
+			     struct usb_host_interface *intf,
+			     int iface, int alt)
+{
+	struct snd_usb_audio_vendor_ops *ops = snd_vendor_get_ops();
+
+	if (ops)
+		return ops->set_interface(udev, intf, iface, alt);
+	return 0;
+}
+
+int snd_vendor_set_rate(struct usb_interface *intf, int iface, int rate,
+			int alt)
+{
+	struct snd_usb_audio_vendor_ops *ops = snd_vendor_get_ops();
+
+	if (ops)
+		return ops->set_rate(intf, iface, rate, alt);
+	return 0;
+}
+
+int snd_vendor_set_pcm_buf(struct usb_device *udev, int iface)
+{
+	struct snd_usb_audio_vendor_ops *ops = snd_vendor_get_ops();
+
+	if (ops)
+		ops->set_pcm_buf(udev, iface);
+	return 0;
+}
+
+int snd_vendor_set_pcm_intf(struct usb_interface *intf, int iface, int alt,
+			    int direction)
+{
+	struct snd_usb_audio_vendor_ops *ops = snd_vendor_get_ops();
+
+	if (ops)
+		return ops->set_pcm_intf(intf, iface, alt, direction);
+	return 0;
+}
+
+int snd_vendor_set_pcm_connection(struct usb_device *udev,
+				  enum snd_vendor_pcm_open_close onoff,
+				  int direction)
+{
+	struct snd_usb_audio_vendor_ops *ops = snd_vendor_get_ops();
+
+	if (ops)
+		return ops->set_pcm_connection(udev, onoff, direction);
+	return 0;
+}
+
+int snd_vendor_set_pcm_binterval(struct audioformat *fp,
+				 struct audioformat *found,
+				 int *cur_attr, int *attr)
+{
+	struct snd_usb_audio_vendor_ops *ops = snd_vendor_get_ops();
+
+	if (ops)
+		return ops->set_pcm_binterval(fp, found, cur_attr, attr);
+	return 0;
+}
+
+static int snd_vendor_usb_add_ctls(struct snd_usb_audio *chip)
+{
+	struct snd_usb_audio_vendor_ops *ops = snd_vendor_get_ops();
+
+	if (ops)
+		return ops->usb_add_ctls(chip);
+	return 0;
+}
+
+struct snd_usb_substream *find_snd_usb_substream(unsigned int card_num,
+	unsigned int pcm_idx, unsigned int direction, struct snd_usb_audio
+	**uchip, void (*disconnect_cb)(struct snd_usb_audio *chip))
+{
+	int idx;
+	struct snd_usb_stream *as;
+	struct snd_usb_substream *subs = NULL;
+	struct snd_usb_audio *chip = NULL;
+
+	mutex_lock(&register_mutex);
+	/*
+	 * legacy audio snd card number assignment is dynamic. Hence
+	 * search using chip->card->number
+	 */
+	for (idx = 0; idx < SNDRV_CARDS; idx++) {
+		if (!usb_chip[idx])
+			continue;
+		if (usb_chip[idx]->card->number == card_num) {
+			chip = usb_chip[idx];
+			break;
+		}
+	}
+
+	if (!chip || atomic_read(&chip->shutdown)) {
+		pr_debug("%s: instance of usb crad # %d does not exist\n",
+			__func__, card_num);
+		goto err;
+	}
+
+	if (pcm_idx >= chip->pcm_devs) {
+		pr_err("%s: invalid pcm dev number %u > %d\n", __func__,
+			pcm_idx, chip->pcm_devs);
+		goto err;
+	}
+
+	if (direction > SNDRV_PCM_STREAM_CAPTURE) {
+		pr_err("%s: invalid direction %u\n", __func__, direction);
+		goto err;
+	}
+
+	list_for_each_entry(as, &chip->pcm_list, list) {
+		if (as->pcm_index == pcm_idx) {
+			subs = &as->substream[direction];
+			if (subs->interface < 0 && !subs->data_endpoint &&
+				!subs->sync_endpoint) {
+				pr_debug("%s: stream disconnected, bail out\n",
+					__func__);
+				subs = NULL;
+				goto err;
+			}
+			goto done;
+		}
+	}
+
+done:
+	chip->card_num = card_num;
+	chip->disconnect_cb = disconnect_cb;
+err:
+	*uchip = chip;
+	if (!subs)
+		pr_debug("%s: substream instance not found\n", __func__);
+	mutex_unlock(&register_mutex);
+	return subs;
+}
+EXPORT_SYMBOL_GPL(find_snd_usb_substream);
+
 /*
  * disconnect streams
  * called from usb_audio_disconnect()
@@ -341,6 +520,7 @@ static void snd_usb_audio_free(struct snd_card *card)
 	list_for_each_entry_safe(ep, n, &chip->ep_list, list)
 		snd_usb_endpoint_free(ep);
 
+	mutex_destroy(&chip->dev_lock);
 	mutex_destroy(&chip->mutex);
 	if (!atomic_read(&chip->shutdown))
 		dev_set_drvdata(&chip->dev->dev, NULL);
@@ -468,6 +648,7 @@ static int snd_usb_audio_create(struct usb_interface *intf,
 
 	chip = card->private_data;
 	mutex_init(&chip->mutex);
+	mutex_init(&chip->dev_lock);
 	init_waitqueue_head(&chip->shutdown_wait);
 	chip->index = idx;
 	chip->dev = dev;
@@ -577,6 +758,10 @@ static int usb_audio_probe(struct usb_interface *intf,
 	if (err < 0)
 		return err;
 
+	err = snd_vendor_connect(intf);
+	if (err)
+		return err;
+
 	/*
 	 * found a config.  now register to ALSA
 	 */
@@ -632,6 +817,8 @@ static int usb_audio_probe(struct usb_interface *intf,
 	}
 	dev_set_drvdata(&dev->dev, chip);
 
+	snd_vendor_usb_add_ctls(chip);
+
 	/*
 	 * For devices with more than one control interface, we assume the
 	 * first contains the audio controls. We might need a more specific
@@ -708,6 +895,11 @@ static void usb_audio_disconnect(struct usb_interface *intf)
 
 	card = chip->card;
 
+	if (chip->disconnect_cb)
+		chip->disconnect_cb(chip);
+
+	snd_vendor_disconnect(intf);
+
 	mutex_lock(&register_mutex);
 	if (atomic_inc_return(&chip->shutdown) == 1) {
 		struct snd_usb_stream *as;
diff --git a/sound/usb/card.h b/sound/usb/card.h
index d8ec5caf4..e1fa9d1ed 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -2,6 +2,8 @@
 #ifndef __USBAUDIO_CARD_H
 #define __USBAUDIO_CARD_H
 
+#include <linux/android_kabi.h>
+
 #define MAX_NR_RATES	1024
 #define MAX_PACKS	6		/* per URB */
 #define MAX_PACKS_HS	(MAX_PACKS * 8)	/* in high speed mode */
@@ -108,6 +110,11 @@ struct snd_usb_endpoint {
 
 	spinlock_t lock;
 	struct list_head list;
+
+	ANDROID_KABI_RESERVE(1);
+	ANDROID_KABI_RESERVE(2);
+	ANDROID_KABI_RESERVE(3);
+	ANDROID_KABI_RESERVE(4);
 };
 
 struct media_ctl;
@@ -133,7 +140,6 @@ struct snd_usb_substream {
 	unsigned int tx_length_quirk:1;	/* add length specifier to transfers */
 	unsigned int fmt_type;		/* USB audio format type (1-3) */
 	unsigned int pkt_offset_adj;	/* Bytes to drop from beginning of packets (for non-compliant devices) */
-	unsigned int stream_offset_adj;	/* Bytes to drop from beginning of stream (for non-compliant devices) */
 
 	unsigned int running: 1;	/* running status */
 
@@ -178,4 +184,25 @@ struct snd_usb_stream {
 	struct list_head list;
 };
 
+struct snd_usb_substream *find_snd_usb_substream(unsigned int card_num,
+	unsigned int pcm_idx, unsigned int direction, struct snd_usb_audio
+	**uchip, void (*disconnect_cb)(struct snd_usb_audio *chip));
+
+int snd_vendor_set_ops(struct snd_usb_audio_vendor_ops *vendor_ops);
+struct snd_usb_audio_vendor_ops *snd_vendor_get_ops(void);
+int snd_vendor_set_interface(struct usb_device *udev,
+			     struct usb_host_interface *alts,
+			     int iface, int alt);
+int snd_vendor_set_rate(struct usb_interface *intf, int iface, int rate,
+			int alt);
+int snd_vendor_set_pcm_buf(struct usb_device *udev, int iface);
+int snd_vendor_set_pcm_intf(struct usb_interface *intf, int iface, int alt,
+			    int direction);
+int snd_vendor_set_pcm_connection(struct usb_device *udev,
+				  enum snd_vendor_pcm_open_close onoff,
+				  int direction);
+int snd_vendor_set_pcm_binterval(struct audioformat *fp,
+				 struct audioformat *found,
+				 int *cur_attr, int *attr);
+
 #endif /* __USBAUDIO_CARD_H */
diff --git a/sound/usb/clock.c b/sound/usb/clock.c
index b118cf976..9a97d7876 100644
--- a/sound/usb/clock.c
+++ b/sound/usb/clock.c
@@ -642,8 +642,13 @@ static int set_sample_rate_v2v3(struct snd_usb_audio *chip, int iface,
 	 * interface is active. */
 	if (rate != prev_rate) {
 		usb_set_interface(dev, iface, 0);
+
+		snd_vendor_set_interface(dev, alts, iface, 0);
+
 		snd_usb_set_interface_quirk(dev);
 		usb_set_interface(dev, iface, fmt->altsetting);
+
+		snd_vendor_set_interface(dev, alts, iface, fmt->altsetting);
 		snd_usb_set_interface_quirk(dev);
 	}
 
diff --git a/sound/usb/pcm.c b/sound/usb/pcm.c
index 7b41f9748..c485b3b8c 100644
--- a/sound/usb/pcm.c
+++ b/sound/usb/pcm.c
@@ -134,6 +134,71 @@ static struct audioformat *find_format(struct snd_usb_substream *subs)
 			found = fp;
 			cur_attr = attr;
 		}
+
+		snd_vendor_set_pcm_binterval(fp, found, &cur_attr, &attr);
+	}
+	return found;
+}
+
+/*
+ * find a matching audio format as well as non-zero service interval
+ */
+static struct audioformat *find_format_and_si(struct snd_usb_substream *subs,
+	unsigned int datainterval)
+{
+	unsigned int i;
+	struct audioformat *fp;
+	struct audioformat *found = NULL;
+	int cur_attr = 0, attr;
+
+	list_for_each_entry(fp, &subs->fmt_list, list) {
+		if (datainterval != fp->datainterval)
+			continue;
+		if (!(fp->formats & pcm_format_to_bits(subs->pcm_format)))
+			continue;
+		if (fp->channels != subs->channels)
+			continue;
+		if (subs->cur_rate < fp->rate_min ||
+		    subs->cur_rate > fp->rate_max)
+			continue;
+		if (!(fp->rates & SNDRV_PCM_RATE_CONTINUOUS)) {
+			for (i = 0; i < fp->nr_rates; i++)
+				if (fp->rate_table[i] == subs->cur_rate)
+					break;
+			if (i >= fp->nr_rates)
+				continue;
+		}
+		attr = fp->ep_attr & USB_ENDPOINT_SYNCTYPE;
+		if (!found) {
+			found = fp;
+			cur_attr = attr;
+			continue;
+		}
+		/* avoid async out and adaptive in if the other method
+		 * supports the same format.
+		 * this is a workaround for the case like
+		 * M-audio audiophile USB.
+		 */
+		if (attr != cur_attr) {
+			if ((attr == USB_ENDPOINT_SYNC_ASYNC &&
+			     subs->direction == SNDRV_PCM_STREAM_PLAYBACK) ||
+			    (attr == USB_ENDPOINT_SYNC_ADAPTIVE &&
+			     subs->direction == SNDRV_PCM_STREAM_CAPTURE))
+				continue;
+			if ((cur_attr == USB_ENDPOINT_SYNC_ASYNC &&
+			     subs->direction == SNDRV_PCM_STREAM_PLAYBACK) ||
+			    (cur_attr == USB_ENDPOINT_SYNC_ADAPTIVE &&
+			     subs->direction == SNDRV_PCM_STREAM_CAPTURE)) {
+				found = fp;
+				cur_attr = attr;
+				continue;
+			}
+		}
+		/* find the format with the largest max. packet size */
+		if (fp->maxpacksize > found->maxpacksize) {
+			found = fp;
+			cur_attr = attr;
+		}
 	}
 	return found;
 }
@@ -563,6 +628,10 @@ static int set_format(struct snd_usb_substream *subs, struct audioformat *fmt)
 		}
 		dev_dbg(&dev->dev, "setting usb interface %d:%d\n",
 			fmt->iface, fmt->altsetting);
+		err = snd_vendor_set_pcm_intf(iface, fmt->iface,
+					      fmt->altsetting, subs->direction);
+		if (err)
+			return err;
 		snd_usb_set_interface_quirk(dev);
 	}
 
@@ -590,6 +659,74 @@ static int set_format(struct snd_usb_substream *subs, struct audioformat *fmt)
 	return 0;
 }
 
+int snd_usb_enable_audio_stream(struct snd_usb_substream *subs,
+	int datainterval, bool enable)
+{
+	struct audioformat *fmt;
+	struct usb_host_interface *alts;
+	struct usb_interface *iface;
+	int ret;
+
+	if (!enable) {
+		if (subs->interface >= 0) {
+			usb_set_interface(subs->dev, subs->interface, 0);
+			subs->altset_idx = 0;
+			subs->interface = -1;
+			subs->cur_audiofmt = NULL;
+		}
+
+		snd_usb_autosuspend(subs->stream->chip);
+		return 0;
+	}
+
+	snd_usb_autoresume(subs->stream->chip);
+	if (datainterval != -EINVAL)
+		fmt = find_format_and_si(subs, datainterval);
+	else
+		fmt = find_format(subs);
+	if (!fmt) {
+		dev_err(&subs->dev->dev,
+		"cannot set format: format = %#x, rate = %d, channels = %d\n",
+			   subs->pcm_format, subs->cur_rate, subs->channels);
+		return -EINVAL;
+	}
+
+	subs->altset_idx = 0;
+	subs->interface = -1;
+	if (atomic_read(&subs->stream->chip->shutdown)) {
+		ret = -ENODEV;
+	} else {
+		ret = set_format(subs, fmt);
+		if (ret < 0)
+			return ret;
+
+		iface = usb_ifnum_to_if(subs->dev, subs->cur_audiofmt->iface);
+		if (!iface) {
+			dev_err(&subs->dev->dev, "Could not get iface %d\n",
+				subs->cur_audiofmt->iface);
+			return -ENODEV;
+		}
+
+		alts = &iface->altsetting[subs->cur_audiofmt->altset_idx];
+		ret = snd_usb_init_sample_rate(subs->stream->chip,
+					       subs->cur_audiofmt->iface,
+					       alts,
+					       subs->cur_audiofmt,
+					       subs->cur_rate);
+		if (ret < 0) {
+			dev_err(&subs->dev->dev, "failed to set rate %d\n",
+				subs->cur_rate);
+			return ret;
+		}
+	}
+
+	subs->interface = fmt->iface;
+	subs->altset_idx = fmt->altset_idx;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_usb_enable_audio_stream);
+
 /*
  * Return the score of matching two audioformats.
  * Veto the audioformat if:
@@ -896,6 +1033,10 @@ static int snd_usb_pcm_prepare(struct snd_pcm_substream *substream)
 	struct usb_interface *iface;
 	int ret;
 
+	ret = snd_vendor_set_pcm_buf(subs->dev, subs->cur_audiofmt->iface);
+	if (ret)
+		return ret;
+
 	if (! subs->cur_audiofmt) {
 		dev_err(&subs->dev->dev, "no format is specified!\n");
 		return -ENXIO;
@@ -932,6 +1073,17 @@ static int snd_usb_pcm_prepare(struct snd_pcm_substream *substream)
 		if (ret < 0)
 			goto unlock;
 
+		if (snd_vendor_get_ops()) {
+			ret = snd_vendor_set_rate(iface,
+						  subs->cur_audiofmt->iface,
+						  subs->cur_rate,
+						  subs->cur_audiofmt->altsetting);
+			if (!ret) {
+				subs->need_setup_ep = false;
+				goto unlock;
+			}
+		}
+
 		ret = configure_endpoint(subs);
 		if (ret < 0)
 			goto unlock;
@@ -1341,6 +1493,11 @@ static int snd_usb_pcm_open(struct snd_pcm_substream *substream)
 	struct snd_usb_substream *subs = &as->substream[direction];
 	int ret;
 
+	ret = snd_vendor_set_pcm_connection(subs->dev, SOUND_PCM_OPEN,
+					    direction);
+	if (ret)
+		return ret;
+
 	subs->interface = -1;
 	subs->altset_idx = 0;
 	runtime->hw = snd_usb_hardware;
@@ -1369,6 +1526,11 @@ static int snd_usb_pcm_close(struct snd_pcm_substream *substream)
 	struct snd_usb_substream *subs = &as->substream[direction];
 	int ret;
 
+	ret = snd_vendor_set_pcm_connection(subs->dev, SOUND_PCM_CLOSE,
+					    direction);
+	if (ret)
+		return ret;
+
 	stop_endpoints(subs, true);
 	snd_media_stop_pipeline(subs);
 
@@ -1376,6 +1538,12 @@ static int snd_usb_pcm_close(struct snd_pcm_substream *substream)
 	    subs->interface >= 0 &&
 	    !snd_usb_lock_shutdown(subs->stream->chip)) {
 		usb_set_interface(subs->dev, subs->interface, 0);
+		ret = snd_vendor_set_pcm_intf(usb_ifnum_to_if(subs->dev,
+							      subs->interface),
+					      subs->interface, 0,
+					      direction);
+		if (ret)
+			return ret;
 		subs->interface = -1;
 		ret = snd_usb_pcm_change_state(subs, UAC3_PD_STATE_D1);
 		snd_usb_unlock_shutdown(subs->stream->chip);
@@ -1417,12 +1585,6 @@ static void retire_capture_urb(struct snd_usb_substream *subs,
 			// continue;
 		}
 		bytes = urb->iso_frame_desc[i].actual_length;
-		if (subs->stream_offset_adj > 0) {
-			unsigned int adj = min(subs->stream_offset_adj, bytes);
-			cp += adj;
-			bytes -= adj;
-			subs->stream_offset_adj -= adj;
-		}
 		frames = bytes / stride;
 		if (!subs->txfr_quirk)
 			bytes = frames * stride;
diff --git a/sound/usb/pcm.h b/sound/usb/pcm.h
index 9833627c1..6e28e791e 100644
--- a/sound/usb/pcm.h
+++ b/sound/usb/pcm.h
@@ -14,5 +14,7 @@ int snd_usb_init_pitch(struct snd_usb_audio *chip, int iface,
 		       struct audioformat *fmt);
 void snd_usb_preallocate_buffer(struct snd_usb_substream *subs);
 
+int snd_usb_enable_audio_stream(struct snd_usb_substream *subs,
+				int datainterval, bool enable);
 
 #endif /* __USBAUDIO_PCM_H */
diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index a756f50d9..a8bb953cc 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -1432,9 +1432,6 @@ void snd_usb_set_format_quirk(struct snd_usb_substream *subs,
 	case USB_ID(0x041e, 0x3f19): /* E-Mu 0204 USB */
 		set_format_emu_quirk(subs, fmt);
 		break;
-	case USB_ID(0x534d, 0x2109): /* MacroSilicon MS2109 */
-		subs->stream_offset_adj = 2;
-		break;
 	}
 }
 
diff --git a/sound/usb/stream.c b/sound/usb/stream.c
index d01edd5da..f40961c7c 100644
--- a/sound/usb/stream.c
+++ b/sound/usb/stream.c
@@ -67,9 +67,13 @@ static void snd_usb_audio_stream_free(struct snd_usb_stream *stream)
 static void snd_usb_audio_pcm_free(struct snd_pcm *pcm)
 {
 	struct snd_usb_stream *stream = pcm->private_data;
+	struct snd_usb_audio *chip;
 	if (stream) {
+		mutex_lock(&stream->chip->dev_lock);
+		chip = stream->chip;
 		stream->pcm = NULL;
 		snd_usb_audio_stream_free(stream);
+		mutex_unlock(&chip->dev_lock);
 	}
 }
 
@@ -94,7 +98,6 @@ static void snd_usb_init_substream(struct snd_usb_stream *as,
 	subs->tx_length_quirk = as->chip->tx_length_quirk;
 	subs->speed = snd_usb_get_speed(subs->dev);
 	subs->pkt_offset_adj = 0;
-	subs->stream_offset_adj = 0;
 
 	snd_usb_set_pcm_ops(as->pcm, stream);
 
diff --git a/sound/usb/usbaudio.h b/sound/usb/usbaudio.h
index 55a2119c2..082a6791e 100644
--- a/sound/usb/usbaudio.h
+++ b/sound/usb/usbaudio.h
@@ -57,6 +57,9 @@ struct snd_usb_audio {
 	struct usb_host_interface *ctrl_intf;	/* the audio control interface */
 	struct media_device *media_dev;
 	struct media_intf_devnode *ctl_intf_media_devnode;
+	struct mutex dev_lock;  /* to protect any race with disconnect */
+	int card_num;	/* cache pcm card number to use upon disconnect */
+	void (*disconnect_cb)(struct snd_usb_audio *chip);
 };
 
 #define usb_audio_err(chip, fmt, args...) \
@@ -122,4 +125,50 @@ void snd_usb_unlock_shutdown(struct snd_usb_audio *chip);
 
 extern bool snd_usb_use_vmalloc;
 
+struct audioformat;
+
+enum snd_vendor_pcm_open_close {
+	SOUND_PCM_CLOSE = 0,
+	SOUND_PCM_OPEN,
+};
+
+/**
+ * struct snd_usb_audio_vendor_ops - function callbacks for USB audio accelerators
+ * @connect: called when a new interface is found
+ * @disconnect: called when an interface is removed
+ * @set_interface: called when an interface is initialized
+ * @set_rate: called when the rate is set
+ * @set_pcm_buf: called when the pcm buffer is set
+ * @set_pcm_intf: called when the pcm interface is set
+ * @set_pcm_connection: called when pcm is opened/closed
+ * @set_pcm_binterval: called when the pcm binterval is set
+ * @usb_add_ctls: called when USB controls are added
+ *
+ * Set of callbacks for some accelerated USB audio streaming hardware.
+ *
+ * TODO: make this USB host-controller specific, right now this only works for
+ * one USB controller in the system at a time, which is only realistic for
+ * self-contained systems like phones.
+ */
+struct snd_usb_audio_vendor_ops {
+	int (*connect)(struct usb_interface *intf);
+	void (*disconnect)(struct usb_interface *intf);
+
+	int (*set_interface)(struct usb_device *udev,
+			     struct usb_host_interface *alts,
+			     int iface, int alt);
+	int (*set_rate)(struct usb_interface *intf, int iface, int rate,
+			int alt);
+	int (*set_pcm_buf)(struct usb_device *udev, int iface);
+	int (*set_pcm_intf)(struct usb_interface *intf, int iface, int alt,
+			    int direction);
+	int (*set_pcm_connection)(struct usb_device *udev,
+				  enum snd_vendor_pcm_open_close onoff,
+				  int direction);
+	int (*set_pcm_binterval)(struct audioformat *fp,
+				 struct audioformat *found,
+				 int *cur_attr, int *attr);
+	int (*usb_add_ctls)(struct snd_usb_audio *chip);
+};
+
 #endif /* __USBAUDIO_H */
-- 
2.17.1

