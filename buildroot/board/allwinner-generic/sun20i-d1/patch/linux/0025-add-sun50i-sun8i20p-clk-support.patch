From bb9b69fc9a26165dc2e6cc7405c1877e9875f4fc Mon Sep 17 00:00:00 2001
From: YuzukiTsuru <gloomyghost@gloomyghost.com>
Date: Fri, 25 Mar 2022 16:50:17 +0800
Subject: [PATCH 25/93] add sun50i sun8i20p clk support

---
 drivers/clk/Kconfig                      |   11 +
 drivers/clk/Makefile                     |    3 +
 drivers/clk/clk-composite.c              |    1 +
 drivers/clk/clk-debugfs.c                |  482 ++++++
 drivers/clk/clk-debugfs.h                |   82 +
 drivers/clk/clk-pwm.c                    |    2 +-
 drivers/clk/clk.c                        |   84 +-
 drivers/clk/qcom/dispcc-sdm845.c         |    2 +
 drivers/clk/qcom/gcc-msm8998.c           |    1 +
 drivers/clk/qcom/gcc-sdm845.c            |    1 +
 drivers/clk/qcom/gpucc-sdm845.c          |    1 +
 drivers/clk/qcom/videocc-sdm845.c        |    1 +
 drivers/clk/sunxi-ng/Kconfig             |   72 +-
 drivers/clk/sunxi-ng/Makefile            |   83 +-
 drivers/clk/sunxi-ng/ccu-sun50i-a100-r.c |  214 +++
 drivers/clk/sunxi-ng/ccu-sun50i-a100-r.h |   21 +
 drivers/clk/sunxi-ng/ccu-sun50i-a100.c   | 1276 ++++++++++++++
 drivers/clk/sunxi-ng/ccu-sun50i-a100.h   |   56 +
 drivers/clk/sunxi-ng/ccu-sun50iw10-r.c   |  238 +++
 drivers/clk/sunxi-ng/ccu-sun50iw10-r.h   |   14 +
 drivers/clk/sunxi-ng/ccu-sun50iw10.c     | 1400 ++++++++++++++++
 drivers/clk/sunxi-ng/ccu-sun50iw10.h     |   14 +
 drivers/clk/sunxi-ng/ccu-sun50iw12-r.c   |  286 ++++
 drivers/clk/sunxi-ng/ccu-sun50iw12-r.h   |   14 +
 drivers/clk/sunxi-ng/ccu-sun50iw12.c     | 1329 +++++++++++++++
 drivers/clk/sunxi-ng/ccu-sun50iw12.h     |   14 +
 drivers/clk/sunxi-ng/ccu-sun50iw9-r.c    |  196 +++
 drivers/clk/sunxi-ng/ccu-sun50iw9-r.h    |   14 +
 drivers/clk/sunxi-ng/ccu-sun50iw9-rtc.c  |  165 ++
 drivers/clk/sunxi-ng/ccu-sun50iw9-rtc.h  |   21 +
 drivers/clk/sunxi-ng/ccu-sun50iw9.c      | 1281 +++++++++++++++
 drivers/clk/sunxi-ng/ccu-sun50iw9.h      |   14 +
 drivers/clk/sunxi-ng/ccu-sun55iw3-r.c    |  282 ++++
 drivers/clk/sunxi-ng/ccu-sun55iw3-r.h    |   14 +
 drivers/clk/sunxi-ng/ccu-sun55iw3-rtc.c  |  194 +++
 drivers/clk/sunxi-ng/ccu-sun55iw3-rtc.h  |   18 +
 drivers/clk/sunxi-ng/ccu-sun55iw3.c      | 1915 ++++++++++++++++++++++
 drivers/clk/sunxi-ng/ccu-sun55iw3.h      |   14 +
 drivers/clk/sunxi-ng/ccu-sun8iw20-r.c    |  162 ++
 drivers/clk/sunxi-ng/ccu-sun8iw20-r.h    |   14 +
 drivers/clk/sunxi-ng/ccu-sun8iw20-rtc.c  |  194 +++
 drivers/clk/sunxi-ng/ccu-sun8iw20-rtc.h  |   18 +
 drivers/clk/sunxi-ng/ccu-sun8iw20.c      | 1325 +++++++++++++++
 drivers/clk/sunxi-ng/ccu-sun8iw20.h      |   14 +
 drivers/clk/sunxi-ng/ccu_common.c        |  151 +-
 drivers/clk/sunxi-ng/ccu_common.h        |   34 +
 drivers/clk/sunxi-ng/ccu_div.c           |    1 +
 drivers/clk/sunxi-ng/ccu_frac.c          |    6 +-
 drivers/clk/sunxi-ng/ccu_frac.h          |    6 +-
 drivers/clk/sunxi-ng/ccu_gate.c          |   18 +
 drivers/clk/sunxi-ng/ccu_gate.h          |   46 +
 drivers/clk/sunxi-ng/ccu_mp.c            |   30 +-
 drivers/clk/sunxi-ng/ccu_mp.h            |   20 +
 drivers/clk/sunxi-ng/ccu_mult.c          |   12 +-
 drivers/clk/sunxi-ng/ccu_mux.c           |    8 +
 drivers/clk/sunxi-ng/ccu_mux.h           |   17 +
 drivers/clk/sunxi-ng/ccu_nk.c            |   19 +-
 drivers/clk/sunxi-ng/ccu_nkm.c           |   21 +-
 drivers/clk/sunxi-ng/ccu_nkmp.c          |   19 +-
 drivers/clk/sunxi-ng/ccu_nm.c            |   33 +-
 drivers/clk/sunxi-ng/ccu_sdm.c           |    6 +-
 drivers/clk/sunxi-ng/ccu_sdm.h           |    8 +-
 drivers/clk/sunxi-ng/rtc-sunxi-ccu.c     |  550 +++++++
 drivers/clk/sunxi/Kconfig                |   20 +-
 drivers/clk/sunxi/Makefile               |   10 +-
 drivers/clk/sunxi/clk-cpu.c              |  161 ++
 drivers/clk/sunxi/clk-cpu.h              |   31 +
 drivers/clk/sunxi/clk-ddr.c              |  297 ++++
 drivers/clk/sunxi/clk-factors.c          |  901 +++++++---
 drivers/clk/sunxi/clk-factors.h          |  393 ++++-
 drivers/clk/sunxi/clk-periph.c           |  763 +++++++++
 drivers/clk/sunxi/clk-periph.h           |  204 +++
 drivers/clk/sunxi/clk-sun8iw15.c         |  681 ++++++++
 drivers/clk/sunxi/clk-sun8iw15.h         |  180 ++
 drivers/clk/sunxi/clk-sun8iw15_tbl.c     |  617 +++++++
 drivers/clk/sunxi/clk-sunxi.c            | 1413 ++++------------
 drivers/clk/sunxi/clk-sunxi.h            |   87 +
 77 files changed, 16880 insertions(+), 1440 deletions(-)
 create mode 100644 drivers/clk/clk-debugfs.c
 create mode 100644 drivers/clk/clk-debugfs.h
 create mode 100644 drivers/clk/sunxi-ng/ccu-sun50i-a100-r.c
 create mode 100644 drivers/clk/sunxi-ng/ccu-sun50i-a100-r.h
 create mode 100644 drivers/clk/sunxi-ng/ccu-sun50i-a100.c
 create mode 100644 drivers/clk/sunxi-ng/ccu-sun50i-a100.h
 create mode 100644 drivers/clk/sunxi-ng/ccu-sun50iw10-r.c
 create mode 100644 drivers/clk/sunxi-ng/ccu-sun50iw10-r.h
 create mode 100644 drivers/clk/sunxi-ng/ccu-sun50iw10.c
 create mode 100644 drivers/clk/sunxi-ng/ccu-sun50iw10.h
 create mode 100644 drivers/clk/sunxi-ng/ccu-sun50iw12-r.c
 create mode 100644 drivers/clk/sunxi-ng/ccu-sun50iw12-r.h
 create mode 100644 drivers/clk/sunxi-ng/ccu-sun50iw12.c
 create mode 100644 drivers/clk/sunxi-ng/ccu-sun50iw12.h
 create mode 100644 drivers/clk/sunxi-ng/ccu-sun50iw9-r.c
 create mode 100644 drivers/clk/sunxi-ng/ccu-sun50iw9-r.h
 create mode 100644 drivers/clk/sunxi-ng/ccu-sun50iw9-rtc.c
 create mode 100644 drivers/clk/sunxi-ng/ccu-sun50iw9-rtc.h
 create mode 100644 drivers/clk/sunxi-ng/ccu-sun50iw9.c
 create mode 100644 drivers/clk/sunxi-ng/ccu-sun50iw9.h
 create mode 100644 drivers/clk/sunxi-ng/ccu-sun55iw3-r.c
 create mode 100644 drivers/clk/sunxi-ng/ccu-sun55iw3-r.h
 create mode 100644 drivers/clk/sunxi-ng/ccu-sun55iw3-rtc.c
 create mode 100644 drivers/clk/sunxi-ng/ccu-sun55iw3-rtc.h
 create mode 100755 drivers/clk/sunxi-ng/ccu-sun55iw3.c
 create mode 100644 drivers/clk/sunxi-ng/ccu-sun55iw3.h
 create mode 100644 drivers/clk/sunxi-ng/ccu-sun8iw20-r.c
 create mode 100644 drivers/clk/sunxi-ng/ccu-sun8iw20-r.h
 create mode 100644 drivers/clk/sunxi-ng/ccu-sun8iw20-rtc.c
 create mode 100644 drivers/clk/sunxi-ng/ccu-sun8iw20-rtc.h
 create mode 100644 drivers/clk/sunxi-ng/ccu-sun8iw20.c
 create mode 100644 drivers/clk/sunxi-ng/ccu-sun8iw20.h
 create mode 100644 drivers/clk/sunxi-ng/rtc-sunxi-ccu.c
 create mode 100644 drivers/clk/sunxi/clk-cpu.c
 create mode 100644 drivers/clk/sunxi/clk-cpu.h
 create mode 100644 drivers/clk/sunxi/clk-ddr.c
 create mode 100644 drivers/clk/sunxi/clk-periph.c
 create mode 100644 drivers/clk/sunxi/clk-periph.h
 create mode 100644 drivers/clk/sunxi/clk-sun8iw15.c
 create mode 100644 drivers/clk/sunxi/clk-sun8iw15.h
 create mode 100644 drivers/clk/sunxi/clk-sun8iw15_tbl.c
 create mode 100644 drivers/clk/sunxi/clk-sunxi.h

diff --git a/drivers/clk/Kconfig b/drivers/clk/Kconfig
index c44247d0b..28b9be52d 100644
--- a/drivers/clk/Kconfig
+++ b/drivers/clk/Kconfig
@@ -23,6 +23,17 @@ config COMMON_CLK
 menu "Common Clock Framework"
 	depends on COMMON_CLK
 
+config COMMON_CLK_DEBUG
+	bool "DebugFS representation of clock tree"
+	select DEBUG_FS
+	default y
+	---help---
+          Creates a directory hierchy in debugfs for visualizing the clk
+          tree structure.  Each directory contains read-only members
+          that export information specific to that clk node: clk_rate,
+          clk_flags, clk_prepare_count, clk_enable_count &
+          clk_notifier_count.
+
 config COMMON_CLK_WM831X
 	tristate "Clock driver for WM831x/2x PMICs"
 	depends on MFD_WM831X
diff --git a/drivers/clk/Makefile b/drivers/clk/Makefile
index 0138fb14e..f717a3a7e 100644
--- a/drivers/clk/Makefile
+++ b/drivers/clk/Makefile
@@ -118,3 +118,6 @@ endif
 obj-$(CONFIG_ARCH_ZX)			+= zte/
 obj-$(CONFIG_ARCH_ZYNQ)			+= zynq/
 obj-$(CONFIG_COMMON_CLK_ZYNQMP)         += zynqmp/
+
+# clk debug
+obj-$(CONFIG_COMMON_CLK_DEBUG) += clk-debugfs.o
diff --git a/drivers/clk/clk-composite.c b/drivers/clk/clk-composite.c
index 4f13a681d..bdc148278 100644
--- a/drivers/clk/clk-composite.c
+++ b/drivers/clk/clk-composite.c
@@ -328,6 +328,7 @@ struct clk *clk_register_composite(struct device *dev, const char *name,
 		return ERR_CAST(hw);
 	return hw->clk;
 }
+EXPORT_SYMBOL_GPL(clk_register_composite);
 
 void clk_unregister_composite(struct clk *clk)
 {
diff --git a/drivers/clk/clk-debugfs.c b/drivers/clk/clk-debugfs.c
new file mode 100644
index 000000000..1653fae37
--- /dev/null
+++ b/drivers/clk/clk-debugfs.c
@@ -0,0 +1,482 @@
+/*
+ * Copyright (C) 2013 Allwinnertech, kevin.z.m <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/debugfs.h>
+#include <linux/uaccess.h>
+#include <linux/clk-provider.h>
+#include <linux/clkdev.h>
+#include <linux/clk/sunxi.h>
+#include <linux/clk.h>
+#include "clk-debugfs.h"
+
+static struct dentry *my_ccudbg_root;
+static struct testclk_data testclk_priv;
+
+static void clktest_process(void)
+{
+	int i, j, enabled, command = 0xff;
+	unsigned long rate;
+	struct clk *cur_clk = NULL;
+	struct clk *parent_clk = NULL;
+	int ret;
+	unsigned long start = 0;
+
+	ret = kstrtoul(testclk_priv.start, 0, (unsigned long *)&start);
+
+	if (start == 1) {
+		if (!strcmp(testclk_priv.command, "getparents"))
+			command = 1;
+		else if (!strcmp(testclk_priv.command, "getparent"))
+			command = 2;
+		else if (!strcmp(testclk_priv.command, "setparent"))
+			command = 3;
+		else if (!strcmp(testclk_priv.command, "getrate"))
+			command = 4;
+		else if (!strcmp(testclk_priv.command, "setrate"))
+			command = 5;
+		else if (!strcmp(testclk_priv.command, "is_enabled"))
+			command = 6;
+		else if (!strcmp(testclk_priv.command, "disable"))
+			command = 7;
+		else if (!strcmp(testclk_priv.command, "enable"))
+			command = 8;
+		else {
+			pr_info("Error Not support command %s\n",
+			       testclk_priv.command);
+			command = 0xff;
+		}
+		if (command != 0xff) {
+			cur_clk = clk_get(NULL, testclk_priv.name);
+			if (!cur_clk || IS_ERR(cur_clk)) {
+				cur_clk = NULL;
+				pr_info("Error Found clk %s\n",
+				       testclk_priv.name);
+				strcpy(testclk_priv.info, "Error");
+				return;
+			}
+			switch (command) {
+			case 1: /* getparents */
+			{
+				j = 0;
+				memset(testclk_priv.info, 0x0,
+				       sizeof(testclk_priv.info));
+				for (i = 0; i < cur_clk->core->num_parents; i++) {
+					memcpy(&testclk_priv.info[j],
+					       cur_clk->core->parents[i].name,
+					       strlen(cur_clk->core
+							  ->parents[i].name));
+					j += strlen(
+					    cur_clk->core->parents[i].name);
+					testclk_priv.info[j] = ' ';
+					j++;
+				}
+				testclk_priv.info[j] = '\0';
+				break;
+			}
+			case 2: /* getparent */
+			{
+
+				parent_clk = clk_get_parent(cur_clk);
+				if (!parent_clk || IS_ERR(parent_clk)) {
+					pr_info("Error Found parent of %s\n",
+					       cur_clk->core->name);
+					strcpy(testclk_priv.info, "Error");
+				} else
+					strcpy(testclk_priv.info,
+					       parent_clk->core->name);
+				break;
+			}
+			case 3: /* setparent */
+			{
+				if (cur_clk->core->parent) {
+					parent_clk =
+					    clk_get(NULL, testclk_priv.param);
+					if (!parent_clk || IS_ERR(parent_clk)) {
+						pr_info(
+						    "Error Found parent %s\n",
+						    testclk_priv.param);
+						strcpy(testclk_priv.info,
+						       "Error");
+					} else {
+						clk_set_parent(cur_clk,
+							       parent_clk);
+						strcpy(testclk_priv.info,
+						       cur_clk->core->parent
+							   ->name);
+						clk_put(parent_clk);
+					}
+				} else
+					strcpy(testclk_priv.info, "Error");
+				break;
+			}
+			case 4: /* getrate */
+			{
+				rate = clk_get_rate(cur_clk);
+				if (rate)
+
+					sprintf(testclk_priv.info, "%d",
+						(unsigned int)rate);
+				else
+					strcpy(testclk_priv.info, "Error");
+				break;
+			}
+			case 5: /* setrate */
+			{
+				ret = kstrtoul(testclk_priv.param, 0,
+						(unsigned long *)&rate);
+				if (rate) {
+					clk_set_rate(cur_clk, rate);
+					sprintf(testclk_priv.info, "%d",
+						(unsigned int)rate);
+				} else
+					strcpy(testclk_priv.info, "Error");
+				break;
+			}
+			case 6: /* is_enabled */
+			{
+				if (!cur_clk->core->ops->is_enabled)
+					enabled =
+					    cur_clk->core->enable_count ? 1 : 0;
+				else
+					enabled =
+					    cur_clk->core->ops->is_enabled(
+						cur_clk->core->hw);
+				if (enabled)
+					strcpy(testclk_priv.info, "enabled");
+				else
+					strcpy(testclk_priv.info, "disabled");
+				break;
+			}
+			case 7: /* disable */
+			{
+				if (!cur_clk->core->ops->is_enabled)
+					enabled =
+					    cur_clk->core->enable_count ? 1 : 0;
+				else
+					enabled =
+					    cur_clk->core->ops->is_enabled(
+						cur_clk->core->hw);
+				if (enabled)
+					clk_disable_unprepare(cur_clk);
+				strcpy(testclk_priv.info, "disabled");
+				break;
+			}
+			case 8: /* enable */
+			{
+				clk_prepare_enable(cur_clk);
+				strcpy(testclk_priv.info, "enabled");
+				break;
+			}
+			default:
+				break;
+			}
+			if (cur_clk)
+				clk_put(cur_clk);
+		}
+	}
+}
+/*##########command###############*/
+static int ccudbg_command_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+static int ccudbg_command_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+static ssize_t ccudbg_command_read(struct file *file, char __user *buf,
+				   size_t count, loff_t *ppos)
+{
+	int len = strlen(testclk_priv.command);
+
+	strcpy(testclk_priv.tmpbuf, testclk_priv.command);
+	testclk_priv.tmpbuf[len] = 0x0A;
+	testclk_priv.tmpbuf[len + 1] = 0x0;
+	len = strlen(testclk_priv.tmpbuf);
+	if (len) {
+		if (*ppos >= len)
+			return 0;
+		if (count >= len)
+			count = len;
+		if (count > (len - *ppos))
+			count = (len - *ppos);
+		if (copy_to_user((void __user *)buf,
+				 (const void *)testclk_priv.tmpbuf,
+				 (unsigned long)len))
+			return -EFAULT;
+		*ppos += count;
+	} else
+		count = 0;
+	return count;
+}
+
+static ssize_t ccudbg_command_write(struct file *file, const char __user *buf,
+				    size_t count, loff_t *ppos)
+{
+	if (count >= sizeof(testclk_priv.command))
+		return 0;
+	if (copy_from_user(testclk_priv.command, buf, count))
+		return -EFAULT;
+	if (testclk_priv.command[count - 1] == 0x0A)
+		testclk_priv.command[count - 1] = 0;
+	else
+		testclk_priv.command[count] = 0;
+	return count;
+}
+/*##########name###############*/
+static int ccudbg_name_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+static int ccudbg_name_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+static ssize_t ccudbg_name_read(struct file *file, char __user *buf,
+				size_t count, loff_t *ppos)
+{
+	int len = strlen(testclk_priv.name);
+
+	strcpy(testclk_priv.tmpbuf, testclk_priv.name);
+	testclk_priv.tmpbuf[len] = 0x0A;
+	testclk_priv.tmpbuf[len + 1] = 0x0;
+	len = strlen(testclk_priv.tmpbuf);
+	if (len) {
+		if (*ppos >= len)
+			return 0;
+		if (count >= len)
+			count = len;
+		if (count > (len - *ppos))
+			count = (len - *ppos);
+		if (copy_to_user((void __user *)buf,
+				 (const void *)testclk_priv.tmpbuf,
+				 (unsigned long)len))
+			return -EFAULT;
+		*ppos += count;
+	} else
+		count = 0;
+	return count;
+}
+
+static ssize_t ccudbg_name_write(struct file *file, const char __user *buf,
+				 size_t count, loff_t *ppos)
+{
+	if (count >= sizeof(testclk_priv.name))
+		return 0;
+	if (copy_from_user(testclk_priv.name, buf, count))
+		return -EFAULT;
+	if (testclk_priv.name[count - 1] == 0x0A)
+		testclk_priv.name[count - 1] = 0;
+	else
+		testclk_priv.name[count] = 0;
+	return count;
+}
+/*##########start###############*/
+static int ccudbg_start_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+static int ccudbg_start_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+static ssize_t ccudbg_start_read(struct file *file, char __user *buf,
+				 size_t count, loff_t *ppos)
+{
+	int len = strlen(testclk_priv.start);
+
+	strcpy(testclk_priv.tmpbuf, testclk_priv.start);
+	testclk_priv.tmpbuf[len] = 0x0A;
+	testclk_priv.tmpbuf[len + 1] = 0x0;
+	len = strlen(testclk_priv.tmpbuf);
+	if (len) {
+		if (*ppos >= len)
+			return 0;
+		if (count >= len)
+			count = len;
+		if (count > (len - *ppos))
+			count = (len - *ppos);
+		if (copy_to_user((void __user *)buf,
+				 (const void *)testclk_priv.tmpbuf,
+				 (unsigned long)len))
+			return -EFAULT;
+		*ppos += count;
+	} else
+		count = 0;
+	return count;
+}
+static ssize_t ccudbg_start_write(struct file *file, const char __user *buf,
+				  size_t count, loff_t *ppos)
+{
+	if (count >= sizeof(testclk_priv.start))
+		return 0;
+	if (copy_from_user(testclk_priv.start, buf, count))
+		return -EFAULT;
+	if (testclk_priv.start[count - 1] == 0x0A)
+		testclk_priv.start[count - 1] = 0;
+	else
+		testclk_priv.start[count] = 0;
+	clktest_process();
+	return count;
+}
+/*##########param###############*/
+static int ccudbg_param_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+static int ccudbg_param_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+static ssize_t ccudbg_param_read(struct file *file, char __user *buf,
+				 size_t count, loff_t *ppos)
+{
+	int len = strlen(testclk_priv.param);
+
+	strcpy(testclk_priv.tmpbuf, testclk_priv.param);
+	testclk_priv.tmpbuf[len] = 0x0A;
+	testclk_priv.tmpbuf[len + 1] = 0x0;
+	len = strlen(testclk_priv.tmpbuf);
+	if (len) {
+		if (*ppos >= len)
+			return 0;
+		if (count >= len)
+			count = len;
+		if (count > (len - *ppos))
+			count = (len - *ppos);
+		if (copy_to_user((void __user *)buf,
+				 (const void *)testclk_priv.tmpbuf,
+				 (unsigned long)len))
+			return -EFAULT;
+		*ppos += count;
+	} else
+		count = 0;
+	return count;
+}
+static ssize_t ccudbg_param_write(struct file *file, const char __user *buf,
+				  size_t count, loff_t *ppos)
+{
+	if (count >= sizeof(testclk_priv.param))
+		return 0;
+	if (copy_from_user(testclk_priv.param, buf, count))
+		return -EFAULT;
+	if (testclk_priv.param[count - 1] == 0x0A)
+		testclk_priv.param[count - 1] = 0;
+	else
+		testclk_priv.param[count] = 0;
+	return count;
+}
+/*##########info###############*/
+static int ccudbg_info_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+static int ccudbg_info_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+static ssize_t ccudbg_info_read(struct file *file, char __user *buf,
+				size_t count, loff_t *ppos)
+{
+	int len = strlen(testclk_priv.info);
+
+	strcpy(testclk_priv.tmpbuf, testclk_priv.info);
+	testclk_priv.tmpbuf[len] = 0x0A;
+	testclk_priv.tmpbuf[len + 1] = 0x0;
+	len = strlen(testclk_priv.tmpbuf);
+	if (len) {
+		if (*ppos >= len)
+			return 0;
+		if (count >= len)
+			count = len;
+		if (count > (len - *ppos))
+			count = (len - *ppos);
+		if (copy_to_user((void __user *)buf,
+				 (const void *)testclk_priv.tmpbuf,
+				 (unsigned long)len))
+			return -EFAULT;
+		*ppos += count;
+	} else
+		count = 0;
+	return count;
+}
+static ssize_t ccudbg_info_write(struct file *file, const char __user *buf,
+				 size_t count, loff_t *ppos)
+{
+	if (count >= sizeof(testclk_priv.info))
+		return 0;
+	if (copy_from_user(testclk_priv.info, buf, count))
+		return -EFAULT;
+	if (testclk_priv.info[count - 1] == 0x0A)
+		testclk_priv.info[count - 1] = 0;
+	else
+		testclk_priv.info[count] = 0;
+	return count;
+}
+static const struct file_operations command_ops = {
+	.write      = ccudbg_command_write,
+	.read       = ccudbg_command_read,
+	.open       = ccudbg_command_open,
+	.release    = ccudbg_command_release,
+};
+static const struct file_operations name_ops = {
+	.write      = ccudbg_name_write,
+	.read       = ccudbg_name_read,
+	.open       = ccudbg_name_open,
+	.release    = ccudbg_name_release,
+};
+static const struct file_operations start_ops = {
+	.write      = ccudbg_start_write,
+	.read       = ccudbg_start_read,
+	.open       = ccudbg_start_open,
+	.release    = ccudbg_start_release,
+};
+static const struct file_operations param_ops = {
+	.write      = ccudbg_param_write,
+	.read       = ccudbg_param_read,
+	.open       = ccudbg_param_open,
+	.release    = ccudbg_param_release,
+};
+static const struct file_operations info_ops = {
+	.write      = ccudbg_info_write,
+	.read       = ccudbg_info_read,
+	.open       = ccudbg_info_open,
+	.release    = ccudbg_info_release,
+};
+static int __init debugfs_test_init(void)
+{
+	my_ccudbg_root = debugfs_create_dir("ccudbg", NULL);
+	if (!debugfs_create_file("command", 0644, my_ccudbg_root, NULL,
+				 &command_ops))
+		goto Fail;
+	if (!debugfs_create_file("name", 0644, my_ccudbg_root, NULL, &name_ops))
+		goto Fail;
+	if (!debugfs_create_file("start", 0644, my_ccudbg_root, NULL,
+				 &start_ops))
+		goto Fail;
+	if (!debugfs_create_file("param", 0644, my_ccudbg_root, NULL,
+				 &param_ops))
+		goto Fail;
+	if (!debugfs_create_file("info", 0644, my_ccudbg_root, NULL, &info_ops))
+		goto Fail;
+	return 0;
+
+Fail:
+	debugfs_remove_recursive(my_ccudbg_root);
+	my_ccudbg_root = NULL;
+	return -ENOENT;
+}
+
+late_initcall(debugfs_test_init);
diff --git a/drivers/clk/clk-debugfs.h b/drivers/clk/clk-debugfs.h
new file mode 100644
index 000000000..8dec2aea3
--- /dev/null
+++ b/drivers/clk/clk-debugfs.h
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2016-2020 Allwinnertech
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef __MACH_CLK_DEBUGFS_H
+#define __MACH_CLK_DEBUGFS_H
+
+struct clk_parent_map {
+	const struct clk_hw	*hw;
+	struct clk_core		*core;
+	const char		*fw_name;
+	const char		*name;
+	int			index;
+};
+
+struct clk_core {
+	const char		*name;
+	const struct clk_ops	*ops;
+	struct clk_hw		*hw;
+	struct module		*owner;
+	struct device		*dev;
+	struct device_node	*of_node;
+	struct clk_core		*parent;
+	struct clk_parent_map	*parents;
+	u8			num_parents;
+	u8			new_parent_index;
+	unsigned long		rate;
+	unsigned long		req_rate;
+	unsigned long		new_rate;
+	struct clk_core		*new_parent;
+	struct clk_core		*new_child;
+	unsigned long		flags;
+	bool			orphan;
+	bool			rpm_enabled;
+	bool			need_sync;
+	bool			boot_enabled;
+	unsigned int		enable_count;
+	unsigned int		prepare_count;
+	unsigned int		protect_count;
+	unsigned long		min_rate;
+	unsigned long		max_rate;
+	unsigned long		accuracy;
+	int			phase;
+	struct clk_duty		duty;
+	struct hlist_head	children;
+	struct hlist_node	child_node;
+	struct hlist_head	clks;
+	unsigned int		notifier_count;
+#ifdef CONFIG_DEBUG_FS
+	struct dentry		*dentry;
+	struct hlist_node	debug_node;
+#endif
+	struct kref		ref;
+};
+
+struct clk {
+	struct clk_core	*core;
+	const char *dev_id;
+	const char *con_id;
+	unsigned long min_rate;
+	unsigned long max_rate;
+	struct hlist_node clks_node;
+};
+
+struct testclk_data {
+	char command[32];
+	char name[32];
+	char start[32];
+	char param[32];
+	char info[512];
+	char tmpbuf[256];
+};
+
+#endif /* __MACH_CLK_DEBUGFS_H */
diff --git a/drivers/clk/clk-pwm.c b/drivers/clk/clk-pwm.c
index 87fe0b0e0..7b1f7a043 100644
--- a/drivers/clk/clk-pwm.c
+++ b/drivers/clk/clk-pwm.c
@@ -89,7 +89,7 @@ static int clk_pwm_probe(struct platform_device *pdev)
 	}
 
 	if (of_property_read_u32(node, "clock-frequency", &clk_pwm->fixed_rate))
-		clk_pwm->fixed_rate = NSEC_PER_SEC / pargs.period;
+		clk_pwm->fixed_rate = div64_u64(NSEC_PER_SEC, pargs.period);
 
 	if (pargs.period != NSEC_PER_SEC / clk_pwm->fixed_rate &&
 	    pargs.period != DIV_ROUND_UP(NSEC_PER_SEC, clk_pwm->fixed_rate)) {
diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 36e9f38a3..5de255193 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -72,6 +72,8 @@ struct clk_core {
 	unsigned long		flags;
 	bool			orphan;
 	bool			rpm_enabled;
+	bool			need_sync;
+	bool			boot_enabled;
 	unsigned int		enable_count;
 	unsigned int		prepare_count;
 	unsigned int		protect_count;
@@ -1200,6 +1202,10 @@ static void clk_unprepare_unused_subtree(struct clk_core *core)
 	hlist_for_each_entry(child, &core->children, child_node)
 		clk_unprepare_unused_subtree(child);
 
+	if (dev_has_sync_state(core->dev) &&
+	    !(core->flags & CLK_DONT_HOLD_STATE))
+		return;
+
 	if (core->prepare_count)
 		return;
 
@@ -1231,6 +1237,10 @@ static void clk_disable_unused_subtree(struct clk_core *core)
 	hlist_for_each_entry(child, &core->children, child_node)
 		clk_disable_unused_subtree(child);
 
+	if (dev_has_sync_state(core->dev) &&
+	    !(core->flags & CLK_DONT_HOLD_STATE))
+		return;
+
 	if (core->flags & CLK_OPS_PARENT_ENABLE)
 		clk_core_prepare_enable(core->parent);
 
@@ -1304,6 +1314,38 @@ static int clk_disable_unused(void)
 }
 late_initcall_sync(clk_disable_unused);
 
+static void clk_unprepare_disable_dev_subtree(struct clk_core *core,
+					      struct device *dev)
+{
+	struct clk_core *child;
+
+	lockdep_assert_held(&prepare_lock);
+
+	hlist_for_each_entry(child, &core->children, child_node)
+		clk_unprepare_disable_dev_subtree(child, dev);
+
+	if (core->dev != dev || !core->need_sync)
+		return;
+
+	clk_core_disable_unprepare(core);
+}
+
+void clk_sync_state(struct device *dev)
+{
+	struct clk_core *core;
+
+	clk_prepare_lock();
+
+	hlist_for_each_entry(core, &clk_root_list, child_node)
+		clk_unprepare_disable_dev_subtree(core, dev);
+
+	hlist_for_each_entry(core, &clk_orphan_list, child_node)
+		clk_unprepare_disable_dev_subtree(core, dev);
+
+	clk_prepare_unlock();
+}
+EXPORT_SYMBOL_GPL(clk_sync_state);
+
 static int clk_core_determine_round_nolock(struct clk_core *core,
 					   struct clk_rate_request *req)
 {
@@ -1678,6 +1720,33 @@ static int clk_fetch_parent_index(struct clk_core *core,
 	return i;
 }
 
+static void clk_core_hold_state(struct clk_core *core)
+{
+	if (core->need_sync || !core->boot_enabled)
+		return;
+
+	if (core->orphan || !dev_has_sync_state(core->dev))
+		return;
+
+	if (core->flags & CLK_DONT_HOLD_STATE)
+		return;
+
+	core->need_sync = !clk_core_prepare_enable(core);
+}
+
+static void __clk_core_update_orphan_hold_state(struct clk_core *core)
+{
+	struct clk_core *child;
+
+	if (core->orphan)
+		return;
+
+	clk_core_hold_state(core);
+
+	hlist_for_each_entry(child, &core->children, child_node)
+		__clk_core_update_orphan_hold_state(child);
+}
+
 /*
  * Update the orphan status of @core and all its children.
  */
@@ -1984,6 +2053,13 @@ static struct clk_core *clk_propagate_rate_change(struct clk_core *core,
 			fail_clk = core;
 	}
 
+	if (core->ops->pre_rate_change) {
+		ret = core->ops->pre_rate_change(core->hw, core->rate,
+						 core->new_rate);
+		if (ret)
+			fail_clk = core;
+	}
+
 	hlist_for_each_entry(child, &core->children, child_node) {
 		/* Skip children who will be reparented to another clock */
 		if (child->new_parent && child->new_parent != core)
@@ -2086,6 +2162,9 @@ static void clk_change_rate(struct clk_core *core)
 	if (core->flags & CLK_RECALC_NEW_RATES)
 		(void)clk_calc_new_rates(core, core->new_rate);
 
+	if (core->ops->post_rate_change)
+		core->ops->post_rate_change(core->hw, old_rate, core->rate);
+
 	/*
 	 * Use safe iteration, as change_rate can actually swap parents
 	 * for certain clock types.
@@ -3278,6 +3357,7 @@ static void clk_core_reparent_orphans_nolock(void)
 			__clk_set_parent_after(orphan, parent, NULL);
 			__clk_recalc_accuracies(orphan);
 			__clk_recalc_rates(orphan, 0);
+			__clk_core_update_orphan_hold_state(orphan);
 		}
 	}
 }
@@ -3424,6 +3504,8 @@ static int __clk_core_init(struct clk_core *core)
 		rate = 0;
 	core->rate = core->req_rate = rate;
 
+	core->boot_enabled = clk_core_is_enabled(core);
+
 	/*
 	 * Enable CLK_IS_CRITICAL clocks so newly added critical clocks
 	 * don't get accidentally disabled when walking the orphan tree and
@@ -3445,9 +3527,9 @@ static int __clk_core_init(struct clk_core *core)
 		}
 	}
 
+	clk_core_hold_state(core);
 	clk_core_reparent_orphans_nolock();
 
-
 	kref_init(&core->ref);
 out:
 	clk_pm_runtime_put(core);
diff --git a/drivers/clk/qcom/dispcc-sdm845.c b/drivers/clk/qcom/dispcc-sdm845.c
index 0cc4909b5..a84f17041 100644
--- a/drivers/clk/qcom/dispcc-sdm845.c
+++ b/drivers/clk/qcom/dispcc-sdm845.c
@@ -3,6 +3,7 @@
  * Copyright (c) 2018, The Linux Foundation. All rights reserved.
  */
 
+#include <linux/clk.h>
 #include <linux/clk-provider.h>
 #include <linux/module.h>
 #include <linux/platform_device.h>
@@ -666,6 +667,7 @@ static struct platform_driver disp_cc_sdm845_driver = {
 	.driver		= {
 		.name	= "disp_cc-sdm845",
 		.of_match_table = disp_cc_sdm845_match_table,
+		.sync_state = clk_sync_state,
 	},
 };
 
diff --git a/drivers/clk/qcom/gcc-msm8998.c b/drivers/clk/qcom/gcc-msm8998.c
index 091acd59c..9ab0abacf 100644
--- a/drivers/clk/qcom/gcc-msm8998.c
+++ b/drivers/clk/qcom/gcc-msm8998.c
@@ -3006,6 +3006,7 @@ static struct platform_driver gcc_msm8998_driver = {
 	.driver		= {
 		.name	= "gcc-msm8998",
 		.of_match_table = gcc_msm8998_match_table,
+		.sync_state = clk_sync_state,
 	},
 };
 
diff --git a/drivers/clk/qcom/gcc-sdm845.c b/drivers/clk/qcom/gcc-sdm845.c
index 56d22dd22..9785bf218 100644
--- a/drivers/clk/qcom/gcc-sdm845.c
+++ b/drivers/clk/qcom/gcc-sdm845.c
@@ -3628,6 +3628,7 @@ static struct platform_driver gcc_sdm845_driver = {
 	.driver		= {
 		.name	= "gcc-sdm845",
 		.of_match_table = gcc_sdm845_match_table,
+		.sync_state = clk_sync_state,
 	},
 };
 
diff --git a/drivers/clk/qcom/gpucc-sdm845.c b/drivers/clk/qcom/gpucc-sdm845.c
index e40efba1b..9aa30cd95 100644
--- a/drivers/clk/qcom/gpucc-sdm845.c
+++ b/drivers/clk/qcom/gpucc-sdm845.c
@@ -233,6 +233,7 @@ static struct platform_driver gpu_cc_sdm845_driver = {
 	.driver = {
 		.name = "sdm845-gpucc",
 		.of_match_table = gpu_cc_sdm845_match_table,
+		.sync_state = clk_sync_state,
 	},
 };
 
diff --git a/drivers/clk/qcom/videocc-sdm845.c b/drivers/clk/qcom/videocc-sdm845.c
index 5d6a7724a..5822252ac 100644
--- a/drivers/clk/qcom/videocc-sdm845.c
+++ b/drivers/clk/qcom/videocc-sdm845.c
@@ -338,6 +338,7 @@ static struct platform_driver video_cc_sdm845_driver = {
 	.driver		= {
 		.name	= "sdm845-videocc",
 		.of_match_table = video_cc_sdm845_match_table,
+		.sync_state = clk_sync_state,
 	},
 };
 
diff --git a/drivers/clk/sunxi-ng/Kconfig b/drivers/clk/sunxi-ng/Kconfig
index cdf333003..2d3049f20 100644
--- a/drivers/clk/sunxi-ng/Kconfig
+++ b/drivers/clk/sunxi-ng/Kconfig
@@ -1,12 +1,53 @@
 # SPDX-License-Identifier: GPL-2.0-only
 config SUNXI_CCU
-	bool "Clock support for Allwinner SoCs"
+	tristate "Clock support for Allwinner SoCs"
 	depends on ARCH_SUNXI || COMPILE_TEST
 	select RESET_CONTROLLER
+	select SUNXI_RTC_CCU
 	default ARCH_SUNXI
 
 if SUNXI_CCU
 
+config SUN8IW20_CCU
+	tristate "Support for the Allwinner SUN8IW20 CCU"
+	default ARM && ARCH_SUN8IW20
+	depends on (ARM && ARCH_SUN8IW20) || (RISCV && ARCH_SUN20IW1) || COMPILE_TEST
+
+config SUN8IW20_R_CCU
+	tristate "Support for the Allwinner SUN8IW20 PRCM CCU"
+	default ARM && ARCH_SUN8IW20
+	depends on (ARM && ARCH_SUN8IW20) || (RISCV && ARCH_SUN20IW1) || COMPILE_TEST
+
+config SUN50IW12_CCU
+	tristate "Support for the Allwinner SUN50IW12 CCU"
+	default ARM64 && ARCH_SUN50IW12
+	depends on (ARM64 && ARCH_SUNXI) || COMPILE_TEST
+
+config SUN50IW12_R_CCU
+	tristate "Support for the Allwinner SUN50IW12 PRCM CCU"
+	default ARM64 && ARCH_SUN50IW12
+	depends on (ARM64 && ARCH_SUNXI) || COMPILE_TEST
+
+config SUN50IW10_CCU
+	tristate "Support for the Allwinner SUN50IW10 CCU"
+	default ARM64 && ARCH_SUN50IW10
+	depends on (ARM64 && ARCH_SUNXI) || COMPILE_TEST
+
+config SUN50IW10_R_CCU
+	tristate "Support for the Allwinner SUN50IW10 PRCM CCU"
+	default ARM64 && ARCH_SUN50IW10
+	depends on (ARM64 && ARCH_SUNXI) || COMPILE_TEST
+
+config SUN50IW9_CCU
+	tristate "Support for the Allwinner SUN50IW9 CCU"
+	default ARM64 && ARCH_SUN50IW9
+	depends on (ARM64 && ARCH_SUNXI) || COMPILE_TEST
+
+config SUN50IW9_R_CCU
+	tristate "Support for the Allwinner SUN50IW9 PRCM CCU"
+	default ARM64 && ARCH_SUN50IW9
+	depends on (ARM64 && ARCH_SUNXI) || COMPILE_TEST
+
 config SUNIV_F1C100S_CCU
 	bool "Support for the Allwinner newer F1C100s CCU"
 	default MACH_SUNIV
@@ -17,6 +58,16 @@ config SUN50I_A64_CCU
 	default ARM64 && ARCH_SUNXI
 	depends on (ARM64 && ARCH_SUNXI) || COMPILE_TEST
 
+config SUN50I_A100_CCU
+	bool "Support for the Allwinner A100 CCU"
+	default ARM64 && ARCH_SUNXI
+	depends on (ARM64 && ARCH_SUNXI) || COMPILE_TEST
+
+config SUN50I_A100_R_CCU
+	bool "Support for the Allwinner A100 PRCM CCU"
+	default ARM64 && ARCH_SUNXI
+	depends on (ARM64 && ARCH_SUNXI) || COMPILE_TEST
+
 config SUN50I_H6_CCU
 	bool "Support for the Allwinner H6 CCU"
 	default ARM64 && ARCH_SUNXI
@@ -38,6 +89,16 @@ config SUN5I_CCU
 	default MACH_SUN5I
 	depends on MACH_SUN5I || COMPILE_TEST
 
+config SUN55IW3_CCU
+	tristate "Support for the Allwinner SUN55IW3 CCU"
+	default ARM64 && ARCH_SUN55IW3
+	depends on (ARM64 && ARCH_SUNXI) || COMPILE_TEST
+
+config SUN55IW3_R_CCU
+	tristate "Support for the Allwinner SUN55IW3 PRCM CCU"
+	default ARM64 && ARCH_SUN55IW3
+	depends on (ARM64 && ARCH_SUNXI) || COMPILE_TEST
+
 config SUN6I_A31_CCU
 	bool "Support for the Allwinner A31/A31s CCU"
 	default MACH_SUN6I
@@ -86,3 +147,12 @@ config SUN8I_R_CCU
 	default MACH_SUN8I || (ARCH_SUNXI && ARM64)
 
 endif
+
+config SUNXI_RTC_CCU
+	tristate "Clock support in RTC domain for Allwinner SoCs"
+	depends on ARCH_SUNXI
+	default y
+	help
+	  sunxi clock provider in RTC domain, which provides clocks such as
+          dcxo24M-out, iosc, osc32k, osc32k-out and rtc-1k. This module is
+	  mandatory for sunxi SoCs. Say 'Y' here.
diff --git a/drivers/clk/sunxi-ng/Makefile b/drivers/clk/sunxi-ng/Makefile
index 4c7bee883..d9d19a87c 100644
--- a/drivers/clk/sunxi-ng/Makefile
+++ b/drivers/clk/sunxi-ng/Makefile
@@ -1,41 +1,58 @@
 # SPDX-License-Identifier: GPL-2.0
+
 # Common objects
-obj-y				+= ccu_common.o
-obj-y				+= ccu_mmc_timing.o
-obj-y				+= ccu_reset.o
+ccu-sunxi-ng-y					+= ccu_common.o
+ccu-sunxi-ng-y					+= ccu_mmc_timing.o
+ccu-sunxi-ng-y					+= ccu_reset.o
 
 # Base clock types
-obj-y				+= ccu_div.o
-obj-y				+= ccu_frac.o
-obj-y				+= ccu_gate.o
-obj-y				+= ccu_mux.o
-obj-y				+= ccu_mult.o
-obj-y				+= ccu_phase.o
-obj-y				+= ccu_sdm.o
+ccu-sunxi-ng-y					+= ccu_div.o
+ccu-sunxi-ng-y					+= ccu_frac.o
+ccu-sunxi-ng-y					+= ccu_gate.o
+ccu-sunxi-ng-y					+= ccu_mux.o
+ccu-sunxi-ng-y					+= ccu_mult.o
+ccu-sunxi-ng-y					+= ccu_phase.o
+ccu-sunxi-ng-y					+= ccu_sdm.o
 
 # Multi-factor clocks
-obj-y				+= ccu_nk.o
-obj-y				+= ccu_nkm.o
-obj-y				+= ccu_nkmp.o
-obj-y				+= ccu_nm.o
-obj-y				+= ccu_mp.o
+ccu-sunxi-ng-y					+= ccu_nk.o
+ccu-sunxi-ng-y					+= ccu_nkm.o
+ccu-sunxi-ng-y					+= ccu_nkmp.o
+ccu-sunxi-ng-y					+= ccu_nm.o
+ccu-sunxi-ng-y					+= ccu_mp.o
+
+obj-$(CONFIG_SUNXI_CCU)				+= ccu-sunxi-ng.o
+obj-$(CONFIG_SUNXI_RTC_CCU)			+= rtc-sunxi-ccu.o
 
 # SoC support
-obj-$(CONFIG_SUNIV_F1C100S_CCU)	+= ccu-suniv-f1c100s.o
-obj-$(CONFIG_SUN50I_A64_CCU)	+= ccu-sun50i-a64.o
-obj-$(CONFIG_SUN50I_H6_CCU)	+= ccu-sun50i-h6.o
-obj-$(CONFIG_SUN50I_H6_R_CCU)	+= ccu-sun50i-h6-r.o
-obj-$(CONFIG_SUN4I_A10_CCU)	+= ccu-sun4i-a10.o
-obj-$(CONFIG_SUN5I_CCU)		+= ccu-sun5i.o
-obj-$(CONFIG_SUN6I_A31_CCU)	+= ccu-sun6i-a31.o
-obj-$(CONFIG_SUN8I_A23_CCU)	+= ccu-sun8i-a23.o
-obj-$(CONFIG_SUN8I_A33_CCU)	+= ccu-sun8i-a33.o
-obj-$(CONFIG_SUN8I_A83T_CCU)	+= ccu-sun8i-a83t.o
-obj-$(CONFIG_SUN8I_H3_CCU)	+= ccu-sun8i-h3.o
-obj-$(CONFIG_SUN8I_V3S_CCU)	+= ccu-sun8i-v3s.o
-obj-$(CONFIG_SUN8I_DE2_CCU)	+= ccu-sun8i-de2.o
-obj-$(CONFIG_SUN8I_R_CCU)	+= ccu-sun8i-r.o
-obj-$(CONFIG_SUN8I_R40_CCU)	+= ccu-sun8i-r40.o
-obj-$(CONFIG_SUN9I_A80_CCU)	+= ccu-sun9i-a80.o
-obj-$(CONFIG_SUN9I_A80_CCU)	+= ccu-sun9i-a80-de.o
-obj-$(CONFIG_SUN9I_A80_CCU)	+= ccu-sun9i-a80-usb.o
+obj-$(CONFIG_SUN8IW20_CCU)		+= ccu-sun8iw20.o
+obj-$(CONFIG_SUN8IW20_CCU)		+= ccu-sun8iw20-rtc.o
+obj-$(CONFIG_SUN8IW20_R_CCU)		+= ccu-sun8iw20-r.o
+obj-$(CONFIG_SUN50IW12_CCU)		+= ccu-sun50iw12.o
+obj-$(CONFIG_SUN50IW12_R_CCU)		+= ccu-sun50iw12-r.o
+obj-$(CONFIG_SUN50IW10_CCU)		+= ccu-sun50iw10.o
+obj-$(CONFIG_SUN50IW10_R_CCU)		+= ccu-sun50iw10-r.o
+obj-$(CONFIG_SUN50IW9_CCU)		+= ccu-sun50iw9.o
+obj-$(CONFIG_SUN50IW9_CCU)		+= ccu-sun50iw9-rtc.o
+obj-$(CONFIG_SUN50IW9_R_CCU)		+= ccu-sun50iw9-r.o
+obj-$(CONFIG_SUN55IW3_CCU)		+= ccu-sun55iw3.o
+obj-$(CONFIG_SUN55IW3_CCU)		+= ccu-sun55iw3-rtc.o
+obj-$(CONFIG_SUN55IW3_R_CCU)		+= ccu-sun55iw3-r.o
+obj-$(CONFIG_SUNIV_F1C100S_CCU) 	+= ccu-suniv-f1c100s.o
+obj-$(CONFIG_SUN50I_A64_CCU)		+= ccu-sun50i-a64.o
+obj-$(CONFIG_SUN50I_H6_CCU)		+= ccu-sun50i-h6.o
+obj-$(CONFIG_SUN50I_H6_R_CCU)		+= ccu-sun50i-h6-r.o
+obj-$(CONFIG_SUN4I_A10_CCU)		+= ccu-sun4i-a10.o
+obj-$(CONFIG_SUN5I_CCU)			+= ccu-sun5i.o
+obj-$(CONFIG_SUN6I_A31_CCU)		+= ccu-sun6i-a31.o
+obj-$(CONFIG_SUN8I_A23_CCU)		+= ccu-sun8i-a23.o
+obj-$(CONFIG_SUN8I_A33_CCU)		+= ccu-sun8i-a33.o
+obj-$(CONFIG_SUN8I_A83T_CCU)		+= ccu-sun8i-a83t.o
+obj-$(CONFIG_SUN8I_H3_CCU)		+= ccu-sun8i-h3.o
+obj-$(CONFIG_SUN8I_V3S_CCU)		+= ccu-sun8i-v3s.o
+obj-$(CONFIG_SUN8I_DE2_CCU)		+= ccu-sun8i-de2.o
+obj-$(CONFIG_SUN8I_R_CCU)		+= ccu-sun8i-r.o
+obj-$(CONFIG_SUN8I_R40_CCU)		+= ccu-sun8i-r40.o
+obj-$(CONFIG_SUN9I_A80_CCU)		+= ccu-sun9i-a80.o
+obj-$(CONFIG_SUN9I_A80_CCU)		+= ccu-sun9i-a80-de.o
+obj-$(CONFIG_SUN9I_A80_CCU)		+= ccu-sun9i-a80-usb.o
diff --git a/drivers/clk/sunxi-ng/ccu-sun50i-a100-r.c b/drivers/clk/sunxi-ng/ccu-sun50i-a100-r.c
new file mode 100644
index 000000000..a56142b90
--- /dev/null
+++ b/drivers/clk/sunxi-ng/ccu-sun50i-a100-r.c
@@ -0,0 +1,214 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2020 Yangtao Li <frank@allwinnertech.com>
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+
+#include "ccu_common.h"
+#include "ccu_reset.h"
+
+#include "ccu_div.h"
+#include "ccu_gate.h"
+#include "ccu_mp.h"
+#include "ccu_nm.h"
+
+#include "ccu-sun50i-a100-r.h"
+
+static const char * const cpus_r_apb2_parents[] = { "dcxo24M", "osc32k",
+						     "iosc", "pll-periph0" };
+static const struct ccu_mux_var_prediv cpus_r_apb2_predivs[] = {
+	{ .index = 3, .shift = 0, .width = 5 },
+};
+
+static struct ccu_div r_cpus_clk = {
+	.div		= _SUNXI_CCU_DIV_FLAGS(8, 2, CLK_DIVIDER_POWER_OF_TWO),
+
+	.mux		= {
+		.shift	= 24,
+		.width	= 2,
+
+		.var_predivs	= cpus_r_apb2_predivs,
+		.n_var_predivs	= ARRAY_SIZE(cpus_r_apb2_predivs),
+	},
+
+	.common		= {
+		.reg		= 0x000,
+		.features	= CCU_FEATURE_VARIABLE_PREDIV,
+		.hw.init	= CLK_HW_INIT_PARENTS("cpus",
+						      cpus_r_apb2_parents,
+						      &ccu_div_ops,
+						      0),
+	},
+};
+
+static CLK_FIXED_FACTOR_HW(r_ahb_clk, "r-ahb", &r_cpus_clk.common.hw, 1, 1, 0);
+
+static struct ccu_div r_apb1_clk = {
+	.div		= _SUNXI_CCU_DIV(0, 2),
+
+	.common		= {
+		.reg		= 0x00c,
+		.hw.init	= CLK_HW_INIT("r-apb1",
+					      "r-ahb",
+					      &ccu_div_ops,
+					      0),
+	},
+};
+
+static struct ccu_div r_apb2_clk = {
+	.div		= _SUNXI_CCU_DIV_FLAGS(8, 2, CLK_DIVIDER_POWER_OF_TWO),
+
+	.mux		= {
+		.shift	= 24,
+		.width	= 2,
+
+		.var_predivs	= cpus_r_apb2_predivs,
+		.n_var_predivs	= ARRAY_SIZE(cpus_r_apb2_predivs),
+	},
+
+	.common		= {
+		.reg		= 0x010,
+		.features	= CCU_FEATURE_VARIABLE_PREDIV,
+		.hw.init	= CLK_HW_INIT_PARENTS("r-apb2",
+						      cpus_r_apb2_parents,
+						      &ccu_div_ops,
+						      0),
+	},
+};
+
+static const struct clk_parent_data clk_parent_r_apb1[] = {
+	{ .hw = &r_apb1_clk.common.hw },
+};
+
+static const struct clk_parent_data clk_parent_r_apb2[] = {
+	{ .hw = &r_apb2_clk.common.hw },
+};
+
+static SUNXI_CCU_GATE_DATA(r_apb1_timer_clk, "r-apb1-timer", clk_parent_r_apb1,
+			   0x11c, BIT(0), 0);
+
+static SUNXI_CCU_GATE_DATA(r_apb1_twd_clk, "r-apb1-twd", clk_parent_r_apb1,
+			   0x12c, BIT(0), 0);
+
+static const char * const r_apb1_pwm_clk_parents[] = { "dcxo24M", "osc32k",
+						       "iosc" };
+static SUNXI_CCU_MUX(r_apb1_pwm_clk, "r-apb1-pwm", r_apb1_pwm_clk_parents,
+		     0x130, 24, 2, 0);
+
+static SUNXI_CCU_GATE_DATA(r_apb1_bus_pwm_clk, "r-apb1-bus-pwm",
+			   clk_parent_r_apb1, 0x13c, BIT(0), 0);
+
+static SUNXI_CCU_GATE_DATA(r_apb1_ppu_clk, "r-apb1-ppu", clk_parent_r_apb1,
+			   0x17c, BIT(0), 0);
+
+static SUNXI_CCU_GATE_DATA(r_apb2_uart_clk, "r-apb2-uart", clk_parent_r_apb2,
+			   0x18c, BIT(0), 0);
+
+static SUNXI_CCU_GATE_DATA(r_apb2_i2c0_clk, "r-apb2-i2c0", clk_parent_r_apb2,
+			   0x19c, BIT(0), 0);
+
+static SUNXI_CCU_GATE_DATA(r_apb2_i2c1_clk, "r-apb2-i2c1", clk_parent_r_apb2,
+			   0x19c, BIT(1), 0);
+
+static const char * const r_apb1_ir_rx_parents[] = { "osc32k", "dcxo24M" };
+static SUNXI_CCU_MP_WITH_MUX_GATE(r_apb1_ir_rx_clk, "r-apb1-ir-rx",
+				  r_apb1_ir_rx_parents, 0x1c0,
+				  0, 5,		/* M */
+				  8, 2,		/* P */
+				  24, 1,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_GATE_DATA(r_apb1_bus_ir_rx_clk, "r-apb1-bus-ir-rx",
+			   clk_parent_r_apb1, 0x1cc, BIT(0), 0);
+
+static SUNXI_CCU_GATE(r_ahb_bus_rtc_clk, "r-ahb-rtc", "r-ahb",
+		      0x20c, BIT(0), 0);
+
+static struct ccu_common *sun50i_a100_r_ccu_clks[] = {
+	&r_cpus_clk.common,
+	&r_apb1_clk.common,
+	&r_apb2_clk.common,
+	&r_apb1_timer_clk.common,
+	&r_apb1_twd_clk.common,
+	&r_apb1_pwm_clk.common,
+	&r_apb1_bus_pwm_clk.common,
+	&r_apb1_ppu_clk.common,
+	&r_apb2_uart_clk.common,
+	&r_apb2_i2c0_clk.common,
+	&r_apb2_i2c1_clk.common,
+	&r_apb1_ir_rx_clk.common,
+	&r_apb1_bus_ir_rx_clk.common,
+	&r_ahb_bus_rtc_clk.common,
+};
+
+static struct clk_hw_onecell_data sun50i_a100_r_hw_clks = {
+	.hws	= {
+		[CLK_R_CPUS]		= &r_cpus_clk.common.hw,
+		[CLK_R_AHB]		= &r_ahb_clk.hw,
+		[CLK_R_APB1]		= &r_apb1_clk.common.hw,
+		[CLK_R_APB2]		= &r_apb2_clk.common.hw,
+		[CLK_R_APB1_TIMER]	= &r_apb1_timer_clk.common.hw,
+		[CLK_R_APB1_TWD]	= &r_apb1_twd_clk.common.hw,
+		[CLK_R_APB1_PWM]	= &r_apb1_pwm_clk.common.hw,
+		[CLK_R_APB1_BUS_PWM]	= &r_apb1_bus_pwm_clk.common.hw,
+		[CLK_R_APB1_PPU]	= &r_apb1_ppu_clk.common.hw,
+		[CLK_R_APB2_UART]	= &r_apb2_uart_clk.common.hw,
+		[CLK_R_APB2_I2C0]	= &r_apb2_i2c0_clk.common.hw,
+		[CLK_R_APB2_I2C1]	= &r_apb2_i2c1_clk.common.hw,
+		[CLK_R_APB1_IR]		= &r_apb1_ir_rx_clk.common.hw,
+		[CLK_R_APB1_BUS_IR]	= &r_apb1_bus_ir_rx_clk.common.hw,
+		[CLK_R_AHB_BUS_RTC]	= &r_ahb_bus_rtc_clk.common.hw,
+	},
+	.num	= CLK_NUMBER,
+};
+
+static struct ccu_reset_map sun50i_a100_r_ccu_resets[] = {
+	[RST_R_APB1_TIMER]	=  { 0x11c, BIT(16) },
+	[RST_R_APB1_BUS_PWM]	=  { 0x13c, BIT(16) },
+	[RST_R_APB1_PPU]	=  { 0x17c, BIT(16) },
+	[RST_R_APB2_UART]	=  { 0x18c, BIT(16) },
+	[RST_R_APB2_I2C0]	=  { 0x19c, BIT(16) },
+	[RST_R_APB2_I2C1]	=  { 0x19c, BIT(17) },
+	[RST_R_APB1_BUS_IR]	=  { 0x1cc, BIT(16) },
+	[RST_R_AHB_BUS_RTC]	=  { 0x20c, BIT(16) },
+};
+
+static const struct sunxi_ccu_desc sun50i_a100_r_ccu_desc = {
+	.ccu_clks	= sun50i_a100_r_ccu_clks,
+	.num_ccu_clks	= ARRAY_SIZE(sun50i_a100_r_ccu_clks),
+
+	.hw_clks	= &sun50i_a100_r_hw_clks,
+
+	.resets		= sun50i_a100_r_ccu_resets,
+	.num_resets	= ARRAY_SIZE(sun50i_a100_r_ccu_resets),
+};
+
+static int sun50i_a100_r_ccu_probe(struct platform_device *pdev)
+{
+	void __iomem *reg;
+
+	reg = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(reg))
+		return PTR_ERR(reg);
+
+	return sunxi_ccu_probe(pdev->dev.of_node, reg, &sun50i_a100_r_ccu_desc);
+}
+
+static const struct of_device_id sun50i_a100_r_ccu_ids[] = {
+	{ .compatible = "allwinner,sun50i-a100-r-ccu" },
+	{ }
+};
+
+static struct platform_driver sun50i_a100_r_ccu_driver = {
+	.probe	= sun50i_a100_r_ccu_probe,
+	.driver	= {
+		.name	= "sun50i-a100-r-ccu",
+		.of_match_table	= sun50i_a100_r_ccu_ids,
+	},
+};
+module_platform_driver(sun50i_a100_r_ccu_driver);
diff --git a/drivers/clk/sunxi-ng/ccu-sun50i-a100-r.h b/drivers/clk/sunxi-ng/ccu-sun50i-a100-r.h
new file mode 100644
index 000000000..3a8f187a5
--- /dev/null
+++ b/drivers/clk/sunxi-ng/ccu-sun50i-a100-r.h
@@ -0,0 +1,21 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2020 Yangtao Li <frank@allwinnertech.com>
+ */
+
+#ifndef _CCU_SUN50I_A100_R_H
+#define _CCU_SUN50I_A100_R_H
+
+#include <dt-bindings/clock/sun50i-a100-r-ccu.h>
+#include <dt-bindings/reset/sun50i-a100-r-ccu.h>
+
+#define CLK_R_CPUS		0
+#define CLK_R_AHB		1
+
+/* exported except APB1 for R_PIO */
+
+#define CLK_R_APB2		3
+
+#define CLK_NUMBER	(CLK_R_AHB_BUS_RTC + 1)
+
+#endif /* _CCU_SUN50I_A100_R_H */
diff --git a/drivers/clk/sunxi-ng/ccu-sun50i-a100.c b/drivers/clk/sunxi-ng/ccu-sun50i-a100.c
new file mode 100644
index 000000000..81b48c73d
--- /dev/null
+++ b/drivers/clk/sunxi-ng/ccu-sun50i-a100.c
@@ -0,0 +1,1276 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2020 Yangtao Li <frank@allwinnertech.com>
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+
+#include "ccu_common.h"
+#include "ccu_reset.h"
+
+#include "ccu_div.h"
+#include "ccu_gate.h"
+#include "ccu_mp.h"
+#include "ccu_mult.h"
+#include "ccu_nk.h"
+#include "ccu_nkm.h"
+#include "ccu_nkmp.h"
+#include "ccu_nm.h"
+
+#include "ccu-sun50i-a100.h"
+
+#define SUN50I_A100_PLL_SDM_ENABLE		BIT(24)
+#define SUN50I_A100_PLL_OUTPUT_ENABLE		BIT(27)
+#define SUN50I_A100_PLL_LOCK			BIT(28)
+#define SUN50I_A100_PLL_LOCK_ENABLE		BIT(29)
+#define SUN50I_A100_PLL_ENABLE			BIT(31)
+
+#define SUN50I_A100_PLL_PERIPH1_PATTERN0	0xd1303333
+
+/*
+ * The CPU PLL is actually NP clock, with P being /1, /2 or /4. However
+ * P should only be used for output frequencies lower than 288 MHz.
+ *
+ * For now we can just model it as a multiplier clock, and force P to /1.
+ *
+ * The M factor is present in the register's description, but not in the
+ * frequency formula, and it's documented as "M is only used for backdoor
+ * testing", so it's not modelled and then force to 0.
+ */
+#define SUN50I_A100_PLL_CPUX_REG		0x000
+static struct ccu_mult pll_cpux_clk = {
+	.enable		= SUN50I_A100_PLL_OUTPUT_ENABLE,
+	.lock		= SUN50I_A100_PLL_LOCK,
+	.mult		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.common		= {
+		.reg		= 0x000,
+		.hw.init	= CLK_HW_INIT("pll-cpux", "dcxo24M",
+					      &ccu_mult_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+/* Some PLLs are input * N / div1 / P. Model them as NKMP with no K */
+#define SUN50I_A100_PLL_DDR0_REG		0x010
+static struct ccu_nkmp pll_ddr0_clk = {
+	.enable		= SUN50I_A100_PLL_OUTPUT_ENABLE,
+	.lock		= SUN50I_A100_PLL_LOCK,
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.p		= _SUNXI_CCU_DIV(0, 1), /* output divider */
+	.common		= {
+		.reg		= 0x010,
+		.hw.init	= CLK_HW_INIT("pll-ddr0", "dcxo24M",
+					      &ccu_nkmp_ops,
+					      CLK_SET_RATE_UNGATE |
+					      CLK_IS_CRITICAL),
+	},
+};
+
+#define SUN50I_A100_PLL_PERIPH0_REG	0x020
+static struct ccu_nkmp pll_periph0_clk = {
+	.enable		= SUN50I_A100_PLL_OUTPUT_ENABLE,
+	.lock		= SUN50I_A100_PLL_LOCK,
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.p		= _SUNXI_CCU_DIV(0, 1), /* output divider */
+	.fixed_post_div	= 2,
+	.common		= {
+		.reg		= 0x020,
+		.features	= CCU_FEATURE_FIXED_POSTDIV,
+		.hw.init	= CLK_HW_INIT("pll-periph0", "dcxo24M",
+					      &ccu_nkmp_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+#define SUN50I_A100_PLL_PERIPH1_REG	0x028
+static struct ccu_nkmp pll_periph1_clk = {
+	.enable		= SUN50I_A100_PLL_OUTPUT_ENABLE,
+	.lock		= SUN50I_A100_PLL_LOCK,
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.p		= _SUNXI_CCU_DIV(0, 1), /* output divider */
+	.fixed_post_div	= 2,
+	.common		= {
+		.reg		= 0x028,
+		.features	= CCU_FEATURE_FIXED_POSTDIV,
+		.hw.init	= CLK_HW_INIT("pll-periph1", "dcxo24M",
+					      &ccu_nkmp_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+#define SUN50I_A100_PLL_PERIPH1_PATTERN0_REG	0x128
+
+#define SUN50I_A100_PLL_GPU_REG		0x030
+static struct ccu_nkmp pll_gpu_clk = {
+	.enable		= SUN50I_A100_PLL_OUTPUT_ENABLE,
+	.lock		= SUN50I_A100_PLL_LOCK,
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.p		= _SUNXI_CCU_DIV(0, 1), /* output divider */
+	.common		= {
+		.reg		= 0x030,
+		.hw.init	= CLK_HW_INIT("pll-gpu", "dcxo24M",
+					      &ccu_nkmp_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+/*
+ * For Video PLLs, the output divider is described as "used for testing"
+ * in the user manual. So it's not modelled and forced to 0.
+ */
+#define SUN50I_A100_PLL_VIDEO0_REG	0x040
+static struct ccu_nm pll_video0_clk = {
+	.enable		= SUN50I_A100_PLL_OUTPUT_ENABLE,
+	.lock		= SUN50I_A100_PLL_LOCK,
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.fixed_post_div	= 4,
+	.common		= {
+		.reg		= 0x040,
+		.features	= CCU_FEATURE_FIXED_POSTDIV,
+		.hw.init	= CLK_HW_INIT("pll-video0", "dcxo24M",
+					      &ccu_nm_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+#define SUN50I_A100_PLL_VIDEO1_REG	0x048
+static struct ccu_nm pll_video1_clk = {
+	.enable		= SUN50I_A100_PLL_OUTPUT_ENABLE,
+	.lock		= SUN50I_A100_PLL_LOCK,
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.fixed_post_div	= 4,
+	.common		= {
+		.reg		= 0x048,
+		.features	= CCU_FEATURE_FIXED_POSTDIV,
+		.hw.init	= CLK_HW_INIT("pll-video1", "dcxo24M",
+					      &ccu_nm_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+#define SUN50I_A100_PLL_VIDEO2_REG	0x050
+static struct ccu_nm pll_video2_clk = {
+	.enable		= SUN50I_A100_PLL_OUTPUT_ENABLE,
+	.lock		= SUN50I_A100_PLL_LOCK,
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.fixed_post_div	= 4,
+	.common		= {
+		.reg		= 0x050,
+		.features	= CCU_FEATURE_FIXED_POSTDIV,
+		.hw.init	= CLK_HW_INIT("pll-video2", "dcxo24M",
+					      &ccu_nm_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+#define SUN50I_A100_PLL_VE_REG		0x058
+static struct ccu_nkmp pll_ve_clk = {
+	.enable		= SUN50I_A100_PLL_OUTPUT_ENABLE,
+	.lock		= SUN50I_A100_PLL_LOCK,
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.p		= _SUNXI_CCU_DIV(0, 1), /* output divider */
+	.common		= {
+		.reg		= 0x058,
+		.hw.init	= CLK_HW_INIT("pll-ve", "dcxo24M",
+					      &ccu_nkmp_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+/*
+ * The COM PLL has m0 dividers in addition to the usual N, M
+ * factors. Since we only need 1 frequencies from this PLL: 45.1584 MHz,
+ * ignore it for now.
+ */
+#define SUN50I_A100_PLL_COM_REG		0x060
+static struct ccu_sdm_setting pll_com_sdm_table[] = {
+	{ .rate = 451584000, .pattern = 0xc0014396, .m = 2, .n = 37 },
+};
+
+static struct ccu_nm pll_com_clk = {
+	.enable		= SUN50I_A100_PLL_OUTPUT_ENABLE,
+	.lock		= SUN50I_A100_PLL_LOCK,
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(0, 1),
+	.sdm		= _SUNXI_CCU_SDM(pll_com_sdm_table, BIT(24),
+					 0x160, BIT(31)),
+	.common		= {
+		.reg		= 0x060,
+		.features	= CCU_FEATURE_SIGMA_DELTA_MOD,
+		.hw.init	= CLK_HW_INIT("pll-com", "dcxo24M",
+					      &ccu_nm_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+#define SUN50I_A100_PLL_VIDEO3_REG	0x068
+static struct ccu_nm pll_video3_clk = {
+	.enable		= SUN50I_A100_PLL_OUTPUT_ENABLE,
+	.lock		= SUN50I_A100_PLL_LOCK,
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.fixed_post_div	= 4,
+	.common		= {
+		.reg		= 0x068,
+		.features	= CCU_FEATURE_FIXED_POSTDIV,
+		.hw.init	= CLK_HW_INIT("pll-video3", "dcxo24M",
+					      &ccu_nm_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+/*
+ * The Audio PLL has m0, m1 dividers in addition to the usual N, M
+ * factors. Since we only need 4 frequencies from this PLL: 22.5792 MHz,
+ * 24.576 MHz, 90.3168MHz and 98.304MHz ignore them for now.
+ * Enforce the default for them, which is m0 = 1, m1 = 0.
+ */
+#define SUN50I_A100_PLL_AUDIO_REG		0x078
+static struct ccu_sdm_setting pll_audio_sdm_table[] = {
+	{ .rate = 45158400, .pattern = 0xc001bcd3, .m = 18, .n = 33 },
+	{ .rate = 49152000, .pattern = 0xc001eb85, .m = 20, .n = 40 },
+	{ .rate = 180633600, .pattern = 0xc001288d, .m = 3, .n = 22 },
+	{ .rate = 196608000, .pattern = 0xc001eb85, .m = 5, .n = 40 },
+};
+
+static struct ccu_nm pll_audio_clk = {
+	.enable		= SUN50I_A100_PLL_OUTPUT_ENABLE,
+	.lock		= SUN50I_A100_PLL_LOCK,
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(16, 6),
+	.fixed_post_div	= 2,
+	.sdm		= _SUNXI_CCU_SDM(pll_audio_sdm_table, BIT(24),
+					 0x178, BIT(31)),
+	.common		= {
+		.reg		= 0x078,
+		.features	= CCU_FEATURE_FIXED_POSTDIV |
+				  CCU_FEATURE_SIGMA_DELTA_MOD,
+		.hw.init	= CLK_HW_INIT("pll-audio", "dcxo24M",
+					      &ccu_nm_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+static const char * const cpux_parents[] = { "dcxo24M", "osc32k",
+					     "iosc", "pll-cpux",
+					      "pll-periph0" };
+static SUNXI_CCU_MUX(cpux_clk, "cpux", cpux_parents,
+		     0x500, 24, 3, CLK_SET_RATE_PARENT | CLK_IS_CRITICAL);
+static SUNXI_CCU_M(axi_clk, "axi", "cpux", 0x500, 0, 2, 0);
+static SUNXI_CCU_M(cpux_apb_clk, "cpux-apb", "cpux", 0x500, 8, 2, 0);
+
+static const char * const psi_ahb1_ahb2_parents[] = { "dcxo24M", "osc32k",
+						      "iosc", "pll-periph0",
+						      "pll-periph0-2x" };
+static SUNXI_CCU_MP_WITH_MUX(psi_ahb1_ahb2_clk, "psi-ahb1-ahb2",
+			     psi_ahb1_ahb2_parents, 0x510,
+			     0, 2,	/* M */
+			     8, 2,	/* P */
+			     24, 3,	/* mux */
+			     0);
+
+static const char * const ahb3_apb1_apb2_parents[] = { "dcxo24M", "osc32k",
+						       "psi-ahb1-ahb2",
+						       "pll-periph0",
+						       "pll-periph0-2x" };
+static SUNXI_CCU_MP_WITH_MUX(ahb3_clk, "ahb3", ahb3_apb1_apb2_parents, 0x51c,
+			     0, 2,	/* M */
+			     8, 2,	/* P */
+			     24, 3,	/* mux */
+			     0);
+
+static SUNXI_CCU_MP_WITH_MUX(apb1_clk, "apb1", ahb3_apb1_apb2_parents, 0x520,
+			     0, 2,	/* M */
+			     8, 2,	/* P */
+			     24, 3,	/* mux */
+			     0);
+
+static SUNXI_CCU_MP_WITH_MUX(apb2_clk, "apb2", ahb3_apb1_apb2_parents, 0x524,
+			     0, 2,	/* M */
+			     8, 2,	/* P */
+			     24, 3,	/* mux */
+			     0);
+
+static const char * const mbus_parents[] = { "dcxo24M", "pll-ddr0",
+					     "pll-periph0",
+					     "pll-periph0-2x" };
+static SUNXI_CCU_M_WITH_MUX_GATE(mbus_clk, "mbus", mbus_parents, 0x540,
+				 0, 3,		/* M */
+				 24, 2,		/* mux */
+				 BIT(31),	/* gate */
+				 CLK_IS_CRITICAL);
+
+static const char * const de_parents[] = { "pll-com", "pll-periph0-2x" };
+static SUNXI_CCU_M_WITH_MUX_GATE(de_clk, "de0", de_parents, 0x600,
+				 0, 4,		/* M */
+				 24, 1,		/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_PARENT);
+
+static SUNXI_CCU_GATE(bus_de_clk, "bus-de", "psi-ahb1-ahb2",
+		      0x60c, BIT(0), 0);
+
+static const char * const g2d_parents[] = { "pll-com", "pll-periph0-2x",
+					     "pll-video0-2x", "pll-video1-2x",
+					     "pll-video2-2x"};
+static SUNXI_CCU_M_WITH_MUX_GATE(g2d_clk, "g2d",
+				 g2d_parents,
+				 0x630,
+				 0, 4,		/* M */
+				 24, 3,		/* mux */
+				 BIT(31),	/* gate */
+				 0);
+
+static SUNXI_CCU_GATE(bus_g2d_clk, "bus-g2d", "psi-ahb1-ahb2",
+		      0x63c, BIT(0), 0);
+
+static const char * const gpu_parents[] = { "pll-gpu" };
+static SUNXI_CCU_M_WITH_MUX_GATE(gpu_clk, "gpu", gpu_parents, 0x670,
+				       0, 2,	/* M */
+				       24, 1,	/* mux */
+				       BIT(31),	/* gate */
+				       0);
+
+static SUNXI_CCU_GATE(bus_gpu_clk, "bus-gpu", "psi-ahb1-ahb2",
+		      0x67c, BIT(0), 0);
+
+static const char * const ce_parents[] = { "dcxo24M", "pll-periph0-2x" };
+static SUNXI_CCU_MP_WITH_MUX_GATE(ce_clk, "ce", ce_parents, 0x680,
+				  0, 4,		/* M */
+				  8, 2,		/* P */
+				  24, 1,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_GATE(bus_ce_clk, "bus-ce", "psi-ahb1-ahb2",
+		      0x68c, BIT(0), 0);
+
+static const char * const ve_parents[] = { "pll-ve" };
+static SUNXI_CCU_M_WITH_MUX_GATE(ve_clk, "ve", ve_parents, 0x690,
+				 0, 3,		/* M */
+				 24, 1,		/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_PARENT);
+
+static SUNXI_CCU_GATE(bus_ve_clk, "bus-ve", "psi-ahb1-ahb2",
+		      0x69c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_dma_clk, "bus-dma", "psi-ahb1-ahb2",
+		      0x70c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_msgbox_clk, "bus-msgbox", "psi-ahb1-ahb2",
+		      0x71c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_spinlock_clk, "bus-spinlock", "psi-ahb1-ahb2",
+		      0x72c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_hstimer_clk, "bus-hstimer", "psi-ahb1-ahb2",
+		      0x73c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(avs_clk, "avs", "dcxo24M", 0x740, BIT(31), 0);
+
+static SUNXI_CCU_GATE(bus_dbg_clk, "bus-dbg", "psi-ahb1-ahb2",
+		      0x78c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_psi_clk, "bus-psi", "psi-ahb1-ahb2",
+		      0x79c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_pwm_clk, "bus-pwm", "apb1", 0x7ac, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_iommu_clk, "bus-iommu", "apb1", 0x7bc, BIT(0), 0);
+
+static SUNXI_CCU_GATE(mbus_dma_clk, "mbus-dma", "mbus",
+		      0x804, BIT(0), 0);
+static SUNXI_CCU_GATE(mbus_ve_clk, "mbus-ve", "mbus",
+		      0x804, BIT(1), 0);
+static SUNXI_CCU_GATE(mbus_ce_clk, "mbus-ce", "mbus",
+		      0x804, BIT(2), 0);
+static SUNXI_CCU_GATE(mbus_nand_clk, "mbus-nand", "mbus",
+		      0x804, BIT(5), 0);
+static SUNXI_CCU_GATE(mbus_csi_clk, "mbus-csi", "mbus",
+		      0x804, BIT(8), 0);
+static SUNXI_CCU_GATE(mbus_isp_clk, "mbus-isp", "mbus",
+		      0x804, BIT(9), 0);
+static SUNXI_CCU_GATE(mbus_g2d_clk, "mbus-g2d", "mbus",
+		      0x804, BIT(10), 0);
+
+static SUNXI_CCU_GATE(bus_dram_clk, "bus-dram", "psi-ahb1-ahb2",
+		      0x80c, BIT(0), CLK_IS_CRITICAL);
+
+static const char * const nand_spi_parents[] = { "dcxo24M",
+						 "pll-periph0",
+						 "pll-periph1",
+						 "pll-periph0-2x",
+						 "pll-periph1-2x" };
+static SUNXI_CCU_MP_WITH_MUX_GATE(nand0_clk, "nand0", nand_spi_parents, 0x810,
+				  0, 4,		/* M */
+				  8, 2,		/* P */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(nand1_clk, "nand1", nand_spi_parents, 0x814,
+				  0, 4,		/* M */
+				  8, 2,		/* P */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_GATE(bus_nand_clk, "bus-nand", "ahb3", 0x82c, BIT(0), 0);
+
+static const char * const mmc_parents[] = { "dcxo24M", "pll-periph0-2x",
+					    "pll-periph1-2x" };
+static SUNXI_CCU_MP_WITH_MUX_GATE_POSTDIV(mmc0_clk, "mmc0", mmc_parents, 0x830,
+					  0, 4,		/* M */
+					  8, 2,		/* P */
+					  24, 2,	/* mux */
+					  BIT(31),	/* gate */
+					  2,		/* post-div */
+					  CLK_SET_RATE_NO_REPARENT);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE_POSTDIV(mmc1_clk, "mmc1", mmc_parents, 0x834,
+					  0, 4,		/* M */
+					  8, 2,		/* P */
+					  24, 2,	/* mux */
+					  BIT(31),	/* gate */
+					  2,		/* post-div */
+					  CLK_SET_RATE_NO_REPARENT);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE_POSTDIV(mmc2_clk, "mmc2", mmc_parents, 0x838,
+					  0, 4,		/* M */
+					  8, 2,		/* P */
+					  24, 2,	/* mux */
+					  BIT(31),	/* gate */
+					  2,		/* post-div */
+					  CLK_SET_RATE_NO_REPARENT);
+
+static SUNXI_CCU_GATE(bus_mmc0_clk, "bus-mmc0", "ahb3", 0x84c, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_mmc1_clk, "bus-mmc1", "ahb3", 0x84c, BIT(1), 0);
+static SUNXI_CCU_GATE(bus_mmc2_clk, "bus-mmc2", "ahb3", 0x84c, BIT(2), 0);
+
+static SUNXI_CCU_GATE(bus_uart0_clk, "bus-uart0", "apb2", 0x90c, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_uart1_clk, "bus-uart1", "apb2", 0x90c, BIT(1), 0);
+static SUNXI_CCU_GATE(bus_uart2_clk, "bus-uart2", "apb2", 0x90c, BIT(2), 0);
+static SUNXI_CCU_GATE(bus_uart3_clk, "bus-uart3", "apb2", 0x90c, BIT(3), 0);
+static SUNXI_CCU_GATE(bus_uart4_clk, "bus-uart4", "apb2", 0x90c, BIT(4), 0);
+
+static SUNXI_CCU_GATE(bus_i2c0_clk, "bus-i2c0", "apb2", 0x91c, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_i2c1_clk, "bus-i2c1", "apb2", 0x91c, BIT(1), 0);
+static SUNXI_CCU_GATE(bus_i2c2_clk, "bus-i2c2", "apb2", 0x91c, BIT(2), 0);
+static SUNXI_CCU_GATE(bus_i2c3_clk, "bus-i2c3", "apb2", 0x91c, BIT(3), 0);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(spi0_clk, "spi0", nand_spi_parents, 0x940,
+				  0, 4,		/* M */
+				  8, 2,		/* P */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(spi1_clk, "spi1", nand_spi_parents, 0x944,
+				  0, 4,		/* M */
+				  8, 2,		/* P */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(spi2_clk, "spi2", nand_spi_parents, 0x948,
+				  0, 4,		/* M */
+				  8, 2,		/* P */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_GATE(bus_spi0_clk, "bus-spi0", "ahb3", 0x96c, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_spi1_clk, "bus-spi1", "ahb3", 0x96c, BIT(1), 0);
+static SUNXI_CCU_GATE(bus_spi2_clk, "bus-spi2", "ahb3", 0x96c, BIT(2), 0);
+
+static SUNXI_CCU_GATE(emac_25m_clk, "emac-25m", "ahb3", 0x970,
+		      BIT(31) | BIT(30), 0);
+
+static SUNXI_CCU_GATE(bus_emac_clk, "bus-emac", "ahb3", 0x97c, BIT(0), 0);
+
+static const char * const ir_parents[] = { "osc32k", "iosc",
+					   "pll-periph0", "pll-periph1" };
+static SUNXI_CCU_MP_WITH_MUX_GATE(ir_rx_clk, "ir-rx", ir_parents, 0x990,
+				  0, 4,		/* M */
+				  8, 2,		/* P */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_GATE(bus_ir_rx_clk, "bus-ir-rx", "ahb3", 0x99c, BIT(0), 0);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(ir_tx_clk, "ir-tx", ir_parents, 0x9c0,
+				  0, 4,		/* M */
+				  8, 2,		/* P */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_GATE(bus_ir_tx_clk, "bus-ir-tx", "apb1", 0x9cc, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_gpadc_clk, "bus-gpadc", "apb1", 0x9ec, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_ths_clk, "bus-ths", "apb1", 0x9fc, BIT(0), 0);
+
+static const char * const audio_parents[] = { "pll-audio", "pll-com-audio" };
+static struct ccu_div i2s0_clk = {
+	.enable		= BIT(31),
+	.div		= _SUNXI_CCU_DIV_FLAGS(8, 2, CLK_DIVIDER_POWER_OF_TWO),
+	.mux		= _SUNXI_CCU_MUX(24, 2),
+	.common		= {
+		.reg		= 0xa10,
+		.hw.init	= CLK_HW_INIT_PARENTS("i2s0",
+						      audio_parents,
+						      &ccu_div_ops,
+						      CLK_SET_RATE_PARENT),
+	},
+};
+
+static struct ccu_div i2s1_clk = {
+	.enable		= BIT(31),
+	.div		= _SUNXI_CCU_DIV_FLAGS(8, 2, CLK_DIVIDER_POWER_OF_TWO),
+	.mux		= _SUNXI_CCU_MUX(24, 2),
+	.common		= {
+		.reg		= 0xa14,
+		.hw.init	= CLK_HW_INIT_PARENTS("i2s1",
+						      audio_parents,
+						      &ccu_div_ops,
+						      CLK_SET_RATE_PARENT),
+	},
+};
+
+static struct ccu_div i2s2_clk = {
+	.enable		= BIT(31),
+	.div		= _SUNXI_CCU_DIV_FLAGS(8, 2, CLK_DIVIDER_POWER_OF_TWO),
+	.mux		= _SUNXI_CCU_MUX(24, 2),
+	.common		= {
+		.reg		= 0xa18,
+		.hw.init	= CLK_HW_INIT_PARENTS("i2s2",
+						      audio_parents,
+						      &ccu_div_ops,
+						      CLK_SET_RATE_PARENT),
+	},
+};
+
+static struct ccu_div i2s3_clk = {
+	.enable		= BIT(31),
+	.div		= _SUNXI_CCU_DIV_FLAGS(8, 2, CLK_DIVIDER_POWER_OF_TWO),
+	.mux		= _SUNXI_CCU_MUX(24, 2),
+	.common		= {
+		.reg		= 0xa1c,
+		.hw.init	= CLK_HW_INIT_PARENTS("i2s3",
+						      audio_parents,
+						      &ccu_div_ops,
+						      CLK_SET_RATE_PARENT),
+	},
+};
+
+static SUNXI_CCU_GATE(bus_i2s0_clk, "bus-i2s0", "apb1", 0xa20, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_i2s1_clk, "bus-i2s1", "apb1", 0xa20, BIT(1), 0);
+static SUNXI_CCU_GATE(bus_i2s2_clk, "bus-i2s2", "apb1", 0xa20, BIT(2), 0);
+static SUNXI_CCU_GATE(bus_i2s3_clk, "bus-i2s3", "apb1", 0xa20, BIT(3), 0);
+
+static struct ccu_div spdif_clk = {
+	.enable		= BIT(31),
+	.div		= _SUNXI_CCU_DIV_FLAGS(8, 2, CLK_DIVIDER_POWER_OF_TWO),
+	.mux		= _SUNXI_CCU_MUX(24, 2),
+	.common		= {
+		.reg		= 0xa24,
+		.hw.init	= CLK_HW_INIT_PARENTS("spdif",
+						      audio_parents,
+						      &ccu_div_ops,
+						      0),
+	},
+};
+
+static SUNXI_CCU_GATE(bus_spdif_clk, "bus-spdif", "apb1", 0xa2c, BIT(0), 0);
+
+static struct ccu_div dmic_clk = {
+	.enable		= BIT(31),
+	.div		= _SUNXI_CCU_DIV_FLAGS(8, 2, CLK_DIVIDER_POWER_OF_TWO),
+	.mux		= _SUNXI_CCU_MUX(24, 2),
+	.common		= {
+		.reg		= 0xa40,
+		.hw.init	= CLK_HW_INIT_PARENTS("dmic",
+						      audio_parents,
+						      &ccu_div_ops,
+						      0),
+	},
+};
+
+static SUNXI_CCU_GATE(bus_dmic_clk, "bus-dmic", "apb1", 0xa4c, BIT(0), 0);
+
+static SUNXI_CCU_M_WITH_MUX_GATE(audio_codec_dac_clk, "audio-codec-dac",
+				 audio_parents, 0xa50,
+				 0, 4,		/* M */
+				 24, 2,		/* mux */
+				 BIT(31),	/* gate */
+				 0);
+
+static SUNXI_CCU_M_WITH_MUX_GATE(audio_codec_adc_clk, "audio-codec-adc",
+				 audio_parents, 0xa54,
+				 0, 4,		/* M */
+				 24, 2,		/* mux */
+				 BIT(31),	/* gate */
+				 0);
+
+static SUNXI_CCU_M_WITH_MUX_GATE(audio_codec_4x_clk, "audio-codec-4x",
+				 audio_parents, 0xa58,
+				 0, 4,		/* M */
+				 24, 2,		/* mux */
+				 BIT(31),	/* gate */
+				 0);
+
+static SUNXI_CCU_GATE(bus_audio_codec_clk, "bus-audio-codec", "apb1", 0xa5c,
+		      BIT(0), 0);
+
+/*
+ * There are OHCI 12M clock source selection bits for 2 USB 2.0 ports.
+ * We will force them to 0 (12M divided from 48M).
+ */
+#define SUN50I_A100_USB0_CLK_REG		0xa70
+#define SUN50I_A100_USB1_CLK_REG		0xa74
+
+static SUNXI_CCU_GATE(usb_ohci0_clk, "usb-ohci0", "osc12M", 0xa70, BIT(31), 0);
+static SUNXI_CCU_GATE(usb_phy0_clk, "usb-phy0", "dcxo24M", 0xa70, BIT(29), 0);
+
+static SUNXI_CCU_GATE(usb_ohci1_clk, "usb-ohci1", "osc12M", 0xa74, BIT(31), 0);
+static SUNXI_CCU_GATE(usb_phy1_clk, "usb-phy1", "dcxo24M", 0xa74, BIT(29), 0);
+
+static SUNXI_CCU_GATE(bus_ohci0_clk, "bus-ohci0", "ahb3", 0xa8c, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_ohci1_clk, "bus-ohci1", "ahb3", 0xa8c, BIT(1), 0);
+static SUNXI_CCU_GATE(bus_ehci0_clk, "bus-ehci0", "ahb3", 0xa8c, BIT(4), 0);
+static SUNXI_CCU_GATE(bus_ehci1_clk, "bus-ehci1", "ahb3", 0xa8c, BIT(5), 0);
+static SUNXI_CCU_GATE(bus_otg_clk, "bus-otg", "ahb3", 0xa8c, BIT(8), 0);
+
+static SUNXI_CCU_GATE(bus_lradc_clk, "bus-lradc", "ahb3", 0xa9c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_dpss_top0_clk, "bus-dpss-top0", "ahb3",
+		      0xabc, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_dpss_top1_clk, "bus-dpss-top1", "ahb3",
+		      0xacc, BIT(0), 0);
+
+static const char * const mipi_dsi_parents[] = { "dcxo24M", "pll-periph0-2x",
+						 "pll-periph0" };
+static SUNXI_CCU_M_WITH_MUX_GATE(mipi_dsi_clk, "mipi-dsi",
+				 mipi_dsi_parents,
+				 0xb24,
+				 0, 4,		/* M */
+				 24, 2,		/* mux */
+				 BIT(31),	/* gate */
+				 0);
+
+static SUNXI_CCU_GATE(bus_mipi_dsi_clk, "bus-mipi-dsi", "ahb3",
+		      0xb4c, BIT(0), 0);
+
+static const char * const tcon_lcd_parents[] = { "pll-video0-4x",
+						  "pll-video1-4x",
+						  "pll-video2-4x",
+						  "pll-video3-4x",
+						  "pll-periph0-2x" };
+static SUNXI_CCU_MP_WITH_MUX_GATE(tcon_lcd_clk, "tcon-lcd0",
+				  tcon_lcd_parents, 0xb60,
+				  0, 4,		/* M */
+				  8, 2,		/* P */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_GATE(bus_tcon_lcd_clk, "bus-tcon-lcd0", "ahb3",
+		      0xb7c, BIT(0), 0);
+
+static const char * const ledc_parents[] = { "dcxo24M",
+					     "pll-periph0" };
+static SUNXI_CCU_MP_WITH_MUX_GATE(ledc_clk, "ledc",
+				  ledc_parents, 0xbf0,
+				  0, 4,		/* M */
+				  8, 2,		/* P */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_GATE(bus_ledc_clk, "bus-ledc", "ahb3", 0xbfc, BIT(0), 0);
+
+static const char * const csi_top_parents[] = { "pll-periph0-2x",
+						"pll-video0-2x",
+						"pll-video1-2x",
+						"pll-video2-2x",
+						"pll-video3-2x" };
+static SUNXI_CCU_M_WITH_MUX_GATE(csi_top_clk, "csi-top",
+				 csi_top_parents, 0xc04,
+				 0, 4,		/* M */
+				 24, 3,		/* mux */
+				 BIT(31),	/* gate */
+				 0);
+
+static const char * const csi0_mclk_parents[] = { "dcxo24M", "pll-video2",
+						  "pll-video3", "pll-video0",
+						  "pll-video1" };
+static SUNXI_CCU_M_WITH_MUX_GATE(csi0_mclk_clk, "csi0-mclk",
+				 csi0_mclk_parents, 0xc08,
+				 0, 5,		/* M */
+				 24, 3,		/* mux */
+				 BIT(31),	/* gate */
+				 0);
+
+static const char * const csi1_mclk_parents[] = { "dcxo24M", "pll-video3",
+						  "pll-video0", "pll-video1",
+						  "pll-video2" };
+static SUNXI_CCU_M_WITH_MUX_GATE(csi1_mclk_clk, "csi1-mclk",
+				 csi1_mclk_parents, 0xc0c,
+				 0, 5,		/* M */
+				 24, 3,		/* mux */
+				 BIT(31),	/* gate */
+				 0);
+
+static SUNXI_CCU_GATE(bus_csi_clk, "bus-csi", "ahb3", 0xc1c, BIT(0), 0);
+
+static const char * const csi_isp_parents[] = { "pll-periph0-2x",
+						"pll-video0-2x",
+						"pll-video1-2x",
+						"pll-video2-2x",
+						"pll-video3-2x" };
+static SUNXI_CCU_M_WITH_MUX_GATE(csi_isp_clk, "csi-isp",
+				 csi_isp_parents, 0xc20,
+				 0, 5,		/* M */
+				 24, 3,		/* mux */
+				 BIT(31),	/* gate */
+				 0);
+
+/* Fixed factor clocks */
+static CLK_FIXED_FACTOR_FW_NAME(osc12M_clk, "osc12M", "hosc", 2, 1, 0);
+
+static CLK_FIXED_FACTOR_HW(pll_com_audio_clk, "pll-com-audio",
+			   &pll_com_clk.common.hw,
+			   5, 1, CLK_SET_RATE_PARENT);
+
+static CLK_FIXED_FACTOR_HW(pll_periph0_2x_clk, "pll-periph0-2x",
+			   &pll_periph0_clk.common.hw,
+			   1, 2, 0);
+
+static CLK_FIXED_FACTOR_HW(pll_periph1_2x_clk, "pll-periph1-2x",
+			   &pll_periph1_clk.common.hw,
+			   1, 2, 0);
+
+static const struct clk_hw *pll_video0_parents[] = {
+	&pll_video0_clk.common.hw
+};
+static CLK_FIXED_FACTOR_HWS(pll_video0_4x_clk, "pll-video0-4x",
+			    pll_video0_parents,
+			    1, 4, CLK_SET_RATE_PARENT);
+static CLK_FIXED_FACTOR_HWS(pll_video0_2x_clk, "pll-video0-2x",
+			    pll_video0_parents,
+			    1, 2, CLK_SET_RATE_PARENT);
+
+static const struct clk_hw *pll_video1_parents[] = {
+	&pll_video1_clk.common.hw
+};
+static CLK_FIXED_FACTOR_HWS(pll_video1_4x_clk, "pll-video1-4x",
+			    pll_video1_parents,
+			    1, 4, CLK_SET_RATE_PARENT);
+static CLK_FIXED_FACTOR_HWS(pll_video1_2x_clk, "pll-video1-2x",
+			    pll_video1_parents,
+			    1, 2, CLK_SET_RATE_PARENT);
+
+static const struct clk_hw *pll_video2_parents[] = {
+	&pll_video2_clk.common.hw
+};
+static CLK_FIXED_FACTOR_HWS(pll_video2_4x_clk, "pll-video2-4x",
+			    pll_video2_parents,
+			    1, 4, CLK_SET_RATE_PARENT);
+static CLK_FIXED_FACTOR_HWS(pll_video2_2x_clk, "pll-video2-2x",
+			    pll_video2_parents,
+			    1, 2, CLK_SET_RATE_PARENT);
+
+static const struct clk_hw *pll_video3_parents[] = {
+	&pll_video3_clk.common.hw
+};
+static CLK_FIXED_FACTOR_HWS(pll_video3_4x_clk, "pll-video3-4x",
+			    pll_video3_parents,
+			    1, 4, CLK_SET_RATE_PARENT);
+static CLK_FIXED_FACTOR_HWS(pll_video3_2x_clk, "pll-video3-2x",
+			    pll_video3_parents,
+			    1, 2, CLK_SET_RATE_PARENT);
+
+static struct ccu_common *sun50i_a100_ccu_clks[] = {
+	&pll_cpux_clk.common,
+	&pll_ddr0_clk.common,
+	&pll_periph0_clk.common,
+	&pll_periph1_clk.common,
+	&pll_gpu_clk.common,
+	&pll_video0_clk.common,
+	&pll_video1_clk.common,
+	&pll_video2_clk.common,
+	&pll_video3_clk.common,
+	&pll_ve_clk.common,
+	&pll_com_clk.common,
+	&pll_audio_clk.common,
+	&cpux_clk.common,
+	&axi_clk.common,
+	&cpux_apb_clk.common,
+	&psi_ahb1_ahb2_clk.common,
+	&ahb3_clk.common,
+	&apb1_clk.common,
+	&apb2_clk.common,
+	&mbus_clk.common,
+	&de_clk.common,
+	&bus_de_clk.common,
+	&g2d_clk.common,
+	&bus_g2d_clk.common,
+	&gpu_clk.common,
+	&bus_gpu_clk.common,
+	&ce_clk.common,
+	&bus_ce_clk.common,
+	&ve_clk.common,
+	&bus_ve_clk.common,
+	&bus_dma_clk.common,
+	&bus_msgbox_clk.common,
+	&bus_spinlock_clk.common,
+	&bus_hstimer_clk.common,
+	&avs_clk.common,
+	&bus_dbg_clk.common,
+	&bus_psi_clk.common,
+	&bus_pwm_clk.common,
+	&bus_iommu_clk.common,
+	&mbus_dma_clk.common,
+	&mbus_ve_clk.common,
+	&mbus_ce_clk.common,
+	&mbus_nand_clk.common,
+	&mbus_csi_clk.common,
+	&mbus_isp_clk.common,
+	&mbus_g2d_clk.common,
+	&bus_dram_clk.common,
+	&nand0_clk.common,
+	&nand1_clk.common,
+	&bus_nand_clk.common,
+	&mmc0_clk.common,
+	&mmc1_clk.common,
+	&mmc2_clk.common,
+	&bus_mmc0_clk.common,
+	&bus_mmc1_clk.common,
+	&bus_mmc2_clk.common,
+	&bus_uart0_clk.common,
+	&bus_uart1_clk.common,
+	&bus_uart2_clk.common,
+	&bus_uart3_clk.common,
+	&bus_uart4_clk.common,
+	&bus_i2c0_clk.common,
+	&bus_i2c1_clk.common,
+	&bus_i2c2_clk.common,
+	&bus_i2c3_clk.common,
+	&spi0_clk.common,
+	&spi1_clk.common,
+	&spi2_clk.common,
+	&bus_spi0_clk.common,
+	&bus_spi1_clk.common,
+	&bus_spi2_clk.common,
+	&emac_25m_clk.common,
+	&bus_emac_clk.common,
+	&ir_rx_clk.common,
+	&bus_ir_rx_clk.common,
+	&ir_tx_clk.common,
+	&bus_ir_tx_clk.common,
+	&bus_gpadc_clk.common,
+	&bus_ths_clk.common,
+	&i2s0_clk.common,
+	&i2s1_clk.common,
+	&i2s2_clk.common,
+	&i2s3_clk.common,
+	&bus_i2s0_clk.common,
+	&bus_i2s1_clk.common,
+	&bus_i2s2_clk.common,
+	&bus_i2s3_clk.common,
+	&spdif_clk.common,
+	&bus_spdif_clk.common,
+	&dmic_clk.common,
+	&bus_dmic_clk.common,
+	&audio_codec_dac_clk.common,
+	&audio_codec_adc_clk.common,
+	&audio_codec_4x_clk.common,
+	&bus_audio_codec_clk.common,
+	&usb_ohci0_clk.common,
+	&usb_phy0_clk.common,
+	&usb_ohci1_clk.common,
+	&usb_phy1_clk.common,
+	&bus_ohci0_clk.common,
+	&bus_ohci1_clk.common,
+	&bus_ehci0_clk.common,
+	&bus_ehci1_clk.common,
+	&bus_otg_clk.common,
+	&bus_lradc_clk.common,
+	&bus_dpss_top0_clk.common,
+	&bus_dpss_top1_clk.common,
+	&mipi_dsi_clk.common,
+	&bus_mipi_dsi_clk.common,
+	&tcon_lcd_clk.common,
+	&bus_tcon_lcd_clk.common,
+	&ledc_clk.common,
+	&bus_ledc_clk.common,
+	&csi_top_clk.common,
+	&csi0_mclk_clk.common,
+	&csi1_mclk_clk.common,
+	&bus_csi_clk.common,
+	&csi_isp_clk.common,
+};
+
+static struct clk_hw_onecell_data sun50i_a100_hw_clks = {
+	.hws	= {
+		[CLK_OSC12M]		= &osc12M_clk.hw,
+		[CLK_PLL_CPUX]		= &pll_cpux_clk.common.hw,
+		[CLK_PLL_DDR0]		= &pll_ddr0_clk.common.hw,
+		[CLK_PLL_PERIPH0]	= &pll_periph0_clk.common.hw,
+		[CLK_PLL_PERIPH0_2X]	= &pll_periph0_2x_clk.hw,
+		[CLK_PLL_PERIPH1]	= &pll_periph1_clk.common.hw,
+		[CLK_PLL_PERIPH1_2X]	= &pll_periph1_2x_clk.hw,
+		[CLK_PLL_GPU]		= &pll_gpu_clk.common.hw,
+		[CLK_PLL_VIDEO0]	= &pll_video0_clk.common.hw,
+		[CLK_PLL_VIDEO0_2X]	= &pll_video0_2x_clk.hw,
+		[CLK_PLL_VIDEO0_4X]	= &pll_video0_4x_clk.hw,
+		[CLK_PLL_VIDEO1]	= &pll_video1_clk.common.hw,
+		[CLK_PLL_VIDEO1_2X]	= &pll_video1_2x_clk.hw,
+		[CLK_PLL_VIDEO1_4X]	= &pll_video1_4x_clk.hw,
+		[CLK_PLL_VIDEO2]	= &pll_video2_clk.common.hw,
+		[CLK_PLL_VIDEO2_2X]	= &pll_video2_2x_clk.hw,
+		[CLK_PLL_VIDEO2_4X]	= &pll_video2_4x_clk.hw,
+		[CLK_PLL_VIDEO3]	= &pll_video3_clk.common.hw,
+		[CLK_PLL_VIDEO3_2X]	= &pll_video3_2x_clk.hw,
+		[CLK_PLL_VIDEO3_4X]	= &pll_video3_4x_clk.hw,
+		[CLK_PLL_VE]		= &pll_ve_clk.common.hw,
+		[CLK_PLL_COM]		= &pll_com_clk.common.hw,
+		[CLK_PLL_COM_AUDIO]	= &pll_com_audio_clk.hw,
+		[CLK_PLL_AUDIO]		= &pll_audio_clk.common.hw,
+		[CLK_CPUX]		= &cpux_clk.common.hw,
+		[CLK_AXI]		= &axi_clk.common.hw,
+		[CLK_CPUX_APB]		= &cpux_apb_clk.common.hw,
+		[CLK_PSI_AHB1_AHB2]	= &psi_ahb1_ahb2_clk.common.hw,
+		[CLK_AHB3]		= &ahb3_clk.common.hw,
+		[CLK_APB1]		= &apb1_clk.common.hw,
+		[CLK_APB2]		= &apb2_clk.common.hw,
+		[CLK_MBUS]		= &mbus_clk.common.hw,
+		[CLK_DE]		= &de_clk.common.hw,
+		[CLK_BUS_DE]		= &bus_de_clk.common.hw,
+		[CLK_G2D]		= &g2d_clk.common.hw,
+		[CLK_BUS_G2D]		= &bus_g2d_clk.common.hw,
+		[CLK_GPU]		= &gpu_clk.common.hw,
+		[CLK_BUS_GPU]		= &bus_gpu_clk.common.hw,
+		[CLK_CE]		= &ce_clk.common.hw,
+		[CLK_BUS_CE]		= &bus_ce_clk.common.hw,
+		[CLK_VE]		= &ve_clk.common.hw,
+		[CLK_BUS_VE]		= &bus_ve_clk.common.hw,
+		[CLK_BUS_DMA]		= &bus_dma_clk.common.hw,
+		[CLK_BUS_MSGBOX]	= &bus_msgbox_clk.common.hw,
+		[CLK_BUS_SPINLOCK]	= &bus_spinlock_clk.common.hw,
+		[CLK_BUS_HSTIMER]	= &bus_hstimer_clk.common.hw,
+		[CLK_AVS]		= &avs_clk.common.hw,
+		[CLK_BUS_DBG]		= &bus_dbg_clk.common.hw,
+		[CLK_BUS_PSI]		= &bus_psi_clk.common.hw,
+		[CLK_BUS_PWM]		= &bus_pwm_clk.common.hw,
+		[CLK_BUS_IOMMU]		= &bus_iommu_clk.common.hw,
+		[CLK_MBUS_DMA]		= &mbus_dma_clk.common.hw,
+		[CLK_MBUS_VE]		= &mbus_ve_clk.common.hw,
+		[CLK_MBUS_CE]		= &mbus_ce_clk.common.hw,
+		[CLK_MBUS_NAND]		= &mbus_nand_clk.common.hw,
+		[CLK_MBUS_CSI]		= &mbus_csi_clk.common.hw,
+		[CLK_MBUS_ISP]		= &mbus_isp_clk.common.hw,
+		[CLK_MBUS_G2D]		= &mbus_g2d_clk.common.hw,
+		[CLK_BUS_DRAM]		= &bus_dram_clk.common.hw,
+		[CLK_NAND0]		= &nand0_clk.common.hw,
+		[CLK_NAND1]		= &nand1_clk.common.hw,
+		[CLK_BUS_NAND]		= &bus_nand_clk.common.hw,
+		[CLK_MMC0]		= &mmc0_clk.common.hw,
+		[CLK_MMC1]		= &mmc1_clk.common.hw,
+		[CLK_MMC2]		= &mmc2_clk.common.hw,
+		[CLK_BUS_MMC0]		= &bus_mmc0_clk.common.hw,
+		[CLK_BUS_MMC1]		= &bus_mmc1_clk.common.hw,
+		[CLK_BUS_MMC2]		= &bus_mmc2_clk.common.hw,
+		[CLK_BUS_UART0]		= &bus_uart0_clk.common.hw,
+		[CLK_BUS_UART1]		= &bus_uart1_clk.common.hw,
+		[CLK_BUS_UART2]		= &bus_uart2_clk.common.hw,
+		[CLK_BUS_UART3]		= &bus_uart3_clk.common.hw,
+		[CLK_BUS_UART4]		= &bus_uart4_clk.common.hw,
+		[CLK_BUS_I2C0]		= &bus_i2c0_clk.common.hw,
+		[CLK_BUS_I2C1]		= &bus_i2c1_clk.common.hw,
+		[CLK_BUS_I2C2]		= &bus_i2c2_clk.common.hw,
+		[CLK_BUS_I2C3]		= &bus_i2c3_clk.common.hw,
+		[CLK_SPI0]		= &spi0_clk.common.hw,
+		[CLK_SPI1]		= &spi1_clk.common.hw,
+		[CLK_SPI2]		= &spi2_clk.common.hw,
+		[CLK_BUS_SPI0]		= &bus_spi0_clk.common.hw,
+		[CLK_BUS_SPI1]		= &bus_spi1_clk.common.hw,
+		[CLK_BUS_SPI2]		= &bus_spi2_clk.common.hw,
+		[CLK_EMAC_25M]		= &emac_25m_clk.common.hw,
+		[CLK_BUS_EMAC]		= &bus_emac_clk.common.hw,
+		[CLK_IR_RX]		= &ir_rx_clk.common.hw,
+		[CLK_BUS_IR_RX]		= &bus_ir_rx_clk.common.hw,
+		[CLK_IR_TX]		= &ir_tx_clk.common.hw,
+		[CLK_BUS_IR_TX]		= &bus_ir_tx_clk.common.hw,
+		[CLK_BUS_GPADC]		= &bus_gpadc_clk.common.hw,
+		[CLK_BUS_THS]		= &bus_ths_clk.common.hw,
+		[CLK_I2S0]		= &i2s0_clk.common.hw,
+		[CLK_I2S1]		= &i2s1_clk.common.hw,
+		[CLK_I2S2]		= &i2s2_clk.common.hw,
+		[CLK_I2S3]		= &i2s3_clk.common.hw,
+		[CLK_BUS_I2S0]		= &bus_i2s0_clk.common.hw,
+		[CLK_BUS_I2S1]		= &bus_i2s1_clk.common.hw,
+		[CLK_BUS_I2S2]		= &bus_i2s2_clk.common.hw,
+		[CLK_BUS_I2S3]		= &bus_i2s3_clk.common.hw,
+		[CLK_SPDIF]		= &spdif_clk.common.hw,
+		[CLK_BUS_SPDIF]		= &bus_spdif_clk.common.hw,
+		[CLK_DMIC]		= &dmic_clk.common.hw,
+		[CLK_BUS_DMIC]		= &bus_dmic_clk.common.hw,
+		[CLK_AUDIO_DAC]		= &audio_codec_dac_clk.common.hw,
+		[CLK_AUDIO_ADC]		= &audio_codec_adc_clk.common.hw,
+		[CLK_AUDIO_4X]		= &audio_codec_4x_clk.common.hw,
+		[CLK_BUS_AUDIO_CODEC]	= &bus_audio_codec_clk.common.hw,
+		[CLK_USB_OHCI0]		= &usb_ohci0_clk.common.hw,
+		[CLK_USB_PHY0]		= &usb_phy0_clk.common.hw,
+		[CLK_USB_OHCI1]		= &usb_ohci1_clk.common.hw,
+		[CLK_USB_PHY1]		= &usb_phy1_clk.common.hw,
+		[CLK_BUS_OHCI0]		= &bus_ohci0_clk.common.hw,
+		[CLK_BUS_OHCI1]		= &bus_ohci1_clk.common.hw,
+		[CLK_BUS_EHCI0]		= &bus_ehci0_clk.common.hw,
+		[CLK_BUS_EHCI1]		= &bus_ehci1_clk.common.hw,
+		[CLK_BUS_OTG]		= &bus_otg_clk.common.hw,
+		[CLK_BUS_LRADC]		= &bus_lradc_clk.common.hw,
+		[CLK_BUS_DPSS_TOP0]	= &bus_dpss_top0_clk.common.hw,
+		[CLK_BUS_DPSS_TOP1]	= &bus_dpss_top1_clk.common.hw,
+		[CLK_MIPI_DSI]		= &mipi_dsi_clk.common.hw,
+		[CLK_BUS_MIPI_DSI]	= &bus_mipi_dsi_clk.common.hw,
+		[CLK_TCON_LCD]		= &tcon_lcd_clk.common.hw,
+		[CLK_BUS_TCON_LCD]	= &bus_tcon_lcd_clk.common.hw,
+		[CLK_LEDC]		= &ledc_clk.common.hw,
+		[CLK_BUS_LEDC]		= &bus_ledc_clk.common.hw,
+		[CLK_CSI_TOP]		= &csi_top_clk.common.hw,
+		[CLK_CSI0_MCLK]		= &csi0_mclk_clk.common.hw,
+		[CLK_CSI1_MCLK]		= &csi1_mclk_clk.common.hw,
+		[CLK_BUS_CSI]		= &bus_csi_clk.common.hw,
+		[CLK_CSI_ISP]		= &csi_isp_clk.common.hw,
+	},
+	.num = CLK_NUMBER,
+};
+
+static struct ccu_reset_map sun50i_a100_ccu_resets[] = {
+	[RST_MBUS]		= { 0x540, BIT(30) },
+
+	[RST_BUS_DE]		= { 0x60c, BIT(16) },
+	[RST_BUS_G2D]		= { 0x63c, BIT(16) },
+	[RST_BUS_GPU]		= { 0x67c, BIT(16) },
+	[RST_BUS_CE]		= { 0x68c, BIT(16) },
+	[RST_BUS_VE]		= { 0x69c, BIT(16) },
+	[RST_BUS_DMA]		= { 0x70c, BIT(16) },
+	[RST_BUS_MSGBOX]	= { 0x71c, BIT(16) },
+	[RST_BUS_SPINLOCK]	= { 0x72c, BIT(16) },
+	[RST_BUS_HSTIMER]	= { 0x73c, BIT(16) },
+	[RST_BUS_DBG]		= { 0x78c, BIT(16) },
+	[RST_BUS_PSI]		= { 0x79c, BIT(16) },
+	[RST_BUS_PWM]		= { 0x7ac, BIT(16) },
+	[RST_BUS_DRAM]		= { 0x80c, BIT(16) },
+	[RST_BUS_NAND]		= { 0x82c, BIT(16) },
+	[RST_BUS_MMC0]		= { 0x84c, BIT(16) },
+	[RST_BUS_MMC1]		= { 0x84c, BIT(17) },
+	[RST_BUS_MMC2]		= { 0x84c, BIT(18) },
+	[RST_BUS_UART0]		= { 0x90c, BIT(16) },
+	[RST_BUS_UART1]		= { 0x90c, BIT(17) },
+	[RST_BUS_UART2]		= { 0x90c, BIT(18) },
+	[RST_BUS_UART3]		= { 0x90c, BIT(19) },
+	[RST_BUS_UART4]		= { 0x90c, BIT(20) },
+	[RST_BUS_I2C0]		= { 0x91c, BIT(16) },
+	[RST_BUS_I2C1]		= { 0x91c, BIT(17) },
+	[RST_BUS_I2C2]		= { 0x91c, BIT(18) },
+	[RST_BUS_I2C3]		= { 0x91c, BIT(19) },
+	[RST_BUS_SPI0]		= { 0x96c, BIT(16) },
+	[RST_BUS_SPI1]		= { 0x96c, BIT(17) },
+	[RST_BUS_SPI2]		= { 0x96c, BIT(18) },
+	[RST_BUS_EMAC]		= { 0x97c, BIT(16) },
+	[RST_BUS_IR_RX]		= { 0x99c, BIT(16) },
+	[RST_BUS_IR_TX]		= { 0x9cc, BIT(16) },
+	[RST_BUS_GPADC]		= { 0x9ec, BIT(16) },
+	[RST_BUS_THS]		= { 0x9fc, BIT(16) },
+	[RST_BUS_I2S0]		= { 0xa20, BIT(16) },
+	[RST_BUS_I2S1]		= { 0xa20, BIT(17) },
+	[RST_BUS_I2S2]		= { 0xa20, BIT(18) },
+	[RST_BUS_I2S3]		= { 0xa20, BIT(19) },
+	[RST_BUS_SPDIF]		= { 0xa2c, BIT(16) },
+	[RST_BUS_DMIC]		= { 0xa4c, BIT(16) },
+	[RST_BUS_AUDIO_CODEC]	= { 0xa5c, BIT(16) },
+
+	[RST_USB_PHY0]		= { 0xa70, BIT(30) },
+	[RST_USB_PHY1]		= { 0xa74, BIT(30) },
+
+	[RST_BUS_OHCI0]		= { 0xa8c, BIT(16) },
+	[RST_BUS_OHCI1]		= { 0xa8c, BIT(17) },
+	[RST_BUS_EHCI0]		= { 0xa8c, BIT(20) },
+	[RST_BUS_EHCI1]		= { 0xa8c, BIT(21) },
+	[RST_BUS_OTG]		= { 0xa8c, BIT(24) },
+
+	[RST_BUS_LRADC]		= { 0xa9c, BIT(16) },
+	[RST_BUS_DPSS_TOP0]	= { 0xabc, BIT(16) },
+	[RST_BUS_DPSS_TOP1]	= { 0xacc, BIT(16) },
+	[RST_BUS_MIPI_DSI]	= { 0xb4c, BIT(16) },
+	[RST_BUS_TCON_LCD]	= { 0xb7c, BIT(16) },
+	[RST_BUS_LVDS]		= { 0xbac, BIT(16) },
+	[RST_BUS_LEDC]		= { 0xbfc, BIT(16) },
+	[RST_BUS_CSI]		= { 0xc1c, BIT(16) },
+	[RST_BUS_CSI_ISP]	= { 0xc2c, BIT(16) },
+};
+
+static const struct sunxi_ccu_desc sun50i_a100_ccu_desc = {
+	.ccu_clks	= sun50i_a100_ccu_clks,
+	.num_ccu_clks	= ARRAY_SIZE(sun50i_a100_ccu_clks),
+
+	.hw_clks	= &sun50i_a100_hw_clks,
+
+	.resets		= sun50i_a100_ccu_resets,
+	.num_resets	= ARRAY_SIZE(sun50i_a100_ccu_resets),
+};
+
+static const u32 sun50i_a100_pll_regs[] = {
+	SUN50I_A100_PLL_CPUX_REG,
+	SUN50I_A100_PLL_DDR0_REG,
+	SUN50I_A100_PLL_PERIPH0_REG,
+	SUN50I_A100_PLL_PERIPH1_REG,
+	SUN50I_A100_PLL_GPU_REG,
+	SUN50I_A100_PLL_VIDEO0_REG,
+	SUN50I_A100_PLL_VIDEO1_REG,
+	SUN50I_A100_PLL_VIDEO2_REG,
+	SUN50I_A100_PLL_VIDEO3_REG,
+	SUN50I_A100_PLL_VE_REG,
+	SUN50I_A100_PLL_COM_REG,
+	SUN50I_A100_PLL_AUDIO_REG,
+};
+
+static const u32 sun50i_a100_pll_video_regs[] = {
+	SUN50I_A100_PLL_VIDEO0_REG,
+	SUN50I_A100_PLL_VIDEO1_REG,
+	SUN50I_A100_PLL_VIDEO2_REG,
+	SUN50I_A100_PLL_VIDEO3_REG,
+};
+
+static const u32 sun50i_a100_usb2_clk_regs[] = {
+	SUN50I_A100_USB0_CLK_REG,
+	SUN50I_A100_USB1_CLK_REG,
+};
+
+static struct ccu_pll_nb sun50i_a100_pll_cpu_nb = {
+	.common = &pll_cpux_clk.common,
+	/* copy from pll_cpux_clk */
+	.enable = BIT(27),
+	.lock   = BIT(28),
+};
+
+static struct ccu_mux_nb sun50i_a100_cpu_nb = {
+	.common         = &cpux_clk.common,
+	.cm             = &cpux_clk.mux,
+	.delay_us       = 1,
+	.bypass_index   = 4, /* index of pll periph0 */
+};
+
+static int sun50i_a100_ccu_probe(struct platform_device *pdev)
+{
+	void __iomem *reg;
+	u32 val;
+	int i, ret;
+
+	reg = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(reg))
+		return PTR_ERR(reg);
+
+	/*
+	 * Enable lock and enable bits on all PLLs.
+	 *
+	 * Due to the current design, multiple PLLs share one power switch,
+	 * so switching PLL is easy to cause stability problems.
+	 * When initializing, we enable them by default. When disable,
+	 * we only turn off the output of PLL.
+	 */
+	for (i = 0; i < ARRAY_SIZE(sun50i_a100_pll_regs); i++) {
+		val = readl(reg + sun50i_a100_pll_regs[i]);
+		val |= SUN50I_A100_PLL_LOCK_ENABLE | SUN50I_A100_PLL_ENABLE;
+		writel(val, reg + sun50i_a100_pll_regs[i]);
+	}
+
+	/*
+	 * In order to pass the EMI certification, the SDM function of
+	 * the peripheral 1 bus is enabled, and the frequency is still
+	 * calculated using the previous division factor.
+	 */
+	writel(SUN50I_A100_PLL_PERIPH1_PATTERN0,
+	       reg + SUN50I_A100_PLL_PERIPH1_PATTERN0_REG);
+
+	val = readl(reg + SUN50I_A100_PLL_PERIPH1_REG);
+	val |= SUN50I_A100_PLL_SDM_ENABLE;
+	writel(val, reg + SUN50I_A100_PLL_PERIPH1_REG);
+
+	/*
+	 * Force the output divider of video PLLs to 0.
+	 *
+	 * See the comment before pll-video0 definition for the reason.
+	 */
+	for (i = 0; i < ARRAY_SIZE(sun50i_a100_pll_video_regs); i++) {
+		val = readl(reg + sun50i_a100_pll_video_regs[i]);
+		val &= ~BIT(0);
+		writel(val, reg + sun50i_a100_pll_video_regs[i]);
+	}
+
+	/*
+	 * Enforce m1 = 0, m0 = 1 for Audio PLL
+	 *
+	 * See the comment before pll-audio definition for the reason.
+	 */
+	val = readl(reg + SUN50I_A100_PLL_AUDIO_REG);
+	val &= ~BIT(1);
+	val |= BIT(0);
+	writel(val, reg + SUN50I_A100_PLL_AUDIO_REG);
+
+	/*
+	 * Force OHCI 12M clock sources to 00 (12MHz divided from 48MHz)
+	 *
+	 * This clock mux is still mysterious, and the code just enforces
+	 * it to have a valid clock parent.
+	 */
+	for (i = 0; i < ARRAY_SIZE(sun50i_a100_usb2_clk_regs); i++) {
+		val = readl(reg + sun50i_a100_usb2_clk_regs[i]);
+		val &= ~GENMASK(25, 24);
+		writel(val, reg + sun50i_a100_usb2_clk_regs[i]);
+	}
+
+	ret = sunxi_ccu_probe(pdev->dev.of_node, reg, &sun50i_a100_ccu_desc);
+	if (ret)
+		return ret;
+
+	/* Gate then ungate PLL CPU after any rate changes */
+	ccu_pll_notifier_register(&sun50i_a100_pll_cpu_nb);
+
+	/* Reparent CPU during PLL CPU rate changes */
+	ccu_mux_notifier_register(pll_cpux_clk.common.hw.clk,
+				  &sun50i_a100_cpu_nb);
+
+	return 0;
+}
+
+static const struct of_device_id sun50i_a100_ccu_ids[] = {
+	{ .compatible = "allwinner,sun50i-a100-ccu" },
+	{ }
+};
+
+static struct platform_driver sun50i_a100_ccu_driver = {
+	.probe	= sun50i_a100_ccu_probe,
+	.driver	= {
+		.name	= "sun50i-a100-ccu",
+		.of_match_table	= sun50i_a100_ccu_ids,
+	},
+};
+module_platform_driver(sun50i_a100_ccu_driver);
diff --git a/drivers/clk/sunxi-ng/ccu-sun50i-a100.h b/drivers/clk/sunxi-ng/ccu-sun50i-a100.h
new file mode 100644
index 000000000..21ce92bb1
--- /dev/null
+++ b/drivers/clk/sunxi-ng/ccu-sun50i-a100.h
@@ -0,0 +1,56 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2020 Yangtao Li <frank@allwinnertech.com>
+ */
+
+#ifndef _CCU_SUN50I_A100_H_
+#define _CCU_SUN50I_A100_H_
+
+#include <dt-bindings/clock/sun50i-a100-ccu.h>
+#include <dt-bindings/reset/sun50i-a100-ccu.h>
+
+#define CLK_OSC12M		0
+#define CLK_PLL_CPUX		1
+#define CLK_PLL_DDR0		2
+
+/* PLL_PERIPH0 exported for PRCM */
+
+#define CLK_PLL_PERIPH0_2X	4
+#define CLK_PLL_PERIPH1		5
+#define CLK_PLL_PERIPH1_2X	6
+#define CLK_PLL_GPU		7
+#define CLK_PLL_VIDEO0		8
+#define CLK_PLL_VIDEO0_2X	9
+#define CLK_PLL_VIDEO0_4X	10
+#define CLK_PLL_VIDEO1		11
+#define CLK_PLL_VIDEO1_2X	12
+#define CLK_PLL_VIDEO1_4X	13
+#define CLK_PLL_VIDEO2		14
+#define CLK_PLL_VIDEO2_2X	15
+#define CLK_PLL_VIDEO2_4X	16
+#define CLK_PLL_VIDEO3		17
+#define CLK_PLL_VIDEO3_2X	18
+#define CLK_PLL_VIDEO3_4X	19
+#define CLK_PLL_VE		20
+#define CLK_PLL_COM		21
+#define CLK_PLL_COM_AUDIO	22
+#define CLK_PLL_AUDIO		23
+
+/* CPUX clock exported for DVFS */
+
+#define CLK_AXI			25
+#define CLK_CPUX_APB		26
+#define CLK_PSI_AHB1_AHB2	27
+#define CLK_AHB3		28
+
+/* APB1 clock exported for PIO */
+
+#define CLK_APB2		30
+
+/* All module clocks and bus gates are exported except DRAM */
+
+#define CLK_BUS_DRAM		58
+
+#define CLK_NUMBER		(CLK_CSI_ISP + 1)
+
+#endif /* _CCU_SUN50I_A100_H_ */
diff --git a/drivers/clk/sunxi-ng/ccu-sun50iw10-r.c b/drivers/clk/sunxi-ng/ccu-sun50iw10-r.c
new file mode 100644
index 000000000..71e3ed91a
--- /dev/null
+++ b/drivers/clk/sunxi-ng/ccu-sun50iw10-r.c
@@ -0,0 +1,238 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2020 frank@allwinnertech.com
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+
+#include "ccu_common.h"
+#include "ccu_reset.h"
+
+#include "ccu_div.h"
+#include "ccu_gate.h"
+#include "ccu_mp.h"
+#include "ccu_nm.h"
+
+#include "ccu-sun50iw10-r.h"
+
+static const char * const cpus_r_apb2_parents[] = { "dcxo24M", "osc32k",
+						     "iosc", "pll-periph0" };
+static const struct ccu_mux_var_prediv cpus_r_apb2_predivs[] = {
+	{ .index = 3, .shift = 0, .width = 5 },
+};
+
+static struct ccu_div cpus_clk = {
+	.div		= _SUNXI_CCU_DIV_FLAGS(8, 2, CLK_DIVIDER_POWER_OF_TWO),
+
+	.mux		= {
+		.shift	= 24,
+		.width	= 2,
+
+		.var_predivs	= cpus_r_apb2_predivs,
+		.n_var_predivs	= ARRAY_SIZE(cpus_r_apb2_predivs),
+	},
+
+	.common		= {
+		.reg		= 0x000,
+		.features	= CCU_FEATURE_VARIABLE_PREDIV,
+		.hw.init	= CLK_HW_INIT_PARENTS("cpus",
+						      cpus_r_apb2_parents,
+						      &ccu_div_ops,
+						      0),
+	},
+};
+
+static CLK_FIXED_FACTOR_HW(r_ahb_clk, "r-ahb", &cpus_clk.common.hw, 1, 1, 0);
+
+static struct ccu_div r_apb1_clk = {
+	.div		= _SUNXI_CCU_DIV(0, 2),
+
+	.common		= {
+		.reg		= 0x00c,
+		.hw.init	= CLK_HW_INIT("r-apb1",
+					      "r-ahb",
+					      &ccu_div_ops,
+					      0),
+	},
+};
+
+static struct ccu_div r_apb2_clk = {
+	.div		= _SUNXI_CCU_DIV_FLAGS(8, 2, CLK_DIVIDER_POWER_OF_TWO),
+
+	.mux		= {
+		.shift	= 24,
+		.width	= 2,
+
+		.var_predivs	= cpus_r_apb2_predivs,
+		.n_var_predivs	= ARRAY_SIZE(cpus_r_apb2_predivs),
+	},
+
+	.common		= {
+		.reg		= 0x010,
+		.features	= CCU_FEATURE_VARIABLE_PREDIV,
+		.hw.init	= CLK_HW_INIT_PARENTS("r-apb2",
+						      cpus_r_apb2_parents,
+						      &ccu_div_ops,
+						      0),
+	},
+};
+
+static SUNXI_CCU_GATE(r_apb1_timer_clk, "r-apb1-timer", "r-apb1",
+		      0x11c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(r_apb1_twd_clk, "r-apb1-twd", "r-apb1",
+		      0x12c, BIT(0), 0);
+
+static const char * const r_apb1_pwm_clk_parents[] = { "dcxo24M", "osc32k",
+						       "iosc" };
+static SUNXI_CCU_MUX(r_apb1_pwm_clk, "r-apb1-pwm", r_apb1_pwm_clk_parents,
+		     0x130, 24, 2, 0);
+
+static SUNXI_CCU_GATE(r_apb1_bus_pwm_clk, "r-apb1-bus-pwm", "r-apb1",
+		      0x13c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(r_apb1_ppu_clk, "r-apb1-ppu", "r-apb1",
+		      0x17c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(r_apb2_uart_clk, "r-apb2-uart", "r-apb2",
+		      0x18c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(r_apb2_i2c0_clk, "r-apb2-i2c0", "r-apb2",
+		      0x19c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(r_apb2_i2c1_clk, "r-apb2-i2c1", "r-apb2",
+		      0x19c, BIT(1), 0);
+
+static const char * const r_apb1_ir_rx_parents[] = { "osc32k", "dcxo24M" };
+static SUNXI_CCU_MP_WITH_MUX_GATE(r_apb1_ir_rx_clk, "r-apb1-ir-rx",
+				  r_apb1_ir_rx_parents, 0x1c0,
+				  0, 5,		/* M */
+				  8, 2,		/* P */
+				  24, 1,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_GATE(r_apb1_bus_ir_rx_clk, "r-apb1-bus-ir-rx", "r-apb1",
+		      0x1cc, BIT(0), 0);
+
+static SUNXI_CCU_GATE(r_ahb_bus_rtc_clk, "r-ahb-rtc", "r-ahb",
+		      0x20c, BIT(0), 0);
+
+static struct ccu_common *sun50iw10_r_ccu_clks[] = {
+	&cpus_clk.common,
+	&r_apb1_clk.common,
+	&r_apb2_clk.common,
+	&r_apb1_timer_clk.common,
+	&r_apb1_twd_clk.common,
+	&r_apb1_pwm_clk.common,
+	&r_apb1_bus_pwm_clk.common,
+	&r_apb1_ppu_clk.common,
+	&r_apb2_uart_clk.common,
+	&r_apb2_i2c0_clk.common,
+	&r_apb2_i2c1_clk.common,
+	&r_apb1_ir_rx_clk.common,
+	&r_apb1_bus_ir_rx_clk.common,
+	&r_ahb_bus_rtc_clk.common,
+};
+
+static struct clk_hw_onecell_data sun50iw10_r_hw_clks = {
+	.hws	= {
+		[CLK_CPUS]		= &cpus_clk.common.hw,
+		[CLK_R_AHB]		= &r_ahb_clk.hw,
+		[CLK_R_APB1]		= &r_apb1_clk.common.hw,
+		[CLK_R_APB2]		= &r_apb2_clk.common.hw,
+		[CLK_R_APB1_TIMER]	= &r_apb1_timer_clk.common.hw,
+		[CLK_R_APB1_TWD]	= &r_apb1_twd_clk.common.hw,
+		[CLK_R_APB1_PWM]	= &r_apb1_pwm_clk.common.hw,
+		[CLK_R_APB1_BUS_PWM]	= &r_apb1_bus_pwm_clk.common.hw,
+		[CLK_R_APB1_PPU]	= &r_apb1_ppu_clk.common.hw,
+		[CLK_R_APB2_UART]	= &r_apb2_uart_clk.common.hw,
+		[CLK_R_APB2_I2C0]	= &r_apb2_i2c0_clk.common.hw,
+		[CLK_R_APB2_I2C1]	= &r_apb2_i2c1_clk.common.hw,
+		[CLK_R_APB1_IR]		= &r_apb1_ir_rx_clk.common.hw,
+		[CLK_R_APB1_BUS_IR]	= &r_apb1_bus_ir_rx_clk.common.hw,
+		[CLK_R_AHB_BUS_RTC]	= &r_ahb_bus_rtc_clk.common.hw,
+	},
+	.num	= CLK_NUMBER,
+};
+
+static struct ccu_reset_map sun50iw10_r_ccu_resets[] = {
+	[RST_R_APB1_TIMER]	=  { 0x11c, BIT(16) },
+	[RST_R_APB1_BUS_PWM]	=  { 0x13c, BIT(16) },
+	[RST_R_APB1_PPU]	=  { 0x17c, BIT(16) },
+	[RST_R_APB2_UART]	=  { 0x18c, BIT(16) },
+	[RST_R_APB2_I2C0]	=  { 0x19c, BIT(16) },
+	[RST_R_APB2_I2C1]	=  { 0x19c, BIT(17) },
+	[RST_R_APB1_BUS_IR]	=  { 0x1cc, BIT(16) },
+	[RST_R_AHB_BUS_RTC]	=  { 0x20c, BIT(16) },
+};
+
+static const struct sunxi_ccu_desc sun50iw10_r_ccu_desc = {
+	.ccu_clks	= sun50iw10_r_ccu_clks,
+	.num_ccu_clks	= ARRAY_SIZE(sun50iw10_r_ccu_clks),
+
+	.hw_clks	= &sun50iw10_r_hw_clks,
+
+	.resets		= sun50iw10_r_ccu_resets,
+	.num_resets	= ARRAY_SIZE(sun50iw10_r_ccu_resets),
+};
+
+static int sun50iw10_r_ccu_probe(struct platform_device *pdev)
+{
+	void __iomem *reg;
+	int ret;
+
+	reg = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(reg))
+		return PTR_ERR(reg);
+
+	ret = sunxi_ccu_probe(pdev->dev.of_node, reg, &sun50iw10_r_ccu_desc);
+	if (ret)
+		return ret;
+
+	sunxi_ccu_sleep_init(reg, sun50iw10_r_ccu_clks,
+			     ARRAY_SIZE(sun50iw10_r_ccu_clks),
+			     NULL, 0);
+
+	printk("Sunxi ccu sun50iw10-r init OK\n");
+
+	return 0;
+}
+
+static const struct of_device_id sun50iw10_r_ccu_ids[] = {
+	{ .compatible = "allwinner,sun50iw10-r-ccu" },
+	{ }
+};
+
+static struct platform_driver sun50iw10_r_ccu_driver = {
+	.probe	= sun50iw10_r_ccu_probe,
+	.driver	= {
+		.name	= "sun50iw10-r-ccu",
+		.of_match_table	= sun50iw10_r_ccu_ids,
+	},
+};
+
+static int __init sunxi_ccu_sun50iw10_r_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&sun50iw10_r_ccu_driver);
+	if (ret)
+		pr_err("register ccu sun50iw10-r failed\n");
+
+	return ret;
+}
+core_initcall(sunxi_ccu_sun50iw10_r_init);
+
+static void __exit sunxi_ccu_sun50iw10_r_exit(void)
+{
+	return platform_driver_unregister(&sun50iw10_r_ccu_driver);
+}
+module_exit(sunxi_ccu_sun50iw10_r_exit);
+
+MODULE_DESCRIPTION("Allwinner sun50iw10-r clk driver");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION("1.0.5");
diff --git a/drivers/clk/sunxi-ng/ccu-sun50iw10-r.h b/drivers/clk/sunxi-ng/ccu-sun50iw10-r.h
new file mode 100644
index 000000000..d824ff620
--- /dev/null
+++ b/drivers/clk/sunxi-ng/ccu-sun50iw10-r.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2020 frank@allwinnertech.com
+ */
+
+#ifndef _CCU_SUN50IW10_R_H
+#define _CCU_SUN50IW10_R_H
+
+#include <dt-bindings/clock/sun50iw10-r-ccu.h>
+#include <dt-bindings/reset/sun50iw10-r-ccu.h>
+
+#define CLK_NUMBER	(CLK_R_AHB_BUS_RTC + 1)
+
+#endif /* _CCU_SUN50IW10_R_H */
diff --git a/drivers/clk/sunxi-ng/ccu-sun50iw10.c b/drivers/clk/sunxi-ng/ccu-sun50iw10.c
new file mode 100644
index 000000000..7964e0645
--- /dev/null
+++ b/drivers/clk/sunxi-ng/ccu-sun50iw10.c
@@ -0,0 +1,1400 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2020 frank@allwinnertech.com
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+
+#include "ccu_common.h"
+#include "ccu_reset.h"
+
+#include "ccu_div.h"
+#include "ccu_gate.h"
+#include "ccu_mp.h"
+#include "ccu_mult.h"
+#include "ccu_nk.h"
+#include "ccu_nkm.h"
+#include "ccu_nkmp.h"
+#include "ccu_nm.h"
+
+#include "ccu-sun50iw10.h"
+
+/*
+ * The CPU PLL is actually NP clock, with P being /1, /2 or /4. However
+ * P should only be used for output frequencies lower than 288 MHz.
+ *
+ * For now we can just model it as a multiplier clock, and force P to /1.
+ *
+ * The M factor is present in the register's description, but not in the
+ * frequency formula, and it's documented as "M is only used for backdoor
+ * testing", so it's not modelled and then force to 0.
+ */
+#define SUN50IW10_PLL_CPUX_REG		0x000
+static struct ccu_mult pll_cpux_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.mult		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.common		= {
+		.reg		= 0x000,
+		.hw.init	= CLK_HW_INIT("pll-cpux", "dcxo24M",
+					      &ccu_mult_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+/* Some PLLs are input * N / div1 / P. Model them as NKMP with no K */
+#define SUN50IW10_PLL_DDR0_REG		0x010
+static struct ccu_nkmp pll_ddr0_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.p		= _SUNXI_CCU_DIV(0, 1), /* output divider */
+	.common		= {
+		.reg		= 0x010,
+		.hw.init	= CLK_HW_INIT("pll-ddr0", "dcxo24M",
+					      &ccu_nkmp_ops,
+					      CLK_SET_RATE_UNGATE |
+					      CLK_IS_CRITICAL),
+	},
+};
+
+#define SUN50IW10_PLL_PERIPH0_REG	0x020
+static struct ccu_nkmp pll_periph0_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.p		= _SUNXI_CCU_DIV(0, 1), /* output divider */
+	.fixed_post_div	= 2,
+	.common		= {
+		.reg		= 0x020,
+		.features	= CCU_FEATURE_FIXED_POSTDIV,
+		.hw.init	= CLK_HW_INIT("pll-periph0", "dcxo24M",
+					      &ccu_nkmp_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+#define SUN50IW10_PLL_PERIPH1_REG	0x028
+static struct ccu_nkmp pll_periph1_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.p		= _SUNXI_CCU_DIV(0, 1), /* output divider */
+	.fixed_post_div	= 2,
+	.common		= {
+		.reg		= 0x028,
+		.features	= CCU_FEATURE_FIXED_POSTDIV,
+		.hw.init	= CLK_HW_INIT("pll-periph1", "dcxo24M",
+					      &ccu_nkmp_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+#define SUN50IW10_PLL_GPU_REG		0x030
+static struct ccu_nkmp pll_gpu_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.p		= _SUNXI_CCU_DIV(0, 1), /* output divider */
+	.common		= {
+		.reg		= 0x030,
+		.hw.init	= CLK_HW_INIT("pll-gpu", "dcxo24M",
+					      &ccu_nkmp_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+/*
+ * For Video PLLs, the output divider is described as "used for testing"
+ * in the user manual. So it's not modelled and forced to 0.
+ */
+#define SUN50IW10_PLL_VIDEO0_REG	0x040
+static struct ccu_nm pll_video0_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.fixed_post_div	= 4,
+	.min_rate	= 288000000,
+	.max_rate	= 2400000000UL,
+	.common		= {
+		.reg		= 0x040,
+		.features	= CCU_FEATURE_FIXED_POSTDIV,
+		.hw.init	= CLK_HW_INIT("pll-video0", "dcxo24M",
+					      &ccu_nm_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+#define SUN50IW10_PLL_VIDEO1_REG	0x048
+static struct ccu_nm pll_video1_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.fixed_post_div	= 4,
+	.min_rate	= 288000000,
+	.max_rate	= 2400000000UL,
+	.common		= {
+		.reg		= 0x048,
+		.features	= CCU_FEATURE_FIXED_POSTDIV,
+		.hw.init	= CLK_HW_INIT("pll-video1", "dcxo24M",
+					      &ccu_nm_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+#define SUN50IW10_PLL_VIDEO2_REG	0x050
+static struct ccu_nm pll_video2_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.fixed_post_div	= 4,
+	.min_rate	= 288000000,
+	.max_rate	= 2400000000UL,
+	.common		= {
+		.reg		= 0x050,
+		.features	= CCU_FEATURE_FIXED_POSTDIV,
+		.hw.init	= CLK_HW_INIT("pll-video2", "dcxo24M",
+					      &ccu_nm_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+#define SUN50IW10_PLL_VE_REG		0x058
+static struct ccu_nkmp pll_ve_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.p		= _SUNXI_CCU_DIV(0, 1), /* output divider */
+	.common		= {
+		.reg		= 0x058,
+		.hw.init	= CLK_HW_INIT("pll-ve", "dcxo24M",
+					      &ccu_nkmp_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+/*
+ * The COM PLL has m0 dividers in addition to the usual N, M
+ * factors. Since we only need 1 frequencies from this PLL: 45.1584 MHz,
+ * ignore it for now.
+ */
+#define SUN50IW10_PLL_COM_REG		0x060
+static struct ccu_sdm_setting pll_com_sdm_table[] = {
+	{ .rate = 451584000, .pattern = 0xc0014396, .m = 2, .n = 37 },
+};
+
+static struct ccu_nm pll_com_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(0, 1),
+	.sdm		= _SUNXI_CCU_SDM(pll_com_sdm_table, BIT(24),
+					 0x160, BIT(31)),
+	.common		= {
+		.reg		= 0x060,
+		.features	= CCU_FEATURE_SIGMA_DELTA_MOD,
+		.hw.init	= CLK_HW_INIT("pll-com", "dcxo24M",
+					      &ccu_nm_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+#define SUN50IW10_PLL_VIDEO3_REG	0x068
+static struct ccu_nm pll_video3_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.fixed_post_div	= 4,
+	.min_rate	= 288000000,
+	.max_rate	= 2400000000UL,
+	.common		= {
+		.reg		= 0x068,
+		.features	= CCU_FEATURE_FIXED_POSTDIV,
+		.hw.init	= CLK_HW_INIT("pll-video3", "dcxo24M",
+					      &ccu_nm_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+/* for pm resume */
+#define SUN50IW10_PLL_PERIPH1_PATTERN0_REG	0x128
+struct ccu_common pll_periph1_pattern0_common = {
+	.reg = 0x128,
+};
+
+/*
+ * The Audio PLL has m0, m1 dividers in addition to the usual N, M
+ * factors. Since we only need 4 frequencies from this PLL: 22.5792 MHz,
+ * 24.576 MHz, 90.3168MHz and 98.304MHz ignore them for now.
+ * Enforce the default for them, which is m0 = 1, m1 = 0.
+ */
+#define SUN50IW10_PLL_AUDIO_REG		0x078
+static struct ccu_sdm_setting pll_audio_sdm_table[] = {
+	{ .rate = 45158400, .pattern = 0xc001bcd3, .m = 18, .n = 33 },
+	{ .rate = 49152000, .pattern = 0xc001eb85, .m = 20, .n = 40 },
+	{ .rate = 180633600, .pattern = 0xc001288d, .m = 3, .n = 22 },
+	{ .rate = 196608000, .pattern = 0xc001eb85, .m = 5, .n = 40 },
+};
+
+static struct ccu_nm pll_audio_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(16, 6),
+	.fixed_post_div	= 2,
+	.sdm		= _SUNXI_CCU_SDM(pll_audio_sdm_table, BIT(24),
+					 0x178, BIT(31)),
+	.common		= {
+		.reg		= 0x078,
+		.features	= CCU_FEATURE_FIXED_POSTDIV |
+				  CCU_FEATURE_SIGMA_DELTA_MOD,
+		.hw.init	= CLK_HW_INIT("pll-audio", "dcxo24M",
+					      &ccu_nm_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+static const char * const cpux_parents[] = { "dcxo24M", "osc32k",
+					     "iosc", "pll-cpux",
+					      "pll-periph0" };
+static SUNXI_CCU_MUX(cpux_clk, "cpux", cpux_parents,
+		     0x500, 24, 3, CLK_SET_RATE_PARENT | CLK_IS_CRITICAL);
+static SUNXI_CCU_M(axi_clk, "axi", "cpux", 0x500, 0, 2, 0);
+static SUNXI_CCU_M(cpux_apb_clk, "cpux-apb", "cpux", 0x500, 8, 2, 0);
+
+static const char * const psi_ahb1_ahb2_parents[] = { "dcxo24M", "osc32k",
+						      "iosc", "pll-periph0",
+						      "pll-periph0-2x" };
+static SUNXI_CCU_MP_WITH_MUX(psi_ahb1_ahb2_clk, "psi-ahb1-ahb2",
+			     psi_ahb1_ahb2_parents,
+			     0x510,
+			     0, 2,	/* M */
+			     8, 2,	/* P */
+			     24, 3,	/* mux */
+			     0);
+
+static const char * const ahb3_apb1_apb2_parents[] = { "dcxo24M", "osc32k",
+						       "psi-ahb1-ahb2",
+						       "pll-periph0",
+						       "pll-periph0-2x" };
+static SUNXI_CCU_MP_WITH_MUX(ahb3_clk, "ahb3", ahb3_apb1_apb2_parents, 0x51c,
+			     0, 2,	/* M */
+			     8, 2,	/* P */
+			     24, 3,	/* mux */
+			     0);
+
+static SUNXI_CCU_MP_WITH_MUX(apb1_clk, "apb1", ahb3_apb1_apb2_parents, 0x520,
+			     0, 2,	/* M */
+			     8, 2,	/* P */
+			     24, 3,	/* mux */
+			     0);
+
+static SUNXI_CCU_MP_WITH_MUX(apb2_clk, "apb2", ahb3_apb1_apb2_parents, 0x524,
+			     0, 2,	/* M */
+			     8, 2,	/* P */
+			     24, 3,	/* mux */
+			     0);
+
+static const char * const mbus_parents[] = { "dcxo24M", "pll-ddr0",
+					     "pll-periph0",
+					     "pll-periph0-2x" };
+static SUNXI_CCU_M_WITH_MUX_GATE(mbus_clk, "mbus", mbus_parents, 0x540,
+				 0, 3,		/* M */
+				 24, 2,		/* mux */
+				 BIT(31),	/* gate */
+				 CLK_IS_CRITICAL);
+
+static const char * const de_parents[] = { "pll-com", "pll-periph0-2x" };
+static SUNXI_CCU_M_WITH_MUX_GATE(de0_clk, "de0", de_parents, 0x600,
+				 0, 4,		/* M */
+				 24, 1,		/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_NO_REPARENT);
+
+static SUNXI_CCU_M_WITH_MUX_GATE(de1_clk, "de1", de_parents, 0x604,
+				 0, 4,		/* M */
+				 24, 1,		/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_NO_REPARENT);
+
+static SUNXI_CCU_GATE(bus_de0_clk, "bus-de0", "psi-ahb1-ahb2",
+		      0x60c, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_de1_clk, "bus-de1", "psi-ahb1-ahb2",
+		      0x60c, BIT(1), 0);
+
+static const char * const eink_parents[] = { "pll-com", "pll-periph0-2x",
+					     "pll-video0", "pll-video1",
+					     "pll-video2"};
+static SUNXI_CCU_M_WITH_MUX_GATE(eink_clk, "eink",
+				 eink_parents,
+				 0x610,
+				 0, 4,		/* M */
+				 24, 3,		/* mux */
+				 BIT(31),	/* gate */
+				 0);
+
+static SUNXI_CCU_GATE(bus_eink_clk, "bus-eink", "psi-ahb1-ahb2",
+		      0x61c, BIT(0), 0);
+
+static const char * const g2d_parents[] = { "pll-com", "pll-periph0-2x",
+					     "pll-video0-2x", "pll-video1-2x",
+					     "pll-video2-2x"};
+static SUNXI_CCU_M_WITH_MUX_GATE(g2d_clk, "g2d",
+				 g2d_parents,
+				 0x630,
+				 0, 4,		/* M */
+				 24, 3,		/* mux */
+				 BIT(31),	/* gate */
+				 0);
+
+static SUNXI_CCU_GATE(bus_g2d_clk, "bus-g2d", "psi-ahb1-ahb2",
+		      0x63c, BIT(0), 0);
+
+static const char * const eink_panel_parents[] = { "pll-video0",
+						   "pll-video1",
+						   "pll-video2",
+						   "pll-video3" };
+static SUNXI_CCU_M_WITH_MUX_GATE(eink_panel_clk, "eink-panel",
+				 eink_panel_parents,
+				 0x640,
+				 0, 5,		/* M */
+				 24, 2,		/* mux */
+				 BIT(31),	/* gate */
+				 0);
+
+static const char * const gpu_parents[] = { "pll-gpu" };
+static SUNXI_CCU_M_WITH_MUX_GATE(gpu_clk, "gpu", gpu_parents, 0x670,
+				       0, 2,	/* M */
+				       24, 1,	/* mux */
+				       BIT(31),	/* gate */
+				       0);
+
+static SUNXI_CCU_GATE(bus_gpu_clk, "bus-gpu", "psi-ahb1-ahb2",
+		      0x67c, BIT(0), 0);
+
+static const char * const ce_parents[] = { "dcxo24M", "pll-periph0-2x" };
+static SUNXI_CCU_MP_WITH_MUX_GATE(ce_clk, "ce", ce_parents, 0x680,
+				  0, 4,		/* M */
+				  8, 2,		/* N */
+				  24, 1,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_GATE(bus_ce_clk, "bus-ce", "psi-ahb1-ahb2",
+		      0x68c, BIT(0), 0);
+
+static const char * const ve_parents[] = { "pll-ve" };
+static SUNXI_CCU_M_WITH_MUX_GATE(ve_clk, "ve", ve_parents, 0x690,
+				 0, 3,		/* M */
+				 24, 1,		/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_PARENT);
+
+static SUNXI_CCU_GATE(bus_ve_clk, "bus-ve", "psi-ahb1-ahb2",
+		      0x69c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_dma_clk, "bus-dma", "psi-ahb1-ahb2",
+		      0x70c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_msgbox_clk, "bus-msgbox", "psi-ahb1-ahb2",
+		      0x71c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_spinlock_clk, "bus-spinlock", "psi-ahb1-ahb2",
+		      0x72c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_hstimer_clk, "bus-hstimer", "psi-ahb1-ahb2",
+		      0x73c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(avs_clk, "avs", "dcxo24M", 0x740, BIT(31), 0);
+
+static SUNXI_CCU_GATE(bus_dbg_clk, "bus-dbg", "psi-ahb1-ahb2",
+		      0x78c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_psi_clk, "bus-psi", "psi-ahb1-ahb2",
+		      0x79c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_pwm_clk, "bus-pwm", "apb1", 0x7ac, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_iommu_clk, "bus-iommu", "apb1", 0x7bc, BIT(0), 0);
+
+static SUNXI_CCU_GATE(mbus_dma_clk, "mbus-dma", "mbus",
+		      0x804, BIT(0), 0);
+static SUNXI_CCU_GATE(mbus_ve_clk, "mbus-ve", "mbus",
+		      0x804, BIT(1), 0);
+static SUNXI_CCU_GATE(mbus_ce_clk, "mbus-ce", "mbus",
+		      0x804, BIT(2), 0);
+static SUNXI_CCU_GATE(mbus_nand_clk, "mbus-nand", "mbus",
+		      0x804, BIT(5), 0);
+static SUNXI_CCU_GATE(mbus_csi_clk, "mbus-csi", "mbus",
+		      0x804, BIT(8), 0);
+static SUNXI_CCU_GATE(mbus_isp_clk, "mbus-isp", "mbus",
+		      0x804, BIT(9), 0);
+static SUNXI_CCU_GATE(mbus_g2d_clk, "mbus-g2d", "mbus",
+		      0x804, BIT(10), 0);
+
+static SUNXI_CCU_GATE(bus_dram_clk, "bus-dram", "psi-ahb1-ahb2",
+		      0x80c, BIT(0), CLK_IS_CRITICAL);
+
+static const char * const nand_spi_parents[] = { "dcxo24M",
+						 "pll-periph0",
+						 "pll-periph1",
+						 "pll-periph0-2x",
+						 "pll-periph1-2x" };
+static SUNXI_CCU_MP_WITH_MUX_GATE(nand0_clk, "nand0", nand_spi_parents, 0x810,
+				  0, 4,		/* M */
+				  8, 2,		/* N */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(nand1_clk, "nand1", nand_spi_parents, 0x814,
+				  0, 4,		/* M */
+				  8, 2,		/* N */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_GATE(bus_nand_clk, "bus-nand", "ahb3", 0x82c, BIT(0), 0);
+
+/* don't use postdiv for bsp kernel */
+static const char * const mmc_parents[] = { "dcxo24M", "pll-periph0-2x",
+					    "pll-periph1-2x" };
+static SUNXI_CCU_MP_WITH_MUX_GATE(mmc0_clk, "mmc0", mmc_parents, 0x830,
+					  0, 4,		/* M */
+					  8, 2,		/* N */
+					  24, 2,	/* mux */
+					  BIT(31),	/* gate */
+					  CLK_SET_RATE_NO_REPARENT);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(mmc1_clk, "mmc1", mmc_parents, 0x834,
+					  0, 4,		/* M */
+					  8, 2,		/* N */
+					  24, 2,	/* mux */
+					  BIT(31),	/* gate */
+					  CLK_SET_RATE_NO_REPARENT);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(mmc2_clk, "mmc2", mmc_parents, 0x838,
+					  0, 4,		/* M */
+					  8, 2,		/* N */
+					  24, 2,	/* mux */
+					  BIT(31),	/* gate */
+					  CLK_SET_RATE_NO_REPARENT);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(mmc3_clk, "mmc3", mmc_parents, 0x83c,
+					  0, 4,		/* M */
+					  8, 2,		/* N */
+					  24, 2,	/* mux */
+					  BIT(31),	/* gate */
+					  CLK_SET_RATE_NO_REPARENT);
+
+static SUNXI_CCU_GATE(bus_mmc0_clk, "bus-mmc0", "ahb3", 0x84c, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_mmc1_clk, "bus-mmc1", "ahb3", 0x84c, BIT(1), 0);
+static SUNXI_CCU_GATE(bus_mmc2_clk, "bus-mmc2", "ahb3", 0x84c, BIT(2), 0);
+static SUNXI_CCU_GATE(bus_mmc3_clk, "bus-mmc3", "ahb3", 0x84c, BIT(3), 0);
+
+static SUNXI_CCU_GATE(bus_uart0_clk, "bus-uart0", "apb2", 0x90c, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_uart1_clk, "bus-uart1", "apb2", 0x90c, BIT(1), 0);
+static SUNXI_CCU_GATE(bus_uart2_clk, "bus-uart2", "apb2", 0x90c, BIT(2), 0);
+static SUNXI_CCU_GATE(bus_uart3_clk, "bus-uart3", "apb2", 0x90c, BIT(3), 0);
+static SUNXI_CCU_GATE(bus_uart4_clk, "bus-uart4", "apb2", 0x90c, BIT(4), 0);
+static SUNXI_CCU_GATE(bus_uart5_clk, "bus-uart5", "apb2", 0x90c, BIT(5), 0);
+static SUNXI_CCU_GATE(bus_uart6_clk, "bus-uart6", "apb2", 0x90c, BIT(6), 0);
+
+static SUNXI_CCU_GATE(bus_i2c0_clk, "bus-i2c0", "apb2", 0x91c, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_i2c1_clk, "bus-i2c1", "apb2", 0x91c, BIT(1), 0);
+static SUNXI_CCU_GATE(bus_i2c2_clk, "bus-i2c2", "apb2", 0x91c, BIT(2), 0);
+static SUNXI_CCU_GATE(bus_i2c3_clk, "bus-i2c3", "apb2", 0x91c, BIT(3), 0);
+static SUNXI_CCU_GATE(bus_i2c4_clk, "bus-i2c4", "apb2", 0x91c, BIT(4), 0);
+static SUNXI_CCU_GATE(bus_i2c5_clk, "bus-i2c5", "apb2", 0x91c, BIT(5), 0);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(spi0_clk, "spi0", nand_spi_parents, 0x940,
+				  0, 4,		/* M */
+				  8, 2,		/* N */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(spi1_clk, "spi1", nand_spi_parents, 0x944,
+				  0, 4,		/* M */
+				  8, 2,		/* N */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(spi2_clk, "spi2", nand_spi_parents, 0x948,
+				  0, 4,		/* M */
+				  8, 2,		/* N */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_GATE(bus_spi0_clk, "bus-spi0", "ahb3", 0x96c, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_spi1_clk, "bus-spi1", "ahb3", 0x96c, BIT(1), 0);
+static SUNXI_CCU_GATE(bus_spi2_clk, "bus-spi2", "ahb3", 0x96c, BIT(2), 0);
+
+static SUNXI_CCU_GATE(emac0_25m_clk, "emac0-25m", "ahb3", 0x970,
+		      BIT(31) | BIT(30), 0);
+
+static SUNXI_CCU_GATE(emac1_25m_clk, "emac1-25m", "ahb3", 0x974,
+		      BIT(31) | BIT(30), 0);
+
+static SUNXI_CCU_GATE(bus_emac0_clk, "bus-emac0", "ahb3", 0x97c, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_emac1_clk, "bus-emac1", "ahb3", 0x97c, BIT(1), 0);
+
+static const char * const ir_parents[] = { "osc32k", "dcxo24M",
+					   "pll-periph0", "pll-periph1" };
+static SUNXI_CCU_MP_WITH_MUX_GATE(ir_rx_clk, "ir-rx", ir_parents, 0x990,
+				  0, 4,		/* M */
+				  8, 2,		/* N */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_GATE(bus_ir_rx_clk, "bus-ir-rx", "ahb3", 0x99c, BIT(0), 0);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(ir_tx_clk, "ir-tx", ir_parents, 0x9c0,
+				  0, 4,		/* M */
+				  8, 2,		/* N */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_GATE(bus_ir_tx_clk, "bus-ir-tx", "apb1", 0x9cc, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_gpadc_clk, "bus-gpadc", "apb1", 0x9ec, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_ths_clk, "bus-ths", "apb1", 0x9fc, BIT(0), 0);
+
+static const char * const audio_parents[] = { "pll-audio", "pll-com-audio" };
+static struct ccu_div i2s0_clk = {
+	.enable		= BIT(31),
+	.div		= _SUNXI_CCU_DIV_FLAGS(8, 2, CLK_DIVIDER_POWER_OF_TWO),
+	.mux		= _SUNXI_CCU_MUX(24, 2),
+	.common		= {
+		.reg		= 0xa10,
+		.hw.init	= CLK_HW_INIT_PARENTS("i2s0",
+						      audio_parents,
+						      &ccu_div_ops,
+						      CLK_SET_RATE_PARENT),
+	},
+};
+
+static struct ccu_div i2s1_clk = {
+	.enable		= BIT(31),
+	.div		= _SUNXI_CCU_DIV_FLAGS(8, 2, CLK_DIVIDER_POWER_OF_TWO),
+	.mux		= _SUNXI_CCU_MUX(24, 2),
+	.common		= {
+		.reg		= 0xa14,
+		.hw.init	= CLK_HW_INIT_PARENTS("i2s1",
+						      audio_parents,
+						      &ccu_div_ops,
+						      CLK_SET_RATE_PARENT),
+	},
+};
+
+static struct ccu_div i2s2_clk = {
+	.enable		= BIT(31),
+	.div		= _SUNXI_CCU_DIV_FLAGS(8, 2, CLK_DIVIDER_POWER_OF_TWO),
+	.mux		= _SUNXI_CCU_MUX(24, 2),
+	.common		= {
+		.reg		= 0xa18,
+		.hw.init	= CLK_HW_INIT_PARENTS("i2s2",
+						      audio_parents,
+						      &ccu_div_ops,
+						      CLK_SET_RATE_PARENT),
+	},
+};
+
+static struct ccu_div i2s3_clk = {
+	.enable		= BIT(31),
+	.div		= _SUNXI_CCU_DIV_FLAGS(8, 2, CLK_DIVIDER_POWER_OF_TWO),
+	.mux		= _SUNXI_CCU_MUX(24, 2),
+	.common		= {
+		.reg		= 0xa1c,
+		.hw.init	= CLK_HW_INIT_PARENTS("i2s3",
+						      audio_parents,
+						      &ccu_div_ops,
+						      CLK_SET_RATE_PARENT),
+	},
+};
+
+static SUNXI_CCU_GATE(bus_i2s0_clk, "bus-i2s0", "apb1", 0xa20, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_i2s1_clk, "bus-i2s1", "apb1", 0xa20, BIT(1), 0);
+static SUNXI_CCU_GATE(bus_i2s2_clk, "bus-i2s2", "apb1", 0xa20, BIT(2), 0);
+static SUNXI_CCU_GATE(bus_i2s3_clk, "bus-i2s3", "apb1", 0xa20, BIT(3), 0);
+
+static struct ccu_div spdif_clk = {
+	.enable		= BIT(31),
+	.div		= _SUNXI_CCU_DIV_FLAGS(8, 2, CLK_DIVIDER_POWER_OF_TWO),
+	.mux		= _SUNXI_CCU_MUX(24, 2),
+	.common		= {
+		.reg		= 0xa24,
+		.hw.init	= CLK_HW_INIT_PARENTS("spdif",
+						      audio_parents,
+						      &ccu_div_ops,
+						      0),
+	},
+};
+
+static SUNXI_CCU_GATE(bus_spdif_clk, "bus-spdif", "apb1", 0xa2c, BIT(0), 0);
+
+static struct ccu_div dmic_clk = {
+	.enable		= BIT(31),
+	.div		= _SUNXI_CCU_DIV_FLAGS(8, 2, CLK_DIVIDER_POWER_OF_TWO),
+	.mux		= _SUNXI_CCU_MUX(24, 2),
+	.common		= {
+		.reg		= 0xa40,
+		.hw.init	= CLK_HW_INIT_PARENTS("dmic",
+						      audio_parents,
+						      &ccu_div_ops,
+						      0),
+	},
+};
+
+static SUNXI_CCU_GATE(bus_dmic_clk, "bus-dmic", "apb1", 0xa4c, BIT(0), 0);
+
+static SUNXI_CCU_M_WITH_MUX_GATE(audio_codec_dac_clk, "audio-codec-dac",
+				 audio_parents, 0xa50,
+				 0, 4,		/* M */
+				 24, 2,		/* mux */
+				 BIT(31),	/* gate */
+				 0);
+
+static SUNXI_CCU_M_WITH_MUX_GATE(audio_codec_adc_clk, "audio-codec-adc",
+				 audio_parents, 0xa54,
+				 0, 4,		/* M */
+				 24, 2,		/* mux */
+				 BIT(31),	/* gate */
+				 0);
+
+static SUNXI_CCU_M_WITH_MUX_GATE(audio_codec_4x_clk, "audio-codec-4x",
+				 audio_parents, 0xa58,
+				 0, 4,		/* M */
+				 24, 2,		/* mux */
+				 BIT(31),	/* gate */
+				 0);
+
+static SUNXI_CCU_GATE(bus_audio_codec_clk, "bus-audio-codec", "apb1", 0xa5c, BIT(0), 0);
+
+/*
+ * There are OHCI 12M clock source selection bits for 2 USB 2.0 ports.
+ * We will force them to 0 (12M divided from 48M).
+ */
+#define SUN50IW10_USB0_CLK_REG		0xa70
+#define SUN50IW10_USB1_CLK_REG		0xa74
+
+static SUNXI_CCU_GATE(usb_ohci0_clk, "usb-ohci0", "osc12M", 0xa70, BIT(31), 0);
+static SUNXI_CCU_GATE(usb_phy0_clk, "usb-phy0", "dcxo24M", 0xa70, BIT(29), 0);
+
+static SUNXI_CCU_GATE(usb_ohci1_clk, "usb-ohci1", "osc12M", 0xa74, BIT(31), 0);
+static SUNXI_CCU_GATE(usb_phy1_clk, "usb-phy1", "dcxo24M", 0xa74, BIT(29), 0);
+
+static SUNXI_CCU_GATE(bus_ohci0_clk, "bus-ohci0", "ahb3", 0xa8c, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_ohci1_clk, "bus-ohci1", "ahb3", 0xa8c, BIT(1), 0);
+static SUNXI_CCU_GATE(bus_ehci0_clk, "bus-ehci0", "ahb3", 0xa8c, BIT(4), 0);
+static SUNXI_CCU_GATE(bus_ehci1_clk, "bus-ehci1", "ahb3", 0xa8c, BIT(5), 0);
+static SUNXI_CCU_GATE(bus_otg_clk, "bus-otg", "ahb3", 0xa8c, BIT(8), 0);
+
+static SUNXI_CCU_GATE(bus_lradc_clk, "bus-lradc", "ahb3", 0xa9c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_dpss_top0_clk, "bus-dpss-top0", "ahb3",
+		      0xabc, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_dpss_top1_clk, "bus-dpss-top1", "ahb3",
+		      0xacc, BIT(0), 0);
+
+static const char * const mipi_dsi_parents[] = { "dcxo24M", "pll-periph0-2x",
+						 "pll-periph0" };
+static SUNXI_CCU_M_WITH_MUX_GATE(mipi_dsi_clk, "mipi-dsi",
+				 mipi_dsi_parents,
+				 0xb24,
+				 0, 4,		/* M */
+				 24, 2,		/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_NO_REPARENT);
+
+static SUNXI_CCU_GATE(bus_mipi_dsi_clk, "bus-mipi-dsi", "ahb3",
+		      0xb4c, BIT(0), 0);
+
+static const char * const tcon_lcd0_parents[] = { "pll-video0-4x",
+						  "pll-video1-4x",
+						  "pll-video2-4x",
+						  "pll-video3-4x",
+						  "pll-periph0-2x" };
+static SUNXI_CCU_MP_WITH_MUX_GATE(tcon_lcd0_clk, "tcon-lcd0",
+				  tcon_lcd0_parents, 0xb60,
+				  0, 4,		/* M */
+				  8, 2,		/* N */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  CLK_SET_RATE_NO_REPARENT | CLK_SET_RATE_PARENT);
+
+static const char * const tcon_lcd1_parents[] = { "pll-video1-4x",
+						  "pll-video2-4x",
+						  "pll-video3-4x",
+						  "pll-video0-4x",
+						  "pll-periph0-2x" };
+static SUNXI_CCU_MP_WITH_MUX_GATE(tcon_lcd1_clk, "tcon-lcd1",
+				  tcon_lcd1_parents, 0xb64,
+				  0, 4,		/* M */
+				  8, 2,		/* N */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  CLK_SET_RATE_NO_REPARENT | CLK_SET_RATE_PARENT);
+
+static SUNXI_CCU_GATE(bus_tcon_lcd0_clk, "bus-tcon-lcd0", "ahb3",
+		      0xb7c, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_tcon_lcd1_clk, "bus-tcon-lcd1", "ahb3",
+		      0xb7c, BIT(1), 0);
+
+static const char * const ledc_parents[] = { "dcxo24M",
+					     "pll-periph0" };
+static SUNXI_CCU_MP_WITH_MUX_GATE(ledc_clk, "ledc",
+				  ledc_parents, 0xbf0,
+				  0, 4,		/* M */
+				  8, 2,		/* N */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_GATE(bus_ledc_clk, "bus-ledc", "ahb3", 0xbfc, BIT(0), 0);
+
+static const char * const csi_top_parents[] = { "pll-periph0-2x",
+						"pll-video0-2x",
+						"pll-video1-2x",
+						"pll-video2-2x",
+						"pll-video3-2x" };
+static SUNXI_CCU_M_WITH_MUX_GATE(csi_top_clk, "csi-top",
+				 csi_top_parents, 0xc04,
+				 0, 4,		/* M */
+				 24, 3,		/* mux */
+				 BIT(31),	/* gate */
+				 0);
+
+static const char * const csi0_mclk_parents[] = { "dcxo24M", "pll-video2",
+						  "pll-video3", "pll-video0",
+						  "pll-video1" };
+static SUNXI_CCU_M_WITH_MUX_GATE(csi0_mclk_clk, "csi0-mclk",
+				 csi0_mclk_parents, 0xc08,
+				 0, 5,		/* M */
+				 24, 3,		/* mux */
+				 BIT(31),	/* gate */
+				 0);
+
+static const char * const csi1_mclk_parents[] = { "dcxo24M", "pll-video3",
+						  "pll-video0", "pll-video1",
+						  "pll-video2" };
+static SUNXI_CCU_M_WITH_MUX_GATE(csi1_mclk_clk, "csi1-mclk",
+				 csi1_mclk_parents, 0xc0c,
+				 0, 5,		/* M */
+				 24, 3,		/* mux */
+				 BIT(31),	/* gate */
+				 0);
+
+static SUNXI_CCU_GATE(bus_csi_clk, "bus-csi", "ahb3", 0xc1c, BIT(0), 0);
+
+static const char * const csi_isp_parents[] = { "pll-periph0-2x",
+						"pll-video0-2x",
+						"pll-video1-2x",
+						"pll-video2-2x",
+						"pll-video3-2x" };
+static SUNXI_CCU_M_WITH_MUX_GATE(csi_isp_clk, "csi-isp",
+				 csi_isp_parents, 0xc20,
+				 0, 5,		/* M */
+				 24, 3,		/* mux */
+				 BIT(31),	/* gate */
+				 0);
+
+/* Fixed factor clocks */
+static CLK_FIXED_FACTOR_FW_NAME(osc12M_clk, "osc12M", "hosc", 2, 1, 0);
+
+static CLK_FIXED_FACTOR_HW(pll_com_audio_clk, "pll-com-audio",
+			   &pll_com_clk.common.hw,
+			   5, 1, CLK_SET_RATE_PARENT);
+
+static CLK_FIXED_FACTOR_HW(pll_periph0_2x_clk, "pll-periph0-2x",
+			   &pll_periph0_clk.common.hw,
+			   1, 2, 0);
+
+static CLK_FIXED_FACTOR_HW(pll_periph1_2x_clk, "pll-periph1-2x",
+			   &pll_periph1_clk.common.hw,
+			   1, 2, 0);
+
+static const struct clk_hw *pll_video0_parents[] = {
+	&pll_video0_clk.common.hw
+};
+static CLK_FIXED_FACTOR_HWS(pll_video0_4x_clk, "pll-video0-4x",
+			    pll_video0_parents,
+			    1, 4, CLK_SET_RATE_PARENT);
+static CLK_FIXED_FACTOR_HWS(pll_video0_2x_clk, "pll-video0-2x",
+			    pll_video0_parents,
+			    1, 2, CLK_SET_RATE_PARENT);
+
+static const struct clk_hw *pll_video1_parents[] = {
+	&pll_video1_clk.common.hw
+};
+static CLK_FIXED_FACTOR_HWS(pll_video1_4x_clk, "pll-video1-4x",
+			    pll_video1_parents,
+			    1, 4, CLK_SET_RATE_PARENT);
+static CLK_FIXED_FACTOR_HWS(pll_video1_2x_clk, "pll-video1-2x",
+			    pll_video1_parents,
+			    1, 2, CLK_SET_RATE_PARENT);
+
+static const struct clk_hw *pll_video2_parents[] = {
+	&pll_video2_clk.common.hw
+};
+static CLK_FIXED_FACTOR_HWS(pll_video2_4x_clk, "pll-video2-4x",
+			    pll_video2_parents,
+			    1, 4, CLK_SET_RATE_PARENT);
+static CLK_FIXED_FACTOR_HWS(pll_video2_2x_clk, "pll-video2-2x",
+			    pll_video2_parents,
+			    1, 2, CLK_SET_RATE_PARENT);
+
+static const struct clk_hw *pll_video3_parents[] = {
+	&pll_video3_clk.common.hw
+};
+static CLK_FIXED_FACTOR_HWS(pll_video3_4x_clk, "pll-video3-4x",
+			    pll_video3_parents,
+			    1, 4, CLK_SET_RATE_PARENT);
+static CLK_FIXED_FACTOR_HWS(pll_video3_2x_clk, "pll-video3-2x",
+			    pll_video3_parents,
+			    1, 2, CLK_SET_RATE_PARENT);
+
+static struct ccu_common *sun50iw10_ccu_clks[] = {
+	&pll_cpux_clk.common,
+	&pll_ddr0_clk.common,
+	&pll_periph0_clk.common,
+	&pll_periph1_pattern0_common, /* for pm resume */
+	&pll_periph1_clk.common,
+	&pll_gpu_clk.common,
+	&pll_video0_clk.common,
+	&pll_video1_clk.common,
+	&pll_video2_clk.common,
+	&pll_video3_clk.common,
+	&pll_ve_clk.common,
+	&pll_com_clk.common,
+	&pll_audio_clk.common,
+	&cpux_clk.common,
+	&axi_clk.common,
+	&cpux_apb_clk.common,
+	&psi_ahb1_ahb2_clk.common,
+	&ahb3_clk.common,
+	&apb1_clk.common,
+	&apb2_clk.common,
+	&mbus_clk.common,
+	&de0_clk.common,
+	&de1_clk.common,
+	&bus_de0_clk.common,
+	&bus_de1_clk.common,
+	&eink_clk.common,
+	&bus_eink_clk.common,
+	&g2d_clk.common,
+	&bus_g2d_clk.common,
+	&eink_panel_clk.common,
+	&gpu_clk.common,
+	&bus_gpu_clk.common,
+	&ce_clk.common,
+	&bus_ce_clk.common,
+	&ve_clk.common,
+	&bus_ve_clk.common,
+	&bus_dma_clk.common,
+	&bus_msgbox_clk.common,
+	&bus_spinlock_clk.common,
+	&bus_hstimer_clk.common,
+	&avs_clk.common,
+	&bus_dbg_clk.common,
+	&bus_psi_clk.common,
+	&bus_pwm_clk.common,
+	&bus_iommu_clk.common,
+	&mbus_dma_clk.common,
+	&mbus_ve_clk.common,
+	&mbus_ce_clk.common,
+	&mbus_nand_clk.common,
+	&mbus_csi_clk.common,
+	&mbus_isp_clk.common,
+	&mbus_g2d_clk.common,
+	&bus_dram_clk.common,
+	&nand0_clk.common,
+	&nand1_clk.common,
+	&bus_nand_clk.common,
+	&mmc0_clk.common,
+	&mmc1_clk.common,
+	&mmc2_clk.common,
+	&mmc3_clk.common,
+	&bus_mmc0_clk.common,
+	&bus_mmc1_clk.common,
+	&bus_mmc2_clk.common,
+	&bus_mmc3_clk.common,
+	&bus_uart0_clk.common,
+	&bus_uart1_clk.common,
+	&bus_uart2_clk.common,
+	&bus_uart3_clk.common,
+	&bus_uart4_clk.common,
+	&bus_uart5_clk.common,
+	&bus_uart6_clk.common,
+	&bus_i2c0_clk.common,
+	&bus_i2c1_clk.common,
+	&bus_i2c2_clk.common,
+	&bus_i2c3_clk.common,
+	&bus_i2c4_clk.common,
+	&bus_i2c5_clk.common,
+	&spi0_clk.common,
+	&spi1_clk.common,
+	&spi2_clk.common,
+	&bus_spi0_clk.common,
+	&bus_spi1_clk.common,
+	&bus_spi2_clk.common,
+	&emac0_25m_clk.common,
+	&emac1_25m_clk.common,
+	&bus_emac0_clk.common,
+	&bus_emac1_clk.common,
+	&ir_rx_clk.common,
+	&bus_ir_rx_clk.common,
+	&ir_tx_clk.common,
+	&bus_ir_tx_clk.common,
+	&bus_gpadc_clk.common,
+	&bus_ths_clk.common,
+	&i2s0_clk.common,
+	&i2s1_clk.common,
+	&i2s2_clk.common,
+	&i2s3_clk.common,
+	&bus_i2s0_clk.common,
+	&bus_i2s1_clk.common,
+	&bus_i2s2_clk.common,
+	&bus_i2s3_clk.common,
+	&spdif_clk.common,
+	&bus_spdif_clk.common,
+	&dmic_clk.common,
+	&bus_dmic_clk.common,
+	&audio_codec_dac_clk.common,
+	&audio_codec_adc_clk.common,
+	&audio_codec_4x_clk.common,
+	&bus_audio_codec_clk.common,
+	&usb_ohci0_clk.common,
+	&usb_phy0_clk.common,
+	&usb_ohci1_clk.common,
+	&usb_phy1_clk.common,
+	&bus_ohci0_clk.common,
+	&bus_ohci1_clk.common,
+	&bus_ehci0_clk.common,
+	&bus_ehci1_clk.common,
+	&bus_otg_clk.common,
+	&bus_lradc_clk.common,
+	&bus_dpss_top0_clk.common,
+	&bus_dpss_top1_clk.common,
+	&mipi_dsi_clk.common,
+	&bus_mipi_dsi_clk.common,
+	&tcon_lcd0_clk.common,
+	&tcon_lcd1_clk.common,
+	&bus_tcon_lcd0_clk.common,
+	&bus_tcon_lcd1_clk.common,
+	&ledc_clk.common,
+	&bus_ledc_clk.common,
+	&csi_top_clk.common,
+	&csi0_mclk_clk.common,
+	&csi1_mclk_clk.common,
+	&bus_csi_clk.common,
+	&csi_isp_clk.common,
+};
+
+static struct clk_hw_onecell_data sun50iw10_hw_clks = {
+	.hws	= {
+		[CLK_OSC12M]		= &osc12M_clk.hw,
+		[CLK_PLL_CPUX]		= &pll_cpux_clk.common.hw,
+		[CLK_PLL_DDR0]		= &pll_ddr0_clk.common.hw,
+		[CLK_PLL_PERIPH0]	= &pll_periph0_clk.common.hw,
+		[CLK_PLL_PERIPH0_2X]	= &pll_periph0_2x_clk.hw,
+		[CLK_PLL_PERIPH1]	= &pll_periph1_clk.common.hw,
+		[CLK_PLL_PERIPH1_2X]	= &pll_periph1_2x_clk.hw,
+		[CLK_PLL_GPU]		= &pll_gpu_clk.common.hw,
+		[CLK_PLL_VIDEO0]	= &pll_video0_clk.common.hw,
+		[CLK_PLL_VIDEO0_2X]	= &pll_video0_2x_clk.hw,
+		[CLK_PLL_VIDEO0_4X]	= &pll_video0_4x_clk.hw,
+		[CLK_PLL_VIDEO1]	= &pll_video1_clk.common.hw,
+		[CLK_PLL_VIDEO1_2X]	= &pll_video1_2x_clk.hw,
+		[CLK_PLL_VIDEO1_4X]	= &pll_video1_4x_clk.hw,
+		[CLK_PLL_VIDEO2]	= &pll_video2_clk.common.hw,
+		[CLK_PLL_VIDEO2_2X]	= &pll_video2_2x_clk.hw,
+		[CLK_PLL_VIDEO2_4X]	= &pll_video2_4x_clk.hw,
+		[CLK_PLL_VIDEO3]	= &pll_video3_clk.common.hw,
+		[CLK_PLL_VIDEO3_2X]	= &pll_video3_2x_clk.hw,
+		[CLK_PLL_VIDEO3_4X]	= &pll_video3_4x_clk.hw,
+		[CLK_PLL_VE]		= &pll_ve_clk.common.hw,
+		[CLK_PLL_COM]		= &pll_com_clk.common.hw,
+		[CLK_PLL_COM_AUDIO]	= &pll_com_audio_clk.hw,
+		[CLK_PLL_AUDIO]		= &pll_audio_clk.common.hw,
+		[CLK_CPUX]		= &cpux_clk.common.hw,
+		[CLK_AXI]		= &axi_clk.common.hw,
+		[CLK_CPUX_APB]		= &cpux_apb_clk.common.hw,
+		[CLK_PSI_AHB1_AHB2]	= &psi_ahb1_ahb2_clk.common.hw,
+		[CLK_AHB3]		= &ahb3_clk.common.hw,
+		[CLK_APB1]		= &apb1_clk.common.hw,
+		[CLK_APB2]		= &apb2_clk.common.hw,
+		[CLK_MBUS]		= &mbus_clk.common.hw,
+		[CLK_DE0]		= &de0_clk.common.hw,
+		[CLK_DE1]		= &de1_clk.common.hw,
+		[CLK_BUS_DE0]		= &bus_de0_clk.common.hw,
+		[CLK_BUS_DE1]		= &bus_de1_clk.common.hw,
+		[CLK_EINK]		= &eink_clk.common.hw,
+		[CLK_BUS_EINK]		= &bus_eink_clk.common.hw,
+		[CLK_G2D]		= &g2d_clk.common.hw,
+		[CLK_BUS_G2D]		= &bus_g2d_clk.common.hw,
+		[CLK_EINK_PANEL]	= &eink_panel_clk.common.hw,
+		[CLK_GPU]		= &gpu_clk.common.hw,
+		[CLK_BUS_GPU]		= &bus_gpu_clk.common.hw,
+		[CLK_CE]		= &ce_clk.common.hw,
+		[CLK_BUS_CE]		= &bus_ce_clk.common.hw,
+		[CLK_VE]		= &ve_clk.common.hw,
+		[CLK_BUS_VE]		= &bus_ve_clk.common.hw,
+		[CLK_BUS_DMA]		= &bus_dma_clk.common.hw,
+		[CLK_BUS_MSGBOX]	= &bus_msgbox_clk.common.hw,
+		[CLK_BUS_SPINLOCK]	= &bus_spinlock_clk.common.hw,
+		[CLK_BUS_HSTIMER]	= &bus_hstimer_clk.common.hw,
+		[CLK_AVS]		= &avs_clk.common.hw,
+		[CLK_BUS_DBG]		= &bus_dbg_clk.common.hw,
+		[CLK_BUS_PSI]		= &bus_psi_clk.common.hw,
+		[CLK_BUS_PWM]		= &bus_pwm_clk.common.hw,
+		[CLK_BUS_IOMMU]		= &bus_iommu_clk.common.hw,
+		[CLK_MBUS_DMA]		= &mbus_dma_clk.common.hw,
+		[CLK_MBUS_VE]		= &mbus_ve_clk.common.hw,
+		[CLK_MBUS_CE]		= &mbus_ce_clk.common.hw,
+		[CLK_MBUS_NAND]		= &mbus_nand_clk.common.hw,
+		[CLK_MBUS_CSI]		= &mbus_csi_clk.common.hw,
+		[CLK_MBUS_ISP]		= &mbus_isp_clk.common.hw,
+		[CLK_MBUS_G2D]		= &mbus_g2d_clk.common.hw,
+		[CLK_BUS_DRAM]		= &bus_dram_clk.common.hw,
+		[CLK_NAND0]		= &nand0_clk.common.hw,
+		[CLK_NAND1]		= &nand1_clk.common.hw,
+		[CLK_BUS_NAND]		= &bus_nand_clk.common.hw,
+		[CLK_MMC0]		= &mmc0_clk.common.hw,
+		[CLK_MMC1]		= &mmc1_clk.common.hw,
+		[CLK_MMC2]		= &mmc2_clk.common.hw,
+		[CLK_MMC3]		= &mmc3_clk.common.hw,
+		[CLK_BUS_MMC0]		= &bus_mmc0_clk.common.hw,
+		[CLK_BUS_MMC1]		= &bus_mmc1_clk.common.hw,
+		[CLK_BUS_MMC2]		= &bus_mmc2_clk.common.hw,
+		[CLK_BUS_MMC3]		= &bus_mmc3_clk.common.hw,
+		[CLK_BUS_UART0]		= &bus_uart0_clk.common.hw,
+		[CLK_BUS_UART1]		= &bus_uart1_clk.common.hw,
+		[CLK_BUS_UART2]		= &bus_uart2_clk.common.hw,
+		[CLK_BUS_UART3]		= &bus_uart3_clk.common.hw,
+		[CLK_BUS_UART4]		= &bus_uart4_clk.common.hw,
+		[CLK_BUS_UART5]		= &bus_uart5_clk.common.hw,
+		[CLK_BUS_UART6]		= &bus_uart6_clk.common.hw,
+		[CLK_BUS_I2C0]		= &bus_i2c0_clk.common.hw,
+		[CLK_BUS_I2C1]		= &bus_i2c1_clk.common.hw,
+		[CLK_BUS_I2C2]		= &bus_i2c2_clk.common.hw,
+		[CLK_BUS_I2C3]		= &bus_i2c3_clk.common.hw,
+		[CLK_BUS_I2C4]		= &bus_i2c4_clk.common.hw,
+		[CLK_BUS_I2C5]		= &bus_i2c5_clk.common.hw,
+		[CLK_SPI0]		= &spi0_clk.common.hw,
+		[CLK_SPI1]		= &spi1_clk.common.hw,
+		[CLK_SPI2]		= &spi2_clk.common.hw,
+		[CLK_BUS_SPI0]		= &bus_spi0_clk.common.hw,
+		[CLK_BUS_SPI1]		= &bus_spi1_clk.common.hw,
+		[CLK_BUS_SPI2]		= &bus_spi2_clk.common.hw,
+		[CLK_EMAC0_25M]		= &emac0_25m_clk.common.hw,
+		[CLK_EMAC1_25M]		= &emac1_25m_clk.common.hw,
+		[CLK_BUS_EMAC0]		= &bus_emac0_clk.common.hw,
+		[CLK_BUS_EMAC1]		= &bus_emac1_clk.common.hw,
+		[CLK_IR_RX]		= &ir_rx_clk.common.hw,
+		[CLK_BUS_IR_RX]		= &bus_ir_rx_clk.common.hw,
+		[CLK_IR_TX]		= &ir_tx_clk.common.hw,
+		[CLK_BUS_IR_TX]		= &bus_ir_tx_clk.common.hw,
+		[CLK_BUS_GPADC]		= &bus_gpadc_clk.common.hw,
+		[CLK_BUS_THS]		= &bus_ths_clk.common.hw,
+		[CLK_I2S0]		= &i2s0_clk.common.hw,
+		[CLK_I2S1]		= &i2s1_clk.common.hw,
+		[CLK_I2S2]		= &i2s2_clk.common.hw,
+		[CLK_I2S3]		= &i2s3_clk.common.hw,
+		[CLK_BUS_I2S0]		= &bus_i2s0_clk.common.hw,
+		[CLK_BUS_I2S1]		= &bus_i2s1_clk.common.hw,
+		[CLK_BUS_I2S2]		= &bus_i2s2_clk.common.hw,
+		[CLK_BUS_I2S3]		= &bus_i2s3_clk.common.hw,
+		[CLK_SPDIF]		= &spdif_clk.common.hw,
+		[CLK_BUS_SPDIF]		= &bus_spdif_clk.common.hw,
+		[CLK_DMIC]		= &dmic_clk.common.hw,
+		[CLK_BUS_DMIC]		= &bus_dmic_clk.common.hw,
+		[CLK_AUDIO_DAC]		= &audio_codec_dac_clk.common.hw,
+		[CLK_AUDIO_ADC]		= &audio_codec_adc_clk.common.hw,
+		[CLK_AUDIO_4X]		= &audio_codec_4x_clk.common.hw,
+		[CLK_BUS_AUDIO_CODEC]	= &bus_audio_codec_clk.common.hw,
+		[CLK_USB_OHCI0]		= &usb_ohci0_clk.common.hw,
+		[CLK_USB_PHY0]		= &usb_phy0_clk.common.hw,
+		[CLK_USB_OHCI1]		= &usb_ohci1_clk.common.hw,
+		[CLK_USB_PHY1]		= &usb_phy1_clk.common.hw,
+		[CLK_BUS_OHCI0]		= &bus_ohci0_clk.common.hw,
+		[CLK_BUS_OHCI1]		= &bus_ohci1_clk.common.hw,
+		[CLK_BUS_EHCI0]		= &bus_ehci0_clk.common.hw,
+		[CLK_BUS_EHCI1]		= &bus_ehci1_clk.common.hw,
+		[CLK_BUS_OTG]		= &bus_otg_clk.common.hw,
+		[CLK_BUS_LRADC]		= &bus_lradc_clk.common.hw,
+		[CLK_BUS_DPSS_TOP0]	= &bus_dpss_top0_clk.common.hw,
+		[CLK_BUS_DPSS_TOP1]	= &bus_dpss_top1_clk.common.hw,
+		[CLK_MIPI_DSI]		= &mipi_dsi_clk.common.hw,
+		[CLK_BUS_MIPI_DSI]	= &bus_mipi_dsi_clk.common.hw,
+		[CLK_TCON_LCD0]		= &tcon_lcd0_clk.common.hw,
+		[CLK_TCON_LCD1]		= &tcon_lcd1_clk.common.hw,
+		[CLK_BUS_TCON_LCD0]	= &bus_tcon_lcd0_clk.common.hw,
+		[CLK_BUS_TCON_LCD1]	= &bus_tcon_lcd1_clk.common.hw,
+		[CLK_LEDC]		= &ledc_clk.common.hw,
+		[CLK_BUS_LEDC]		= &bus_ledc_clk.common.hw,
+		[CLK_CSI_TOP]		= &csi_top_clk.common.hw,
+		[CLK_CSI0_MCLK]		= &csi0_mclk_clk.common.hw,
+		[CLK_CSI1_MCLK]		= &csi1_mclk_clk.common.hw,
+		[CLK_BUS_CSI]		= &bus_csi_clk.common.hw,
+		[CLK_CSI_ISP]		= &csi_isp_clk.common.hw,
+	},
+	.num = CLK_NUMBER,
+};
+
+static struct ccu_reset_map sun50iw10_ccu_resets[] = {
+	[RST_MBUS]		= { 0x540, BIT(30) },
+
+	[RST_BUS_DE0]		= { 0x60c, BIT(16) },
+	[RST_BUS_DE1]		= { 0x60c, BIT(17) },
+	[RST_BUS_EINK]		= { 0x61c, BIT(16) },
+	[RST_BUS_G2D]		= { 0x63c, BIT(16) },
+	[RST_BUS_GPU]		= { 0x67c, BIT(16) },
+	[RST_BUS_CE]		= { 0x68c, BIT(16) },
+	[RST_BUS_VE]		= { 0x69c, BIT(16) },
+	[RST_BUS_DMA]		= { 0x70c, BIT(16) },
+	[RST_BUS_MSGBOX]	= { 0x71c, BIT(16) },
+	[RST_BUS_SPINLOCK]	= { 0x72c, BIT(16) },
+	[RST_BUS_HSTIMER]	= { 0x73c, BIT(16) },
+	[RST_BUS_DBG]		= { 0x78c, BIT(16) },
+	[RST_BUS_PSI]		= { 0x79c, BIT(16) },
+	[RST_BUS_PWM]		= { 0x7ac, BIT(16) },
+	[RST_BUS_DRAM]		= { 0x80c, BIT(16) },
+	[RST_BUS_NAND]		= { 0x82c, BIT(16) },
+	[RST_BUS_MMC0]		= { 0x84c, BIT(16) },
+	[RST_BUS_MMC1]		= { 0x84c, BIT(17) },
+	[RST_BUS_MMC2]		= { 0x84c, BIT(18) },
+	[RST_BUS_MMC3]		= { 0x84c, BIT(19) },
+	[RST_BUS_UART0]		= { 0x90c, BIT(16) },
+	[RST_BUS_UART1]		= { 0x90c, BIT(17) },
+	[RST_BUS_UART2]		= { 0x90c, BIT(18) },
+	[RST_BUS_UART3]		= { 0x90c, BIT(19) },
+	[RST_BUS_UART4]		= { 0x90c, BIT(20) },
+	[RST_BUS_UART5]		= { 0x90c, BIT(21) },
+	[RST_BUS_UART6]		= { 0x90c, BIT(22) },
+	[RST_BUS_I2C0]		= { 0x91c, BIT(16) },
+	[RST_BUS_I2C1]		= { 0x91c, BIT(17) },
+	[RST_BUS_I2C2]		= { 0x91c, BIT(18) },
+	[RST_BUS_I2C3]		= { 0x91c, BIT(19) },
+	[RST_BUS_I2C4]		= { 0x91c, BIT(20) },
+	[RST_BUS_I2C5]		= { 0x91c, BIT(21) },
+	[RST_BUS_SPI0]		= { 0x96c, BIT(16) },
+	[RST_BUS_SPI1]		= { 0x96c, BIT(17) },
+	[RST_BUS_SPI2]		= { 0x96c, BIT(18) },
+	[RST_BUS_EMAC0]		= { 0x97c, BIT(16) },
+	[RST_BUS_EMAC1]		= { 0x97c, BIT(17) },
+	[RST_BUS_IR_RX]		= { 0x99c, BIT(16) },
+	[RST_BUS_IR_TX]		= { 0x9cc, BIT(16) },
+	[RST_BUS_GPADC]		= { 0x9ec, BIT(16) },
+	[RST_BUS_THS]		= { 0x9fc, BIT(16) },
+	[RST_BUS_I2S0]		= { 0xa20, BIT(16) },
+	[RST_BUS_I2S1]		= { 0xa20, BIT(17) },
+	[RST_BUS_I2S2]		= { 0xa20, BIT(18) },
+	[RST_BUS_I2S3]		= { 0xa20, BIT(19) },
+	[RST_BUS_SPDIF]		= { 0xa2c, BIT(16) },
+	[RST_BUS_DMIC]		= { 0xa4c, BIT(16) },
+	[RST_BUS_AUDIO_CODEC]	= { 0xa5c, BIT(16) },
+
+	[RST_USB_PHY0]		= { 0xa70, BIT(30) },
+	[RST_USB_PHY1]		= { 0xa74, BIT(30) },
+
+	[RST_BUS_OHCI0]		= { 0xa8c, BIT(16) },
+	[RST_BUS_OHCI1]		= { 0xa8c, BIT(17) },
+	[RST_BUS_EHCI0]		= { 0xa8c, BIT(20) },
+	[RST_BUS_EHCI1]		= { 0xa8c, BIT(21) },
+	[RST_BUS_OTG]		= { 0xa8c, BIT(24) },
+
+	[RST_BUS_LRADC]		= { 0xa9c, BIT(16) },
+	[RST_BUS_DPSS_TOP0]	= { 0xabc, BIT(16) },
+	[RST_BUS_DPSS_TOP1]	= { 0xacc, BIT(16) },
+	[RST_BUS_MIPI_DSI]	= { 0xb4c, BIT(16) },
+	[RST_BUS_TCON_LCD0]	= { 0xb7c, BIT(16) },
+	[RST_BUS_TCON_LCD1]	= { 0xb7c, BIT(17) },
+	[RST_BUS_LVDS0]		= { 0xbac, BIT(16) },
+	[RST_BUS_LVDS1]		= { 0xbac, BIT(17) },
+	[RST_BUS_LEDC]		= { 0xbfc, BIT(16) },
+	[RST_BUS_CSI]		= { 0xc1c, BIT(16) },
+	[RST_BUS_CSI_ISP]	= { 0xc2c, BIT(16) },
+};
+
+static const struct sunxi_ccu_desc sun50iw10_ccu_desc = {
+	.ccu_clks	= sun50iw10_ccu_clks,
+	.num_ccu_clks	= ARRAY_SIZE(sun50iw10_ccu_clks),
+
+	.hw_clks	= &sun50iw10_hw_clks,
+
+	.resets		= sun50iw10_ccu_resets,
+	.num_resets	= ARRAY_SIZE(sun50iw10_ccu_resets),
+};
+
+static const u32 pll_regs[] = {
+	SUN50IW10_PLL_CPUX_REG,
+	SUN50IW10_PLL_DDR0_REG,
+	SUN50IW10_PLL_PERIPH0_REG,
+	SUN50IW10_PLL_PERIPH1_REG,
+	SUN50IW10_PLL_GPU_REG,
+	SUN50IW10_PLL_VIDEO0_REG,
+	SUN50IW10_PLL_VIDEO1_REG,
+	SUN50IW10_PLL_VIDEO2_REG,
+	SUN50IW10_PLL_VIDEO3_REG,
+	SUN50IW10_PLL_VE_REG,
+	SUN50IW10_PLL_COM_REG,
+	SUN50IW10_PLL_AUDIO_REG,
+};
+
+static const u32 pll_video_regs[] = {
+	SUN50IW10_PLL_VIDEO0_REG,
+	SUN50IW10_PLL_VIDEO1_REG,
+	SUN50IW10_PLL_VIDEO2_REG,
+	SUN50IW10_PLL_VIDEO3_REG,
+};
+
+static const u32 usb2_clk_regs[] = {
+	SUN50IW10_USB0_CLK_REG,
+	SUN50IW10_USB1_CLK_REG,
+};
+
+static struct ccu_pll_nb sun50iw10_pll_cpu_nb = {
+	.common = &pll_cpux_clk.common,
+	/* copy from pll_cpux_clk */
+	.enable = BIT(27),
+	.lock   = BIT(28),
+};
+
+static struct ccu_mux_nb sun50iw10_cpu_nb = {
+	.common         = &cpux_clk.common,
+	.cm             = &cpux_clk.mux,
+	.delay_us       = 1,
+	.bypass_index   = 4, /* index of pll periph0 */
+};
+
+static int sun50iw10_ccu_probe(struct platform_device *pdev)
+{
+	void __iomem *reg;
+	u32 val;
+	int i, ret;
+
+	reg = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(reg))
+		return PTR_ERR(reg);
+
+	/* Enable the lock bits on all PLLs */
+	for (i = 0; i < ARRAY_SIZE(pll_regs); i++) {
+		val = readl(reg + pll_regs[i]);
+		val |= BIT(29);
+		writel(val, reg + pll_regs[i]);
+	}
+
+	/*
+	 * In order to pass the EMI certification, the SDM function of
+	 * the peripheral 1 bus is enabled, and the frequency is still
+	 * calculated using the previous division factor.
+	 */
+	writel(0xd1303333, reg + SUN50IW10_PLL_PERIPH1_PATTERN0_REG);
+
+	val = readl(reg + SUN50IW10_PLL_PERIPH1_REG);
+	val |= BIT(24);
+	writel(val, reg + SUN50IW10_PLL_PERIPH1_REG);
+
+	/*
+	 * Force the output divider of video PLLs to 0.
+	 *
+	 * See the comment before pll-video0 definition for the reason.
+	 */
+	for (i = 0; i < ARRAY_SIZE(pll_video_regs); i++) {
+		val = readl(reg + pll_video_regs[i]);
+		val &= ~BIT(0);
+		writel(val, reg + pll_video_regs[i]);
+	}
+
+	/* Enforce m1 = 0, m0 = 1 for Audio PLL */
+	val = readl(reg + SUN50IW10_PLL_AUDIO_REG);
+	val &= ~BIT(1);
+	val |= BIT(0);
+	writel(val, reg + SUN50IW10_PLL_AUDIO_REG);
+
+	/*
+	 * Force OHCI 12M clock sources to 00 (12MHz divided from 48MHz)
+	 *
+	 * This clock mux is still mysterious, and the code just enforces
+	 * it to have a valid clock parent.
+	 */
+	for (i = 0; i < ARRAY_SIZE(usb2_clk_regs); i++) {
+		val = readl(reg + usb2_clk_regs[i]);
+		val &= ~GENMASK(25, 24);
+		writel (val, reg + usb2_clk_regs[i]);
+	}
+
+	ret = sunxi_ccu_probe(pdev->dev.of_node, reg, &sun50iw10_ccu_desc);
+	if (ret)
+		return ret;
+
+	/* Gate then ungate PLL CPU after any rate changes */
+	ccu_pll_notifier_register(&sun50iw10_pll_cpu_nb);
+
+	/* Reparent CPU during PLL CPU rate changes */
+	ccu_mux_notifier_register(pll_cpux_clk.common.hw.clk,
+				  &sun50iw10_cpu_nb);
+
+	sunxi_ccu_sleep_init(reg, sun50iw10_ccu_clks,
+			     ARRAY_SIZE(sun50iw10_ccu_clks),
+			     NULL, 0);
+
+	printk("Sunxi ccu sun50iw10 init OK\n");
+
+	return 0;
+}
+
+static const struct of_device_id sun50iw10_ccu_ids[] = {
+	{ .compatible = "allwinner,sun50iw10-ccu" },
+	{ }
+};
+
+static struct platform_driver sun50iw10_ccu_driver = {
+	.probe	= sun50iw10_ccu_probe,
+	.driver	= {
+		.name	= "sun50iw10-ccu",
+		.of_match_table	= sun50iw10_ccu_ids,
+	},
+};
+
+static int __init sunxi_ccu_sun50iw10_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&sun50iw10_ccu_driver);
+	if (ret)
+		pr_err("register ccu sun50iw10 failed\n");
+
+	return ret;
+}
+core_initcall(sunxi_ccu_sun50iw10_init);
+
+static void __exit sunxi_ccu_sun50iw10_exit(void)
+{
+	return platform_driver_unregister(&sun50iw10_ccu_driver);
+}
+module_exit(sunxi_ccu_sun50iw10_exit);
+
+MODULE_DESCRIPTION("Allwinner sun50iw10 clk driver");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION("1.0.5");
diff --git a/drivers/clk/sunxi-ng/ccu-sun50iw10.h b/drivers/clk/sunxi-ng/ccu-sun50iw10.h
new file mode 100644
index 000000000..3b04d1974
--- /dev/null
+++ b/drivers/clk/sunxi-ng/ccu-sun50iw10.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2020 frank@allwinnertech.com
+ */
+
+#ifndef _CCU_SUN50IW10_H_
+#define _CCU_SUN50IW10_H_
+
+#include <dt-bindings/clock/sun50iw10-ccu.h>
+#include <dt-bindings/reset/sun50iw10-ccu.h>
+
+#define CLK_NUMBER		(CLK_CSI_ISP + 1)
+
+#endif /* _CCU_SUN50IW10_H_ */
diff --git a/drivers/clk/sunxi-ng/ccu-sun50iw12-r.c b/drivers/clk/sunxi-ng/ccu-sun50iw12-r.c
new file mode 100644
index 000000000..c61f03017
--- /dev/null
+++ b/drivers/clk/sunxi-ng/ccu-sun50iw12-r.c
@@ -0,0 +1,286 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2020 frank@allwinnertech.com
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+
+#include "ccu_common.h"
+#include "ccu_reset.h"
+
+#include "ccu_div.h"
+#include "ccu_gate.h"
+#include "ccu_mp.h"
+#include "ccu_nm.h"
+
+#include "ccu-sun50iw12-r.h"
+
+
+static const char * const cpus_r_apb_parents[] = { "dcxo24M", "osc32k",
+						     "iosc", "pll-periph0" };
+static const struct ccu_mux_var_prediv cpus_r_apb_predivs[] = {
+	{ .index = 3, .shift = 0, .width = 5 },
+};
+
+static struct ccu_div cpus_clk = {
+	.div		= _SUNXI_CCU_DIV_FLAGS(8, 2, CLK_DIVIDER_POWER_OF_TWO),
+
+	.mux		= {
+		.shift	= 24,
+		.width	= 2,
+
+		.var_predivs	= cpus_r_apb_predivs,
+		.n_var_predivs	= ARRAY_SIZE(cpus_r_apb_predivs),
+	},
+
+	.common		= {
+		.reg		= 0x000,
+		.features	= CCU_FEATURE_VARIABLE_PREDIV,
+		.hw.init	= CLK_HW_INIT_PARENTS("cpus",
+						      cpus_r_apb_parents,
+						      &ccu_div_ops,
+						      0),
+	},
+};
+
+static CLK_FIXED_FACTOR_HW(r_ahb_clk, "r-ahb", &cpus_clk.common.hw, 1, 1, 0);
+
+static struct ccu_div r_apb0_clk = {
+	.div		= _SUNXI_CCU_DIV_FLAGS(8, 2, CLK_DIVIDER_POWER_OF_TWO),
+
+	.mux		= {
+		.shift	= 24,
+		.width	= 2,
+
+		.var_predivs	= cpus_r_apb_predivs,
+		.n_var_predivs	= ARRAY_SIZE(cpus_r_apb_predivs),
+	},
+
+	.common		= {
+		.reg		= 0x0C,
+		.features	= CCU_FEATURE_VARIABLE_PREDIV,
+		.hw.init	= CLK_HW_INIT_PARENTS("r-apb0",
+						      cpus_r_apb_parents,
+						      &ccu_div_ops,
+						      0),
+	},
+};
+
+static struct ccu_div r_apb1_clk = {
+	.div		= _SUNXI_CCU_DIV_FLAGS(8, 2, CLK_DIVIDER_POWER_OF_TWO),
+
+	.mux		= {
+		.shift	= 24,
+		.width	= 2,
+
+		.var_predivs	= cpus_r_apb_predivs,
+		.n_var_predivs	= ARRAY_SIZE(cpus_r_apb_predivs),
+	},
+
+	.common		= {
+		.reg		= 0x10,
+		.features	= CCU_FEATURE_VARIABLE_PREDIV,
+		.hw.init	= CLK_HW_INIT_PARENTS("r-apb1",
+						      cpus_r_apb_parents,
+						      &ccu_div_ops,
+						      0),
+	},
+};
+
+static const char * const r_timer_parents[] = { "dcxo24M", "iosc",
+						     "osc32k", "r-ahb" };
+static struct ccu_div r_apb0_timer0_clk = {
+	.enable		= BIT(0),
+	.div		= _SUNXI_CCU_DIV_FLAGS(1, 3, CLK_DIVIDER_POWER_OF_TWO),
+	.mux		= _SUNXI_CCU_MUX(4, 2),
+	.common		= {
+		.reg		= 0x110,
+		.hw.init	= CLK_HW_INIT_PARENTS("r-timer0",
+						      r_timer_parents,
+						      &ccu_div_ops,
+						      0),
+	},
+};
+
+static struct ccu_div r_apb0_timer1_clk = {
+	.enable		= BIT(0),
+	.div		= _SUNXI_CCU_DIV_FLAGS(1, 3, CLK_DIVIDER_POWER_OF_TWO),
+	.mux		= _SUNXI_CCU_MUX(4, 2),
+	.common		= {
+		.reg		= 0x114,
+		.hw.init	= CLK_HW_INIT_PARENTS("r-timer1",
+						      r_timer_parents,
+						      &ccu_div_ops,
+						      0),
+	},
+};
+
+static struct ccu_div r_apb0_timer2_clk = {
+	.enable		= BIT(0),
+	.div		= _SUNXI_CCU_DIV_FLAGS(1, 3, CLK_DIVIDER_POWER_OF_TWO),
+	.mux		= _SUNXI_CCU_MUX(4, 2),
+	.common		= {
+		.reg		= 0x118,
+		.hw.init	= CLK_HW_INIT_PARENTS("r-timer2",
+						      r_timer_parents,
+						      &ccu_div_ops,
+						      0),
+	},
+};
+static SUNXI_CCU_GATE(bus_r_apb0_timer0_clk, "bus-r-timer0", "r-apb0",
+		      0x11c, BIT(0), 0);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(r_apb0_edid_clk, "r-edid",
+				  cpus_r_apb_parents, 0x124,
+				  0, 5,		/* M */
+				  8, 2,		/* P */
+				  24, 2,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_GATE(bus_r_apb0_wdt1_clk, "bus-r-wdt1", "r-apb0",
+		      0x12c, BIT(0), 0);
+
+static const char * const r_pwm_parents[] = { "dcxo24M", "osc32k",
+						   "iosc" };
+static SUNXI_CCU_MUX_WITH_GATE(r_apb0_pwm_clk, "r-pwm",
+			       r_pwm_parents, 0x130,
+			       24, 2,		/* mux */
+			       BIT(31),		/* gate */
+			       0);
+
+static SUNXI_CCU_GATE(bus_r_apb0_pwm_clk, "bus-r-pwm", "r-apb0",
+		      0x13c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_apb1_r_uart_clk, "bus-r-uart", "r-apb1",
+		      0x18c, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_r_apb1_i2c0_clk, "bus-r-i2c0", "r-apb1",
+		      0x19c, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_r_apb1_i2c1_clk, "bus-r-i2c1", "r-apb1",
+		      0x19c, BIT(1), 0);
+
+static SUNXI_CCU_GATE(bus_r_apb1_ppu_clk, "bus-r-ppu", "r-apb1",
+		      0x1ac, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_r_apb1_bus_tzma_clk, "bus-r-tzma", "r-apb1",
+		      0x1b0, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_r_cpus_bist_clk, "bus-r-cpus_bist", "r-apb1",
+		      0x1bc, BIT(0), 0);
+
+static const char * const r_ir_parents[] = { "osc32k", "dcxo24M" };
+static SUNXI_CCU_MP_WITH_MUX_GATE(r_apb0_ir_clk, "r-ir",
+				  r_ir_parents, 0x1c0,
+				  0, 5,		/* M */
+				  8, 2,		/* P */
+				  24, 1,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_GATE(bus_r_apb0_ir_clk, "bus-r-ir", "r-apb0",
+		      0x1cc, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_r_ahb_rtc_clk, "bus-r-rtc", "r-ahb",
+		      0x20c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_r_ahb_cpucfg_clk, "bus-r-cpucfg", "r-ahb",
+		      0x22c, BIT(0), 0);
+
+static struct ccu_common *sun50iw12_r_ccu_clks[] = {
+	&cpus_clk.common,
+	&r_apb0_clk.common,
+	&r_apb1_clk.common,
+	&r_apb0_timer0_clk.common,
+	&r_apb0_timer1_clk.common,
+	&r_apb0_timer2_clk.common,
+	&bus_r_apb0_timer0_clk.common,
+	&r_apb0_edid_clk.common,
+	&bus_r_apb0_wdt1_clk.common,
+	&r_apb0_pwm_clk.common,
+	&bus_r_apb0_pwm_clk.common,
+	&bus_apb1_r_uart_clk.common,
+	&bus_r_apb1_i2c0_clk.common,
+	&bus_r_apb1_i2c1_clk.common,
+	&bus_r_apb1_ppu_clk.common,
+	&bus_r_apb1_bus_tzma_clk.common,
+	&bus_r_cpus_bist_clk.common,
+	&r_apb0_ir_clk.common,
+	&bus_r_apb0_ir_clk.common,
+	&bus_r_ahb_rtc_clk.common,
+	&bus_r_ahb_cpucfg_clk.common,
+};
+
+static struct clk_hw_onecell_data sun50iw12_r_hw_clks = {
+	.hws	= {
+		[CLK_CPUS]		= &cpus_clk.common.hw,
+		[CLK_R_AHB]		= &r_ahb_clk.hw,
+		[CLK_R_APB0]		= &r_apb0_clk.common.hw,
+		[CLK_R_APB1]		= &r_apb1_clk.common.hw,
+		[CLK_R_APB0_TIMER0]	= &r_apb0_timer0_clk.common.hw,
+		[CLK_R_APB0_TIMER1]	= &r_apb0_timer1_clk.common.hw,
+		[CLK_R_APB0_TIMER2]	= &r_apb0_timer2_clk.common.hw,
+		[CLK_R_APB0_BUS_TIMER0]	= &bus_r_apb0_timer0_clk.common.hw,
+		[CLK_R_APB0_EDID]	= &r_apb0_edid_clk.common.hw,
+		[CLK_R_APB0_BUS_WDT1]	= &bus_r_apb0_wdt1_clk.common.hw,
+		[CLK_R_APB0_PWM]	= &r_apb0_pwm_clk.common.hw,
+		[CLK_R_APB0_BUS_PWM]	= &bus_r_apb0_pwm_clk.common.hw,
+		[CLK_R_APB1_BUS_UART]	= &bus_apb1_r_uart_clk.common.hw,
+		[CLK_R_APB1_BUS_I2C0]	= &bus_r_apb1_i2c0_clk.common.hw,
+		[CLK_R_APB1_BUS_I2C1]	= &bus_r_apb1_i2c1_clk.common.hw,
+		[CLK_R_APB1_BUS_PPU]	= &bus_r_apb1_ppu_clk.common.hw,
+		[CLK_R_APB1_BUS_TZMA]	= &bus_r_apb1_bus_tzma_clk.common.hw,
+		[CLK_R_CPUS_BUS_BIST]	= &bus_r_cpus_bist_clk.common.hw,
+		[CLK_R_APB0_IR]		= &r_apb0_ir_clk.common.hw,
+		[CLK_R_APB0_BUS_IR]	= &bus_r_apb0_ir_clk.common.hw,
+		[CLK_R_AHB_BUS_RTC]	= &bus_r_ahb_rtc_clk.common.hw,
+		[CLK_R_AHB_BUS_CPUCFG]	= &bus_r_ahb_cpucfg_clk.common.hw,
+	},
+	.num	= CLK_NUMBER,
+};
+
+static struct ccu_reset_map sun50iw12_r_ccu_resets[] = {
+	[RST_R_APB0_BUS_TIMER0]	=  { 0x11c, BIT(16) },
+	[RST_R_APB0_BUS_EDID]	=  { 0x120, BIT(16) },
+	[RST_R_APB0_BUS_PWM]	=  { 0x13c, BIT(16) },
+	[RST_R_APB1_BUS_UART0]	=  { 0x18c, BIT(16) },
+	[RST_R_APB1_BUS_I2C0]	=  { 0x19c, BIT(16) },
+	[RST_R_APB1_BUS_I2C1]	=  { 0x19c, BIT(17) },
+	[RST_R_APB1_BUS_PPU]	=  { 0x1ac, BIT(16) },
+	[RST_R_APB0_BUS_IR_RX]	=  { 0x1cc, BIT(16) },
+	[RST_R_AHB_BUS_RTC]	=  { 0x20c, BIT(16) },
+	[RST_R_AHB_BUS_CPUCFG]	=  { 0x22c, BIT(16) },
+	[RST_R_MODULE]		=  { 0x260, BIT(0) },
+};
+
+static const struct sunxi_ccu_desc sun50iw12_r_ccu_desc = {
+	.ccu_clks	= sun50iw12_r_ccu_clks,
+	.num_ccu_clks	= ARRAY_SIZE(sun50iw12_r_ccu_clks),
+
+	.hw_clks	= &sun50iw12_r_hw_clks,
+
+	.resets		= sun50iw12_r_ccu_resets,
+	.num_resets	= ARRAY_SIZE(sun50iw12_r_ccu_resets),
+};
+
+static void __init of_sun50iw12_r_ccu_init(struct device_node *node)
+{
+	void __iomem *reg;
+	int ret;
+
+	reg = of_iomap(node, 0);
+	if (IS_ERR(reg))
+		return;
+
+	ret = sunxi_ccu_probe(node, reg, &sun50iw12_r_ccu_desc);
+	if (ret)
+		return;
+
+	sunxi_ccu_sleep_init(reg, sun50iw12_r_ccu_clks,
+			     ARRAY_SIZE(sun50iw12_r_ccu_clks),
+			     NULL, 0);
+}
+
+CLK_OF_DECLARE(sun50iw12_r_ccu_init, "allwinner,sun50iw12-r-ccu", of_sun50iw12_r_ccu_init);
diff --git a/drivers/clk/sunxi-ng/ccu-sun50iw12-r.h b/drivers/clk/sunxi-ng/ccu-sun50iw12-r.h
new file mode 100644
index 000000000..ba91da88c
--- /dev/null
+++ b/drivers/clk/sunxi-ng/ccu-sun50iw12-r.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright 2020 frank@allwinnertech.com
+ */
+
+#ifndef _CCU_SUN50IW12_R_H
+#define _CCU_SUN50IW12_R_H
+
+#include <dt-bindings/clock/sun50iw12-r-ccu.h>
+#include <dt-bindings/reset/sun50iw12-r-ccu.h>
+
+#define CLK_NUMBER	(CLK_R_AHB_BUS_CPUCFG + 1)
+
+#endif /* _CCU_SUN50IW12_R_H */
diff --git a/drivers/clk/sunxi-ng/ccu-sun50iw12.c b/drivers/clk/sunxi-ng/ccu-sun50iw12.c
new file mode 100644
index 000000000..41e97f32d
--- /dev/null
+++ b/drivers/clk/sunxi-ng/ccu-sun50iw12.c
@@ -0,0 +1,1329 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2020 frank@allwinnertech.com
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/io.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+
+#include "ccu_common.h"
+#include "ccu_reset.h"
+
+#include "ccu_div.h"
+#include "ccu_gate.h"
+#include "ccu_mp.h"
+#include "ccu_mult.h"
+#include "ccu_nk.h"
+#include "ccu_nkm.h"
+#include "ccu_nkmp.h"
+#include "ccu_nm.h"
+
+#include "ccu-sun50iw12.h"
+
+/*
+ * The CPU PLL is actually NP clock, with P being /1, /2 or /4. However
+ * P should only be used for output frequencies lower than 288 MHz.
+ *
+ * For now we can just model it as a multiplier clock, and force P to /1.
+ *
+ * The M factor is present in the register's description, but not in the
+ * frequency formula, and it's documented as "M is only used for backdoor
+ * testing", so it's not modelled and then force to 0.
+ */
+#define SUN50IW12_PLL_CPUX_REG		0x000
+static struct ccu_mult pll_cpux_clk = {
+	.enable		= BIT(31),
+	.lock		= BIT(28),
+	.mult		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.common		= {
+		.reg		= 0x000,
+		.hw.init	= CLK_HW_INIT("pll-cpux", "dcxo24M",
+					      &ccu_mult_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+/* Some PLLs are input * N / div1 / P. Model them as NKMP with no K */
+#define SUN50IW12_PLL_DDR_REG		0x010
+static struct ccu_nkmp pll_ddr_clk = {
+	.enable		= BIT(31),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.p		= _SUNXI_CCU_DIV(0, 1), /* output divider */
+	.common		= {
+		.reg		= 0x010,
+		.hw.init	= CLK_HW_INIT("pll-ddr", "dcxo24M",
+					      &ccu_nkmp_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+#define SUN50IW12_PLL_PERIPH0_REG	0x020
+static struct ccu_nkmp pll_periph0_clk = {
+	.enable		= BIT(31),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.p		= _SUNXI_CCU_DIV(0, 1), /* output divider */
+	.fixed_post_div	= 2,
+	.common		= {
+		.reg		= 0x020,
+		.features	= CCU_FEATURE_FIXED_POSTDIV,
+		.hw.init	= CLK_HW_INIT("pll-periph0", "dcxo24M",
+					      &ccu_nkmp_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+#define SUN50IW12_PLL_PERIPH1_REG	0x028
+static struct ccu_nkmp pll_periph1_clk = {
+	.enable		= BIT(31),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.p		= _SUNXI_CCU_DIV(0, 1), /* output divider */
+	.fixed_post_div	= 2,
+	.common		= {
+		.reg		= 0x028,
+		.features	= CCU_FEATURE_FIXED_POSTDIV,
+		.hw.init	= CLK_HW_INIT("pll-periph1", "dcxo24M",
+					      &ccu_nkmp_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+#define SUN50IW12_PLL_GPU_REG		0x030
+static struct ccu_nkmp pll_gpu_clk = {
+	.enable		= BIT(31),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.p		= _SUNXI_CCU_DIV(0, 1), /* output divider */
+	.common		= {
+		.reg		= 0x030,
+		.hw.init	= CLK_HW_INIT("pll-gpu", "dcxo24M",
+					      &ccu_nkmp_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+/*
+ * For Video PLLs, the output divider is described as "used for testing"
+ * in the user manual. So it's not modelled and forced to 0.
+ */
+#define SUN50IW12_PLL_VIDEO0_REG	0x040
+static struct ccu_nm pll_video0_clk = {
+	.enable		= BIT(31),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.fixed_post_div	= 4,
+	.min_rate	= 288000000,
+	.max_rate	= 2400000000UL,
+	.common		= {
+		.reg		= 0x040,
+		.features	= CCU_FEATURE_FIXED_POSTDIV,
+		.hw.init	= CLK_HW_INIT("pll-video0", "dcxo24M",
+					      &ccu_nm_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+#define SUN50IW12_PLL_VIDEO1_REG	0x048
+static struct ccu_nm pll_video1_clk = {
+	.enable		= BIT(31),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.fixed_post_div	= 4,
+	.min_rate	= 288000000,
+	.max_rate	= 2400000000UL,
+	.common		= {
+		.reg		= 0x048,
+		.features	= CCU_FEATURE_FIXED_POSTDIV,
+		.hw.init	= CLK_HW_INIT("pll-video1", "dcxo24M",
+					      &ccu_nm_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+#define SUN50IW12_PLL_VIDEO2_REG	0x050
+static struct ccu_nm pll_video2_clk = {
+	.enable		= BIT(31),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.fixed_post_div	= 4,
+	.min_rate	= 288000000,
+	.max_rate	= 2400000000UL,
+	.common		= {
+		.reg		= 0x050,
+		.features	= CCU_FEATURE_FIXED_POSTDIV,
+		.hw.init	= CLK_HW_INIT("pll-video2", "dcxo24M",
+					      &ccu_nm_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+#define SUN50IW12_PLL_VE_REG		0x058
+static struct ccu_nkmp pll_ve_clk = {
+	.enable		= BIT(31),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.p		= _SUNXI_CCU_DIV(0, 1), /* output divider */
+	.common		= {
+		.reg		= 0x058,
+		.hw.init	= CLK_HW_INIT("pll-ve", "dcxo24M",
+					      &ccu_nkmp_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+#define SUN50IW12_PLL_ADC_REG		0x060
+static struct ccu_nkmp pll_adc_clk = {
+	.enable		= BIT(31),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.p		= _SUNXI_CCU_DIV(0, 1), /* output divider */
+	.common		= {
+		.reg		= 0x060,
+		.hw.init	= CLK_HW_INIT("pll-adc", "dcxo24M",
+					      &ccu_nkmp_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+#define SUN50IW12_PLL_VIDEO3_REG	0x068
+static struct ccu_nm pll_video3_clk = {
+	.enable		= BIT(31),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.fixed_post_div	= 4,
+	.min_rate	= 288000000,
+	.max_rate	= 2400000000UL,
+	.common		= {
+		.reg		= 0x068,
+		.features	= CCU_FEATURE_FIXED_POSTDIV,
+		.hw.init	= CLK_HW_INIT("pll-video3", "dcxo24M",
+					      &ccu_nm_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+/*
+ * We don't have any need for the variable divider for now, so we just
+ * hardcode it to match with the clock names.
+ */
+#define SUN50IW12_PLL_AUDIO_REG		0x078
+static struct ccu_nm pll_audio_clk = {
+	.enable		= BIT(31),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.common		= {
+		.reg		= 0x078,
+		.hw.init	= CLK_HW_INIT("pll-audio", "dcxo24M",
+					      &ccu_nm_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+/*
+ * When pll_cpux is selected as the clock source for cpux, there is
+ * an additional frequency division factor m, which we will ignore here.
+ */
+static const char * const cpux_parents[] = { "dcxo24M", "osc32k",
+					     "iosc", "pll-cpux",
+					     "pll-periph0",
+					     "pll-periph0-2x" };
+static SUNXI_CCU_MUX(cpux_clk, "cpux", cpux_parents,
+		     0x500, 24, 3, CLK_SET_RATE_PARENT | CLK_IS_CRITICAL);
+static SUNXI_CCU_M(axi_clk, "axi", "cpux", 0x500, 0, 2, 0);
+static SUNXI_CCU_M(cpux_apb_clk, "cpux-apb", "cpux", 0x500, 8, 2, 0);
+
+static const char * const ahb_apb0_apb1_parents[] = { "dcxo24M", "osc32k",
+						      "iosc", "pll-periph0",
+						      "pll-periph0-2x" };
+static SUNXI_CCU_MP_WITH_MUX(ahb_clk, "ahb",
+			     ahb_apb0_apb1_parents,
+			     0x510,
+			     0, 2,	/* M */
+			     8, 2,	/* P */
+			     24, 3,	/* mux */
+			     0);
+
+static SUNXI_CCU_MP_WITH_MUX(apb0_clk, "apb0", ahb_apb0_apb1_parents, 0x520,
+			     0, 2,	/* M */
+			     8, 2,	/* P */
+			     24, 3,	/* mux */
+			     0);
+
+static SUNXI_CCU_MP_WITH_MUX(apb1_clk, "apb1", ahb_apb0_apb1_parents, 0x524,
+			     0, 2,	/* M */
+			     8, 2,	/* P */
+			     24, 3,	/* mux */
+			     0);
+
+static const char * const mbus_parents[] = { "dcxo24M", "pll-ddr",
+					     "pll-periph0", "pll-periph0-2x" };
+static SUNXI_CCU_M_WITH_MUX_GATE(mbus_clk, "mbus", mbus_parents, 0x540,
+				 0, 5,		/* M */
+				 24, 2,		/* mux */
+				 BIT(31),	/* gate */
+				 CLK_IS_CRITICAL);
+
+static const char * const mips_parents[] = { "pll-periph0-2x", "pll-video0-4x",
+					     "dcxo24M" };
+static SUNXI_CCU_M_WITH_MUX_GATE(mips_clk, "mips", mips_parents, 0x600,
+				 0, 3,		/* M */
+				 24, 2,		/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_PARENT);
+
+static SUNXI_CCU_GATE(bus_mips_clk, "bus-mips", "ahb",
+		      0x60c, BIT(0), 0);
+
+static SUNXI_CCU_M_WITH_GATE(gpu_clk, "gpu", "pll-gpu",
+			     0x670, 0, 5, BIT(31), 0);
+
+static SUNXI_CCU_GATE(bus_gpu_clk, "bus-gpu", "ahb",
+		      0x67c, BIT(0), 0);
+
+static const char * const ce_parents[] = { "dcxo24M", "pll-periph0-2x" };
+static SUNXI_CCU_MP_WITH_MUX_GATE(ce_clk, "ce", ce_parents, 0x680,
+				  0, 4,		/* M */
+				  8, 2,		/* N */
+				  24, 1,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_GATE(bus_ce_clk, "bus-ce", "ahb",
+		      0x68c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_ce_sys_clk, "bus-ce-sys", "ahb",
+		      0x68c, BIT(1), 0);
+
+static const char * const ve_core_parents[] = { "pll-ve",
+						"pll-periph0-2x" };
+static SUNXI_CCU_M_WITH_MUX_GATE(ve_core_clk, "ve-core", ve_core_parents,
+				 0x690,
+				 0, 3,		/* M */
+				 24, 1,		/* mux */
+				 BIT(31),	/* gate */
+				 0);
+
+static SUNXI_CCU_GATE(bus_ve_clk, "bus-ve", "ahb",
+		      0x69c, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_av1_clk, "bus-av1", "ahb",
+		      0x69c, BIT(1), 0);
+static SUNXI_CCU_GATE(bus_ve3_clk, "bus-ve3", "ahb",
+		      0x69c, BIT(2), 0);
+
+static SUNXI_CCU_GATE(bus_dma_clk, "bus-dma", "ahb",
+		      0x70c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_msgbox_clk, "bus-msgbox", "ahb",
+		      0x71c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_spinlock_clk, "bus-spinlock", "ahb",
+		      0x72c, BIT(0), 0);
+
+static const struct ccu_mux_var_prediv ahb_predivs[] = {
+	{ .index = 3, .shift = 0, .width = 5 },
+};
+
+static const char * const timer_parents[] = {"dcxo24M", "iosc",
+					     "osc32k", "ahb"};
+
+static struct ccu_div timer0_clk = {
+	.enable = BIT(0),
+	.div	= _SUNXI_CCU_DIV_FLAGS(1, 3, CLK_DIVIDER_POWER_OF_TWO),
+	.mux	= {
+		.shift = 4,
+		.width = 2,
+
+		.var_predivs	= ahb_predivs,
+		.n_var_predivs	= ARRAY_SIZE(ahb_predivs),
+	},
+	.common = {
+		.reg = 0x730,
+		.features = CCU_FEATURE_VARIABLE_PREDIV,
+		.hw.init  = CLK_HW_INIT_PARENTS("timer0",
+				timer_parents,
+				&ccu_div_ops,
+				0),
+	},
+};
+
+static struct ccu_div timer1_clk = {
+	.enable = BIT(0),
+	.div	= _SUNXI_CCU_DIV_FLAGS(1, 3, CLK_DIVIDER_POWER_OF_TWO),
+	.mux	= {
+		.shift = 4,
+		.width = 2,
+
+		.var_predivs	= ahb_predivs,
+		.n_var_predivs	= ARRAY_SIZE(ahb_predivs),
+	},
+	.common = {
+		.reg = 0x734,
+		.features = CCU_FEATURE_VARIABLE_PREDIV,
+		.hw.init  = CLK_HW_INIT_PARENTS("timer1",
+				timer_parents,
+				&ccu_div_ops,
+				0),
+	},
+};
+
+static struct ccu_div timer2_clk = {
+	.enable = BIT(0),
+	.div	= _SUNXI_CCU_DIV_FLAGS(1, 3, CLK_DIVIDER_POWER_OF_TWO),
+	.mux	= {
+		.shift = 4,
+		.width = 2,
+
+		.var_predivs	= ahb_predivs,
+		.n_var_predivs	= ARRAY_SIZE(ahb_predivs),
+	},
+	.common = {
+		.reg = 0x738,
+		.features = CCU_FEATURE_VARIABLE_PREDIV,
+		.hw.init  = CLK_HW_INIT_PARENTS("timer2",
+				timer_parents,
+				&ccu_div_ops,
+				0),
+	},
+};
+
+static struct ccu_div timer3_clk = {
+	.enable = BIT(0),
+	.div	= _SUNXI_CCU_DIV_FLAGS(1, 3, CLK_DIVIDER_POWER_OF_TWO),
+	.mux	= {
+		.shift = 4,
+		.width = 2,
+
+		.var_predivs	= ahb_predivs,
+		.n_var_predivs	= ARRAY_SIZE(ahb_predivs),
+	},
+	.common = {
+		.reg = 0x73c,
+		.features = CCU_FEATURE_VARIABLE_PREDIV,
+		.hw.init  = CLK_HW_INIT_PARENTS("timer3",
+				timer_parents,
+				&ccu_div_ops,
+				0),
+	},
+};
+
+static struct ccu_div timer4_clk = {
+	.enable = BIT(0),
+	.div	= _SUNXI_CCU_DIV_FLAGS(1, 3, CLK_DIVIDER_POWER_OF_TWO),
+	.mux	= {
+		.shift = 4,
+		.width = 2,
+
+		.var_predivs	= ahb_predivs,
+		.n_var_predivs	= ARRAY_SIZE(ahb_predivs),
+	},
+	.common = {
+		.reg = 0x740,
+		.features = CCU_FEATURE_VARIABLE_PREDIV,
+		.hw.init  = CLK_HW_INIT_PARENTS("timer4",
+				timer_parents,
+				&ccu_div_ops,
+				0),
+	},
+};
+
+static struct ccu_div timer5_clk = {
+	.enable = BIT(0),
+	.div	= _SUNXI_CCU_DIV_FLAGS(1, 3, CLK_DIVIDER_POWER_OF_TWO),
+	.mux	= {
+		.shift = 4,
+		.width = 2,
+
+		.var_predivs	= ahb_predivs,
+		.n_var_predivs	= ARRAY_SIZE(ahb_predivs),
+	},
+	.common = {
+		.reg = 0x744,
+		.features = CCU_FEATURE_VARIABLE_PREDIV,
+		.hw.init  = CLK_HW_INIT_PARENTS("timer5",
+				timer_parents,
+				&ccu_div_ops,
+				0),
+	},
+};
+
+static SUNXI_CCU_GATE(bus_timer0_clk, "bus-timer0", "ahb",
+		      0x750, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_dbg_clk, "bus-dbg", "ahb",
+		      0x78c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_pwm_clk, "bus-pwm", "apb0",
+		      0x7ac, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_iommu_clk, "bus-iommu", "apb0",
+		      0x7bc, BIT(0), 0);
+
+static const char * const dram_parents[] = { "pll-ddr",
+					     "pll-periph1-2x" };
+static SUNXI_CCU_MP_WITH_MUX_GATE(dram_clk, "dram",
+				 dram_parents,
+				 0x800,
+				 0, 5,		/* M */
+				 8, 2,		/* N */
+				 24, 2,		/* mux */
+				 BIT(31),	/* gate */
+				 CLK_IS_CRITICAL);
+
+static SUNXI_CCU_GATE(mbus_dma_clk, "mbus-dma", "mbus",
+		      0x804, BIT(0), 0);
+static SUNXI_CCU_GATE(mbus_ve3_clk, "mbus-ve3", "mbus",
+		      0x804, BIT(1), 0);
+static SUNXI_CCU_GATE(mbus_ce_clk, "mbus-ce", "mbus",
+		      0x804, BIT(2), 0);
+static SUNXI_CCU_GATE(mbus_av1_clk, "mbus-av1", "mbus",
+		      0x804, BIT(3), 0);
+static SUNXI_CCU_GATE(mbus_nand_clk, "mbus-nand", "mbus",
+		      0x804, BIT(5), 0);
+
+static SUNXI_CCU_GATE(bus_dram_clk, "bus-dram", "ahb",
+		      0x80c, BIT(0), CLK_IS_CRITICAL);
+
+static const char * const nand_spi_parents[] = { "dcxo24M", "pll-periph0",
+					     "pll-periph1", "pll-periph0-2x",
+					     "pll-periph1-2x" };
+static SUNXI_CCU_MP_WITH_MUX_GATE(nand0_clk, "nand0", nand_spi_parents, 0x810,
+				  0, 4,		/* M */
+				  8, 2,		/* P */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(nand1_clk, "nand1", nand_spi_parents, 0x814,
+				  0, 4,		/* M */
+				  8, 2,		/* P */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_GATE(bus_nand_clk, "bus-nand", "ahb", 0x82c, BIT(0), 0);
+
+/* XXX: don't use POSTDIV for BSP kernel */
+static const char * const mmc_parents[] = { "dcxo24M", "pll-periph0-2x",
+					    "pll-periph1-2x" };
+static SUNXI_CCU_MP_WITH_MUX_GATE(mmc0_clk, "mmc0", mmc_parents, 0x830,
+					  0, 4,		/* M */
+					  8, 2,		/* P */
+					  24, 3,	/* mux */
+					  BIT(31),	/* gate */
+					  0);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(mmc1_clk, "mmc1", mmc_parents, 0x834,
+					  0, 4,		/* M */
+					  8, 2,		/* P */
+					  24, 3,	/* mux */
+					  BIT(31),	/* gate */
+					  0);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(mmc2_clk, "mmc2", mmc_parents, 0x838,
+					  0, 4,		/* M */
+					  8, 2,		/* P */
+					  24, 3,	/* mux */
+					  BIT(31),	/* gate */
+					  0);
+
+static SUNXI_CCU_GATE(bus_mmc0_clk, "bus-mmc0", "ahb", 0x84c, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_mmc1_clk, "bus-mmc1", "ahb", 0x84c, BIT(1), 0);
+static SUNXI_CCU_GATE(bus_mmc2_clk, "bus-mmc2", "ahb", 0x84c, BIT(2), 0);
+
+static SUNXI_CCU_GATE(bus_uart0_clk, "bus-uart0", "apb1", 0x90c, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_uart1_clk, "bus-uart1", "apb1", 0x90c, BIT(1), 0);
+static SUNXI_CCU_GATE(bus_uart2_clk, "bus-uart2", "apb1", 0x90c, BIT(2), 0);
+static SUNXI_CCU_GATE(bus_uart3_clk, "bus-uart3", "apb1", 0x90c, BIT(3), 0);
+
+static SUNXI_CCU_GATE(bus_i2c0_clk, "bus-i2c0", "apb1", 0x91c, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_i2c1_clk, "bus-i2c1", "apb1", 0x91c, BIT(1), 0);
+static SUNXI_CCU_GATE(bus_i2c2_clk, "bus-i2c2", "apb1", 0x91c, BIT(2), 0);
+static SUNXI_CCU_GATE(bus_i2c3_clk, "bus-i2c3", "apb1", 0x91c, BIT(3), 0);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(spi0_clk, "spi0", nand_spi_parents, 0x940,
+					0, 4,	/* M */
+					8, 2,	/* P */
+					24, 3,	/* mux */
+					BIT(31),/* gate */
+					0);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(spi1_clk, "spi1", nand_spi_parents, 0x944,
+					0, 4,	/* M */
+					8, 2,	/* P */
+					24, 3,	/* mux */
+					BIT(31),/* gate */
+					0);
+
+static SUNXI_CCU_GATE(bus_spi0_clk, "bus-spi0", "ahb", 0x96c, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_spi1_clk, "bus-spi1", "ahb", 0x96c, BIT(1), 0);
+
+static SUNXI_CCU_GATE(emac_25M_clk, "emac-25M", "ahb",
+		      0x970, BIT(30) | BIT(31), 0);
+static SUNXI_CCU_GATE(bus_emac_clk, "bus-emac", "ahb", 0x97c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_gpadc_clk, "bus-gpadc", "apb1", 0x9ec, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_ths_clk, "bus-ths", "apb1", 0x9fc, BIT(0), 0);
+
+static const char * const i2s_spdif_tx_parents[] = { "pll-audio"};
+static SUNXI_CCU_MP_WITH_MUX_GATE(i2s0_clk, "i2s0", i2s_spdif_tx_parents,
+			     0xa10,
+			     0, 5,
+			     8, 2,
+			     24, 3,
+			     BIT(31),
+			     0);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(i2s1_clk, "i2s1", i2s_spdif_tx_parents,
+			     0xa14,
+			     0, 5,
+			     8, 2,
+			     24, 3,
+			     BIT(31),
+			     0);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(i2s2_clk, "i2s2", i2s_spdif_tx_parents,
+				  0xa14,
+				  0, 5,
+				  8, 2,
+				  24, 3,
+				  BIT(31),
+				  0);
+
+static SUNXI_CCU_GATE(bus_i2s0_clk, "bus-i2s0", "apb1", 0xa20, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_i2s1_clk, "bus-i2s1", "apb1", 0xa20, BIT(1), 0);
+static SUNXI_CCU_GATE(bus_i2s2_clk, "bus-i2s2", "apb1", 0xa20, BIT(2), 0);
+
+static const char * const spdif_rx_parents[] = {"pll-periph0-2x",
+						"pll-audio"};
+static SUNXI_CCU_MP_WITH_MUX_GATE(spdif0_rx_clk, "spdif0-rx",
+			     spdif_rx_parents,
+			     0xa30,
+			     0, 5,	/* m */
+			     8, 2,	/* p */
+			     24, 3,	/* mux */
+			     BIT(31),
+			     0);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(spdif0_tx_clk, "spdif0-tx",
+			     i2s_spdif_tx_parents,
+			     0xa34,
+			     0, 5,	/* m */
+			     8, 2,	/* p */
+			     24, 1,	/* mux */
+			     BIT(31),
+			     0);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(spdif1_rx_clk, "spdif1-rx",
+			     spdif_rx_parents,
+			     0xa40,
+			     0, 5,	/* m */
+			     8, 2,	/* p */
+			     24, 3,	/* mux */
+			     BIT(31),
+			     0);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(spdif1_tx_clk, "spdif1-tx",
+			     i2s_spdif_tx_parents,
+			     0xa44,
+			     0, 5,	/* m */
+			     8, 2,	/* p */
+			     24, 1,	/* mux */
+			     BIT(31),
+			     0);
+
+static SUNXI_CCU_GATE(bus_spdif0_clk, "bus-spdif0", "apb1", 0xa2c, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_spdif1_clk, "bus-spdif1", "apb1", 0xa2c, BIT(1), 0);
+
+static const char * const audio_hub_parents[] = { "pll-audio"};
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(audio_hub_clk, "audio-hub",
+			     audio_hub_parents,
+			     0xa50,
+			     0, 5,	/* m */
+			     8, 2,	/* p */
+			     24, 3,	/* mux */
+			     BIT(31),
+			     0);
+
+static SUNXI_CCU_GATE(bus_audio_hub_clk, "bus-audio_hub", "apb1", 0xa5c, BIT(0), 0);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(audio_codec_dac_clk, "audio-codec-dac",
+			     audio_hub_parents,
+			     0xa60,
+			     0, 5,	/* m */
+			     8, 2,	/* p */
+			     24, 3,	/* mux */
+			     BIT(31),
+			     0);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(audio_codec_adc_clk, "audio-codec-adc",
+			     audio_hub_parents,
+			     0xa64,
+			     0, 5,	/* m */
+			     8, 2,	/* p */
+			     24, 3,	/* mux */
+			     BIT(31),
+			     0);
+
+static SUNXI_CCU_GATE(bus_audio_codec_clk, "bus-audio-codec", "apb1",
+		      0xa6c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(usb_ohci0_clk, "usb-ohci0", "osc12M", 0xa70, BIT(31), 0);
+static SUNXI_CCU_GATE(usb_ohci1_clk, "usb-ohci1", "osc12M", 0xa78, BIT(31), 0);
+static SUNXI_CCU_GATE(usb_ohci2_clk, "usb-ohci2", "osc12M", 0xa80, BIT(31), 0);
+
+/*
+ * There are OHCI 12M clock source selection bits for 3 USB 2.0 ports.
+ * We will force them to 0 (12M divided from 48M).
+ */
+static SUNXI_CCU_GATE(bus_ohci0_clk, "bus-ohci0", "osc12M", 0xa8c, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_ohci1_clk, "bus-ohci1", "osc12M", 0xa8c, BIT(1), 0);
+static SUNXI_CCU_GATE(bus_ohci2_clk, "bus-ohci2", "osc12M", 0xa8c, BIT(2), 0);
+static SUNXI_CCU_GATE(bus_ehci0_clk, "bus-ehci0", "ahb", 0xa8c, BIT(4), 0);
+static SUNXI_CCU_GATE(bus_ehci1_clk, "bus-ehci1", "ahb", 0xa8c, BIT(5), 0);
+static SUNXI_CCU_GATE(bus_ehci2_clk, "bus-ehci2", "ahb", 0xa8c, BIT(6), 0);
+static SUNXI_CCU_GATE(bus_otg0_clk, "bus-otg0", "ahb", 0xa8c, BIT(8), 0);
+
+static SUNXI_CCU_GATE(bus_lradc_clk, "bus-lradc", "ahb", 0xa9c, BIT(8), 0);
+
+static const char *const adc_parents[] = {"pll-adc", "pll-video0"};
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(adc_clk, "adc",
+			     adc_parents,
+			     0xd10,
+			     0, 5,	/* m */
+			     8, 2,	/* p */
+			     24, 1,	/* mux */
+			     BIT(31),
+			     0);
+
+static const char * const dtmb_120M_parents[] = { "pll-adc", "pll-periph0" };
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(dtmb_120M_clk, "dtmb-120M",
+			     dtmb_120M_parents,
+			     0xd18,
+			     0, 2,	/* m */
+			     8, 2,	/* p */
+			     24, 1,	/* mux */
+			     BIT(31),
+			     0);
+
+static const char * const tvfe_1296M_parents[] = { "pll-video0-4x", "pll-adc" };
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(tvfe_1296M_clk, "tvfe_1296M_clk",
+			     tvfe_1296M_parents,
+			     0xd18,
+			     0, 2,	/* m */
+			     8, 2,	/* p */
+			     24, 1,	/* mux */
+			     BIT(31),
+			     0);
+
+static const char * const i2h_parents[] = { "pll-video0-4x",
+					    "pll-periph0-2x",
+					    "pll-periph1-2x"};
+
+static SUNXI_CCU_M_WITH_MUX_GATE(i2h_clk, "i2h", i2h_parents, 0xd24,
+				 0, 5,		/* M */
+				 24, 3,		/* mux */
+				 BIT(31),	/* gate */
+				 0);
+
+static const char * const cip_tsx_parents[] = { "pll-periph0",
+					    "pll-periph1"};
+
+static SUNXI_CCU_M_WITH_MUX_GATE(cip_tsx_clk, "cip-tsx", cip_tsx_parents,  0xd28,
+				 0, 3,
+				 24, 1,
+				 BIT(31),
+				 0);
+
+static SUNXI_CCU_M_WITH_MUX_GATE(cip_mcx_clk, "cip-mcx", cip_tsx_parents,  0xd2c,
+				 0, 3,
+				 24, 1,
+				 BIT(31),
+				 0);
+
+static const char * const cip_tsp_parents[] = { "pll-video0-4x",
+					    "pll-adc"};
+
+static SUNXI_CCU_M_WITH_MUX_GATE(cip_tsp_clk, "cip-tsp", cip_tsp_parents,  0xd30,
+				 0, 3,
+				 24, 1,
+				 BIT(31),
+				 0);
+
+static SUNXI_CCU_M_WITH_MUX_GATE(tsa_tsp_clk, "tsa-tsp", cip_tsp_parents,  0xd34,
+				 0, 3,
+				 24, 1,
+				 BIT(31),
+				 0);
+
+static const char * const cip27_parents[] = { "pll-video0",
+					      "pll-adc" };
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(cip27_clk, "cip27",
+			     cip27_parents,
+			     0xd38,
+			     0, 4,	/* m */
+			     8, 2,	/* p */
+			     24, 1,	/* mux */
+			     BIT(31),
+			     0);
+
+static const char *const cip_mts0_parents[] = { "pll-video1-4x", "pll-video0-4x",
+					      "pll-video3-4x", "pll-adc",
+					      "pll-periph0-2x"};
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(cip_mts0_clk, "cip-mts",
+			     cip_mts0_parents,
+			     0xd40,
+			     0, 5,	/* m */
+			     8, 2,	/* p */
+			     24, 3,	/* mux */
+			     BIT(31),
+			     0);
+
+static const char * const audio_cpu_parents[] = { "pll-periph0-2x",
+						  "pll-periph1-2x"};
+
+static SUNXI_CCU_M_WITH_MUX_GATE(audio_cpu_clk, "audio_cpu", audio_cpu_parents,  0xd48,
+				 0, 3,
+				 24, 1,
+				 BIT(31),
+				 0);
+
+static const char * const audio_umac_parents[] = { "pll-periph0",
+						  "pll-periph1"};
+
+static SUNXI_CCU_M_WITH_MUX_GATE(audio_umac_clk, "audio_umac", audio_umac_parents,  0xd4c,
+				 0, 3,
+				 24, 1,
+				 BIT(31),
+				 0);
+
+static const char * const audio_ihb_parents[] = { "pll-video0-4x",
+						  "pll-periph0",
+						  "pll-periph1"};
+
+static SUNXI_CCU_M_WITH_MUX_GATE(audio_ihb_clk, "audio_ihb", audio_ihb_parents,  0xd50,
+				 0, 4,
+				 24, 3,
+				 BIT(31),
+				 0);
+
+static const char * const tsa432_parents[] = { "pll-video0-4x",
+					       "pll-adc"};
+
+static SUNXI_CCU_M_WITH_MUX_GATE(tsa432_clk, "tsa432", tsa432_parents,  0xd58,
+				 0, 3,
+				 24, 1,
+				 BIT(31),
+				 0);
+
+static const char *const mpg_parents[] = { "pll-video1-4x", "dcxo24M",
+					  "pll-adc"};
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(mpg0_clk, "mpg0",
+			     mpg_parents,
+			     0xd5c,
+			     0, 4,	/* m */
+			     8, 2,	/* p */
+			     24, 3,	/* mux */
+			     BIT(31),
+			     0);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(mpg1_clk, "mpg1",
+			     mpg_parents,
+			     0xd60,
+			     0, 4,	/* m */
+			     8, 2,	/* p */
+			     24, 3,	/* mux */
+			     BIT(31),
+			     0);
+
+static SUNXI_CCU_GATE(bus_demod_clk, "bus-demod", "pll-video0-4x",
+		      0xd64, BIT(0), 0);
+
+static const char *const tcd3_parents[] = { "pll-video0-4x", "pll-adc"};
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(tcd3_clk, "tcd3",
+			     tcd3_parents,
+			     0xd6c,
+			     0, 3,	/* m */
+			     8, 2,	/* p */
+			     24, 1,	/* mux */
+			     BIT(31),
+			     0);
+
+static const char *const vincap_dma_parents[] = { "pll-video2-4x", "pll-periph0"};
+static SUNXI_CCU_M_WITH_MUX_GATE(vincap_dma_clk, "vincap-dma", vincap_dma_parents,
+			     0xd74,
+			     0, 5,	/* M */
+			     24, 1,	/* mux */
+			     BIT(31),	/* gate */
+			     0);
+static SUNXI_CCU_GATE(bus_hdmi_audio_clk, "bus-hdmi-audio", "ahb",
+		      0xd80, BIT(31), 0);
+static SUNXI_CCU_GATE(bus_cap_300M_clk, "bus-cap-300M", "ahb",
+		      0xd80, BIT(30), 0);
+
+static const char *const hdmi_audio_parents[] = { "pll-video3-4x", "pll-periph0-2x"};
+static SUNXI_CCU_M_WITH_MUX_GATE(hdmi_audio_clk, "hdmi-audio", hdmi_audio_parents,
+			     0xd84,
+			     0, 5,	/* M */
+			     24, 1,	/* mux */
+			     BIT(31),	/* gate */
+			     0);
+
+static SUNXI_CCU_GATE(bus_tvcap_clk, "bus-tvcap", "ahb",
+		      0xd88, BIT(0), 0);
+
+static SUNXI_CCU_M_WITH_GATE(deint_clk, "deint", "pll-video2-4x",
+			     0xdb0, 0, 5, BIT(31), 0);
+
+static const char * const svp_dtl_parents[] = { "pll-periph0-2x",
+						"pll-video0-4x",
+						"pll-periph1-2x"};
+static SUNXI_CCU_M_WITH_MUX_GATE(svp_dtl_clk, "svp-dtl", svp_dtl_parents,
+				 0xdb8,
+				 0, 5,		/* M */
+				 24, 3,		/* mux */
+				 BIT(31) | BIT(30),	/* gate */
+				 0);
+
+static const char * const afbd_parents[] = { "pll-periph0-2x",
+					     "pll-periph0",
+					     "pll-video0-4x",
+					     "pll-adc"};
+static SUNXI_CCU_M_WITH_MUX_GATE(afbd_clk, "afbd", afbd_parents,
+				 0xdc0,
+				 0, 4,		/* M */
+				 24, 3,		/* mux */
+				 BIT(31),	/* gate */
+				 0);
+
+static SUNXI_CCU_GATE(bus_disp_clk, "bus-disp", "apb1",
+		      0xdd8, BIT(0), 0);
+
+/* Fixed factor clocks */
+static CLK_FIXED_FACTOR_FW_NAME(osc12M_clk, "osc12M", "hosc", 2, 1, 0);
+
+static CLK_FIXED_FACTOR_HW(pll_periph0_2x_clk, "pll-periph0-2x",
+			   &pll_periph0_clk.common.hw,
+			   1, 2, 0);
+
+static CLK_FIXED_FACTOR_HW(pll_periph1_2x_clk, "pll-periph1-2x",
+			   &pll_periph1_clk.common.hw,
+			   1, 2, 0);
+
+static CLK_FIXED_FACTOR_HW(pll_video0_4x_clk, "pll-video0-4x",
+			   &pll_video0_clk.common.hw,
+			   1, 4, CLK_SET_RATE_PARENT);
+static CLK_FIXED_FACTOR_HW(pll_video1_4x_clk, "pll-video1-4x",
+			   &pll_video1_clk.common.hw,
+			   1, 4, CLK_SET_RATE_PARENT);
+static CLK_FIXED_FACTOR_HW(pll_video2_4x_clk, "pll-video2-4x",
+			   &pll_video2_clk.common.hw,
+			   1, 4, CLK_SET_RATE_PARENT);
+static CLK_FIXED_FACTOR_HW(pll_video3_4x_clk, "pll-video3-4x",
+			   &pll_video3_clk.common.hw,
+			   1, 4, CLK_SET_RATE_PARENT);
+
+static struct ccu_common *sun50iw12_ccu_clks[] = {
+	&pll_cpux_clk.common,
+	&pll_ddr_clk.common,
+	&pll_periph0_clk.common,
+	&pll_periph1_clk.common,
+	&pll_gpu_clk.common,
+	&pll_video0_clk.common,
+	&pll_video1_clk.common,
+	&pll_video2_clk.common,
+	&pll_ve_clk.common,
+	&pll_adc_clk.common,
+	&pll_video3_clk.common,
+	&pll_audio_clk.common,
+	&cpux_clk.common,
+	&axi_clk.common,
+	&cpux_apb_clk.common,
+	&ahb_clk.common,
+	&apb0_clk.common,
+	&apb1_clk.common,
+	&mbus_clk.common,
+	&mips_clk.common,
+	&bus_mips_clk.common,
+	&gpu_clk.common,
+	&bus_gpu_clk.common,
+	&ce_clk.common,
+	&bus_ce_clk.common,
+	&bus_ce_sys_clk.common,
+	&ve_core_clk.common,
+	&bus_ve_clk.common,
+	&bus_av1_clk.common,
+	&bus_ve3_clk.common,
+	&bus_dma_clk.common,
+	&bus_msgbox_clk.common,
+	&bus_spinlock_clk.common,
+	&timer0_clk.common,
+	&timer1_clk.common,
+	&timer2_clk.common,
+	&timer3_clk.common,
+	&timer4_clk.common,
+	&timer5_clk.common,
+	&bus_timer0_clk.common,
+	&bus_dbg_clk.common,
+	&bus_pwm_clk.common,
+	&bus_iommu_clk.common,
+	&dram_clk.common,
+	&mbus_dma_clk.common,
+	&mbus_ve3_clk.common,
+	&mbus_ce_clk.common,
+	&mbus_av1_clk.common,
+	&mbus_nand_clk.common,
+	&bus_dram_clk.common,
+	&nand0_clk.common,
+	&nand1_clk.common,
+	&bus_nand_clk.common,
+	&mmc0_clk.common,
+	&mmc1_clk.common,
+	&mmc2_clk.common,
+	&bus_mmc0_clk.common,
+	&bus_mmc1_clk.common,
+	&bus_mmc2_clk.common,
+	&bus_uart0_clk.common,
+	&bus_uart1_clk.common,
+	&bus_uart2_clk.common,
+	&bus_uart3_clk.common,
+	&bus_i2c0_clk.common,
+	&bus_i2c1_clk.common,
+	&bus_i2c2_clk.common,
+	&bus_i2c3_clk.common,
+	&spi0_clk.common,
+	&spi1_clk.common,
+	&bus_spi0_clk.common,
+	&bus_spi1_clk.common,
+	&emac_25M_clk.common,
+	&bus_emac_clk.common,
+	&bus_gpadc_clk.common,
+	&bus_ths_clk.common,
+	&i2s0_clk.common,
+	&i2s1_clk.common,
+	&i2s2_clk.common,
+	&bus_i2s0_clk.common,
+	&bus_i2s1_clk.common,
+	&bus_i2s2_clk.common,
+	&spdif0_rx_clk.common,
+	&spdif0_tx_clk.common,
+	&spdif1_rx_clk.common,
+	&spdif1_tx_clk.common,
+	&bus_spdif0_clk.common,
+	&bus_spdif1_clk.common,
+	&audio_hub_clk.common,
+	&bus_audio_hub_clk.common,
+	&audio_codec_dac_clk.common,
+	&audio_codec_adc_clk.common,
+	&bus_audio_codec_clk.common,
+	&usb_ohci0_clk.common,
+	&usb_ohci1_clk.common,
+	&usb_ohci2_clk.common,
+	&bus_ohci0_clk.common,
+	&bus_ohci1_clk.common,
+	&bus_ohci2_clk.common,
+	&bus_ehci0_clk.common,
+	&bus_ehci1_clk.common,
+	&bus_ehci2_clk.common,
+	&bus_otg0_clk.common,
+	&bus_lradc_clk.common,
+	&adc_clk.common,
+	&dtmb_120M_clk.common,
+	&tvfe_1296M_clk.common,
+	&i2h_clk.common,
+	&cip_tsx_clk.common,
+	&cip_mcx_clk.common,
+	&cip_tsp_clk.common,
+	&tsa_tsp_clk.common,
+	&cip27_clk.common,
+	&cip_mts0_clk.common,
+	&audio_cpu_clk.common,
+	&audio_umac_clk.common,
+	&audio_ihb_clk.common,
+	&tsa432_clk.common,
+	&mpg0_clk.common,
+	&mpg1_clk.common,
+	&bus_demod_clk.common,
+	&tcd3_clk.common,
+	&vincap_dma_clk.common,
+	&bus_hdmi_audio_clk.common,
+	&bus_cap_300M_clk.common,
+	&hdmi_audio_clk.common,
+	&bus_tvcap_clk.common,
+	&deint_clk.common,
+	&svp_dtl_clk.common,
+	&afbd_clk.common,
+	&bus_disp_clk.common,
+};
+
+static struct clk_hw_onecell_data sun50iw12_hw_clks = {
+	.hws	= {
+		[CLK_OSC12M]		= &osc12M_clk.hw,
+		[CLK_PLL_CPUX]		= &pll_cpux_clk.common.hw,
+		[CLK_PLL_DDR0]		= &pll_ddr_clk.common.hw,
+		[CLK_PLL_PERIPH0]	= &pll_periph0_clk.common.hw,
+		[CLK_PLL_PERIPH0_2X]	= &pll_periph0_2x_clk.hw,
+		[CLK_PLL_PERIPH1]	= &pll_periph1_clk.common.hw,
+		[CLK_PLL_PERIPH1_2X]	= &pll_periph1_2x_clk.hw,
+		[CLK_PLL_GPU]		= &pll_gpu_clk.common.hw,
+		[CLK_PLL_VIDEO0]	= &pll_video0_clk.common.hw,
+		[CLK_PLL_VIDEO0_4X]	= &pll_video0_4x_clk.hw,
+		[CLK_PLL_VIDEO1]	= &pll_video1_clk.common.hw,
+		[CLK_PLL_VIDEO1_4X]	= &pll_video1_4x_clk.hw,
+		[CLK_PLL_VIDEO2]	= &pll_video2_clk.common.hw,
+		[CLK_PLL_VIDEO2_4X]	= &pll_video2_4x_clk.hw,
+		[CLK_PLL_VE]		= &pll_ve_clk.common.hw,
+		[CLK_PLL_ADC]		= &pll_adc_clk.common.hw,
+		[CLK_PLL_VIDEO3]	= &pll_video3_clk.common.hw,
+		[CLK_PLL_VIDEO3_4X]	= &pll_video3_4x_clk.hw,
+		[CLK_PLL_AUDIO]		= &pll_audio_clk.common.hw,
+		[CLK_CPUX]		= &cpux_clk.common.hw,
+		[CLK_AXI]		= &axi_clk.common.hw,
+		[CLK_CPUX_APB]		= &cpux_apb_clk.common.hw,
+		[CLK_AHB]		= &ahb_clk.common.hw,
+		[CLK_APB0]		= &apb0_clk.common.hw,
+		[CLK_APB1]		= &apb1_clk.common.hw,
+		[CLK_MBUS]		= &mbus_clk.common.hw,
+		[CLK_MIPS]		= &mips_clk.common.hw,
+		[CLK_BUS_MIPS]		= &bus_mips_clk.common.hw,
+		[CLK_GPU]		= &gpu_clk.common.hw,
+		[CLK_BUS_GPU]		= &bus_gpu_clk.common.hw,
+		[CLK_CE]		= &ce_clk.common.hw,
+		[CLK_BUS_CE]		= &bus_ce_clk.common.hw,
+		[CLK_VE_CORE]		= &ve_core_clk.common.hw,
+		[CLK_BUS_VE]		= &bus_ve_clk.common.hw,
+		[CLK_BUS_AV1]		= &bus_av1_clk.common.hw,
+		[CLK_BUS_VE3]		= &bus_ve3_clk.common.hw,
+		[CLK_BUS_DMA]		= &bus_dma_clk.common.hw,
+		[CLK_MSGBOX]		= &bus_msgbox_clk.common.hw,
+		[CLK_SPINLOCK]		= &bus_spinlock_clk.common.hw,
+		[CLK_TIMER0]		= &timer0_clk.common.hw,
+		[CLK_TIMER1]		= &timer1_clk.common.hw,
+		[CLK_TIMER2]		= &timer2_clk.common.hw,
+		[CLK_TIMER3]		= &timer3_clk.common.hw,
+		[CLK_TIMER4]		= &timer4_clk.common.hw,
+		[CLK_TIMER5]		= &timer5_clk.common.hw,
+		[CLK_BUS_TIMER0]	= &bus_timer0_clk.common.hw,
+		[CLK_BUS_DBG]		= &bus_dbg_clk.common.hw,
+		[CLK_BUS_PWM]		= &bus_pwm_clk.common.hw,
+		[CLK_BUS_IOMMU]		= &bus_iommu_clk.common.hw,
+		[CLK_DRAM]		= &dram_clk.common.hw,
+		[CLK_MBUS_DMA]		= &mbus_dma_clk.common.hw,
+		[CLK_MBUS_VE3]		= &mbus_ve3_clk.common.hw,
+		[CLK_MBUS_CE]		= &mbus_ce_clk.common.hw,
+		[CLK_MBUS_AV1]		= &mbus_av1_clk.common.hw,
+		[CLK_MBUS_NAND]		= &mbus_nand_clk.common.hw,
+		[CLK_BUS_DRAM]		= &bus_dram_clk.common.hw,
+		[CLK_NAND0]		= &nand0_clk.common.hw,
+		[CLK_NAND1]		= &nand1_clk.common.hw,
+		[CLK_BUS_NAND]		= &bus_nand_clk.common.hw,
+		[CLK_MMC0]		= &mmc0_clk.common.hw,
+		[CLK_MMC1]		= &mmc1_clk.common.hw,
+		[CLK_MMC2]		= &mmc2_clk.common.hw,
+		[CLK_BUS_MMC0]		= &bus_mmc0_clk.common.hw,
+		[CLK_BUS_MMC1]		= &bus_mmc1_clk.common.hw,
+		[CLK_BUS_MMC2]		= &bus_mmc2_clk.common.hw,
+		[CLK_BUS_UART0]		= &bus_uart0_clk.common.hw,
+		[CLK_BUS_UART1]		= &bus_uart1_clk.common.hw,
+		[CLK_BUS_UART2]		= &bus_uart2_clk.common.hw,
+		[CLK_BUS_UART3]		= &bus_uart3_clk.common.hw,
+		[CLK_BUS_I2C0]		= &bus_i2c0_clk.common.hw,
+		[CLK_BUS_I2C1]		= &bus_i2c1_clk.common.hw,
+		[CLK_BUS_I2C2]		= &bus_i2c2_clk.common.hw,
+		[CLK_BUS_I2C3]		= &bus_i2c3_clk.common.hw,
+		[CLK_SPI0]		= &spi0_clk.common.hw,
+		[CLK_SPI1]		= &spi1_clk.common.hw,
+		[CLK_BUS_SPI0]		= &bus_spi0_clk.common.hw,
+		[CLK_BUS_SPI1]		= &bus_spi1_clk.common.hw,
+		[CLK_EMAC_25M]		= &emac_25M_clk.common.hw,
+		[CLK_BUS_EMAC]		= &bus_emac_clk.common.hw,
+		[CLK_BUS_GPADC]		= &bus_gpadc_clk.common.hw,
+		[CLK_BUS_THS]		= &bus_ths_clk.common.hw,
+		[CLK_I2S0]		= &i2s0_clk.common.hw,
+		[CLK_I2S1]		= &i2s1_clk.common.hw,
+		[CLK_I2S2]		= &i2s2_clk.common.hw,
+		[CLK_BUS_I2S0]		= &bus_i2s0_clk.common.hw,
+		[CLK_BUS_I2S1]		= &bus_i2s1_clk.common.hw,
+		[CLK_BUS_I2S2]		= &bus_i2s2_clk.common.hw,
+		[CLK_SPDIF0_RX]		= &spdif0_rx_clk.common.hw,
+		[CLK_SPDIF0_TX]		= &spdif0_tx_clk.common.hw,
+		[CLK_SPDIF1_RX]		= &spdif1_rx_clk.common.hw,
+		[CLK_SPDIF1_TX]		= &spdif1_tx_clk.common.hw,
+		[CLK_BUS_SPDIF0]	= &bus_spdif0_clk.common.hw,
+		[CLK_BUS_SPDIF1]	= &bus_spdif1_clk.common.hw,
+		[CLK_AUDIO_HUB]		= &audio_hub_clk.common.hw,
+		[CLK_AUDIO_CODEC_DAC]	= &audio_codec_dac_clk.common.hw,
+		[CLK_AUDIO_CODEC_ADC]	= &audio_codec_adc_clk.common.hw,
+		[CLK_BUS_AUDIO_CODEC]	= &bus_audio_codec_clk.common.hw,
+		[CLK_USB_OHCI0]		= &usb_ohci0_clk.common.hw,
+		[CLK_USB_OHCI1]		= &usb_ohci1_clk.common.hw,
+		[CLK_USB_OHCI2]		= &usb_ohci2_clk.common.hw,
+		[CLK_BUS_OHCI0]		= &bus_ohci0_clk.common.hw,
+		[CLK_BUS_OHCI1]		= &bus_ohci1_clk.common.hw,
+		[CLK_BUS_OHCI2]		= &bus_ohci2_clk.common.hw,
+		[CLK_BUS_EHCI0]		= &bus_ehci0_clk.common.hw,
+		[CLK_BUS_EHCI1]		= &bus_ehci1_clk.common.hw,
+		[CLK_BUS_EHCI2]		= &bus_ehci2_clk.common.hw,
+		[CLK_BUS_OTG]		= &bus_otg0_clk.common.hw,
+		[CLK_BUS_LRADC]		= &bus_lradc_clk.common.hw,
+		[CLK_ADC]		= &adc_clk.common.hw,
+		[CLK_DTMB_120M]		= &dtmb_120M_clk.common.hw,
+		[CLK_TVFE_1296M]	= &tvfe_1296M_clk.common.hw,
+		[CLK_I2H]		= &i2h_clk.common.hw,
+		[CLK_CIP_TSX]		= &cip_tsx_clk.common.hw,
+		[CLK_CIP_MCX]		= &cip_mcx_clk.common.hw,
+		[CLK_CIP_TSP]		= &cip_tsp_clk.common.hw,
+		[CLK_TSA_TSP]		= &tsa_tsp_clk.common.hw,
+		[CLK_CIP27]		= &cip27_clk.common.hw,
+		[CLK_CIP_MTS0]		= &cip_mts0_clk.common.hw,
+		[CLK_AUDIO_CPU]		= &audio_cpu_clk.common.hw,
+		[CLK_AUDIO_UMAC]	= &audio_umac_clk.common.hw,
+		[CLK_AUDIO_IHB]		= &audio_ihb_clk.common.hw,
+		[CLK_TSA432]		= &tsa432_clk.common.hw,
+		[CLK_MPG0]		= &mpg0_clk.common.hw,
+		[CLK_MPG1]		= &mpg1_clk.common.hw,
+		[CLK_BUS_DEMOD]		= &bus_demod_clk.common.hw,
+		[CLK_TCD3]		= &tcd3_clk.common.hw,
+		[CLK_VINCAP_DMA]	= &vincap_dma_clk.common.hw,
+		[CLK_BUS_HDMI_AUDIO]	= &bus_hdmi_audio_clk.common.hw,
+		[CLK_BUS_CAP_300M]	= &bus_cap_300M_clk.common.hw,
+		[CLK_HDMI_AUDIO]	= &hdmi_audio_clk.common.hw,
+		[CLK_BUS_TVCAP]		= &bus_tvcap_clk.common.hw,
+		[CLK_DEINT]		= &deint_clk.common.hw,
+		[CLK_SVP_DTL]		= &svp_dtl_clk.common.hw,
+		[CLK_AFBD]		= &afbd_clk.common.hw,
+		[CLK_BUS_DISP]		= &bus_disp_clk.common.hw,
+	},
+	.num = CLK_NUMBER,
+};
+
+static struct ccu_reset_map sun50iw12_ccu_resets[] = {
+	[RST_MBUS]		= { 0x540, BIT(30) },
+	[RST_BUS_MIPS]		= { 0x60c, BIT(16) },
+	[RST_BUS_MIPS_COLD]	= { 0x60c, BIT(17) },
+	[RST_BUS_MIPS_SOFT]	= { 0x60c, BIT(18) },
+	[RST_BUS_GPU]		= { 0x67c, BIT(16) },
+	[RST_BUS_CE]		= { 0x68c, BIT(16) },
+	[RST_BUS_CE_SYS]	= { 0x68c, BIT(17) },
+	[RST_BUS_VE]		= { 0x69c, BIT(16) },
+	[RST_BUS_AV1]		= { 0x69c, BIT(17) },
+	[RST_BUS_VE3]		= { 0x69c, BIT(18) },
+	[RST_BUS_DMA]		= { 0x70c, BIT(16) },
+	[RST_BUS_MSGBOX]	= { 0x71c, BIT(16) },
+	[RST_BUS_SPINLOCK]	= { 0x72c, BIT(16) },
+	[RST_BUS_TIMER0]	= { 0x750, BIT(16) },
+	[RST_BUS_DBGSYS]	= { 0x78c, BIT(16) },
+	[RST_BUS_PWM]		= { 0x7ac, BIT(16) },
+	[RST_BUS_DRAM_MODULE]	= { 0x800, BIT(30) },
+	[RST_BUS_DRAM]		= { 0x80c, BIT(16) },
+	[RST_BUS_NAND]		= { 0x82c, BIT(16) },
+	[RST_BUS_MMC0]		= { 0x84c, BIT(16) },
+	[RST_BUS_MMC1]		= { 0x84c, BIT(17) },
+	[RST_BUS_MMC2]		= { 0x84c, BIT(18) },
+	[RST_BUS_UART0]		= { 0x90c, BIT(16) },
+	[RST_BUS_UART1]		= { 0x90c, BIT(17) },
+	[RST_BUS_UART2]		= { 0x90c, BIT(18) },
+	[RST_BUS_UART3]		= { 0x90c, BIT(19) },
+	[RST_BUS_UART4]		= { 0x90c, BIT(20) },
+	[RST_BUS_I2C0]		= { 0x91c, BIT(16) },
+	[RST_BUS_I2C1]		= { 0x91c, BIT(17) },
+	[RST_BUS_I2C2]		= { 0x91c, BIT(18) },
+	[RST_BUS_I2C3]		= { 0x91c, BIT(19) },
+	[RST_BUS_SPI0]		= { 0x96c, BIT(16) },
+	[RST_BUS_SPI1]		= { 0x96c, BIT(17) },
+	[RST_BUS_EMAC]		= { 0x97c, BIT(16) },
+	[RST_BUS_GPADC]		= { 0x9ec, BIT(16) },
+	[RST_BUS_THS]		= { 0x9fc, BIT(16) },
+	[RST_BUS_I2S0]		= { 0xa20, BIT(16) },
+	[RST_BUS_I2S1]		= { 0xa20, BIT(17) },
+	[RST_BUS_I2S2]		= { 0xa20, BIT(18) },
+	[RST_BUS_SPDIF0]	= { 0xa2c, BIT(16) },
+	[RST_BUS_SPDIF1]	= { 0xa2c, BIT(17) },
+	[RST_BUS_AUDIO_HUB]	= { 0xa5c, BIT(16) },
+	[RST_BUS_AUDIO_CODEC]	= { 0xa6c, BIT(16) },
+	[RST_USB_PHY0]		= { 0xa70, BIT(30) },
+	[RST_USB_PHY1]		= { 0xa78, BIT(30) },
+	[RST_USB_PHY2]		= { 0xa80, BIT(30) },
+	[RST_BUS_OHCI0]		= { 0xa8c, BIT(16) },
+	[RST_BUS_OHCI1]		= { 0xa8c, BIT(17) },
+	[RST_BUS_OHCI2]		= { 0xa8c, BIT(18) },
+	[RST_BUS_EHCI0]		= { 0xa8c, BIT(20) },
+	[RST_BUS_EHCI1]		= { 0xa8c, BIT(21) },
+	[RST_BUS_EHCI2]		= { 0xa8c, BIT(22) },
+	[RST_BUS_OTG]		= { 0xa8c, BIT(24) },
+	[RST_BUS_LRADC]		= { 0xa9c, BIT(16) },
+	[RST_BUS_LVDS]		= { 0xbac, BIT(16) },
+	[RST_BUS_DEMOD]		= { 0xd64, BIT(16) },
+	[RST_BUS_TVCAP]		= { 0xd88, BIT(16) },
+	[RST_BUS_DISP]		= { 0xdd8, BIT(16) },
+};
+
+static const struct sunxi_ccu_desc sun50iw12_ccu_desc = {
+	.ccu_clks	= sun50iw12_ccu_clks,
+	.num_ccu_clks	= ARRAY_SIZE(sun50iw12_ccu_clks),
+
+	.hw_clks	= &sun50iw12_hw_clks,
+
+	.resets		= sun50iw12_ccu_resets,
+	.num_resets	= ARRAY_SIZE(sun50iw12_ccu_resets),
+};
+
+static const u32 pll_regs[] = {
+	SUN50IW12_PLL_CPUX_REG,
+	SUN50IW12_PLL_DDR_REG,
+	SUN50IW12_PLL_PERIPH0_REG,
+	SUN50IW12_PLL_PERIPH1_REG,
+	SUN50IW12_PLL_GPU_REG,
+	SUN50IW12_PLL_VIDEO0_REG,
+	SUN50IW12_PLL_VIDEO1_REG,
+	SUN50IW12_PLL_VIDEO2_REG,
+	SUN50IW12_PLL_VE_REG,
+	SUN50IW12_PLL_ADC_REG,
+	SUN50IW12_PLL_VIDEO3_REG,
+	SUN50IW12_PLL_AUDIO_REG,
+};
+
+static void __init of_sun50iw12_ccu_init(struct device_node *node)
+{
+	void __iomem *reg;
+	int i;
+	u32 val;
+
+	reg = of_iomap(node, 0);
+	if (IS_ERR(reg))
+		return;
+
+	/* Enable the lock bits on all PLLs */
+	for (i = 0; i < ARRAY_SIZE(pll_regs); i++) {
+		val = readl(reg + pll_regs[i]);
+		val |= BIT(29);
+		writel(val, reg + pll_regs[i]);
+	}
+
+	sunxi_ccu_probe(node, reg, &sun50iw12_ccu_desc);
+}
+
+CLK_OF_DECLARE(sun50iw12_ccu_init, "allwinner,sun50iw12-ccu", of_sun50iw12_ccu_init);
diff --git a/drivers/clk/sunxi-ng/ccu-sun50iw12.h b/drivers/clk/sunxi-ng/ccu-sun50iw12.h
new file mode 100644
index 000000000..44ede7e0c
--- /dev/null
+++ b/drivers/clk/sunxi-ng/ccu-sun50iw12.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright 2020 frank@allwinnertech.com
+ */
+
+#ifndef _CCU_SUN50IW12_H_
+#define _CCU_SUN50IW12_H_
+
+#include <dt-bindings/clock/sun50iw12-ccu.h>
+#include <dt-bindings/reset/sun50iw12-ccu.h>
+
+#define CLK_NUMBER		(CLK_BUS_DISP + 1)
+
+#endif /* _CCU_SUN50IW12_H_ */
diff --git a/drivers/clk/sunxi-ng/ccu-sun50iw9-r.c b/drivers/clk/sunxi-ng/ccu-sun50iw9-r.c
new file mode 100644
index 000000000..6f843bd68
--- /dev/null
+++ b/drivers/clk/sunxi-ng/ccu-sun50iw9-r.c
@@ -0,0 +1,196 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2020 frank@allwinnertech.com
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+
+#include "ccu_common.h"
+#include "ccu_reset.h"
+
+#include "ccu_div.h"
+#include "ccu_gate.h"
+#include "ccu_mp.h"
+#include "ccu_nm.h"
+
+#include "ccu-sun50iw9-r.h"
+
+static const char * const cpus_r_apb2_parents[] = { "dcxo24M", "osc32k",
+						     "iosc", "pll-periph0" };
+static const struct ccu_mux_var_prediv cpus_r_apb2_predivs[] = {
+	{ .index = 3, .shift = 0, .width = 5 },
+};
+
+static struct ccu_div r_cpus_clk = {
+	.div		= _SUNXI_CCU_DIV_FLAGS(8, 2, CLK_DIVIDER_POWER_OF_TWO),
+
+	.mux		= {
+		.shift	= 24,
+		.width	= 2,
+
+		.var_predivs	= cpus_r_apb2_predivs,
+		.n_var_predivs	= ARRAY_SIZE(cpus_r_apb2_predivs),
+	},
+
+	.common		= {
+		.reg		= 0x000,
+		.features	= CCU_FEATURE_VARIABLE_PREDIV,
+		.hw.init	= CLK_HW_INIT_PARENTS("cpus",
+						      cpus_r_apb2_parents,
+						      &ccu_div_ops,
+						      0),
+	},
+};
+
+static CLK_FIXED_FACTOR_HW(r_ahb_clk, "r-ahb", &r_cpus_clk.common.hw, 1, 1, 0);
+
+static struct ccu_div r_apb1_clk = {
+	.div		= _SUNXI_CCU_DIV(0, 2),
+
+	.common		= {
+		.reg		= 0x00c,
+		.hw.init	= CLK_HW_INIT("r-apb1",
+					      "r-ahb",
+					      &ccu_div_ops,
+					      0),
+	},
+};
+
+static struct ccu_div r_apb2_clk = {
+	.div		= _SUNXI_CCU_DIV_FLAGS(8, 2, CLK_DIVIDER_POWER_OF_TWO),
+
+	.mux		= {
+		.shift	= 24,
+		.width	= 2,
+
+		.var_predivs	= cpus_r_apb2_predivs,
+		.n_var_predivs	= ARRAY_SIZE(cpus_r_apb2_predivs),
+	},
+
+	.common		= {
+		.reg		= 0x010,
+		.features	= CCU_FEATURE_VARIABLE_PREDIV,
+		.hw.init	= CLK_HW_INIT_PARENTS("r-apb2",
+						      cpus_r_apb2_parents,
+						      &ccu_div_ops,
+						      0),
+	},
+};
+
+static SUNXI_CCU_GATE(r_apb1_twd_clk, "r-apb1-twd", "r-apb1",
+		      0x12c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(r_apb2_i2c_clk, "r-apb2-i2c", "r-apb2",
+		      0x19c, BIT(0), 0);
+
+/* APB2? */
+static SUNXI_CCU_GATE(r_apb2_can_clk, "r-apb2-can", "r-apb2",
+		      0x1ac, BIT(0), 0);
+
+static const char * const r_apb1_ir_rx_parents[] = { "osc32k", "dcxo24M" };
+static SUNXI_CCU_MP_WITH_MUX_GATE(r_apb1_ir_rx_clk, "r-apb1-ir-rx",
+				  r_apb1_ir_rx_parents, 0x1c0,
+				  0, 5,		/* M */
+				  8, 2,		/* P */
+				  24, 1,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_GATE(r_apb1_bus_ir_rx_clk, "r-apb1-bus-ir-rx", "r-apb1",
+		      0x1cc, BIT(0), 0);
+
+static SUNXI_CCU_GATE(r_ahb_bus_rtc_clk, "r-ahb-rtc", "r-ahb",
+		      0x20c, BIT(0), 0);
+
+static struct ccu_common *sun50iw9_r_ccu_clks[] = {
+	&r_cpus_clk.common,
+	&r_apb1_clk.common,
+	&r_apb2_clk.common,
+	&r_apb1_twd_clk.common,
+	&r_apb2_i2c_clk.common,
+	&r_apb2_can_clk.common,
+	&r_apb1_ir_rx_clk.common,
+	&r_apb1_bus_ir_rx_clk.common,
+	&r_ahb_bus_rtc_clk.common,
+};
+
+static struct clk_hw_onecell_data sun50iw9_r_hw_clks = {
+	.hws	= {
+		[CLK_R_CPUS]		= &r_cpus_clk.common.hw,
+		[CLK_R_AHB]		= &r_ahb_clk.hw,
+		[CLK_R_APB1]		= &r_apb1_clk.common.hw,
+		[CLK_R_APB2]		= &r_apb2_clk.common.hw,
+		[CLK_R_APB1_TWD]	= &r_apb1_twd_clk.common.hw,
+		[CLK_R_APB2_I2C]	= &r_apb2_i2c_clk.common.hw,
+		[CLK_R_APB2_CAN]	= &r_apb2_can_clk.common.hw,
+		[CLK_R_APB1_IR]		= &r_apb1_ir_rx_clk.common.hw,
+		[CLK_R_APB1_BUS_IR]	= &r_apb1_bus_ir_rx_clk.common.hw,
+		[CLK_R_AHB_BUS_RTC]	= &r_ahb_bus_rtc_clk.common.hw,
+	},
+	.num	= CLK_NUMBER,
+};
+
+static struct ccu_reset_map sun50iw9_r_ccu_resets[] = {
+	[RST_R_APB1_TWD]	=  { 0x12c, BIT(16) },
+	[RST_R_APB2_I2C]	=  { 0x19c, BIT(16) },
+	[RST_R_APB2_CAN]	=  { 0x1ac, BIT(16) },
+	[RST_R_APB1_BUS_IR]	=  { 0x1cc, BIT(16) },
+};
+
+static const struct sunxi_ccu_desc sun50iw9_r_ccu_desc = {
+	.ccu_clks	= sun50iw9_r_ccu_clks,
+	.num_ccu_clks	= ARRAY_SIZE(sun50iw9_r_ccu_clks),
+
+	.hw_clks	= &sun50iw9_r_hw_clks,
+
+	.resets		= sun50iw9_r_ccu_resets,
+	.num_resets	= ARRAY_SIZE(sun50iw9_r_ccu_resets),
+};
+
+static int sun50iw9_r_ccu_probe(struct platform_device *pdev)
+{
+	void __iomem *reg;
+	int ret;
+
+	reg = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(reg))
+		return PTR_ERR(reg);
+
+	ret = sunxi_ccu_probe(pdev->dev.of_node, reg, &sun50iw9_r_ccu_desc);
+	if (ret)
+		return ret;
+
+	sunxi_ccu_sleep_init(reg, sun50iw9_r_ccu_clks,
+			     ARRAY_SIZE(sun50iw9_r_ccu_clks),
+			     NULL, 0);
+
+	printk("Sunxi ccu sun50iw9-r init OK\n");
+
+	return 0;
+}
+
+static const struct of_device_id sun50iw9_r_ccu_ids[] = {
+	{ .compatible = "allwinner,sun50iw9-r-ccu" },
+	{ }
+};
+
+static struct platform_driver sun50iw9_r_ccu_driver = {
+	.probe	= sun50iw9_r_ccu_probe,
+	.driver	= {
+		.name	= "sun50iw9-r-ccu",
+		.of_match_table	= sun50iw9_r_ccu_ids,
+	},
+};
+
+static int __init sunxi_ccu_sun50iw9_r_init(void)
+{
+	return platform_driver_register(&sun50iw9_r_ccu_driver);
+}
+core_initcall(sunxi_ccu_sun50iw9_r_init);
+
+MODULE_DESCRIPTION("Allwinner sun50iw9-r clk driver");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION("1.0.5");
diff --git a/drivers/clk/sunxi-ng/ccu-sun50iw9-r.h b/drivers/clk/sunxi-ng/ccu-sun50iw9-r.h
new file mode 100644
index 000000000..12e42ba65
--- /dev/null
+++ b/drivers/clk/sunxi-ng/ccu-sun50iw9-r.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright 2020 frank@allwinnertech.com
+ */
+
+#ifndef _CCU_SUN50IW9_R_H
+#define _CCU_SUN50IW9_R_H
+
+#include <dt-bindings/clock/sun50iw9-r-ccu.h>
+#include <dt-bindings/reset/sun50iw9-r-ccu.h>
+
+#define CLK_NUMBER	(CLK_R_AHB_BUS_RTC + 1)
+
+#endif /* _CCU_SUN50IW9_R_H */
diff --git a/drivers/clk/sunxi-ng/ccu-sun50iw9-rtc.c b/drivers/clk/sunxi-ng/ccu-sun50iw9-rtc.c
new file mode 100644
index 000000000..7782b2407
--- /dev/null
+++ b/drivers/clk/sunxi-ng/ccu-sun50iw9-rtc.c
@@ -0,0 +1,165 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * sunxi RTC ccu driver
+ *
+ * Copyright (c) 2020, DaLv <lvda@allwinnertech.com>
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/io.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/module.h>
+
+#include "ccu_common.h"
+#include "ccu_reset.h"
+#include "ccu_div.h"
+#include "ccu_gate.h"
+#include "ccu_mp.h"
+#include "ccu_mult.h"
+#include "ccu_nk.h"
+#include "ccu_nkm.h"
+#include "ccu_nkmp.h"
+#include "ccu_nm.h"
+#include "ccu_phase.h"
+
+#include "ccu-sun50iw9-rtc.h"
+
+/*
+ * clock source:
+ *  iosc---16M_RC: used by the cpu system directly.
+ *  dcxo---24M Crystal: used by the cpu system directly.
+ *  osc32k---to make it easier, force it to be a fixed clock source:open auto-switch,
+ *  use the 32768 EXT Crystal as default
+ *
+ * the 3 clock source can be treated as the fixed rate clock.
+ * They should be descripted in the dts, being parsed by
+ * clk-fixed-rate.c
+ */
+
+static CLK_FIXED_FACTOR_FW_NAME(rtc_1k_clk, "rtc-1k", "losc", 32, 1, 0);
+
+/* pll-periph0-2x-32k, real source is pll-periph0-2x */
+static CLK_FIXED_FACTOR_FW_NAME(pll_periph0_2x_32k_clk, "pll-periph0-2x-32k", "losc", 1, 1, 0);
+
+static CLK_FIXED_FACTOR_FW_NAME(dcxo_32k_clk, "dcxo-32k", "dcxo24M", 750, 1, 0);
+
+static SUNXI_CCU_GATE(dcxo_32k_out_clk, "dcxo-32k-out", "dcxo-32k", 0x60, BIT(16), 0);
+
+static const char * const osc32k_out_parents[] = { "osc32k", "pll-periph0-2x-32k", "dcxo-32k-out"};
+
+static SUNXI_CCU_MUX_WITH_GATE(osc32k_out_clk, "osc32k-out", osc32k_out_parents,
+			       0x60, 1, 2, BIT(0), 0);
+
+static struct ccu_common *sun50iw9_rtc_ccu_clks[] = {
+	&osc32k_out_clk.common,
+	&dcxo_32k_out_clk.common,
+};
+
+static struct clk_hw_onecell_data sun50iw9_rtc_ccu_hw_clks = {
+	.hws	= {
+		[CLK_RTC_1K]			= &rtc_1k_clk.hw,
+		[CLK_PLL_PERIPHO_2X_32K]	= &pll_periph0_2x_32k_clk.hw,
+		[CLK_DCXO_32K]			= &dcxo_32k_clk.hw,
+		[CLK_DCXO_32K_OUT]		= &dcxo_32k_out_clk.common.hw,
+		[CLK_OSC32K_OUT]		= &osc32k_out_clk.common.hw,
+	},
+	.num	= CLK_NUMBER,
+};
+
+static const struct sunxi_ccu_desc sun50iw9_rtc_ccu_desc = {
+	.ccu_clks	= sun50iw9_rtc_ccu_clks,
+	.num_ccu_clks	= ARRAY_SIZE(sun50iw9_rtc_ccu_clks),
+
+	.hw_clks	= &sun50iw9_rtc_ccu_hw_clks,
+};
+
+static void clock_source_init(char __iomem *base)
+{
+	/* (1) enable DCXO */
+	/* by default, DCXO_EN = 1. We don't have to do this... */
+	set_reg(base + XO_CTRL_REG, 0x1, 1, 0);
+
+	/* (2) enable calibrated RC-16M, and switch to it */
+	/* set WAKEUP_DCXO_EN is 0 */
+	set_reg(base + CALI_CTRL_REG, 0x0, 1, 31);
+	/*
+	 * open Calibrated RC and select it
+	 * BIT(0)   0: Normal RC; 1: Calibrated RC
+	 * BIT(1)   0: disable; 1: enable
+	 */
+	set_reg(base + INTOSC_CLK_AUTO_CALI_REG, 0x3, 2, 0);
+
+	/* (3) enable auto switch function */
+	/*
+	 * In some cases, we boot with auto switch function disabled, and try to
+	 * enable the auto switch function by rebooting.
+	 * But the rtc default value does not change unless vcc-rtc is loss.
+	 * So we should not rely on the default value of reg.
+	 * BIT(14): LOSC auto switch 32k clk source sel enable. 1: enable
+	 * BIT(15): LOSC auto switch function disable. 1: disable
+	 */
+	//set_reg(base + LOSC_CTRL_REG, 0x16aa3, 20, 12);
+	set_reg_key(base + LOSC_CTRL_REG,
+		    KEY_FIELD_MAGIC, 16, 16,
+		    0x1, 2, 14);
+
+	/* (4) set the parent of osc32k-sys to ext-osc32k */
+	set_reg_key(base + LOSC_CTRL_REG,
+		    0x16aa, 16, 16,
+		    0x1, 1, 0);
+	/*
+	 * the 32K fanout has been set in the clk tree
+	 * this part can be deleted
+	 */
+	/* (5) set the parent of osc32k-out to osc32k-sys*/
+	/* by default, LOSC_OUT_SRC_SEL = 0x0. We don't have to do this... */
+	set_reg(base + LOSC_OUT_GATING_REG,
+		0x0, 2, 1);
+}
+
+static int sun50iw9_rtc_ccu_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct device *dev = &pdev->dev;
+	void __iomem *reg;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(dev, "Fail to get IORESOURCE_MEM\n");
+		return -EINVAL;
+	}
+
+	/*
+	 * Don't use devm_ioremap_resource() here! Or else the RTC driver will
+	 * not able to get the same resource later in rtc-sunxi.c.
+	 */
+	reg = devm_ioremap(dev, res->start, resource_size(res));
+	if (IS_ERR(reg)) {
+		dev_err(dev, "Fail to map IO resource\n");
+		return PTR_ERR(reg);
+	}
+
+	clock_source_init(reg);
+
+	return sunxi_ccu_probe(pdev->dev.of_node, reg, &sun50iw9_rtc_ccu_desc);
+}
+
+static const struct of_device_id sun50iw9_rtc_ccu_ids[] = {
+	{ .compatible = "allwinner,sun50iw9-rtc-ccu" },
+	{ }
+};
+
+static struct platform_driver sun50iw9_rtc_ccu_driver = {
+	.probe	= sun50iw9_rtc_ccu_probe,
+	.driver	= {
+		.name	= "sun50iw9-rtc-ccu",
+		.of_match_table	= sun50iw9_rtc_ccu_ids,
+	},
+};
+builtin_platform_driver(sun50iw9_rtc_ccu_driver);
+
+MODULE_DESCRIPTION("sunxi RTC CCU driver");
+MODULE_AUTHOR("Da Lv <lvda@allwinnertech.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION("1.1.0");
diff --git a/drivers/clk/sunxi-ng/ccu-sun50iw9-rtc.h b/drivers/clk/sunxi-ng/ccu-sun50iw9-rtc.h
new file mode 100644
index 000000000..049e65ed3
--- /dev/null
+++ b/drivers/clk/sunxi-ng/ccu-sun50iw9-rtc.h
@@ -0,0 +1,21 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2020 lvda@allwinnertech.com
+ */
+
+#ifndef _CCU_SUN50IW9_RTC_H_
+#define _CCU_SUN50IW9_RTC_H_
+
+#include <dt-bindings/clock/sun50iw9-ccu-rtc.h>
+
+#define LOSC_CTRL_REG			0x00
+#define KEY_FIELD_MAGIC			0x16AA
+#define INTOSC_CLK_AUTO_CALI_REG	0x0C
+#define LOSC_OUT_GATING_REG		0x60  /* Or: 32K_FOUT_CTRL_GATING_REG */
+#define XO_CTRL_REG			0x160  /* XO Control register */
+#define CALI_CTRL_REG			0x164
+
+#define CLK_NUMBER			(CLK_OSC32K_OUT + 1)
+
+#endif /* _CCU_SUN50IW9_RTC_H_ */
+
diff --git a/drivers/clk/sunxi-ng/ccu-sun50iw9.c b/drivers/clk/sunxi-ng/ccu-sun50iw9.c
new file mode 100644
index 000000000..5c1315b3c
--- /dev/null
+++ b/drivers/clk/sunxi-ng/ccu-sun50iw9.c
@@ -0,0 +1,1281 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2020 frank@allwinnertech.com
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+
+#include "ccu_common.h"
+#include "ccu_reset.h"
+
+#include "ccu_div.h"
+#include "ccu_gate.h"
+#include "ccu_mp.h"
+#include "ccu_mult.h"
+#include "ccu_nk.h"
+#include "ccu_nkm.h"
+#include "ccu_nkmp.h"
+#include "ccu_nm.h"
+
+#include "ccu-sun50iw9.h"
+
+/*
+ * The CPU PLL is actually NP clock, with P being /1, /2 or /4. However
+ * P should only be used for output frequencies lower than 288 MHz.
+ *
+ * For now we can just model it as a multiplier clock, and force P to /1.
+ *
+ * The M factor is present in the register's description, but not in the
+ * frequency formula, and it's documented as "M is only used for backdoor
+ * testing", so it's not modelled and then force to 0.
+ */
+#define SUN50IW9_PLL_CPUX_REG		0x000
+static struct ccu_mult pll_cpux_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.mult		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.common		= {
+		.reg		= 0x000,
+		.hw.init	= CLK_HW_INIT("pll-cpux", "dcxo24M",
+					      &ccu_mult_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+/* Some PLLs are input * N / div1 / P. Model them as NKMP with no K */
+#define SUN50IW9_PLL_DDR0_REG		0x010
+static struct ccu_nkmp pll_ddr0_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.p		= _SUNXI_CCU_DIV(0, 1), /* output divider */
+	.common		= {
+		.reg		= 0x010,
+		.hw.init	= CLK_HW_INIT("pll-ddr0", "dcxo24M",
+					      &ccu_nkmp_ops,
+					      CLK_SET_RATE_UNGATE |
+					      CLK_IS_CRITICAL),
+	},
+};
+
+#define SUN50IW9_PLL_DDR1_REG		0x018
+static struct ccu_nkmp pll_ddr1_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.p		= _SUNXI_CCU_DIV(0, 1), /* output divider */
+	.common		= {
+		.reg		= 0x018,
+		.hw.init	= CLK_HW_INIT("pll-ddr1", "dcxo24M",
+					      &ccu_nkmp_ops,
+					      CLK_SET_RATE_UNGATE |
+					      CLK_IS_CRITICAL),
+	},
+};
+
+#define SUN50IW9_PLL_PERIPH0_REG	0x020
+static struct ccu_nkmp pll_periph0_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.p		= _SUNXI_CCU_DIV(0, 1), /* output divider */
+	.fixed_post_div	= 2,
+	.common		= {
+		.reg		= 0x020,
+		.features	= CCU_FEATURE_FIXED_POSTDIV,
+		.hw.init	= CLK_HW_INIT("pll-periph0", "dcxo24M",
+					      &ccu_nkmp_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+#define SUN50IW9_PLL_PERIPH1_REG	0x028
+static struct ccu_nkmp pll_periph1_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.p		= _SUNXI_CCU_DIV(0, 1), /* output divider */
+	.fixed_post_div	= 2,
+	.common		= {
+		.reg		= 0x028,
+		.features	= CCU_FEATURE_FIXED_POSTDIV,
+		.hw.init	= CLK_HW_INIT("pll-periph1", "dcxo24M",
+					      &ccu_nkmp_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+#define SUN50IW9_PLL_GPU_REG		0x030
+static struct ccu_nkmp pll_gpu_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.p		= _SUNXI_CCU_DIV(0, 1), /* output divider */
+	.common		= {
+		.reg		= 0x030,
+		.hw.init	= CLK_HW_INIT("pll-gpu", "dcxo24M",
+					      &ccu_nkmp_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+/*
+ * For Video PLLs, the output divider is described as "used for testing"
+ * in the user manual. So it's not modelled and forced to 0.
+ */
+#define SUN50IW9_PLL_VIDEO0_REG		0x040
+static struct ccu_nm pll_video0_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.fixed_post_div	= 4,
+	.min_rate	= 288000000,
+	.max_rate	= 2400000000UL,
+	.common		= {
+		.reg		= 0x040,
+		.features	= CCU_FEATURE_FIXED_POSTDIV,
+		.hw.init	= CLK_HW_INIT("pll-video0", "dcxo24M",
+					      &ccu_nm_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+#define SUN50IW9_PLL_VIDEO1_REG		0x048
+static struct ccu_nm pll_video1_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.fixed_post_div	= 4,
+	.min_rate	= 288000000,
+	.max_rate	= 2400000000UL,
+	.common		= {
+		.reg		= 0x048,
+		.features	= CCU_FEATURE_FIXED_POSTDIV,
+		.hw.init	= CLK_HW_INIT("pll-video1", "dcxo24M",
+					      &ccu_nm_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+#define SUN50IW9_PLL_VIDEO2_REG		0x050
+static struct ccu_nm pll_video2_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.fixed_post_div	= 4,
+	.min_rate	= 288000000,
+	.max_rate	= 2400000000UL,
+	.common		= {
+		.reg		= 0x050,
+		.features	= CCU_FEATURE_FIXED_POSTDIV,
+		.hw.init	= CLK_HW_INIT("pll-video2", "dcxo24M",
+					      &ccu_nm_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+#define SUN50IW9_PLL_VE_REG		0x058
+static struct ccu_nkmp pll_ve_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.p		= _SUNXI_CCU_DIV(0, 1), /* output divider */
+	.common		= {
+		.reg		= 0x058,
+		.hw.init	= CLK_HW_INIT("pll-ve", "dcxo24M",
+					      &ccu_nkmp_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+#define SUN50IW9_PLL_DE_REG		0x060
+static struct ccu_nkmp pll_de_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.p		= _SUNXI_CCU_DIV(0, 1), /* output divider */
+	.common		= {
+		.reg		= 0x060,
+		.hw.init	= CLK_HW_INIT("pll-de", "dcxo24M",
+					      &ccu_nkmp_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+/* for pm resume */
+#define SUN50IW9_PLL_PERIPH1_PATTERN0_REG	0x128
+static struct ccu_common pll_periph1_pattern0_common = {
+	.reg = 0x128,
+};
+
+/*
+ * The Audio PLL has m0, m1 dividers in addition to the usual N, M
+ * factors. Since we only need 4 frequencies from this PLL: 22.5792 MHz,
+ * 24.576 MHz, 90.3168MHz and 98.304MHz ignore them for now.
+ * Enforce the default for them, which is m0 = 1, m1 = 0.
+ */
+#define SUN50IW9_PLL_AUDIO_REG		0x078
+static struct ccu_sdm_setting pll_audio_sdm_table[] = {
+	{ .rate = 45158400, .pattern = 0xc001bcd3, .m = 18, .n = 33 },
+	{ .rate = 49152000, .pattern = 0xc001eb85, .m = 20, .n = 40 },
+	{ .rate = 180633600, .pattern = 0xc001288d, .m = 3, .n = 22 },
+	{ .rate = 196608000, .pattern = 0xc001eb85, .m = 5, .n = 40 },
+};
+
+static struct ccu_nm pll_audio_4x_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(16, 6),
+	.fixed_post_div	= 2,
+	.sdm		= _SUNXI_CCU_SDM(pll_audio_sdm_table, BIT(24),
+					 0x178, BIT(31)),
+	.common		= {
+		.reg		= 0x078,
+		.features	= CCU_FEATURE_FIXED_POSTDIV |
+				  CCU_FEATURE_SIGMA_DELTA_MOD,
+		.hw.init	= CLK_HW_INIT("pll-audio-4x", "dcxo24M",
+					      &ccu_nm_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+#define SUN50IW9_PLL_CSI_REG		0x0e0
+static struct ccu_nkmp pll_csi_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.p		= _SUNXI_CCU_DIV(0, 1), /* output divider */
+	.common		= {
+		.reg		= 0x0e0,
+		.hw.init	= CLK_HW_INIT("pll-csi", "dcxo24M",
+					      &ccu_nkmp_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+static const char * const cpux_parents[] = { "dcxo24M", "osc32k",
+					     "iosc", "pll-cpux",
+					      "pll-periph0" };
+static SUNXI_CCU_MUX(cpux_clk, "cpux", cpux_parents,
+		     0x500, 24, 3, CLK_SET_RATE_PARENT | CLK_IS_CRITICAL);
+static SUNXI_CCU_M(axi_clk, "axi", "cpux", 0x500, 0, 2, 0);
+static SUNXI_CCU_M(cpux_apb_clk, "cpux-apb", "cpux", 0x500, 8, 2, 0);
+
+static const char * const psi_ahb1_ahb2_parents[] = { "dcxo24M", "osc32k",
+						      "iosc", "pll-periph0" };
+static SUNXI_CCU_MP_WITH_MUX(psi_ahb1_ahb2_clk, "psi-ahb1-ahb2",
+			     psi_ahb1_ahb2_parents,
+			     0x510,
+			     0, 2,	/* M */
+			     8, 2,	/* P */
+			     24, 2,	/* mux */
+			     0);
+
+static const char * const ahb3_apb1_apb2_parents[] = { "dcxo24M", "osc32k",
+						       "psi-ahb1-ahb2",
+						       "pll-periph0" };
+static SUNXI_CCU_MP_WITH_MUX(ahb3_clk, "ahb3", ahb3_apb1_apb2_parents, 0x51c,
+			     0, 2,	/* M */
+			     8, 2,	/* P */
+			     24, 2,	/* mux */
+			     0);
+
+static SUNXI_CCU_MP_WITH_MUX(apb1_clk, "apb1", ahb3_apb1_apb2_parents, 0x520,
+			     0, 2,	/* M */
+			     8, 2,	/* P */
+			     24, 2,	/* mux */
+			     0);
+
+static SUNXI_CCU_MP_WITH_MUX(apb2_clk, "apb2", ahb3_apb1_apb2_parents, 0x524,
+			     0, 2,	/* M */
+			     8, 2,	/* P */
+			     24, 2,	/* mux */
+			     0);
+
+static const char * const mbus_parents[] = { "dcxo24M", "pll-periph0-2x",
+					     "pll-ddr0", "pll-ddr1" };
+static SUNXI_CCU_M_WITH_MUX_GATE(mbus_clk, "mbus", mbus_parents, 0x540,
+				 0, 3,		/* M */
+				 24, 2,		/* mux */
+				 BIT(31),	/* gate */
+				 CLK_IS_CRITICAL);
+
+static const char * const de_di_g2d_parents[] = { "pll-de", "pll-periph0-2x" };
+static SUNXI_CCU_M_WITH_MUX_GATE(de_clk, "de", de_di_g2d_parents, 0x600,
+				 0, 4,		/* M */
+				 24, 1,		/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_NO_REPARENT);
+
+static SUNXI_CCU_GATE(bus_de_clk, "bus-de", "psi-ahb1-ahb2",
+		      0x60c, BIT(0), 0);
+
+static SUNXI_CCU_M_WITH_MUX_GATE(di_clk, "di", de_di_g2d_parents, 0x620,
+				 0, 4,		/* M */
+				 24, 1,		/* mux */
+				 BIT(31),	/* gate */
+				 0);
+
+static SUNXI_CCU_GATE(bus_di_clk, "bus-di", "psi-ahb1-ahb2",
+		      0x62c, BIT(0), 0);
+
+static SUNXI_CCU_M_WITH_MUX_GATE(g2d_clk, "g2d", de_di_g2d_parents, 0x630,
+				 0, 4,		/* M */
+				 24, 1,		/* mux */
+				 BIT(31),	/* gate */
+				 0);
+
+static SUNXI_CCU_GATE(bus_g2d_clk, "bus-g2d", "psi-ahb1-ahb2",
+		      0x63c, BIT(0), 0);
+
+static const char * const gpu_parents[] = { "pll-gpu", "gpu1" };
+static SUNXI_CCU_M_WITH_MUX_GATE(gpu0_clk, "gpu0", gpu_parents, 0x670,
+				       0, 2,	/* M */
+				       24, 1,	/* mux */
+				       BIT(31),	/* gate */
+				       0);
+
+static SUNXI_CCU_M_WITH_GATE(gpu1_clk, "gpu1", "pll-periph0-2x",
+			     0x674, 0, 2, BIT(31), 0);
+
+static SUNXI_CCU_GATE(bus_gpu_clk, "bus-gpu", "psi-ahb1-ahb2",
+		      0x67c, BIT(0), 0);
+
+static const char * const ce_parents[] = { "dcxo24M", "pll-periph0-2x" };
+static SUNXI_CCU_MP_WITH_MUX_GATE(ce_clk, "ce", ce_parents, 0x680,
+				  0, 4,		/* M */
+				  8, 2,		/* P */
+				  24, 1,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_GATE(bus_ce_clk, "bus-ce", "psi-ahb1-ahb2",
+		      0x68c, BIT(0), 0);
+/*
+ * delete the mux because it has only one parent
+ */
+static SUNXI_CCU_M_WITH_GATE(ve_clk, "ve", "pll-ve",
+			     0x690, 0, 3,
+			     BIT(31), CLK_SET_RATE_PARENT);
+
+static SUNXI_CCU_GATE(bus_ve_clk, "bus-ve", "psi-ahb1-ahb2",
+		      0x69c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_dma_clk, "bus-dma", "psi-ahb1-ahb2",
+		      0x70c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_hstimer_clk, "bus-hstimer", "psi-ahb1-ahb2",
+		      0x73c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(avs_clk, "avs", "dcxo24M", 0x740, BIT(31), 0);
+
+static SUNXI_CCU_GATE(bus_dbg_clk, "bus-dbg", "dcxo24M",
+		      0x78c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_psi_clk, "bus-psi", "psi-ahb1-ahb2",
+		      0x79c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_pwm_clk, "bus-pwm", "apb1", 0x7ac, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_iommu_clk, "bus-iommu", "apb1", 0x7bc, BIT(0), 0);
+
+static const char * const dram_parents[] = { "pll-ddr0", "pll-ddr1" };
+static SUNXI_CCU_M_WITH_MUX(dram_clk, "dram", dram_parents,
+			    0x800, 0, 2, 24, 2, CLK_IS_CRITICAL);
+
+static SUNXI_CCU_GATE(mbus_dma_clk, "mbus-dma", "mbus",
+		      0x804, BIT(0), 0);
+static SUNXI_CCU_GATE(mbus_ve_clk, "mbus-ve", "mbus",
+		      0x804, BIT(1), 0);
+static SUNXI_CCU_GATE(mbus_ce_clk, "mbus-ce", "mbus",
+		      0x804, BIT(2), 0);
+static SUNXI_CCU_GATE(mbus_ts_clk, "mbus-ts", "mbus",
+		      0x804, BIT(3), 0);
+static SUNXI_CCU_GATE(mbus_nand_clk, "mbus-nand", "mbus",
+		      0x804, BIT(5), 0);
+static SUNXI_CCU_GATE(mbus_csi_clk, "mbus-csi", "mbus",
+		      0x804, BIT(8), 0);
+static SUNXI_CCU_GATE(mbus_g2d_clk, "mbus-g2d", "mbus",
+		      0x804, BIT(10), 0);
+
+static SUNXI_CCU_GATE(bus_dram_clk, "bus-dram", "psi-ahb1-ahb2",
+		      0x80c, BIT(0), CLK_IS_CRITICAL);
+
+static const char * const nand_spi_parents[] = { "dcxo24M",
+						 "pll-periph0",
+						 "pll-periph1",
+						 "pll-periph0-2x",
+						 "pll-periph1-2x" };
+static SUNXI_CCU_MP_WITH_MUX_GATE(nand0_clk, "nand0", nand_spi_parents, 0x810,
+				  0, 4,		/* M */
+				  8, 2,		/* P */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(nand1_clk, "nand1", nand_spi_parents, 0x814,
+				  0, 4,		/* M */
+				  8, 2,		/* P */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_GATE(bus_nand_clk, "bus-nand", "ahb3", 0x82c, BIT(0), 0);
+
+/* don't use postdiv for bsp kernel */
+static const char * const mmc_parents[] = { "dcxo24M", "pll-periph0-2x",
+					    "pll-periph1-2x" };
+static SUNXI_CCU_MP_WITH_MUX_GATE(mmc0_clk, "mmc0", mmc_parents, 0x830,
+					  0, 4,		/* M */
+					  8, 2,		/* P */
+					  24, 2,	/* mux */
+					  BIT(31),	/* gate */
+					  CLK_SET_RATE_NO_REPARENT);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(mmc1_clk, "mmc1", mmc_parents, 0x834,
+					  0, 4,		/* M */
+					  8, 2,		/* P */
+					  24, 2,	/* mux */
+					  BIT(31),	/* gate */
+					  CLK_SET_RATE_NO_REPARENT);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(mmc2_clk, "mmc2", mmc_parents, 0x838,
+					  0, 4,		/* M */
+					  8, 2,		/* P */
+					  24, 2,	/* mux */
+					  BIT(31),	/* gate */
+					  CLK_SET_RATE_NO_REPARENT);
+
+static SUNXI_CCU_GATE(bus_mmc0_clk, "bus-mmc0", "ahb3", 0x84c, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_mmc1_clk, "bus-mmc1", "ahb3", 0x84c, BIT(1), 0);
+static SUNXI_CCU_GATE(bus_mmc2_clk, "bus-mmc2", "ahb3", 0x84c, BIT(2), 0);
+
+static SUNXI_CCU_GATE(bus_uart0_clk, "bus-uart0", "apb2", 0x90c, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_uart1_clk, "bus-uart1", "apb2", 0x90c, BIT(1), 0);
+static SUNXI_CCU_GATE(bus_uart2_clk, "bus-uart2", "apb2", 0x90c, BIT(2), 0);
+static SUNXI_CCU_GATE(bus_uart3_clk, "bus-uart3", "apb2", 0x90c, BIT(3), 0);
+static SUNXI_CCU_GATE(bus_uart4_clk, "bus-uart4", "apb2", 0x90c, BIT(4), 0);
+static SUNXI_CCU_GATE(bus_uart5_clk, "bus-uart5", "apb2", 0x90c, BIT(5), 0);
+
+static SUNXI_CCU_GATE(bus_i2c0_clk, "bus-i2c0", "apb2", 0x91c, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_i2c1_clk, "bus-i2c1", "apb2", 0x91c, BIT(1), 0);
+static SUNXI_CCU_GATE(bus_i2c2_clk, "bus-i2c2", "apb2", 0x91c, BIT(2), 0);
+static SUNXI_CCU_GATE(bus_i2c3_clk, "bus-i2c3", "apb2", 0x91c, BIT(3), 0);
+static SUNXI_CCU_GATE(bus_i2c4_clk, "bus-i2c4", "apb2", 0x91c, BIT(4), 0);
+
+static SUNXI_CCU_GATE(bus_scr_clk, "bus-scr", "apb2", 0x93c, BIT(0), 0);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(spi0_clk, "spi0", nand_spi_parents, 0x940,
+				  0, 4,		/* M */
+				  8, 2,		/* P */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(spi1_clk, "spi1", nand_spi_parents, 0x944,
+				  0, 4,		/* M */
+				  8, 2,		/* P */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_GATE(bus_spi0_clk, "bus-spi0", "ahb3", 0x96c, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_spi1_clk, "bus-spi1", "ahb3", 0x96c, BIT(1), 0);
+
+static SUNXI_CCU_GATE(emac_25m_clk, "emac0-25m", "ahb3", 0x970,
+		      BIT(31) | BIT(30), 0);
+
+static SUNXI_CCU_GATE(bus_emac0_clk, "bus-emac0", "ahb3", 0x97c, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_emac1_clk, "bus-emac1", "ahb3", 0x97c, BIT(1), 0);
+
+static const char * const ts_parents[] = { "dcxo24M", "pll-periph0" };
+static SUNXI_CCU_MP_WITH_MUX_GATE(ts_clk, "ts", ts_parents, 0x9b0,
+				  0, 4,		/* M */
+				  8, 2,		/* P */
+				  24, 1,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_GATE(bus_ts_clk, "bus-ts", "ahb3", 0x9bc, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_gpadc_clk, "bus-gpadc", "dcxo24M", 0x9ec, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_ths_clk, "bus-ths", "dcxo24M", 0x9fc, BIT(0), 0);
+
+/*
+ * No one uses the pll-audio-hs, we do not support this clock.
+ */
+static const char * const audio_parents[] = { "pll-audio", "pll-audio-2x",
+					      "pll-audio-4x" };
+static struct ccu_div spdif_clk = {
+	.enable		= BIT(31),
+	.div		= _SUNXI_CCU_DIV_FLAGS(8, 2, CLK_DIVIDER_POWER_OF_TWO),
+	.mux		= _SUNXI_CCU_MUX(24, 2),
+	.common		= {
+		.reg		= 0xa20,
+		.hw.init	= CLK_HW_INIT_PARENTS("spdif",
+						      audio_parents,
+						      &ccu_div_ops,
+						      0),
+	},
+};
+
+static SUNXI_CCU_GATE(bus_spdif_clk, "bus-spdif", "apb1", 0xa2c, BIT(0), 0);
+
+static struct ccu_div dmic_clk = {
+	.enable		= BIT(31),
+	.div		= _SUNXI_CCU_DIV_FLAGS(8, 2, CLK_DIVIDER_POWER_OF_TWO),
+	.mux		= _SUNXI_CCU_MUX(24, 2),
+	.common		= {
+		.reg		= 0xa40,
+		.hw.init	= CLK_HW_INIT_PARENTS("dmic",
+						      audio_parents,
+						      &ccu_div_ops,
+						      0),
+	},
+};
+
+static SUNXI_CCU_GATE(bus_dmic_clk, "bus-dmic", "apb1", 0xa4c, BIT(0), 0);
+
+static SUNXI_CCU_M_WITH_MUX_GATE(audio_codec_clk, "audio-codec",
+				 audio_parents, 0xa50,
+				 0, 4,		/* M */
+				 24, 2,		/* mux */
+				 BIT(31),	/* gate */
+				 0);
+
+static SUNXI_CCU_M_WITH_MUX_GATE(audio_codec_4x_clk, "audio-codec-4x",
+				 audio_parents, 0xa54,
+				 0, 4,		/* M */
+				 24, 2,		/* mux */
+				 BIT(31),	/* gate */
+				 0);
+
+static SUNXI_CCU_GATE(bus_audio_codec_clk, "bus-audio-codec", "apb1",
+		      0xa5c, BIT(0), 0);
+
+static struct ccu_div audio_hub_clk = {
+	.enable		= BIT(31),
+	.div		= _SUNXI_CCU_DIV_FLAGS(8, 2, CLK_DIVIDER_POWER_OF_TWO),
+	.mux		= _SUNXI_CCU_MUX(24, 2),
+	.common		= {
+		.reg		= 0xa60,
+		.hw.init	= CLK_HW_INIT_PARENTS("audio-hub",
+						      audio_parents,
+						      &ccu_div_ops,
+						      0),
+	},
+};
+
+static SUNXI_CCU_GATE(bus_audio_hub_clk, "bus-audio-hub", "apb1",
+		      0xa6c, BIT(0), 0);
+
+/*
+ * There are OHCI 12M clock source selection bits for 2 USB 2.0 ports.
+ * We will force them to 0 (12M divided from 48M).
+ */
+#define SUN50IW9_USB0_CLK_REG		0xa70
+#define SUN50IW9_USB1_CLK_REG		0xa74
+#define SUN50IW9_USB2_CLK_REG		0xa78
+#define SUN50IW9_USB3_CLK_REG		0xa7c
+
+static SUNXI_CCU_GATE(usb_ohci0_clk, "usb-ohci0", "osc12M", 0xa70, BIT(31), 0);
+static SUNXI_CCU_GATE(usb_phy0_clk, "usb-phy0", "dcxo24M", 0xa70, BIT(29), 0);
+
+static SUNXI_CCU_GATE(usb_ohci1_clk, "usb-ohci1", "osc12M", 0xa74, BIT(31), 0);
+static SUNXI_CCU_GATE(usb_phy1_clk, "usb-phy1", "dcxo24M", 0xa74, BIT(29), 0);
+
+static SUNXI_CCU_GATE(usb_ohci2_clk, "usb-ohci2", "osc12M", 0xa78, BIT(31), 0);
+static SUNXI_CCU_GATE(usb_phy2_clk, "usb-phy2", "dcxo24M", 0xa78, BIT(29), 0);
+
+static SUNXI_CCU_GATE(usb_ohci3_clk, "usb-ohci3", "osc12M", 0xa7c, BIT(31), 0);
+static SUNXI_CCU_GATE(usb_phy3_clk, "usb-phy3", "dcxo24M", 0xa7c, BIT(29), 0);
+
+static SUNXI_CCU_GATE(bus_ohci0_clk, "bus-ohci0", "ahb3", 0xa8c, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_ohci1_clk, "bus-ohci1", "ahb3", 0xa8c, BIT(1), 0);
+static SUNXI_CCU_GATE(bus_ohci2_clk, "bus-ohci2", "ahb3", 0xa8c, BIT(2), 0);
+static SUNXI_CCU_GATE(bus_ohci3_clk, "bus-ohci3", "ahb3", 0xa8c, BIT(3), 0);
+static SUNXI_CCU_GATE(bus_ehci0_clk, "bus-ehci0", "ahb3", 0xa8c, BIT(4), 0);
+static SUNXI_CCU_GATE(bus_ehci1_clk, "bus-ehci1", "ahb3", 0xa8c, BIT(5), 0);
+static SUNXI_CCU_GATE(bus_ehci2_clk, "bus-ehci2", "ahb3", 0xa8c, BIT(6), 0);
+static SUNXI_CCU_GATE(bus_ehci3_clk, "bus-ehci3", "ahb3", 0xa8c, BIT(7), 0);
+static SUNXI_CCU_GATE(bus_otg_clk, "bus-otg", "ahb3", 0xa8c, BIT(8), 0);
+
+static SUNXI_CCU_GATE(bus_lradc_clk, "bus-lradc", "ahb3", 0xa9c, BIT(0), 0);
+
+static const char * const hdmi_parents[] = { "pll-video0", "pll-video0-4x",
+					     "pll-video2", "pll-video2-4x" };
+static SUNXI_CCU_M_WITH_MUX_GATE(hdmi_clk, "hdmi", hdmi_parents, 0xb00,
+				 0, 4,		/* M */
+				 24, 2,		/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_NO_REPARENT);
+
+static SUNXI_CCU_GATE(hdmi_slow_clk, "hdmi-slow", "dcxo24M", 0xb04, BIT(31), 0);
+
+static struct ccu_gate pll_periph0_2x_div_clk = {
+	.enable	= BIT(30),
+	.common	= {
+		.reg		= 0xb10,
+		.prediv		= 36621,
+		.features	= CCU_FEATURE_ALL_PREDIV,
+		.hw.init	= CLK_HW_INIT("pll-periph0-2x-div",
+					      "pll-periph0-2x",
+					      &ccu_gate_ops, 0),
+	}
+};
+
+static const char * const hdmi_cec_parents[] = { "osc32k",
+						 "pll-periph0-2x-div" };
+static SUNXI_CCU_MUX_WITH_GATE(hdmi_cec_clk, "hdmi-cec", hdmi_cec_parents,
+			       0xb10, 24, 2,  BIT(31), 0);
+
+static SUNXI_CCU_GATE(bus_hdmi_clk, "bus-hdmi", "ahb3", 0xb1c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_display_if_top_clk, "bus-display-if-top", "ahb3",
+		      0xb5c, BIT(0), 0);
+
+static const char * const video_parents[] = { "pll-video0", "pll-video0-4x",
+					      "pll-video1", "pll-video1-4x" };
+static SUNXI_CCU_MUX_WITH_GATE(tcon_lcd0_clk, "tcon-lcd0", video_parents,
+			       0xb60, 24, 3,  BIT(31), CLK_SET_RATE_PARENT);
+
+static SUNXI_CCU_MUX_WITH_GATE(tcon_lcd1_clk, "tcon-lcd1", video_parents,
+			       0xb64, 24, 3,  BIT(31), CLK_SET_RATE_PARENT);
+
+static SUNXI_CCU_GATE(bus_tcon_lcd0_clk, "bus-tcon-lcd0", "ahb3",
+		      0xb7c, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_tcon_lcd1_clk, "bus-tcon-lcd1", "ahb3",
+		      0xb7c, BIT(1), 0);
+
+/*
+ * "pll-video2", "pll-video2-4x" undocemented.
+ */
+static const char * const tcon_tv_parents[] = { "pll-video0",
+						"pll-video0-4x",
+						"pll-video1",
+						"pll-video1-4x",
+						"pll-video2",
+						"pll-video2-4x" };
+static SUNXI_CCU_MP_WITH_MUX_GATE(tcon_tv0_clk, "tcon-tv0",
+				  tcon_tv_parents, 0xb80,
+				  0, 4,		/* M */
+				  8, 2,		/* P */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  CLK_SET_RATE_NO_REPARENT);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(tcon_tv1_clk, "tcon-tv1",
+				  tcon_tv_parents, 0xb84,
+				  0, 4,		/* M */
+				  8, 2,		/* P */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_GATE(bus_tcon_tv0_clk, "bus-tcon-tv0", "ahb3",
+		      0xb9c, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_tcon_tv1_clk, "bus-tcon-tv1", "ahb3",
+		      0xb9c, BIT(1), 0);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(tve_clk, "tve", video_parents, 0xbb0,
+				  0, 4,		/* M */
+				  8, 2,		/* P */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_GATE(bus_tve_clk, "bus-tve", "ahb3", 0xbbc, BIT(1), 0);
+
+static SUNXI_CCU_GATE(bus_tve_top_clk, "bus-tve-top", "ahb3",
+		      0xbbc, BIT(0), 0);
+
+static const char * const csi_top_parents[] = { "pll-video0", "pll-ve",
+						"pll-periph0", "pll-csi" };
+static const u8 csi_top_table[] = { 0, 2, 3, 4 };
+
+static SUNXI_CCU_M_WITH_MUX_TABLE_GATE(csi_top_clk, "csi-top",
+				       csi_top_parents, csi_top_table,
+				       0xc04, 0, 4,
+				       24, 3,
+				       BIT(31), 0);
+
+static const char * const csi_mclk_parents[] = { "dcxo24M", "pll-video0",
+						 "pll-periph0-2x",
+						 "pll-periph1", "pll-csi"};
+static const u8 csi_mclk_table[] = { 0, 1, 2, 3, 5};
+
+static SUNXI_CCU_M_WITH_MUX_TABLE_GATE(csi0_mclk_clk, "csi-mclk0",
+				       csi_mclk_parents, csi_mclk_table,
+				       0xc08, 0, 5,
+				       24, 3,
+				       BIT(31), 0);
+
+static SUNXI_CCU_M_WITH_MUX_TABLE_GATE(csi1_mclk_clk, "csi-mclk1",
+				       csi_mclk_parents, csi_mclk_table,
+				       0xc0c, 0, 5,
+				       24, 3,
+				       BIT(31), 0);
+
+static SUNXI_CCU_GATE(bus_csi_clk, "bus-csi", "ahb3", 0xc2c, BIT(0), 0);
+
+static const char * const hdmi_hdcp_parents[] = { "pll-periph0",
+						  "pll-periph1" };
+static SUNXI_CCU_M_WITH_MUX_GATE(hdmi_hdcp_clk, "hdmi-hdcp",
+				 hdmi_hdcp_parents, 0xc40,
+				 0, 4,		/* M */
+				 24, 2,		/* mux */
+				 BIT(31),	/* gate */
+				 0);
+
+
+static SUNXI_CCU_GATE(bus_hdmi_hdcp_clk, "bus-hdmi-hdcp", "ahb3",
+		      0xc4c, BIT(0), 0);
+
+/* Fixed factor clocks */
+static CLK_FIXED_FACTOR_FW_NAME(osc12M_clk, "osc12M", "hosc", 2, 1, 0);
+
+static const struct clk_hw *clk_parent_pll_audio[] = {
+	&pll_audio_4x_clk.common.hw
+};
+
+static CLK_FIXED_FACTOR_HWS(pll_audio_clk, "pll-audio",
+			    clk_parent_pll_audio,
+			    4, 1, CLK_SET_RATE_PARENT);
+static CLK_FIXED_FACTOR_HWS(pll_audio_2x_clk, "pll-audio-2x",
+			    clk_parent_pll_audio,
+			    2, 1, CLK_SET_RATE_PARENT);
+
+static CLK_FIXED_FACTOR_HW(pll_periph0_2x_clk, "pll-periph0-2x",
+			   &pll_periph0_clk.common.hw,
+			   1, 2, 0);
+
+static CLK_FIXED_FACTOR_HW(pll_periph1_2x_clk, "pll-periph1-2x",
+			   &pll_periph1_clk.common.hw,
+			   1, 2, 0);
+
+static CLK_FIXED_FACTOR_HW(pll_video0_4x_clk, "pll-video0-4x",
+			   &pll_video0_clk.common.hw,
+			   1, 4, CLK_SET_RATE_PARENT);
+static CLK_FIXED_FACTOR_HW(pll_video1_4x_clk, "pll-video1-4x",
+			   &pll_video1_clk.common.hw,
+			   1, 4, CLK_SET_RATE_PARENT);
+static CLK_FIXED_FACTOR_HW(pll_video2_4x_clk, "pll-video2-4x",
+			   &pll_video2_clk.common.hw,
+			   1, 4, CLK_SET_RATE_PARENT);
+
+static struct ccu_common *sun50iw9_ccu_clks[] = {
+	&pll_cpux_clk.common,
+	&pll_ddr0_clk.common,
+	&pll_ddr1_clk.common,
+	&pll_periph0_clk.common,
+	&pll_periph1_pattern0_common, /* for pm resume */
+	&pll_periph1_clk.common,
+	&pll_gpu_clk.common,
+	&pll_video0_clk.common,
+	&pll_video1_clk.common,
+	&pll_video2_clk.common,
+	&pll_ve_clk.common,
+	&pll_de_clk.common,
+	&pll_audio_4x_clk.common,
+	&pll_csi_clk.common,
+	&cpux_clk.common,
+	&axi_clk.common,
+	&cpux_apb_clk.common,
+	&psi_ahb1_ahb2_clk.common,
+	&ahb3_clk.common,
+	&apb1_clk.common,
+	&apb2_clk.common,
+	&mbus_clk.common,
+	&de_clk.common,
+	&bus_de_clk.common,
+	&di_clk.common,
+	&bus_di_clk.common,
+	&g2d_clk.common,
+	&bus_g2d_clk.common,
+	&gpu0_clk.common,
+	&gpu1_clk.common,
+	&bus_gpu_clk.common,
+	&ce_clk.common,
+	&bus_ce_clk.common,
+	&ve_clk.common,
+	&bus_ve_clk.common,
+	&bus_dma_clk.common,
+	&bus_hstimer_clk.common,
+	&avs_clk.common,
+	&bus_dbg_clk.common,
+	&bus_psi_clk.common,
+	&bus_pwm_clk.common,
+	&bus_iommu_clk.common,
+	&dram_clk.common,
+	&mbus_dma_clk.common,
+	&mbus_ve_clk.common,
+	&mbus_ce_clk.common,
+	&mbus_ts_clk.common,
+	&mbus_nand_clk.common,
+	&mbus_csi_clk.common,
+	&mbus_g2d_clk.common,
+	&bus_dram_clk.common,
+	&nand0_clk.common,
+	&nand1_clk.common,
+	&bus_nand_clk.common,
+	&mmc0_clk.common,
+	&mmc1_clk.common,
+	&mmc2_clk.common,
+	&bus_mmc0_clk.common,
+	&bus_mmc1_clk.common,
+	&bus_mmc2_clk.common,
+	&bus_uart0_clk.common,
+	&bus_uart1_clk.common,
+	&bus_uart2_clk.common,
+	&bus_uart3_clk.common,
+	&bus_uart4_clk.common,
+	&bus_uart5_clk.common,
+	&bus_i2c0_clk.common,
+	&bus_i2c1_clk.common,
+	&bus_i2c2_clk.common,
+	&bus_i2c3_clk.common,
+	&bus_i2c4_clk.common,
+	&bus_scr_clk.common,
+	&spi0_clk.common,
+	&spi1_clk.common,
+	&bus_spi0_clk.common,
+	&bus_spi1_clk.common,
+	&emac_25m_clk.common,
+	&bus_emac0_clk.common,
+	&bus_emac1_clk.common,
+	&ts_clk.common,
+	&bus_ts_clk.common,
+	&bus_gpadc_clk.common,
+	&bus_ths_clk.common,
+	&spdif_clk.common,
+	&bus_spdif_clk.common,
+	&dmic_clk.common,
+	&bus_dmic_clk.common,
+	&audio_codec_clk.common,
+	&audio_codec_4x_clk.common,
+	&bus_audio_codec_clk.common,
+	&audio_hub_clk.common,
+	&bus_audio_hub_clk.common,
+	&usb_ohci0_clk.common,
+	&usb_phy0_clk.common,
+	&usb_ohci1_clk.common,
+	&usb_phy1_clk.common,
+	&usb_ohci2_clk.common,
+	&usb_phy2_clk.common,
+	&usb_ohci3_clk.common,
+	&usb_phy3_clk.common,
+	&bus_ohci0_clk.common,
+	&bus_ohci1_clk.common,
+	&bus_ohci2_clk.common,
+	&bus_ohci3_clk.common,
+	&bus_ehci0_clk.common,
+	&bus_ehci1_clk.common,
+	&bus_ehci2_clk.common,
+	&bus_ehci3_clk.common,
+	&bus_otg_clk.common,
+	&bus_lradc_clk.common,
+	&hdmi_clk.common,
+	&hdmi_slow_clk.common,
+	&pll_periph0_2x_div_clk.common,
+	&hdmi_cec_clk.common,
+	&bus_hdmi_clk.common,
+	&bus_display_if_top_clk.common,
+	&tcon_lcd0_clk.common,
+	&tcon_lcd1_clk.common,
+	&bus_tcon_lcd0_clk.common,
+	&bus_tcon_lcd1_clk.common,
+	&tcon_tv0_clk.common,
+	&tcon_tv1_clk.common,
+	&bus_tcon_tv0_clk.common,
+	&bus_tcon_tv1_clk.common,
+	&tve_clk.common,
+	&bus_tve_clk.common,
+	&bus_tve_top_clk.common,
+	&csi_top_clk.common,
+	&csi0_mclk_clk.common,
+	&csi1_mclk_clk.common,
+	&bus_csi_clk.common,
+	&hdmi_hdcp_clk.common,
+	&bus_hdmi_hdcp_clk.common,
+};
+
+static struct clk_hw_onecell_data sun50iw9_hw_clks = {
+	.hws	= {
+		[CLK_OSC12M]		= &osc12M_clk.hw,
+		[CLK_PLL_CPUX]		= &pll_cpux_clk.common.hw,
+		[CLK_PLL_DDR0]		= &pll_ddr0_clk.common.hw,
+		[CLK_PLL_DDR1]		= &pll_ddr1_clk.common.hw,
+		[CLK_PLL_PERIPH0]	= &pll_periph0_clk.common.hw,
+		[CLK_PLL_PERIPH0_2X]	= &pll_periph0_2x_clk.hw,
+		[CLK_PLL_PERIPH1]	= &pll_periph1_clk.common.hw,
+		[CLK_PLL_PERIPH1_2X]	= &pll_periph1_2x_clk.hw,
+		[CLK_PLL_GPU]		= &pll_gpu_clk.common.hw,
+		[CLK_PLL_VIDEO0]	= &pll_video0_clk.common.hw,
+		[CLK_PLL_VIDEO0_4X]	= &pll_video0_4x_clk.hw,
+		[CLK_PLL_VIDEO1]	= &pll_video1_clk.common.hw,
+		[CLK_PLL_VIDEO1_4X]	= &pll_video1_4x_clk.hw,
+		[CLK_PLL_VIDEO2]	= &pll_video2_clk.common.hw,
+		[CLK_PLL_VIDEO2_4X]	= &pll_video2_4x_clk.hw,
+		[CLK_PLL_VE]		= &pll_ve_clk.common.hw,
+		[CLK_PLL_DE]		= &pll_de_clk.common.hw,
+		[CLK_PLL_AUDIO]		= &pll_audio_clk.hw,
+		[CLK_PLL_AUDIO_2X]	= &pll_audio_2x_clk.hw,
+		[CLK_PLL_AUDIO_4X]	= &pll_audio_4x_clk.common.hw,
+		[CLK_PLL_CSI]		= &pll_csi_clk.common.hw,
+		[CLK_CPUX]		= &cpux_clk.common.hw,
+		[CLK_AXI]		= &axi_clk.common.hw,
+		[CLK_CPUX_APB]		= &cpux_apb_clk.common.hw,
+		[CLK_PSI_AHB1_AHB2]	= &psi_ahb1_ahb2_clk.common.hw,
+		[CLK_AHB3]		= &ahb3_clk.common.hw,
+		[CLK_APB1]		= &apb1_clk.common.hw,
+		[CLK_APB2]		= &apb2_clk.common.hw,
+		[CLK_MBUS]		= &mbus_clk.common.hw,
+		[CLK_DE]		= &de_clk.common.hw,
+		[CLK_BUS_DE]		= &bus_de_clk.common.hw,
+		[CLK_DI]		= &di_clk.common.hw,
+		[CLK_BUS_DI]		= &bus_di_clk.common.hw,
+		[CLK_G2D]		= &g2d_clk.common.hw,
+		[CLK_BUS_G2D]		= &bus_g2d_clk.common.hw,
+		[CLK_GPU0]		= &gpu0_clk.common.hw,
+		[CLK_GPU1]		= &gpu1_clk.common.hw,
+		[CLK_BUS_GPU]		= &bus_gpu_clk.common.hw,
+		[CLK_CE]		= &ce_clk.common.hw,
+		[CLK_BUS_CE]		= &bus_ce_clk.common.hw,
+		[CLK_VE]		= &ve_clk.common.hw,
+		[CLK_BUS_VE]		= &bus_ve_clk.common.hw,
+		[CLK_BUS_DMA]		= &bus_dma_clk.common.hw,
+		[CLK_BUS_HSTIMER]	= &bus_hstimer_clk.common.hw,
+		[CLK_AVS]		= &avs_clk.common.hw,
+		[CLK_BUS_DBG]		= &bus_dbg_clk.common.hw,
+		[CLK_BUS_PSI]		= &bus_psi_clk.common.hw,
+		[CLK_BUS_PWM]		= &bus_pwm_clk.common.hw,
+		[CLK_BUS_IOMMU]		= &bus_iommu_clk.common.hw,
+		[CLK_DRAM]		= &dram_clk.common.hw,
+		[CLK_MBUS_DMA]		= &mbus_dma_clk.common.hw,
+		[CLK_MBUS_VE]		= &mbus_ve_clk.common.hw,
+		[CLK_MBUS_CE]		= &mbus_ce_clk.common.hw,
+		[CLK_MBUS_TS]		= &mbus_ts_clk.common.hw,
+		[CLK_MBUS_NAND]		= &mbus_nand_clk.common.hw,
+		[CLK_MBUS_CSI]		= &mbus_csi_clk.common.hw,
+		[CLK_MBUS_G2D]		= &mbus_g2d_clk.common.hw,
+		[CLK_BUS_DRAM]		= &bus_dram_clk.common.hw,
+		[CLK_NAND0]		= &nand0_clk.common.hw,
+		[CLK_NAND1]		= &nand1_clk.common.hw,
+		[CLK_BUS_NAND]		= &bus_nand_clk.common.hw,
+		[CLK_MMC0]		= &mmc0_clk.common.hw,
+		[CLK_MMC1]		= &mmc1_clk.common.hw,
+		[CLK_MMC2]		= &mmc2_clk.common.hw,
+		[CLK_BUS_MMC0]		= &bus_mmc0_clk.common.hw,
+		[CLK_BUS_MMC1]		= &bus_mmc1_clk.common.hw,
+		[CLK_BUS_MMC2]		= &bus_mmc2_clk.common.hw,
+		[CLK_BUS_UART0]		= &bus_uart0_clk.common.hw,
+		[CLK_BUS_UART1]		= &bus_uart1_clk.common.hw,
+		[CLK_BUS_UART2]		= &bus_uart2_clk.common.hw,
+		[CLK_BUS_UART3]		= &bus_uart3_clk.common.hw,
+		[CLK_BUS_UART4]		= &bus_uart4_clk.common.hw,
+		[CLK_BUS_UART5]		= &bus_uart5_clk.common.hw,
+		[CLK_BUS_I2C0]		= &bus_i2c0_clk.common.hw,
+		[CLK_BUS_I2C1]		= &bus_i2c1_clk.common.hw,
+		[CLK_BUS_I2C2]		= &bus_i2c2_clk.common.hw,
+		[CLK_BUS_I2C3]		= &bus_i2c3_clk.common.hw,
+		[CLK_BUS_I2C4]		= &bus_i2c4_clk.common.hw,
+		[CLK_BUS_SCR]		= &bus_scr_clk.common.hw,
+		[CLK_SPI0]		= &spi0_clk.common.hw,
+		[CLK_SPI1]		= &spi1_clk.common.hw,
+		[CLK_BUS_SPI0]		= &bus_spi0_clk.common.hw,
+		[CLK_BUS_SPI1]		= &bus_spi1_clk.common.hw,
+		[CLK_EMAC_25M]		= &emac_25m_clk.common.hw,
+		[CLK_BUS_EMAC0]		= &bus_emac0_clk.common.hw,
+		[CLK_BUS_EMAC1]		= &bus_emac1_clk.common.hw,
+		[CLK_TS]		= &ts_clk.common.hw,
+		[CLK_BUS_TS]		= &bus_ts_clk.common.hw,
+		[CLK_BUS_GPADC]		= &bus_gpadc_clk.common.hw,
+		[CLK_BUS_THS]		= &bus_ths_clk.common.hw,
+		[CLK_SPDIF]		= &spdif_clk.common.hw,
+		[CLK_BUS_SPDIF]		= &bus_spdif_clk.common.hw,
+		[CLK_DMIC]		= &dmic_clk.common.hw,
+		[CLK_BUS_DMIC]		= &bus_dmic_clk.common.hw,
+		[CLK_AUDIO]		= &audio_codec_clk.common.hw,
+		[CLK_AUDIO_4X]		= &audio_codec_4x_clk.common.hw,
+		[CLK_BUS_AUDIO_CODEC]	= &bus_audio_codec_clk.common.hw,
+		[CLK_AUDIO_HUB]		= &audio_hub_clk.common.hw,
+		[CLK_BUS_AUDIO_HUB]	= &bus_audio_hub_clk.common.hw,
+		[CLK_USB_OHCI0]		= &usb_ohci0_clk.common.hw,
+		[CLK_USB_PHY0]		= &usb_phy0_clk.common.hw,
+		[CLK_USB_OHCI1]		= &usb_ohci1_clk.common.hw,
+		[CLK_USB_PHY1]		= &usb_phy1_clk.common.hw,
+		[CLK_USB_OHCI2]		= &usb_ohci2_clk.common.hw,
+		[CLK_USB_PHY2]		= &usb_phy2_clk.common.hw,
+		[CLK_USB_OHCI3]		= &usb_ohci3_clk.common.hw,
+		[CLK_USB_PHY3]		= &usb_phy3_clk.common.hw,
+		[CLK_BUS_OHCI0]		= &bus_ohci0_clk.common.hw,
+		[CLK_BUS_OHCI1]		= &bus_ohci1_clk.common.hw,
+		[CLK_BUS_OHCI2]		= &bus_ohci2_clk.common.hw,
+		[CLK_BUS_OHCI3]		= &bus_ohci3_clk.common.hw,
+		[CLK_BUS_EHCI0]		= &bus_ehci0_clk.common.hw,
+		[CLK_BUS_EHCI1]		= &bus_ehci1_clk.common.hw,
+		[CLK_BUS_EHCI2]		= &bus_ehci2_clk.common.hw,
+		[CLK_BUS_EHCI3]		= &bus_ehci3_clk.common.hw,
+		[CLK_BUS_OTG]		= &bus_otg_clk.common.hw,
+		[CLK_BUS_LRADC]		= &bus_lradc_clk.common.hw,
+		[CLK_HDMI]		= &hdmi_clk.common.hw,
+		[CLK_HDMI_SLOW]		= &hdmi_slow_clk.common.hw,
+		[CLK_PLL_PERIPH0_2X_DIV] = &pll_periph0_2x_div_clk.common.hw,
+		[CLK_HDMI_CEC]		= &hdmi_cec_clk.common.hw,
+		[CLK_BUS_HDMI]		= &bus_hdmi_clk.common.hw,
+		[CLK_BUS_DISPLAY_IF_TOP] = &bus_display_if_top_clk.common.hw,
+		[CLK_TCON_LCD0]		= &tcon_lcd0_clk.common.hw,
+		[CLK_TCON_LCD1]		= &tcon_lcd1_clk.common.hw,
+		[CLK_BUS_TCON_LCD0]	= &bus_tcon_lcd0_clk.common.hw,
+		[CLK_BUS_TCON_LCD1]	= &bus_tcon_lcd1_clk.common.hw,
+		[CLK_TCON_TV0]		= &tcon_tv0_clk.common.hw,
+		[CLK_TCON_TV1]		= &tcon_tv1_clk.common.hw,
+		[CLK_BUS_TCON_TV0]	= &bus_tcon_tv0_clk.common.hw,
+		[CLK_BUS_TCON_TV1]	= &bus_tcon_tv1_clk.common.hw,
+		[CLK_TVE]		= &tve_clk.common.hw,
+		[CLK_BUS_TVE]		= &bus_tve_clk.common.hw,
+		[CLK_BUS_TVE_TOP]	= &bus_tve_top_clk.common.hw,
+		[CLK_CSI_TOP]		= &csi_top_clk.common.hw,
+		[CLK_CSI0_MCLK]		= &csi0_mclk_clk.common.hw,
+		[CLK_CSI1_MCLK]		= &csi1_mclk_clk.common.hw,
+		[CLK_BUS_CSI]		= &bus_csi_clk.common.hw,
+		[CLK_HDMI_HDCP]		= &hdmi_hdcp_clk.common.hw,
+		[CLK_BUS_HDMI_HDCP]	= &bus_hdmi_hdcp_clk.common.hw,
+	},
+	.num = CLK_NUMBER,
+};
+
+static struct ccu_reset_map sun50iw9_ccu_resets[] = {
+	[RST_MBUS]		= { 0x540, BIT(30) },
+
+	[RST_BUS_DE]		= { 0x60c, BIT(16) },
+	[RST_BUS_DI]		= { 0x62c, BIT(16) },
+	[RST_BUS_G2D]		= { 0x63c, BIT(16) },
+	[RST_BUS_GPU]		= { 0x67c, BIT(16) },
+	[RST_BUS_CE]		= { 0x68c, BIT(16) },
+	[RST_BUS_VE]		= { 0x69c, BIT(16) },
+	[RST_BUS_DMA]		= { 0x70c, BIT(16) },
+	[RST_BUS_HSTIMER]	= { 0x73c, BIT(16) },
+	[RST_BUS_DBG]		= { 0x78c, BIT(16) },
+	[RST_BUS_PSI]		= { 0x79c, BIT(16) },
+	[RST_BUS_PWM]		= { 0x7ac, BIT(16) },
+	[RST_BUS_DRAM]		= { 0x80c, BIT(16) },
+	[RST_BUS_NAND]		= { 0x82c, BIT(16) },
+	[RST_BUS_MMC0]		= { 0x84c, BIT(16) },
+	[RST_BUS_MMC1]		= { 0x84c, BIT(17) },
+	[RST_BUS_MMC2]		= { 0x84c, BIT(18) },
+	[RST_BUS_UART0]		= { 0x90c, BIT(16) },
+	[RST_BUS_UART1]		= { 0x90c, BIT(17) },
+	[RST_BUS_UART2]		= { 0x90c, BIT(18) },
+	[RST_BUS_UART3]		= { 0x90c, BIT(19) },
+	[RST_BUS_UART4]		= { 0x90c, BIT(20) },
+	[RST_BUS_UART5]		= { 0x90c, BIT(21) },
+	[RST_BUS_I2C0]		= { 0x91c, BIT(16) },
+	[RST_BUS_I2C1]		= { 0x91c, BIT(17) },
+	[RST_BUS_I2C2]		= { 0x91c, BIT(18) },
+	[RST_BUS_I2C3]		= { 0x91c, BIT(19) },
+	[RST_BUS_I2C4]		= { 0x91c, BIT(20) },
+	[RST_BUS_SCR]		= { 0x93c, BIT(16) },
+	[RST_BUS_SPI0]		= { 0x96c, BIT(16) },
+	[RST_BUS_SPI1]		= { 0x96c, BIT(17) },
+	[RST_BUS_EMAC0]		= { 0x97c, BIT(16) },
+	[RST_BUS_EMAC1]		= { 0x97c, BIT(17) },
+	[RST_BUS_TS]		= { 0x9bc, BIT(16) },
+	[RST_BUS_GPADC]		= { 0x9ec, BIT(16) },
+	[RST_BUS_THS]		= { 0x9fc, BIT(16) },
+	[RST_BUS_SPDIF]		= { 0xa2c, BIT(16) },
+	[RST_BUS_DMIC]		= { 0xa4c, BIT(16) },
+	[RST_BUS_AUDIO_CODEC]	= { 0xa5c, BIT(16) },
+	[RST_BUS_AUDIO_HUB]	= { 0xa6c, BIT(16) },
+
+	[RST_USB_PHY0]		= { 0xa70, BIT(30) },
+	[RST_USB_PHY1]		= { 0xa74, BIT(30) },
+	[RST_USB_PHY2]		= { 0xa78, BIT(30) },
+	[RST_USB_PHY3]		= { 0xa7c, BIT(30) },
+
+	[RST_BUS_OHCI0]		= { 0xa8c, BIT(16) },
+	[RST_BUS_OHCI1]		= { 0xa8c, BIT(17) },
+	[RST_BUS_OHCI2]		= { 0xa8c, BIT(18) },
+	[RST_BUS_OHCI3]		= { 0xa8c, BIT(19) },
+	[RST_BUS_EHCI0]		= { 0xa8c, BIT(20) },
+	[RST_BUS_EHCI1]		= { 0xa8c, BIT(21) },
+	[RST_BUS_EHCI2]		= { 0xa8c, BIT(22) },
+	[RST_BUS_EHCI3]		= { 0xa8c, BIT(23) },
+	[RST_BUS_OTG]		= { 0xa8c, BIT(24) },
+
+	[RST_BUS_LRADC]		= { 0xa9c, BIT(16) },
+	[RST_BUS_HDMI_MAIN]	= { 0xb1c, BIT(16) },
+	[RST_BUS_HDMI_SUB]	= { 0xb1c, BIT(17) },
+	[RST_BUS_DISPLAY_IF_TOP] = { 0xb5c, BIT(16) },
+	[RST_BUS_TCON_LCD0]	= { 0xb7c, BIT(16) },
+	[RST_BUS_TCON_LCD1]	= { 0xb7c, BIT(17) },
+	[RST_BUS_TCON_TV0]	= { 0xb9c, BIT(16) },
+	[RST_BUS_TCON_TV1]	= { 0xb9c, BIT(17) },
+	[RST_BUS_LVDS]		= { 0xbac, BIT(16) },
+	[RST_BUS_TVE_TOP]	= { 0xbbc, BIT(16) },
+	[RST_BUS_TVE]		= { 0xbbc, BIT(17) },
+	[RST_BUS_CSI]		= { 0xc2c, BIT(16) },
+	[RST_BUS_HDMI_HDCP]	= { 0xc4c, BIT(16) },
+};
+
+static const struct sunxi_ccu_desc sun50iw9_ccu_desc = {
+	.ccu_clks	= sun50iw9_ccu_clks,
+	.num_ccu_clks	= ARRAY_SIZE(sun50iw9_ccu_clks),
+
+	.hw_clks	= &sun50iw9_hw_clks,
+
+	.resets		= sun50iw9_ccu_resets,
+	.num_resets	= ARRAY_SIZE(sun50iw9_ccu_resets),
+};
+
+static const u32 sun50iw9_pll_regs[] = {
+	SUN50IW9_PLL_CPUX_REG,
+	SUN50IW9_PLL_DDR0_REG,
+	SUN50IW9_PLL_DDR1_REG,
+	SUN50IW9_PLL_PERIPH0_REG,
+	SUN50IW9_PLL_PERIPH1_REG,
+	SUN50IW9_PLL_GPU_REG,
+	SUN50IW9_PLL_VIDEO0_REG,
+	SUN50IW9_PLL_VIDEO1_REG,
+	SUN50IW9_PLL_VIDEO2_REG,
+	SUN50IW9_PLL_VE_REG,
+	SUN50IW9_PLL_DE_REG,
+	SUN50IW9_PLL_AUDIO_REG,
+	SUN50IW9_PLL_CSI_REG,
+};
+
+static const u32 sun50iw9_pll_video_regs[] = {
+	SUN50IW9_PLL_VIDEO0_REG,
+	SUN50IW9_PLL_VIDEO1_REG,
+	SUN50IW9_PLL_VIDEO2_REG,
+};
+
+static const u32 sun50iw9_usb_clk_regs[] = {
+	SUN50IW9_USB0_CLK_REG,
+	SUN50IW9_USB1_CLK_REG,
+	SUN50IW9_USB2_CLK_REG,
+	SUN50IW9_USB3_CLK_REG,
+};
+
+static struct ccu_pll_nb sun50iw9_pll_cpu_nb = {
+	.common = &pll_cpux_clk.common,
+	/* copy from pll_cpux_clk */
+	.enable = BIT(27),
+	.lock   = BIT(28),
+};
+
+static struct ccu_mux_nb sun50iw9_cpu_nb = {
+	.common         = &cpux_clk.common,
+	.cm             = &cpux_clk.mux,
+	.delay_us       = 1,
+	.bypass_index   = 4, /* index of pll periph0 */
+};
+
+static int sun50iw9_ccu_probe(struct platform_device *pdev)
+{
+	void __iomem *reg;
+	int ret;
+	int i;
+
+	reg = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(reg))
+		return PTR_ERR(reg);
+
+	/* Enable the lock bits on all PLLs */
+	for (i = 0; i < ARRAY_SIZE(sun50iw9_pll_regs); i++) {
+		set_reg(reg + sun50iw9_pll_regs[i], 1, 1, 29);
+	}
+
+	/*
+	 * In order to pass the EMI certification, the SDM function of
+	 * the peripheral 1 bus is enabled, and the frequency is still
+	 * calculated using the previous division factor.
+	 */
+	set_reg(reg + SUN50IW9_PLL_PERIPH1_PATTERN0_REG, 0xd1303333, 32, 0);
+	set_reg(reg + SUN50IW9_PLL_PERIPH1_REG, 1, 1, 24);
+
+	/*
+	 * Force the output divider of video PLLs to 0.
+	 *
+	 * See the comment before pll-video0 definition for the reason.
+	 */
+	for (i = 0; i < ARRAY_SIZE(sun50iw9_pll_video_regs); i++) {
+		set_reg(reg + sun50iw9_pll_video_regs[i], 0x0, 1, 0);
+	}
+
+	/* Enforce m1 = 0, m0 = 1 for Audio PLL */
+	set_reg(reg + SUN50IW9_PLL_AUDIO_REG, 0x1, 2, 0);
+
+	/*
+	 * Force OHCI 12M clock sources to 00 (12MHz divided from 48MHz)
+	 *
+	 * This clock mux is still mysterious, and the code just enforces
+	 * it to have a valid clock parent.
+	 */
+	for (i = 0; i < ARRAY_SIZE(sun50iw9_usb_clk_regs); i++) {
+		set_reg(reg + sun50iw9_usb_clk_regs[i], 0x0, 2, 24);
+	}
+
+	ret = sunxi_ccu_probe(pdev->dev.of_node, reg, &sun50iw9_ccu_desc);
+	if (ret)
+		return ret;
+
+	/* Gate then ungate PLL CPU after any rate changes */
+	ccu_pll_notifier_register(&sun50iw9_pll_cpu_nb);
+
+	/* Reparent CPU during PLL CPU rate changes */
+	ccu_mux_notifier_register(pll_cpux_clk.common.hw.clk,
+				  &sun50iw9_cpu_nb);
+
+	sunxi_ccu_sleep_init(reg, sun50iw9_ccu_clks,
+			     ARRAY_SIZE(sun50iw9_ccu_clks),
+			     NULL, 0);
+
+	return 0;
+}
+
+static const struct of_device_id sun50iw9_ccu_ids[] = {
+	{ .compatible = "allwinner,sun50iw9-ccu" },
+	{ }
+};
+
+static struct platform_driver sun50iw9_ccu_driver = {
+	.probe	= sun50iw9_ccu_probe,
+	.driver	= {
+		.name	= "sun50iw9-ccu",
+		.of_match_table	= sun50iw9_ccu_ids,
+	},
+};
+
+static int __init sunxi_ccu_sun50iw9_init(void)
+{
+	return platform_driver_register(&sun50iw9_ccu_driver);
+}
+core_initcall(sunxi_ccu_sun50iw9_init);
+
+static void __exit sunxi_ccu_sun50iw9_exit(void)
+{
+	return platform_driver_unregister(&sun50iw9_ccu_driver);
+}
+module_exit(sunxi_ccu_sun50iw9_exit);
+
+MODULE_DESCRIPTION("Allwinner sun50iw9 clk driver");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION("1.0.5");
diff --git a/drivers/clk/sunxi-ng/ccu-sun50iw9.h b/drivers/clk/sunxi-ng/ccu-sun50iw9.h
new file mode 100644
index 000000000..506144165
--- /dev/null
+++ b/drivers/clk/sunxi-ng/ccu-sun50iw9.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2020 frank@allwinnertech.com
+ */
+
+#ifndef _CCU_SUN50IW9_H_
+#define _CCU_SUN50IW9_H_
+
+#include <dt-bindings/clock/sun50iw9-ccu.h>
+#include <dt-bindings/reset/sun50iw9-ccu.h>
+
+#define CLK_NUMBER		(CLK_BUS_HDMI_HDCP + 1)
+
+#endif /* _CCU_SUN50IW9_H_ */
diff --git a/drivers/clk/sunxi-ng/ccu-sun55iw3-r.c b/drivers/clk/sunxi-ng/ccu-sun55iw3-r.c
new file mode 100644
index 000000000..46cf5c28c
--- /dev/null
+++ b/drivers/clk/sunxi-ng/ccu-sun55iw3-r.c
@@ -0,0 +1,282 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021 liujuan1@allwinnertech.com
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+
+#include "ccu_common.h"
+#include "ccu_reset.h"
+
+#include "ccu_div.h"
+#include "ccu_gate.h"
+#include "ccu_mp.h"
+#include "ccu_nm.h"
+
+#include "ccu-sun55iw3-r.h"
+
+static const char * const ahbs_parents[] = { "dcxo24M", "ext-32k",
+						   "rc-16m", "pll-peri0-div3",
+						   "pll-audio1-4x" };
+
+static SUNXI_CCU_M_WITH_MUX(r_ahb_clk, "r-ahb",
+			     ahbs_parents, 0x000,
+			     0, 5,
+			     24, 3,
+			     0);
+
+static SUNXI_CCU_M_WITH_MUX(r_apbs0_clk, "r-apbs0",
+			     ahbs_parents, 0x00c,
+			     0, 5,
+			     24, 3,
+			     0);
+
+static SUNXI_CCU_M_WITH_MUX(r_apbs1_clk, "r-apbs1",
+			     ahbs_parents, 0x010,
+			     0, 5,
+			     24, 3,
+			     0);
+
+static const char * const r_timer_parents[] = { "dcxo24M", "ext-32k",
+						   "rc-16m", "pll-peri-200m" };
+
+static struct ccu_div r_timer0_clk = {
+	.enable		= BIT(0),
+	.div		= _SUNXI_CCU_DIV_FLAGS(1, 4, CLK_DIVIDER_POWER_OF_TWO),
+	.mux		= _SUNXI_CCU_MUX(4, 2),
+	.common		= {
+		.reg		= 0x0100,
+		.hw.init	= CLK_HW_INIT("r-timer0",
+					      "r_timer_parents",
+					      &ccu_div_ops, 0),
+	},
+};
+
+static struct ccu_div r_timer1_clk = {
+	.enable		= BIT(0),
+	.div		= _SUNXI_CCU_DIV_FLAGS(1, 4, CLK_DIVIDER_POWER_OF_TWO),
+	.mux		= _SUNXI_CCU_MUX(4, 2),
+	.common		= {
+		.reg		= 0x0104,
+		.hw.init	= CLK_HW_INIT("r-timer1",
+					      "r_timer_parents",
+					      &ccu_div_ops, 0),
+	},
+};
+
+static struct ccu_div r_timer2_clk = {
+	.enable		= BIT(0),
+	.div		= _SUNXI_CCU_DIV_FLAGS(1, 4, CLK_DIVIDER_POWER_OF_TWO),
+	.mux		= _SUNXI_CCU_MUX(4, 2),
+	.common		= {
+		.reg		= 0x0108,
+		.hw.init	= CLK_HW_INIT("r-timer2",
+					      "r_timer_parents",
+					      &ccu_div_ops, 0),
+	},
+};
+
+static SUNXI_CCU_GATE(r_timer_gating_clk, "r-timer-gating",
+                      "dcxo24M",
+                      0x011c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(r_twd_gating_clk, "r-twd-gating",
+                      "dcxo24M",
+                      0x012c, BIT(0), 0);
+
+static const char * const r_pwm_parents[] = { "dcxo24M", "ext-32k", "rc-16m" };
+
+static SUNXI_CCU_MUX_WITH_GATE(r_pwm_clk, "r-pwm",
+			r_pwm_parents, 0x0130,
+			24, 2,
+			BIT(31), 0 );
+
+static SUNXI_CCU_GATE(r_pwm_gating_clk, "r-pwm-gating",
+                      "dcxo24M",
+                      0x013c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(r_can_gating_clk, "r-can-gating",
+                      "dcxo24M",
+                      0x014c, BIT(0), 0);
+
+static const char * const r_spi_parents[] = { "dcxo24M", "pll-peri0-div3",
+					      "pll-peri0-300m", "pll-peri1-300m" };
+
+static SUNXI_CCU_M_WITH_MUX_GATE(r_spi_clk, "r-spi",
+                                 r_spi_parents, 0x0150,
+			         0, 5,	/* M */
+			         24, 2,	/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_PARENT);
+
+static SUNXI_CCU_GATE(r_spi_gating_clk, "r-spi-gating",
+                      "dcxo24M",
+                      0x015c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(r_splock_gating_clk, "r-splock-gating",
+                      "dcxo24M",
+                      0x016c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(r_mbox_gating_clk, "r-mbox-gating",
+                      "dcxo24M",
+                      0x017c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(r_uart1_gating_clk, "r-uart1-gating",
+                      "dcxo24M",
+                      0x018c, BIT(1), 0);
+
+static SUNXI_CCU_GATE(r_uart0_gating_clk, "r-uart0-gating",
+                      "dcxo24M",
+                      0x018c, BIT(1), 0);
+
+static SUNXI_CCU_GATE(r_twi1_gating_clk, "r-twi1-gating",
+                      "dcxo24M",
+                      0x019c, BIT(1), 0);
+
+static SUNXI_CCU_GATE(r_twi0_gating_clk, "r-twi0-gating",
+                      "dcxo24M",
+                      0x019c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(r_ppu1_gating_clk, "r-ppu1-gating",
+                      "dcxo24M",
+                      0x01ac, BIT(1), 0);
+
+static SUNXI_CCU_GATE(r_ppu_gating_clk, "r-ppu-gating",
+                      "dcxo24M",
+                      0x01ac, BIT(0), 0);
+
+static SUNXI_CCU_GATE(r_tzma_gating_clk, "r-tzma-gating",
+                      "dcxo24M",
+                      0x01b0, BIT(0), 0);
+
+static SUNXI_CCU_GATE(r_cpus_bist_gating_clk, "r-cpus-bist-gating",
+                      "dcxo24M",
+                      0x01bc, BIT(0), 0);
+
+static const char * const r_irrx_parents[] = { "ext-32k", "dcxo24M" };
+
+static SUNXI_CCU_M_WITH_MUX_GATE(r_irrx_clk, "r-irrx",
+                                 r_spi_parents, 0x01c0,
+			         0, 5,	/* M */
+			         24, 2,	/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_PARENT);
+
+static SUNXI_CCU_GATE(r_irrx_gating_clk, "r-irrx-gating",
+                      "dcxo24M",
+                      0x01cc, BIT(0), 0);
+
+static SUNXI_CCU_GATE(dma_clken_sw_clk, "dma-clken-sw",
+                      "dcxo24M",
+                      0x01dc, BIT(0), 0);
+
+static SUNXI_CCU_GATE(r_rtc_gating_clk, "r-rtc-gating",
+                      "dcxo24M",
+                      0x020c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(r_cpucfg_gating_clk, "r-cpucfg-gating",
+                      "dcxo24M",
+                      0x022c, BIT(0), 0);
+
+static struct ccu_common *sun55iw3_r_ccu_clks[] = {
+	&r_ahb_clk.common,
+	&r_apbs0_clk.common,
+	&r_apbs1_clk.common,
+	&r_timer0_clk.common,
+	&r_timer1_clk.common,
+	&r_timer2_clk.common,
+};
+
+static struct clk_hw_onecell_data sun55iw3_r_hw_clks = {
+	.hws	= {
+		[CLK_R_TIMER0]	= &r_timer0_clk.common.hw,
+		[CLK_R_TIMER1]	= &r_timer1_clk.common.hw,
+		[CLK_R_TIMER2]	= &r_timer2_clk.common.hw,
+	},
+	.num	= CLK_NUMBER,
+};
+
+static struct ccu_reset_map sun55iw3_r_ccu_resets[] = {
+	[RST_R_TIMER]		=  { 0x11b, BIT(16) },
+	[RST_R_PWM]		=  { 0x13c, BIT(16) },
+	[RST_R_CAN]		=  { 0x14c, BIT(16) },
+	[RST_R_SPI]		=  { 0x15c, BIT(16) },
+	[RST_R_SPLOCK]		=  { 0x16c, BIT(16) },
+	[RST_R_MBOX]		=  { 0x17c, BIT(16) },
+	[RST_R_UART1]		=  { 0x18c, BIT(17) },
+	[RST_R_UART0]		=  { 0x18c, BIT(16) },
+	[RST_R_TWI1]		=  { 0x19c, BIT(17) },
+	[RST_R_TWI0]		=  { 0x19c, BIT(16) },
+	[RST_R_PPU1]		=  { 0x1ac, BIT(17) },
+	[RST_R_PPU]		=  { 0x1ac, BIT(16) },
+	[RST_R_IRRX]		=  { 0x1cc, BIT(16) },
+	[RST_R_RTC]		=  { 0x20c, BIT(16) },
+	[RST_R_CPUCFG]		=  { 0x22c, BIT(16) },
+};
+
+static const struct sunxi_ccu_desc sun55iw3_r_ccu_desc = {
+	.ccu_clks	= sun55iw3_r_ccu_clks,
+	.num_ccu_clks	= ARRAY_SIZE(sun55iw3_r_ccu_clks),
+
+	.hw_clks	= &sun55iw3_r_hw_clks,
+
+	.resets		= sun55iw3_r_ccu_resets,
+	.num_resets	= ARRAY_SIZE(sun55iw3_r_ccu_resets),
+};
+
+static int sun55iw3_r_ccu_probe(struct platform_device *pdev)
+{
+	void __iomem *reg;
+	int ret;
+
+	reg = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(reg))
+		return PTR_ERR(reg);
+
+	ret = sunxi_ccu_probe(pdev->dev.of_node, reg, &sun55iw3_r_ccu_desc);
+	if (ret)
+		return ret;
+
+	sunxi_ccu_sleep_init(reg, sun55iw3_r_ccu_clks,
+			     ARRAY_SIZE(sun55iw3_r_ccu_clks),
+			     NULL, 0);
+
+	return 0;
+}
+
+static const struct of_device_id sun55iw3_r_ccu_ids[] = {
+	{ .compatible = "allwinner,sun55iw3-r-ccu" },
+	{ .compatible = "allwinner,sun20iw1-r-ccu" },
+	{ }
+};
+
+static struct platform_driver sun55iw3_r_ccu_driver = {
+	.probe	= sun55iw3_r_ccu_probe,
+	.driver	= {
+		.name	= "sun55iw3-r-ccu",
+		.of_match_table	= sun55iw3_r_ccu_ids,
+	},
+};
+
+static int __init sunxi_r_ccu_sun55iw3_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&sun55iw3_r_ccu_driver);
+	if (ret)
+		pr_err("register ccu sun55iw3 failed\n");
+
+	return ret;
+}
+core_initcall(sunxi_r_ccu_sun55iw3_init);
+
+static void __exit sunxi_r_ccu_sun55iw3_exit(void)
+{
+	return platform_driver_unregister(&sun55iw3_r_ccu_driver);
+}
+module_exit(sunxi_r_ccu_sun55iw3_exit);
+
+MODULE_VERSION("1.0.0");
diff --git a/drivers/clk/sunxi-ng/ccu-sun55iw3-r.h b/drivers/clk/sunxi-ng/ccu-sun55iw3-r.h
new file mode 100644
index 000000000..559b64c6f
--- /dev/null
+++ b/drivers/clk/sunxi-ng/ccu-sun55iw3-r.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2020 liujuan1@allwinnertech.com
+ */
+
+#ifndef _CCU_SUN55IW3_R_H
+#define _CCU_SUN55IW3_R_H
+
+#include <dt-bindings/clock/sun55iw3-r-ccu.h>
+#include <dt-bindings/reset/sun55iw3-r-ccu.h>
+
+#define CLK_NUMBER	(CLK_R_MAX_NO + 1)
+
+#endif /* _CCU_SUN55IW3_R_H */
diff --git a/drivers/clk/sunxi-ng/ccu-sun55iw3-rtc.c b/drivers/clk/sunxi-ng/ccu-sun55iw3-rtc.c
new file mode 100644
index 000000000..e5a529eba
--- /dev/null
+++ b/drivers/clk/sunxi-ng/ccu-sun55iw3-rtc.c
@@ -0,0 +1,194 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * sunxi RTC ccu driver
+ *
+ * Copyright (c) 2021,<liujuan1@allwinnertech.com>
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/io.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/module.h>
+
+#include "ccu_common.h"
+#include "ccu_reset.h"
+#include "ccu_div.h"
+#include "ccu_gate.h"
+#include "ccu_mp.h"
+#include "ccu_mult.h"
+#include "ccu_nk.h"
+#include "ccu_nkm.h"
+#include "ccu_nkmp.h"
+#include "ccu_nm.h"
+#include "ccu_phase.h"
+
+#include "ccu-sun55iw3-rtc.h"
+
+/*
+ * iosc clk:
+ */
+static SUNXI_CCU_GATE(iosc_clk, "iosc", "rc-16m", 0x160, BIT(0), 0);
+
+static SUNXI_CCU_GATE_WITH_KEY(ext32k_gate_clk, "ext32k-gate",
+			       "ext-32k", 0x0,
+			       KEY_FIELD_MAGIC_NUM_RTC,
+			       BIT(4), 0);
+
+static CLK_FIXED_FACTOR(iosc_div32k_clk, "iosc-div32k", "iosc", 500, 1, 0);
+
+/*
+ * osc32k clk(losc)
+ */
+static const char * const osc32k_parents[] = { "iosc-div32k", "ext32k-gate" };
+static SUNXI_CCU_MUX_WITH_GATE_KEY(osc32k_clk, "osc32k", osc32k_parents,
+				   0x0, 0, 1,
+				   KEY_FIELD_MAGIC_NUM_RTC, 0, 0);
+
+static SUNXI_CCU_GATE_WITH_FIXED_RATE(dcxo24M_div32k_clk, "dcxo24M-div32k",
+				      "dcxo24M", 0x60,
+				      32768, BIT(16));
+/*
+ * rtc-1k clock
+ */
+static const char * const rtc32k_clk_parents[] = { "osc32k", "dcxo24M-div32k"};
+static SUNXI_CCU_MUX_WITH_GATE_KEY(rtc32k_clk, "rtc32k", rtc32k_clk_parents,
+				   0x0, 1, 1,
+				   KEY_FIELD_MAGIC_NUM_RTC, 0, 0);
+static CLK_FIXED_FACTOR(rtc_1k_clk, "rtc-1k", "rtc32k", 32, 1, 0);
+
+/* rtc-32k-fanout: only for debug */
+static const char * const rtc_32k_fanout_clk_parents[] = { "osc32k", "ext32k-gate",
+							   "dcxo24M-div32k"};
+static SUNXI_CCU_MUX_WITH_GATE(rtc_32k_fanout_clk, "rtc-32k-fanout",
+			       rtc_32k_fanout_clk_parents, 0x60, 1,
+			       2, BIT(0), 0);
+
+/* TODO: should add the div func */
+static SUNXI_CCU_GATE(rtc_spi_clk, "rtc-spi", "r-ahb", 0x310, BIT(31), 0);
+
+static struct ccu_common *sun55iw3_rtc_ccu_clks[] = {
+	&iosc_clk.common,
+	&ext32k_gate_clk.common,
+	&osc32k_clk.common,
+	&dcxo24M_div32k_clk.common,
+	&rtc32k_clk.common,
+	&rtc_32k_fanout_clk.common,
+	&rtc_spi_clk.common,
+};
+
+static struct clk_hw_onecell_data sun55iw3_rtc_ccu_hw_clks = {
+	.hws	= {
+		[CLK_IOSC]			= &iosc_clk.common.hw,
+		[CLK_EXT32K_GATE]		= &ext32k_gate_clk.common.hw,
+		[CLK_IOSC_DIV32K]		= &iosc_div32k_clk.hw,
+		[CLK_OSC32K]			= &osc32k_clk.common.hw,
+		[CLK_DCXO24M_DIV32K]		= &dcxo24M_div32k_clk.common.hw,
+		[CLK_RTC32K]			= &rtc32k_clk.common.hw,
+		[CLK_RTC_1K]			= &rtc_1k_clk.hw,
+		[CLK_RTC_32K_FANOUT]		= &rtc_32k_fanout_clk.common.hw,
+		[CLK_RTC_SPI]			= &rtc_spi_clk.common.hw,
+	},
+	.num	= CLK_NUMBER,
+};
+
+static const struct sunxi_ccu_desc sun55iw3_rtc_ccu_desc = {
+	.ccu_clks	= sun55iw3_rtc_ccu_clks,
+	.num_ccu_clks	= ARRAY_SIZE(sun55iw3_rtc_ccu_clks),
+
+	.hw_clks	= &sun55iw3_rtc_ccu_hw_clks,
+};
+
+static void clock_source_init(char __iomem *base)
+{
+	/* (1) enable DCXO */
+	/* by default, DCXO_EN = 1. We don't have to do this... */
+	set_reg(base + XO_CTRL_REG, 0x1, 1, 1);
+
+	/* (2) enable auto switch function */
+	/*
+	 * In some cases, we boot with auto switch function disabled, and try to
+	 * enable the auto switch function by rebooting.
+	 * But the rtc default value does not change unless vcc-rtc is loss.
+	 * So we should not rely on the default value of reg.
+	 * BIT(14): LOSC auto switch 32k clk source sel enable. 1: enable
+	 * BIT(15): LOSC auto switch function disable. 1: disable
+	 */
+	set_reg_key(base + LOSC_CTRL_REG,
+		    KEY_FIELD_MAGIC_NUM_RTC >> 16, 16, 16,
+		    0x1, 2, 14);
+
+	/* (3) set the parent of osc32k-sys to ext-osc32k */
+	set_reg_key(base + LOSC_CTRL_REG,
+		    KEY_FIELD_MAGIC_NUM_RTC >> 16, 16, 16,
+		    0x1, 1, 0);
+
+	/* (4) set the parent of osc32k-out to osc32k-sys */
+	/* by default, LOSC_OUT_SRC_SEL = 0x0. We don't have to do this... */
+	set_reg(base + LOSC_OUT_GATING_REG,
+		0x0, 2, 1);
+}
+
+static int sun55iw3_rtc_ccu_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct device *dev = &pdev->dev;
+	void __iomem *reg;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(dev, "Fail to get IORESOURCE_MEM\n");
+		return -EINVAL;
+	}
+
+	/*
+	 * Don't use devm_ioremap_resource() here! Or else the RTC driver will
+	 * not able to get the same resource later in rtc-sunxi.c.
+	 */
+	reg = devm_ioremap(dev, res->start, resource_size(res));
+	if (IS_ERR(reg)) {
+		dev_err(dev, "Fail to map IO resource\n");
+		return PTR_ERR(reg);
+	}
+
+	clock_source_init(reg);
+
+	return sunxi_ccu_probe(pdev->dev.of_node, reg, &sun55iw3_rtc_ccu_desc);
+}
+
+static const struct of_device_id sun55iw3_rtc_ccu_ids[] = {
+	{ .compatible = "allwinner,sun55iw3-rtc-ccu" },
+	{ .compatible = "allwinner,sun20iw1-rtc-ccu" },
+	{ }
+};
+
+static struct platform_driver sun55iw3_rtc_ccu_driver = {
+	.probe	= sun55iw3_rtc_ccu_probe,
+	.driver	= {
+		.name	= "sun55iw3-rtc-ccu",
+		.of_match_table	= sun55iw3_rtc_ccu_ids,
+	},
+};
+
+static int __init sun55iw3_rtc_ccu_init(void)
+{
+	int err;
+
+	err = platform_driver_register(&sun55iw3_rtc_ccu_driver);
+	if (err)
+		pr_err("Fail to register sunxi_rtc_ccu as platform device\n");
+
+	return err;
+}
+core_initcall(sun55iw3_rtc_ccu_init);
+
+static void __exit sun55iw3_rtc_ccu_exit(void)
+{
+	platform_driver_unregister(&sun55iw3_rtc_ccu_driver);
+}
+module_exit(sun55iw3_rtc_ccu_exit);
+
+MODULE_DESCRIPTION("sunxi RTC CCU driver");
+MODULE_AUTHOR("Juan Liu<liujuan1@allwinnertech.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION("1.0.0");
diff --git a/drivers/clk/sunxi-ng/ccu-sun55iw3-rtc.h b/drivers/clk/sunxi-ng/ccu-sun55iw3-rtc.h
new file mode 100644
index 000000000..e4bed13b9
--- /dev/null
+++ b/drivers/clk/sunxi-ng/ccu-sun55iw3-rtc.h
@@ -0,0 +1,18 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 liujuan1@allwinnertech.com
+ */
+
+#ifndef _CCU_SUN55IW3_RTC_H_
+#define _CCU_SUN55IW3_RTC_H_
+
+#include <dt-bindings/clock/sun55iw3-rtc.h>
+
+#define LOSC_CTRL_REG			0x00
+#define KEY_FIELD_MAGIC_NUM_RTC		0x16AA0000
+#define LOSC_OUT_GATING_REG		0x60  /* Or: 32K_FOUT_CTRL_GATING_REG */
+#define XO_CTRL_REG			0x160
+
+#define CLK_NUMBER			(CLK_RTC_MAX_NO + 1)
+
+#endif /* _CCU_SUN55IW3_RTC_H_ */
diff --git a/drivers/clk/sunxi-ng/ccu-sun55iw3.c b/drivers/clk/sunxi-ng/ccu-sun55iw3.c
new file mode 100755
index 000000000..582ff6e24
--- /dev/null
+++ b/drivers/clk/sunxi-ng/ccu-sun55iw3.c
@@ -0,0 +1,1915 @@
+// SPDX-License-Identifier: GPL-3.0
+/*
+ * Copyright (c) 2021 liujuan1@allwinnertech.com
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+
+#include "ccu_common.h"
+#include "ccu_reset.h"
+
+#include "ccu_div.h"
+#include "ccu_gate.h"
+#include "ccu_mp.h"
+#include "ccu_mult.h"
+#include "ccu_nk.h"
+#include "ccu_nkm.h"
+#include "ccu_nkmp.h"
+#include "ccu_nm.h"
+
+#include "ccu-sun55iw3.h"
+
+/*
+ * The CPU PLL is actually NP clock, with P being /1, /2 or /4. However
+ * P should only be used for output frequencies lower than 288 MHz.
+ *
+ * For now we can just model it as a multiplier clock, and force P to /1.
+ *
+ * The M factor is present in the register's description, but not in the
+ * frequency formula, and it's documented as "M is only used for backdoor
+ * testing", so it's not modelled and then force to 0.
+ */
+
+/* ccu_des_start */
+
+#define SUN55IW3_PLL_CPU0_CTRL_REG   0x0000
+static struct ccu_mult pll_cpu0_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.mult		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.common		= {
+		.reg		= 0x0000,
+		.hw.init	= CLK_HW_INIT("pll-cpu0", "dcxo24M",
+					      &ccu_mult_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+/* @TODO */
+#define SUN55IW3_PLL_CPU1_CTRL_REG   0x0008
+#define SUN55IW3_PLL_CPU2_CTRL_REG   0x000C
+
+#define SUN55IW3_PLL_DDR_CTRL_REG   0x0010
+static struct ccu_nkmp pll_ddr_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(0, 1), /* input divider */
+	.p		= _SUNXI_CCU_DIV(1, 1), /* output divider */
+	.common		= {
+		.reg		= 0x0010,
+		.hw.init	= CLK_HW_INIT("pll-ddr", "dcxo24M",
+					      &ccu_nkmp_ops,
+					      CLK_SET_RATE_UNGATE |
+					      CLK_IS_CRITICAL),
+	},
+};
+
+#define SUN55IW3_PLL_PERI0_CTRL_REG   0x0020
+static struct ccu_nm pll_peri0_parent_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.common		= {
+		.reg		= 0x0020,
+		.hw.init	= CLK_HW_INIT("pll-peri0-parent", "dcxo24M",
+					      &ccu_nm_ops,
+					      CLK_SET_RATE_UNGATE |
+					      CLK_IS_CRITICAL),
+	},
+};
+
+static SUNXI_CCU_M(pll_peri0_2x_clk, "pll-peri0-2x",
+		   "pll-peri0-parent", 0x0020, 16, 3, 0);
+
+static CLK_FIXED_FACTOR_HW(pll_peri0_div3_clk, "pll-peri0-div3",
+			   &pll_peri0_2x_clk.common.hw,
+			   6, 1, 0);
+
+static SUNXI_CCU_M(pll_peri0_800m_clk, "pll-peri0-800m",
+		   "pll-peri0-parent", 0x0020, 20, 3, 0);
+
+static SUNXI_CCU_M(pll_peri0_480m_clk, "pll-peri0-480m",
+		   "pll-peri0-parent", 0x0020, 2, 3, 0);
+
+static CLK_FIXED_FACTOR_HW(pll_peri0_600m_clk, "pll-peri0-600m",
+			   &pll_peri0_2x_clk.common.hw,
+			   2, 1, 0);
+
+static CLK_FIXED_FACTOR_HW(pll_peri0_400m_clk, "pll-peri0-400m",
+			   &pll_peri0_2x_clk.common.hw,
+			   3, 1, 0);
+
+static CLK_FIXED_FACTOR(pll_peri0_300m_clk, "pll-peri0-300m",
+			   "pll-peri0-600m",
+			   2, 1, 0);
+
+static CLK_FIXED_FACTOR(pll_peri0_200m_clk, "pll-peri0-200m",
+			   "pll-peri0-400m",
+			   2, 1, 0);
+
+static CLK_FIXED_FACTOR(pll_peri0_160m_clk, "pll-peri0-160m",
+			   "pll-peri0-480m",
+			   3, 1, 0);
+
+static CLK_FIXED_FACTOR(pll_peri0_150m_clk, "pll-peri0-150m",
+			   "pll-peri0-300m",
+			   2, 1, 0);
+
+#define SUN55IW3_PLL_PERI1_CTRL_REG   0x0028
+static struct ccu_nm pll_peri1_parent_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.common		= {
+		.reg		= 0x0028,
+		.hw.init	= CLK_HW_INIT("pll-peri1-parent", "dcxo24M",
+					      &ccu_nm_ops,
+					      CLK_SET_RATE_UNGATE |
+					      CLK_IS_CRITICAL),
+	},
+};
+
+static SUNXI_CCU_M(pll_peri1_2x_clk, "pll-peri1-2x",
+		   "pll-peri1-parent", 0x0028, 16, 3, 0);
+
+static SUNXI_CCU_M(pll_peri1_800m_clk, "pll-peri1-800m",
+		   "pll-peri1-parent", 0x0028, 20, 3, 0);
+
+static SUNXI_CCU_M(pll_peri1_480m_clk, "pll-peri1-480m",
+		   "pll-peri1-parent", 0x0028, 2, 3, 0);
+
+static CLK_FIXED_FACTOR_HW(pll_peri1_600m_clk, "pll-peri1-600m",
+			   &pll_peri1_2x_clk.common.hw,
+			   2, 1, 0);
+
+static CLK_FIXED_FACTOR_HW(pll_peri1_400m_clk, "pll-peri1-400m",
+			   &pll_peri1_2x_clk.common.hw,
+			   3, 1, 0);
+
+static CLK_FIXED_FACTOR(pll_peri1_300m_clk, "pll-peri1-300m",
+			   "pll-peri1-600m",
+			   2, 1, 0);
+
+static CLK_FIXED_FACTOR(pll_peri1_200m_clk, "pll-peri1-200m",
+			   "pll-peri1-400m",
+			   2, 1, 0);
+
+static CLK_FIXED_FACTOR(pll_peri1_160m_clk, "pll-peri1-160m",
+			   "pll-peri1-480m",
+			   3, 1, 0);
+
+static CLK_FIXED_FACTOR(pll_peri1_150m_clk, "pll-peri1-150m",
+			   "pll-peri1-300m",
+			   2, 1, 0);
+
+#define SUN55IW3_PLL_GPU_CTRL_REG   0x0030
+static struct ccu_nkmp pll_gpu_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.p		= _SUNXI_CCU_DIV(0, 1), /* output divider */
+	.common		= {
+		.reg		= 0x0030,
+		.hw.init	= CLK_HW_INIT("pll-gpu", "dcxo24M",
+					      &ccu_nkmp_ops,
+					      CLK_SET_RATE_UNGATE |
+					      CLK_IS_CRITICAL),
+	},
+};
+
+#define SUN55IW3_PLL_VIDEO0_CTRL_REG   0x0040
+static struct ccu_nm pll_video0_4x_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.common		= {
+		.reg		= 0x0040,
+		.hw.init	= CLK_HW_INIT("pll_video0_4x_clk", "dcxo24M",
+					      &ccu_nm_ops,
+					      CLK_SET_RATE_UNGATE |
+					      CLK_IS_CRITICAL),
+	},
+};
+
+static CLK_FIXED_FACTOR_HW(pll_video0_2x_clk, "pll-video0-2x",
+			   &pll_video0_4x_clk.common.hw,
+			   2, 1, 0);
+
+static CLK_FIXED_FACTOR_HW(pll_video0_1x_clk, "pll-video0-1x",
+			   &pll_video0_4x_clk.common.hw,
+			   4, 1, 0);
+
+#define SUN55IW3_PLL_VIDEO1_CTRL_REG   0x0048
+static struct ccu_nm pll_video1_4x_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(0, 1), /* input divider */
+	.common		= {
+		.reg		= 0x0048,
+		.hw.init	= CLK_HW_INIT("pll_video1_4x_clk", "dcxo24M",
+					      &ccu_nm_ops,
+					      CLK_SET_RATE_UNGATE |
+					      CLK_IS_CRITICAL),
+	},
+};
+
+static CLK_FIXED_FACTOR_HW(pll_video1_2x_clk, "pll-video1-2x",
+			   &pll_video1_4x_clk.common.hw,
+			   2, 1, 0);
+
+static CLK_FIXED_FACTOR_HW(pll_video1_1x_clk, "pll-video1-1x",
+			   &pll_video1_4x_clk.common.hw,
+			   4, 1, 0);
+
+#define SUN55IW3_PLL_VIDEO2_CTRL_REG   0x0050
+static struct ccu_nm pll_video2_4x_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.common		= {
+		.reg		= 0x0050,
+		.hw.init	= CLK_HW_INIT("pll_video2_4x_clk", "dcxo24M",
+					      &ccu_nm_ops,
+					      CLK_SET_RATE_UNGATE |
+					      CLK_IS_CRITICAL),
+	},
+};
+
+static CLK_FIXED_FACTOR_HW(pll_video2_2x_clk, "pll-video2-2x",
+			   &pll_video2_4x_clk.common.hw,
+			   2, 1, 0);
+
+static CLK_FIXED_FACTOR_HW(pll_video2_1x_clk, "pll-video2-1x",
+			   &pll_video2_4x_clk.common.hw,
+			   4, 1, 0);
+
+#define SUN55IW3_PLL_VE_CTRL_REG   0x0058
+static struct ccu_nkmp pll_ve_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(0, 1), /* input divider */
+	.p		= _SUNXI_CCU_DIV(1, 1), /* output divider */
+	.common		= {
+		.reg		= 0x0058,
+		.hw.init	= CLK_HW_INIT("pll-ve", "dcxo24M",
+					      &ccu_nkmp_ops,
+					      CLK_SET_RATE_UNGATE |
+					      CLK_IS_CRITICAL),
+	},
+};
+
+#define SUN55IW3_PLL_VIDEO3_CTRL_REG   0x0068
+static struct ccu_nm pll_video3_4x_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.common		= {
+		.reg		= 0x0068,
+		.hw.init	= CLK_HW_INIT("pll-video3-4x", "dcxo24M",
+					      &ccu_nm_ops,
+					      CLK_SET_RATE_UNGATE |
+					      CLK_IS_CRITICAL),
+	},
+};
+
+static CLK_FIXED_FACTOR_HW(pll_video3_2x_clk, "pll-video3-2x",
+			   &pll_video3_4x_clk.common.hw,
+			   2, 1, 0);
+
+static CLK_FIXED_FACTOR_HW(pll_video3_1x_clk, "pll-video3-1x",
+			   &pll_video3_4x_clk.common.hw,
+			   4, 1, 0);
+
+#define SUN55IW3_PLL_AUDIO0_REG		0x078
+static struct ccu_sdm_setting pll_audio0_sdm_table[] = {
+	{ .rate = 45158400, .pattern = 0xc001bcd3, .m = 18, .n = 33 },
+	{ .rate = 49152000, .pattern = 0xc001eb85, .m = 20, .n = 40 },
+	{ .rate = 180633600, .pattern = 0xc001288d, .m = 3, .n = 22 },
+	{ .rate = 196608000, .pattern = 0xc001eb85, .m = 5, .n = 40 },
+};
+
+static struct ccu_nm pll_audio0_4x_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(16, 6),
+	.fixed_post_div	= 2,
+	.sdm		= _SUNXI_CCU_SDM(pll_audio0_sdm_table, BIT(24),
+					 0x178, BIT(31)),
+	.common		= {
+		.reg		= 0x078,
+		.features	= CCU_FEATURE_FIXED_POSTDIV |
+				  CCU_FEATURE_SIGMA_DELTA_MOD,
+		.hw.init	= CLK_HW_INIT("pll-audio0-4x", "dcxo24M",
+					      &ccu_nm_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+static CLK_FIXED_FACTOR_HW(pll_audio0_2x_clk, "pll-audio0-2x",
+			   &pll_audio0_4x_clk.common.hw,
+			   2, 1, 0);
+
+static CLK_FIXED_FACTOR_HW(pll_audio0_1x_clk, "pll-audio0-1x",
+			   &pll_audio0_4x_clk.common.hw,
+			   4, 1, 0);
+
+static CLK_FIXED_FACTOR(pll_audio0_div_48m_clk, "pll-audio0-div-48m",
+			   "pll-audio0-2x", 4, 1, 0);
+
+#define SUN55IW3_PLL_NPU_CTRL_REG   0x0080
+static struct ccu_nm pll_npu_4x_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.common		= {
+		.reg		= 0x0080,
+		.hw.init	= CLK_HW_INIT("pll-npu-4x", "dcxo24M",
+					      &ccu_nm_ops,
+					      CLK_SET_RATE_UNGATE |
+					      CLK_IS_CRITICAL),
+	},
+};
+
+static CLK_FIXED_FACTOR_HW(pll_npu_2x_clk, "pll-npu-2x",
+			   &pll_npu_4x_clk.common.hw,
+			   2, 1, 0);
+
+static CLK_FIXED_FACTOR_HW(pll_npu_1x_clk, "pll-npu-1x",
+			   &pll_npu_4x_clk.common.hw,
+			   4, 1, 0);
+
+static struct clk_div_table cpu0_div_table[] = {
+	{ .val = 0, .div = 1 },
+	{ .val = 1, .div = 2 },
+	{ .val = 2, .div = 4 },
+};
+
+static SUNXI_CCU_DIV_TABLE(cpu0_div, "cpu0-div", "pll-cpu0",
+		0x0500, 16, 2, cpu0_div_table, CLK_SET_RATE_PARENT);
+
+static const char * const cpu_parents[] = { "hosc", "osc32k", "clk16m-rc", "cpu0-div", "pll-peri0-600m", "pll-cpu2" };
+
+static SUNXI_CCU_MUX(cpu_clk, "cpu", cpu_parents,
+		     0x0500, 24, 3, CLK_SET_RATE_PARENT | CLK_IS_CRITICAL);
+
+static SUNXI_CCU_M(cpu_axi_clk, "cpu-axi",
+		   "dsu-parent", 0x0500, 1, 2, 0);
+
+static SUNXI_CCU_M(cpu_apb_clk, "cpu-apb",
+		   "dsu-parent", 0x0500, 8, 2, 0);
+
+static SUNXI_CCU_M(cpu_peri_clk, "cpu-peri",
+		   "dsu-parent", 0x0500, 2, 2, 0);
+
+/* wrong clk name:0504
+static SUNXI_CCU_GATE(cpu_gatin_clk, "cpu-gatin",
+                      "cpu-gatin-clk-parents",
+                      0x0504, BIT(16), 0);
+
+static SUNXI_CCU_GATE(dsu_clk_clk, "dsu-clk",
+                      "dsu-clk-clk-parents",
+                      0x0504, BIT(1), 0);
+
+static SUNXI_CCU_GATE(cpu0_clk_clk, "cpu0-clk",
+                      "cpu0-clk-clk-parents",
+                      0x0504, BIT(0), 0);
+*/
+
+static const char * const trace_parents[] = { "hosc", "osc32k", "clk16m-rc", "peri0-300m", "peri0-400m" };
+
+static SUNXI_CCU_M_WITH_MUX_GATE(trace_clk, "trace",
+                                 trace_parents, 0x0508,
+			         0, 5,	/* M */
+			         24, 3,	/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_PARENT);
+
+static struct clk_div_table cpu1_div_table[] = {
+	{ .val = 0, .div = 1 },
+	{ .val = 1, .div = 2 },
+	{ .val = 2, .div = 4 },
+};
+
+static SUNXI_CCU_DIV_TABLE(cpu1_div, "cpu1-div", "pll-cpu1",
+		0x050c, 16, 2, cpu0_div_table, CLK_SET_RATE_PARENT);
+
+static const char * const dsu_parents[] = { "hosc", "osc32k", "clk16m-rc", "cpu1-div", "pll-peri0-2x", "pll-peri0-600m" };
+
+static SUNXI_CCU_MUX(dsu_parents_clk, "dsu-parents", dsu_parents,
+		     0x050c, 24, 3, CLK_SET_RATE_PARENT | CLK_IS_CRITICAL);
+
+static const char * const ahb_parents[] = { "hosc", "osc32k", "clk16m-rc", "pll-peri0-600m" };
+
+SUNXI_CCU_M_WITH_MUX(ahb_clk, "ahb", ahb_parents,
+		     0x0510, 0, 5, 24, 2, CLK_SET_RATE_PARENT);
+
+static const char * const apb0_parents[] = { "hosc", "osc32k", "clk16m-rc", "pll-peri0-600m" };
+
+SUNXI_CCU_M_WITH_MUX(apb0_clk, "apb0", apb0_parents,
+		     0x0520, 0, 5, 24, 2, CLK_SET_RATE_PARENT);
+
+static const char * const apb1_parents[] = { "hosc", "osc32k", "clk16m-rc", "pll-peri0-600m" };
+
+SUNXI_CCU_M_WITH_MUX(apb1_clk, "apb1", apb1_parents,
+		     0x0524, 0, 5, 24, 2, CLK_SET_RATE_PARENT);
+
+static const char * const mbus_parents[] = { "hosc", "pll-ddr", "peri0-600m", "peri0-480m", "peri0-400m" };
+
+static SUNXI_CCU_M_WITH_MUX_GATE(mbus_clk, "mbus",
+                                 mbus_parents, 0x0540,
+			         0, 5,	/* M */
+			         24, 3,	/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_PARENT);
+
+static SUNXI_CCU_GATE(nsi_clk, "nsi",
+                      "dcxo24M",
+                      0x054C, BIT(0), 0);
+
+static const char * const gic_parents[] = { "hosc", "osc32k", "peri0-600m", "peri0-480m" };
+
+static SUNXI_CCU_M_WITH_MUX_GATE(gic_clk, "gic",
+                                 gic_parents, 0x0550,
+			         0, 5,	/* M */
+			         24, 2,	/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_PARENT);
+
+static const char * const de_parents[] = { "peri0-300m", "peri0-400m", "pll-video0-4x", "pll-video1-4x", "pll-video2-4x", "pll-video3-4x" };
+
+static SUNXI_CCU_M_WITH_MUX_GATE(de_clk, "de",
+                                 de_parents, 0x0600,
+			         0, 5,	/* M */
+			         24, 3,	/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_PARENT);
+
+static SUNXI_CCU_GATE(de0_clk, "de0",
+                      "dcxo24M",
+                      0x060C, BIT(0), 0);
+
+static const char * const di_parents[] = { "peri0-400m", "pll-video0-4x" };
+
+static SUNXI_CCU_M_WITH_MUX_GATE(di_clk, "di",
+                                 di_parents, 0x0620,
+			         0, 5,	/* M */
+			         24, 3,	/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_PARENT);
+
+static SUNXI_CCU_GATE(bus_di_clk, "bus-di",
+                      "dcxo24M",
+                      0x062C, BIT(0), 0);
+
+static const char * const g2d_parents[] = { "peri0-400m", "peri0-300m", "pll-video0-4x" };
+
+static SUNXI_CCU_M_WITH_MUX_GATE(g2d_clk, "g2d",
+                                 g2d_parents, 0x0630,
+			         0, 5,	/* M */
+			         24, 3,	/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_PARENT);
+
+static SUNXI_CCU_GATE(bus_g2d_clk, "bus-g2d",
+                      "dcxo24M",
+                      0x063C, BIT(0), 0);
+
+static const char * const cpu_core_parents[] = { "peri0-800m", "peri0-600m", "peri0-400m", "peri0-300m", "peri0-200m" };
+
+static SUNXI_CCU_M_WITH_MUX_GATE(cpu_core_clk, "cpu-core",
+                                 cpu_core_parents, 0x0670,
+			         0, 4,	/* M */
+			         24, 3,	/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_PARENT);
+
+static SUNXI_CCU_GATE(gpu_clk, "gpu",
+                      "dcxo24M",
+                      0x067C, BIT(0), 0);
+
+static const char * const ce_parents[] = { "hosc", "peri0-480m", "peri0-400m", "peri0-300m" };
+
+static SUNXI_CCU_M_WITH_MUX_GATE(ce_clk, "ce",
+                                 ce_parents, 0x0680,
+			         0, 5,	/* M */
+			         24, 3,	/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_PARENT);
+
+static SUNXI_CCU_GATE(ce_sys_clk, "ce-sys",
+                      "dcxo24M",
+                      0x068C, BIT(1), 0);
+
+static SUNXI_CCU_GATE(bus_ce_clk, "bus-ce",
+                      "dcxo24M",
+                      0x068C, BIT(0), 0);
+
+static const char * const ve_parents[] = { "vepll", "peri0-480m", "peri0-400m", "peri0-300m" };
+
+static SUNXI_CCU_M_WITH_MUX_GATE(ve_clk, "ve",
+                                 ve_parents, 0x0690,
+			         0, 5,	/* M */
+			         24, 3,	/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_PARENT);
+
+static SUNXI_CCU_GATE(bus_ve_clk, "bus-ve",
+                      "dcxo24M",
+                      0x069C, BIT(0), 0);
+
+static const char * const npu_parents[] = { "peri0-480m", "peri0-600m", "peri0-800m", "npupll4x" };
+
+static SUNXI_CCU_M_WITH_MUX_GATE(npu_clk, "npu",
+                                 npu_parents, 0x06E0,
+			         0, 5,	/* M */
+			         24, 3,	/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_PARENT);
+
+static SUNXI_CCU_GATE(dma_clk, "dma",
+                      "dcxo24M",
+                      0x070C, BIT(0), 0);
+
+static SUNXI_CCU_GATE(msgbox1_clk, "msgbox1",
+                      "dcxo24M",
+                      0x071C, BIT(1), 0);
+
+static SUNXI_CCU_GATE(msgbox0_clk, "msgbox0",
+                      "dcxo24M",
+                      0x071C, BIT(0), 0);
+
+static SUNXI_CCU_GATE(spinlock_clk, "spinlock",
+                      "dcxo24M",
+                      0x072C, BIT(0), 0);
+
+static SUNXI_CCU_GATE(timer_clk, "timer",
+                      "dcxo24M",
+                      0x074C, BIT(0), 0);
+
+static SUNXI_CCU_GATE(dbgsys_clk, "dbgsys",
+                      "dcxo24M",
+                      0x078C, BIT(0), 0);
+
+static SUNXI_CCU_GATE(pwm_clk, "pwm",
+                      "dcxo24M",
+                      0x07AC, BIT(0), 0);
+
+static SUNXI_CCU_GATE(iommu_clk, "iommu",
+                      "dcxo24M",
+                      0x07BC, BIT(0), 0);
+
+static const char * const timer0_parents[] = { "hosc", "rc-clk-16m", "clk-32k", "clk- peri0-200m" };
+
+static struct ccu_div timer0_clk = {
+	.enable		= BIT(31),
+	.div		= _SUNXI_CCU_DIV_FLAGS(0, 3, CLK_DIVIDER_POWER_OF_TWO),
+	.mux		= _SUNXI_CCU_MUX(24, 3),
+	.common		= {
+		.reg		= 0x0730,
+		.hw.init	= CLK_HW_INIT("timer0", "timer0-parent", &ccu_div_ops, 0),
+	},
+};
+
+static const char * const timer1_parents[] = { "hosc", "rc-clk-16m", "clk-32k", "clk- peri0-200m" };
+
+static struct ccu_div timer1_clk = {
+	.enable		= BIT(31),
+	.div		= _SUNXI_CCU_DIV_FLAGS(0, 3, CLK_DIVIDER_POWER_OF_TWO),
+	.mux		= _SUNXI_CCU_MUX(24, 3),
+	.common		= {
+		.reg		= 0x0730,
+		.hw.init	= CLK_HW_INIT("timer1", "timer1-parent", &ccu_div_ops, 0),
+	},
+};
+
+static const char * const timer2_parents[] = { "hosc", "rc-clk-16m", "clk-32k", "clk- peri0-200m" };
+
+static struct ccu_div timer2_clk = {
+	.enable		= BIT(31),
+	.div		= _SUNXI_CCU_DIV_FLAGS(0, 3, CLK_DIVIDER_POWER_OF_TWO),
+	.mux		= _SUNXI_CCU_MUX(24, 3),
+	.common		= {
+		.reg		= 0x0730,
+		.hw.init	= CLK_HW_INIT("timer2", "timer2-parent", &ccu_div_ops, 0),
+	},
+};
+
+static const char * const timer3_parents[] = { "hosc", "rc-clk-16m", "clk-32k", "clk- peri0-200m" };
+
+static struct ccu_div timer3_clk = {
+	.enable		= BIT(31),
+	.div		= _SUNXI_CCU_DIV_FLAGS(0, 3, CLK_DIVIDER_POWER_OF_TWO),
+	.mux		= _SUNXI_CCU_MUX(24, 3),
+	.common		= {
+		.reg		= 0x0730,
+		.hw.init	= CLK_HW_INIT("timer3", "timer3-parent", &ccu_div_ops, 0),
+	},
+};
+
+static const char * const timer4_parents[] = { "hosc", "rc-clk-16m", "clk-32k", "clk- peri0-200m" };
+
+static struct ccu_div timer4_clk = {
+	.enable		= BIT(31),
+	.div		= _SUNXI_CCU_DIV_FLAGS(0, 3, CLK_DIVIDER_POWER_OF_TWO),
+	.mux		= _SUNXI_CCU_MUX(24, 3),
+	.common		= {
+		.reg		= 0x0730,
+		.hw.init	= CLK_HW_INIT("timer4", "timer4-parent", &ccu_div_ops, 0),
+	},
+};
+
+static const char * const timer5_parents[] = { "hosc", "rc-clk-16m", "clk-32k", "clk- peri0-200m" };
+
+static struct ccu_div timer5_clk = {
+	.enable		= BIT(31),
+	.div		= _SUNXI_CCU_DIV_FLAGS(0, 3, CLK_DIVIDER_POWER_OF_TWO),
+	.mux		= _SUNXI_CCU_MUX(24, 3),
+	.common		= {
+		.reg		= 0x0730,
+		.hw.init	= CLK_HW_INIT("timer5", "timer5-parent", &ccu_div_ops, 0),
+	},
+};
+
+static const char * const dram_parents[] = { "pll-ddr", "peri1-600m", "peri1-480m", "peri1-400m", "peri1-150m" };
+
+static SUNXI_CCU_M_WITH_MUX_GATE(dram_clk, "dram",
+                                 dram_parents, 0x0800,
+			         0, 5,	/* M */
+			         24, 3,	/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_PARENT);
+
+static SUNXI_CCU_GATE(nand_mbus_gate_clk, "nand-mbus-gate",
+                      "dcxo24M",
+                      0x0804, BIT(22), 0);
+
+static SUNXI_CCU_GATE(npu_mbus_gate_clk, "npu-mbus-gate",
+                      "dcxo24M",
+                      0x0804, BIT(21), 0);
+
+static SUNXI_CCU_GATE(vid_in_mbus_gate_clk, "vid-in-mbus-gate",
+                      "dcxo24M",
+                      0x0804, BIT(20), 0);
+
+static SUNXI_CCU_GATE(vid_out_mbus_gate_clk, "vid-out-mbus-gate",
+                      "dcxo24M",
+                      0x0804, BIT(19), 0);
+
+static SUNXI_CCU_GATE(ce_mbus_gate_clk, "ce-mbus-gate",
+                      "dcxo24M",
+                      0x0804, BIT(18), 0);
+
+static SUNXI_CCU_GATE(ve_mbus_gate_clk, "ve-mbus-gate",
+                      "dcxo24M",
+                      0x0804, BIT(17), 0);
+
+static SUNXI_CCU_GATE(dma_mbus_gate_clk, "dma-mbus-gate",
+                      "dcxo24M",
+                      0x0804, BIT(16), 0);
+
+static SUNXI_CCU_GATE(bus_dram_clk, "bus-dram",
+                      "dcxo24M",
+                      0x080C, BIT(0), 0);
+
+static const char * const nand0_clk0_parents[] = { "hosc", "peri0-400m", "peri0-300m", "peri1-400m", "peri1-300m" };
+
+static SUNXI_CCU_M_WITH_MUX_GATE(nand0_clk0_clk, "nand0-clk0",
+                                 nand0_clk0_parents, 0x0810,
+			         0, 5,	/* M */
+			         24, 3,	/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_PARENT);
+
+static const char * const nand0_clk1_parents[] = { "hosc", "peri0-400m", "peri0-300m", "peri1-400m", "peri1-300m" };
+
+static SUNXI_CCU_M_WITH_MUX_GATE(nand0_clk1_clk, "nand0-clk1",
+                                 nand0_clk1_parents, 0x0814,
+			         0, 5,	/* M */
+			         24, 3,	/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_PARENT);
+
+static SUNXI_CCU_GATE(nand0_clk, "nand0",
+                      "dcxo24M",
+                      0x082C, BIT(0), 0);
+
+static const char * const smhc0_parents[] = { "hosc", "peri0-400m", "peri0-300m", "peri1-400m", "peri1-300m" };
+
+static SUNXI_CCU_MP_WITH_MUX_GATE_NO_INDEX(smhc0_clk, "smhc0",
+                                           smhc0_parents, 0x0830,
+                                           0, 5,	/* M */
+                                           8, 5,	/* N */
+			                   24, 3,	/* mux */
+					   BIT(31), 0);
+
+static const char * const smhc1_parents[] = { "hosc", "peri0-400m", "peri0-300m", "peri1-400m", "peri1-300m" };
+
+static SUNXI_CCU_MP_WITH_MUX_GATE_NO_INDEX(smhc1_clk, "smhc1",
+                                           smhc1_parents, 0x0834,
+                                           0, 5,	/* M */
+                                           8, 5,	/* N */
+			                   24, 3,	/* mux */
+					   BIT(31), 0);
+
+static const char * const smhc2_parents[] = { "hosc", "peri0-800m", "peri0-600m", "peri1-800m", "peri1-600m" };
+
+static SUNXI_CCU_MP_WITH_MUX_GATE_NO_INDEX(smhc2_clk, "smhc2",
+                                           smhc2_parents, 0x0838,
+                                           0, 5,	/* M */
+                                           8, 5,	/* N */
+			                   24, 3,	/* mux */
+					   BIT(31), 0);
+
+static SUNXI_CCU_GATE(bus_smhc2_clk, "bus-smhc2",
+                      "dcxo24M",
+                      0x084C, BIT(2), 0);
+
+static SUNXI_CCU_GATE(bus_smhc1_clk, "bus-smhc1",
+                      "dcxo24M",
+                      0x084C, BIT(1), 0);
+
+static SUNXI_CCU_GATE(bus_smhc0_clk, "bus-smhc0",
+                      "dcxo24M",
+                      0x084C, BIT(0), 0);
+
+static SUNXI_CCU_GATE(sysdap_clk, "sysdap",
+                      "dcxo24M",
+                      0x088C, BIT(0), 0);
+
+static SUNXI_CCU_GATE(uart7_clk, "uart7",
+                      "dcxo24M",
+                      0x090C, BIT(7), 0);
+
+static SUNXI_CCU_GATE(uart6_clk, "uart6",
+                      "dcxo24M",
+                      0x090C, BIT(6), 0);
+
+static SUNXI_CCU_GATE(uart5_clk, "uart5",
+                      "dcxo24M",
+                      0x090C, BIT(5), 0);
+
+static SUNXI_CCU_GATE(uart4_clk, "uart4",
+                      "dcxo24M",
+                      0x090C, BIT(4), 0);
+
+static SUNXI_CCU_GATE(uart3_clk, "uart3",
+                      "dcxo24M",
+                      0x090C, BIT(3), 0);
+
+static SUNXI_CCU_GATE(uart2_clk, "uart2",
+                      "dcxo24M",
+                      0x090C, BIT(2), 0);
+
+static SUNXI_CCU_GATE(bus_uart1_clk, "bus-uart1",
+                      "dcxo24M",
+                      0x090C, BIT(1), 0);
+
+static SUNXI_CCU_GATE(bus_uart0_clk, "bus-uart0",
+                      "dcxo24M",
+                      0x090C, BIT(0), 0);
+
+static SUNXI_CCU_GATE(twi5_clk, "twi5",
+                      "dcxo24M",
+                      0x091C, BIT(5), 0);
+
+static SUNXI_CCU_GATE(twi4_clk, "twi4",
+                      "dcxo24M",
+                      0x091C, BIT(4), 0);
+
+static SUNXI_CCU_GATE(twi3_clk, "twi3",
+                      "dcxo24M",
+                      0x091C, BIT(3), 0);
+
+static SUNXI_CCU_GATE(twi2_clk, "twi2",
+                      "dcxo24M",
+                      0x091C, BIT(2), 0);
+
+static SUNXI_CCU_GATE(twi1_clk, "twi1",
+                      "dcxo24M",
+                      0x091C, BIT(1), 0);
+
+static SUNXI_CCU_GATE(twi0_clk, "twi0",
+                      "dcxo24M",
+                      0x091C, BIT(0), 0);
+
+static SUNXI_CCU_GATE(can0_clk, "can0",
+                      "dcxo24M",
+                      0x092C, BIT(0), 0);
+
+static const char * const spi0_parents[] = { "hosc", "peri0-300m", "peri0-200m", "peri1-300m", "peri1-200m" };
+
+static SUNXI_CCU_M_WITH_MUX_GATE(spi0_clk, "spi0",
+                                           spi0_parents, 0x0940,
+                                           0, 5,	/* M */
+			                   24, 3,	/* mux */
+					   BIT(31), 0);
+
+static const char * const spi1_parents[] = { "hosc", "peri0-300m", "peri0-200m", "peri1-300m", "peri1-200m" };
+
+static SUNXI_CCU_M_WITH_MUX_GATE(spi1_clk, "spi1",
+                                           spi1_parents, 0x0944,
+                                           0, 5,	/* M */
+			                   24, 3,	/* mux */
+					   BIT(31), 0);
+
+static const char * const spi2_parents[] = { "hosc", "peri0-300m", "peri0-200m", "peri1-300m", "peri1-200m" };
+
+static SUNXI_CCU_M_WITH_MUX_GATE(spi2_clk, "spi2",
+                                           spi2_parents, 0x0948,
+                                           0, 5,	/* M */
+			                   24, 3,	/* mux */
+					   BIT(31), 0);
+
+static const char * const spif_parents[] = { "hosc", "peri0-200m", "peri0-300m", "peri1-200m", "peri1-300m" };
+
+static SUNXI_CCU_MP_WITH_MUX_GATE_NO_INDEX(spif_clk, "spif",
+                                           spif_parents, 0x0950,
+                                           0, 5,	/* M */
+                                           8, 5,	/* N */
+			                   24, 3,	/* mux */
+					   BIT(31), 0);
+
+static SUNXI_CCU_GATE(bus_spif_clk, "bus-spif",
+                      "dcxo24M",
+                      0x096C, BIT(3), 0);
+
+static SUNXI_CCU_GATE(bus_spi2_clk, "bus-spi2",
+                      "dcxo24M",
+                      0x096C, BIT(2), 0);
+
+static SUNXI_CCU_GATE(bus_spi1_clk, "bus-spi1",
+                      "dcxo24M",
+                      0x096C, BIT(1), 0);
+
+static SUNXI_CCU_GATE(bus_spi0_clk, "bus-spi0",
+                      "dcxo24M",
+                      0x096C, BIT(0), 0);
+
+static SUNXI_CCU_GATE(gmac0_25m_clk, "gmac0-25m",
+                      "dcxo24M",
+                      0x0970, BIT(31), 0);
+
+static SUNXI_CCU_GATE(gmac0_25m_clk_src_clk, "gmac0-25m-clk-src",
+                      "dcxo24M",
+                      0x0970, BIT(30), 0);
+
+static SUNXI_CCU_GATE(gmac1_25m_clk, "gmac1-25m",
+                      "dcxo24M",
+                      0x0974, BIT(31), 0);
+
+static SUNXI_CCU_GATE(gmac1_25m_clk_src_clk, "gmac1-25m-clk-src",
+                      "dcxo24M",
+                      0x0974, BIT(30), 0);
+
+static SUNXI_CCU_GATE(gmac1_clk, "gmac1",
+                      "dcxo24M",
+                      0x097C, BIT(1), 0);
+
+static SUNXI_CCU_GATE(gmac0_clk, "gmac0",
+                      "dcxo24M",
+                      0x097C, BIT(0), 0);
+
+static const char * const irrx_parents[] = { "osc32k", "hosc" };
+
+static SUNXI_CCU_M_WITH_MUX_GATE(irrx_clk, "irrx",
+                                 irrx_parents, 0x0990,
+			         0, 5,	/* M */
+			         24, 1,	/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_PARENT);
+
+static SUNXI_CCU_GATE(bus_irrx_clk, "bus-irrx",
+                      "dcxo24M",
+                      0x099C, BIT(0), 0);
+
+static const char * const irtx_parents[] = { "hosc", "peri1-600m" };
+
+static SUNXI_CCU_M_WITH_MUX_GATE(irtx_clk, "irtx",
+                                 irtx_parents, 0x09C0,
+			         0, 5,	/* M */
+			         24, 3,	/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_PARENT);
+
+static SUNXI_CCU_GATE(bus_irtx_clk, "bus-irtx",
+                      "dcxo24M",
+                      0x09CC, BIT(0), 0);
+
+static SUNXI_CCU_GATE(gpadc_24m_clk, "gpadc-24m",
+                      "dcxo24M",
+                      0x09E0, BIT(31), 0);
+
+static SUNXI_CCU_GATE(gpadc_clk, "gpadc",
+                      "dcxo24M",
+                      0x09EC, BIT(0), 0);
+
+static SUNXI_CCU_GATE(ths_clk, "ths",
+                      "dcxo24M",
+                      0x09FC, BIT(0), 0);
+
+static SUNXI_CCU_GATE(usb_clk, "usb",
+                      "dcxo24M",
+                      0x0A70, BIT(31), 0);
+
+static CLK_FIXED_FACTOR(dcxo24M_div_12m_clk, "dcxo24M-div-12m", "dcxo24M", 2, 1, 0);
+
+#define SUN55IW3_USB0_CTRL_REG   0x0A70
+static const char * const usb_parents[] = { "pll-audio0-div-48m", "dcxo24-div-12m", "osc32k", "iosc" };
+
+static SUNXI_CCU_MUX_WITH_GATE(usb0_clk, "usb0", usb_parents, 0x0A70,
+			       24, 2, BIT(31), 0);
+
+#define SUN55IW3_USB1_CTRL_REG   0x0A74
+static SUNXI_CCU_MUX_WITH_GATE(usb1_clk, "usb1", usb_parents, 0x0A74,
+			       24, 2, BIT(31), 0);
+
+static SUNXI_CCU_GATE(usbotg0_clk, "usbotg0",
+                      "dcxo24M",
+                      0x0A8C, BIT(8), 0);
+
+static SUNXI_CCU_GATE(usbehci1_clk, "usbehci1",
+                      "dcxo24M",
+                      0x0A8C, BIT(5), 0);
+
+static SUNXI_CCU_GATE(usbehci0_clk, "usbehci0",
+                      "dcxo24M",
+                      0x0A8C, BIT(4), 0);
+
+static SUNXI_CCU_GATE(usbohci1_clk, "usbohci1",
+                      "dcxo24M",
+                      0x0A8C, BIT(1), 0);
+
+static SUNXI_CCU_GATE(usbohci0_clk, "usbohci0",
+                      "dcxo24M",
+                      0x0A8C, BIT(0), 0);
+
+static SUNXI_CCU_GATE(lradc_clk, "lradc",
+                      "dcxo24M",
+                      0x0A9C, BIT(0), 0);
+
+static const char * const pcie_ref_alt_parents[] = { "hosc", "osc32k" };
+
+static SUNXI_CCU_M_WITH_MUX_GATE(pcie_ref_alt_clk, "pcie-ref-alt",
+                                 pcie_ref_alt_parents, 0x0AA0,
+			         0, 5,	/* M */
+			         24, 1,	/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_PARENT);
+
+static SUNXI_CCU_GATE(pcie_ref_clk, "pcie-ref",
+                      "dcxo24M",
+                      0x0AA4, BIT(31), 0);
+
+static SUNXI_CCU_GATE(pcie_clk, "pcie",
+                      "dcxo24M",
+                      0x0AAC, BIT(0), 0);
+
+static SUNXI_CCU_GATE(dpss_top0_clk, "dpss-top0",
+                      "dcxo24M",
+                      0x0ABC, BIT(0), 0);
+
+static SUNXI_CCU_GATE(dpss_top1_clk, "dpss-top1",
+                      "dcxo24M",
+                      0x0ACC, BIT(0), 0);
+
+static SUNXI_CCU_GATE(hdmi_24m_clk, "hdmi-24m",
+                      "dcxo24M",
+                      0x0B04, BIT(31), 0);
+
+static const char * const hdmi_cec_parents[] = { "osc32k", "hdmi-cec-osc32k" };
+
+static SUNXI_CCU_MUX_WITH_GATE(hdmi_cec_clk, "hdmi-cec",
+                               hdmi_cec_parents, 0x0B10,
+			       24, 1,	/* mux */
+			       BIT(31), 0);
+
+static SUNXI_CCU_GATE(hdmi_clk, "hdmi",
+                      "dcxo24M",
+                      0x0B1C, BIT(0), 0);
+
+static const char * const dsi0_parents[] = { "hosc", "peri0-200m", "peri0-150m" };
+
+static SUNXI_CCU_M_WITH_MUX_GATE(dsi0_clk, "dsi0",
+                                 dsi0_parents, 0x0B24,
+			         0, 5,	/* M */
+			         24, 3,	/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_PARENT);
+
+static const char * const dsi1_parents[] = { "hosc", "peri0-200m", "peri0-150m" };
+
+static SUNXI_CCU_M_WITH_MUX_GATE(dsi1_clk, "dsi1",
+                                 dsi1_parents, 0x0B28,
+			         0, 5,	/* M */
+			         24, 3,	/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_PARENT);
+
+static SUNXI_CCU_GATE(bus_dsi1_clk, "bus-dsi1",
+                      "dcxo24M",
+                      0x0B4C, BIT(1), 0);
+
+static SUNXI_CCU_GATE(bus_dsi0_clk, "bus-dsi0",
+                      "dcxo24M",
+                      0x0B4C, BIT(0), 0);
+
+static const char * const vo0_tconlcd0_parents[] = { "pll-video0-4x", "pll-video1-4x", "pll-video2-4x", "pll-video3-4x", "pll-peri0-2x" };
+
+static SUNXI_CCU_M_WITH_MUX_GATE(vo0_tconlcd0_clk, "vo0-tconlcd0",
+                                 vo0_tconlcd0_parents, 0x0B60,
+			         0, 5,	/* M */
+			         24, 3,	/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_PARENT);
+
+static const char * const vo0_tconlcd1_parents[] = { "pll-video0-4x", "pll-video1-4x", "pll-video2-4x", "pll-video3-4x", "pll-peri0-2x" };
+
+static SUNXI_CCU_M_WITH_MUX_GATE(vo0_tconlcd1_clk, "vo0-tconlcd1",
+                                 vo0_tconlcd1_parents, 0x0B64,
+			         0, 5,	/* M */
+			         24, 3,	/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_PARENT);
+
+static const char * const vo1_tconlcd0_parents[] = { "pll-video0-4x", "pll-video1-4x", "pll-video2-4x", "pll-video3-4x", "pll-peri0-2x" };
+
+static SUNXI_CCU_M_WITH_MUX_GATE(vo1_tconlcd0_clk, "vo1-tconlcd0",
+                                 vo1_tconlcd0_parents, 0x0B68,
+			         0, 5,	/* M */
+			         24, 3,	/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_PARENT);
+
+static const char * const combphy0_parents[] = { "pll-video0-4x", "pll-video1-4x", "pll-video2-4x", "pll-video3-4x", "pll-peri0-2x" };
+
+static SUNXI_CCU_M_WITH_MUX_GATE(combphy0_clk, "combphy0",
+                                 combphy0_parents, 0x0B6C,
+			         0, 5,	/* M */
+			         24, 3,	/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_PARENT);
+
+static const char * const combphy1_parents[] = { "pll-video0-4x", "pll-video1-4x", "pll-video2-4x", "pll-video3-4x", "pll-peri0-2x" };
+
+static SUNXI_CCU_M_WITH_MUX_GATE(combphy1_clk, "combphy1",
+                                 combphy1_parents, 0x0B70,
+			         0, 5,	/* M */
+			         24, 3,	/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_PARENT);
+
+static SUNXI_CCU_GATE(bus_vo1_tconlcd0_clk, "bus-vo1-tconlcd0",
+                      "dcxo24M",
+                      0x0B7C, BIT(2), 0);
+
+static SUNXI_CCU_GATE(bus_vo0_tconlcd1_clk, "bus-vo0-tconlcd1",
+                      "dcxo24M",
+                      0x0B7C, BIT(1), 0);
+
+static SUNXI_CCU_GATE(bus_vo0_tconlcd0_clk, "bus-vo0-tconlcd0",
+                      "dcxo24M",
+                      0x0B7C, BIT(0), 0);
+
+static const char * const tcontv_parents[] = { "pll-video0-4x", "pll-video1-4x", "pll-video2-4x", "pll-video3-4x", "pll-peri0-2x" };
+
+static SUNXI_CCU_M_WITH_MUX_GATE(tcontv_clk, "tcontv",
+                                 tcontv_parents, 0x0B80,
+			         0, 5,	/* M */
+			         24, 3,	/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_PARENT);
+
+static const char * const tcontv1_parents[] = { "pll-video0-4x", "pll-video1-4x", "pll-video2-4x", "pll-video3-4x", "pll-peri0-2x" };
+
+static SUNXI_CCU_M_WITH_MUX_GATE(tcontv1_clk, "tcontv1",
+                                 tcontv1_parents, 0x0B84,
+			         0, 5,	/* M */
+			         24, 3,	/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_PARENT);
+
+static SUNXI_CCU_GATE(bus_tcontv1_clk, "bus-tcontv1",
+                      "dcxo24M",
+                      0x0B9C, BIT(1), 0);
+
+static SUNXI_CCU_GATE(bus_tcontv_clk, "bus-tcontv",
+                      "dcxo24M",
+                      0x0B9C, BIT(0), 0);
+
+static const char * const ledc_parents[] = { "hosc", "peri0-600m" };
+
+static SUNXI_CCU_M_WITH_MUX_GATE(ledc_clk, "ledc",
+                                           ledc_parents, 0x0BF0,
+                                           0, 5,	/* M */
+			                   24, 1,	/* mux */
+					   BIT(31), 0);
+
+static const char * const edp_parents[] = { "pll-video0-4x", "pll-vidio1-4x", "pll-vidio2-4x", "pll-vidio3-4x", "pll-peri0-2x", };
+
+static SUNXI_CCU_M_WITH_MUX_GATE(edp_clk, "edp",
+                                 edp_parents, 0x0BB0,
+			         0, 5,	/* M */
+			         24, 3,	/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_PARENT);
+
+static SUNXI_CCU_GATE(bus_ledc_clk, "bus-ledc",
+                      "dcxo24M",
+                      0x0BFC, BIT(0), 0);
+
+static const char * const csi_parents[] = { "peri0-300m", "peri0-400m", "peri0-480m", "pll-video0-4x", "pll-video3-4x" };
+
+static SUNXI_CCU_M_WITH_MUX_GATE(csi_clk, "csi",
+                                 csi_parents, 0x0C04,
+			         0, 5,	/* M */
+			         24, 3,	/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_PARENT);
+
+static const char * const csi_master0_parents[] = { "hosc", "pll-video3-4x", "pll-video0-4x", "pll-video1-4x", "pll-video2-4x" };
+
+static SUNXI_CCU_MP_WITH_MUX_GATE_NO_INDEX(csi_master0_clk, "csi-master0",
+                                           csi_master0_parents, 0x0C08,
+                                           0, 5,	/* M */
+                                           8, 5,	/* N */
+			                   24, 3,	/* mux */
+					   BIT(31), 0);
+
+static const char * const csi_master1_parents[] = { "hosc", "pll-video3-4x", "pll-video0-4x", "pll-video1-4x", "pll-video2-4x" };
+
+static SUNXI_CCU_MP_WITH_MUX_GATE_NO_INDEX(csi_master1_clk, "csi-master1",
+                                           csi_master1_parents, 0x0C0C,
+                                           0, 5,	/* M */
+                                           8, 5,	/* N */
+			                   24, 3,	/* mux */
+					   BIT(31), 0);
+
+static const char * const csi_master2_parents[] = { "hosc", "pll-video3-4x", "pll-video0-4x", "pll-video1-4x", "pll-video2-4x" };
+
+static SUNXI_CCU_MP_WITH_MUX_GATE_NO_INDEX(csi_master2_clk, "csi-master2",
+                                           csi_master2_parents, 0x0C10,
+                                           0, 5,	/* M */
+                                           8, 5,	/* N */
+			                   24, 3,	/* mux */
+					   BIT(31), 0);
+
+static const char * const csi_master3_parents[] = { "hosc", "pll-video3-4x", "pll-video0-4x", "pll-video1-4x", "pll-video2-4x" };
+
+static SUNXI_CCU_MP_WITH_MUX_GATE_NO_INDEX(csi_master3_clk, "csi-master3",
+                                           csi_master3_parents, 0x0C14,
+                                           0, 5,	/* M */
+                                           8, 5,	/* N */
+			                   24, 3,	/* mux */
+					   BIT(31), 0);
+
+static SUNXI_CCU_GATE(bus_csi_clk, "bus-csi",
+                      "dcxo24M",
+                      0x0C1C, BIT(0), 0);
+
+static const char * const isp_parents[] = { "peri0-300m", "peri0-400m", "pll-video0-4x", "pll-video3-4x" };
+
+static SUNXI_CCU_M_WITH_MUX_GATE(isp_clk, "isp",
+                                 isp_parents, 0x0C20,
+			         0, 5,	/* M */
+			         24, 3,	/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_PARENT);
+
+static const char * const dsp_parents[] = { "hosc", "osc32k", "clk16m-rc", "pll-peri0-2x", "peri0-480m" };
+
+static SUNXI_CCU_M_WITH_MUX_GATE(dsp_clk, "dsp",
+                                 dsp_parents, 0x0C70,
+			         0, 5,	/* M */
+			         24, 3,	/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_PARENT);
+
+static SUNXI_CCU_GATE(cpus_hclk_gate_clk, "cpus-hclk-gate",
+                      "dcxo24M",
+                      0x0E04, BIT(28), 0);
+
+static SUNXI_CCU_GATE(spif_mbus_ahb_gate_clk, "spif-mbus-ahb-gate",
+                      "dcxo24M",
+                      0x0E04, BIT(22), 0);
+
+static SUNXI_CCU_GATE(gmac1_mbus_ahb_gate_clk, "gmac1-mbus-ahb-gate",
+                      "dcxo24M",
+                      0x0E04, BIT(21), 0);
+
+static SUNXI_CCU_GATE(gmac0_mbus_ahb_gate_clk, "gmac0-mbus-ahb-gate",
+                      "dcxo24M",
+                      0x0E04, BIT(20), 0);
+
+static SUNXI_CCU_GATE(smhc2_mbus_ahb_gate_clk, "smhc2-mbus-ahb-gate",
+                      "dcxo24M",
+                      0x0E04, BIT(19), 0);
+
+static SUNXI_CCU_GATE(smhc1_mbus_ahb_gate_clk, "smhc1-mbus-ahb-gate",
+                      "dcxo24M",
+                      0x0E04, BIT(18), 0);
+
+static SUNXI_CCU_GATE(smhc0_mbus_ahb_gate_clk, "smhc0-mbus-ahb-gate",
+                      "dcxo24M",
+                      0x0E04, BIT(17), 0);
+
+static SUNXI_CCU_GATE(usb_mbus_ahb_gate_clk, "usb-mbus-ahb-gate",
+                      "dcxo24M",
+                      0x0E04, BIT(16), 0);
+
+static SUNXI_CCU_GATE(gmac1_ahb_gate_clk, "gmac1-ahb-gate",
+                      "dcxo24M",
+                      0x0E04, BIT(9), 0);
+
+static SUNXI_CCU_GATE(gmac0_ahb_gate_clk, "gmac0-ahb-gate",
+                      "dcxo24M",
+                      0x0E04, BIT(8), 0);
+
+static SUNXI_CCU_GATE(smhc2_ahb_gate_clk, "smhc2-ahb-gate",
+                      "dcxo24M",
+                      0x0E04, BIT(7), 0);
+
+static SUNXI_CCU_GATE(smhc1_ahb_gate_clk, "smhc1-ahb-gate",
+                      "dcxo24M",
+                      0x0E04, BIT(6), 0);
+
+static SUNXI_CCU_GATE(smhc0_ahb_gate_clk, "smhc0-ahb-gate",
+                      "dcxo24M",
+                      0x0E04, BIT(5), 0);
+
+static SUNXI_CCU_GATE(usb_ahb_gate_clk, "usb-ahb-gate",
+                      "dcxo24M",
+                      0x0E04, BIT(4), 0);
+
+static SUNXI_CCU_GATE(vid_out_ahb_gate_clk, "vid-out-ahb-gate",
+                      "dcxo24M",
+                      0x0E04, BIT(3), 0);
+
+static SUNXI_CCU_GATE(vid_in_ahb_gate_clk, "vid-in-ahb-gate",
+                      "dcxo24M",
+                      0x0E04, BIT(2), 0);
+
+static SUNXI_CCU_GATE(ve_ahb_gate_clk, "ve-ahb-gate",
+                      "dcxo24M",
+                      0x0E04, BIT(1), 0);
+
+static SUNXI_CCU_GATE(npu_ahb_gate_clk, "npu-ahb-gate",
+                      "dcxo24M",
+                      0x0E04, BIT(0), 0);
+
+static SUNXI_CCU_GATE(res_dcap_24m_clk, "res-dcap-24m",
+                      "dcxo24M",
+                      0x0E0C, BIT(3), 0);
+
+static SUNXI_CCU_GATE(usb_24m_clk, "usb-24m",
+                      "dcxo24M",
+                      0x0E0C, BIT(0), 0);
+
+static SUNXI_CCU_GATE(fanout_25m_clk, "fanout-25m",
+                      "dcxo24M",
+                      0x0F30, BIT(3), 0);
+
+static SUNXI_CCU_GATE(fanout_16m_clk, "fanout-16m",
+                      "dcxo24M",
+                      0x0F30, BIT(2), 0);
+
+static SUNXI_CCU_GATE(fanout_12m_clk, "fanout-12m",
+                      "dcxo24M",
+                      0x0F30, BIT(1), 0);
+
+static SUNXI_CCU_GATE(fanout_24m_clk, "fanout-24m",
+                      "dcxo24M",
+                      0x0F30, BIT(0), 0);
+
+static const char * const clk27m_fanout_parents[] = { "pll-video0-1x", "pll-video1-1x", "pll-video2-1x","pll-video3-1x" };
+
+static SUNXI_CCU_MP_WITH_MUX_GATE_NO_INDEX(clk27m_fanout_clk, "clk27m_fanout",
+                                           clk27m_fanout_parents, 0x0F34,
+                                           0, 5,	/* M */
+                                           8, 5,	/* N */
+			                   24, 2,	/* mux */
+					   BIT(31), 0);
+
+static const char * const clk_fanout_parents[] = { "apb0" };
+
+static SUNXI_CCU_MP_WITH_MUX_GATE_NO_INDEX(clk_fanout_clk, "clk_fanout",
+                                           clk_fanout_parents, 0x0F38,
+                                           0, 5,	/* M */
+                                           5, 5,	/* N */
+			                   24, 2,	/* mux */
+					   BIT(31), 0);
+
+static const char * const fanout2_clk_parents[] = { "fanout-32k", "osc32k","clk12m", "clk16m", "clk24m", "clk25m", "clk27m", "pclk" };
+
+static SUNXI_CCU_MUX(fanout2_clk, "fanout2", fanout2_clk_parents,
+		     0x0F3C, 6, 3, CLK_SET_RATE_PARENT | CLK_IS_CRITICAL);
+
+static const char * const fanout1_clk_parents[] = { "fanout-32k", "osc32k","clk12m", "clk16m", "clk24m", "clk25m", "clk27m", "pclk" };
+
+static SUNXI_CCU_MUX(fanout1_clk, "fanout1", fanout1_clk_parents,
+		     0x0F3C, 3, 3, CLK_SET_RATE_PARENT | CLK_IS_CRITICAL);
+
+static const char * const fanout0_clk_parents[] = { "fanout-32k", "osc32k","clk12m", "clk16m", "clk24m", "clk25m", "clk27m", "pclk" };
+
+static SUNXI_CCU_MUX(fanout0_clk, "fanout0", fanout0_clk_parents,
+		     0x0F3C, 0, 3, CLK_SET_RATE_PARENT | CLK_IS_CRITICAL);
+
+/* for pm resume */
+#define SUN55IW3_PLL_PERIPH1_PATTERN0_REG	0x128
+static struct ccu_common pll_periph1_pattern0_common = {
+	.reg = 0x128,
+};
+
+/* ccu_des_end */
+
+/* rst_def_start */
+static struct ccu_reset_map sun55iw3_ccu_resets[] = {
+ [RST_MBUS]			= { 0x0540, BIT(30) },
+ [RST_BUS_NSI]			= { 0x054c, BIT(16) },
+ [RST_BUS_DE0]			= { 0x060c, BIT(16) },
+ [RST_BUS_DI]			= { 0x062c, BIT(16) },
+ [RST_BUS_G2D]			= { 0x063c, BIT(16) },
+ [RST_BUS_GPU]			= { 0x067c, BIT(16) },
+ [RST_BUS_CE_SY]		= { 0x068c, BIT(17) },
+ [RST_BUS_CE]			= { 0x068c, BIT(16) },
+ [RST_BUS_VE]			= { 0x069c, BIT(16) },
+ [RST_BUS_DMA]			= { 0x070c, BIT(16) },
+ [RST_BUS_MSGBOX1]		= { 0x071c, BIT(17) },
+ [RST_BUS_MSGBOX0]		= { 0x071c, BIT(16) },
+ [RST_BUS_SPINLOCK]		= { 0x072c, BIT(16) },
+ [RST_BUS_TIME]			= { 0x074c, BIT(16) },
+ [RST_BUS_DBGSY]		= { 0x078c, BIT(16) },
+ [RST_BUS_PWM]			= { 0x07ac, BIT(16) },
+ [RST_BUS_DRAM]			= { 0x080c, BIT(16) },
+ [RST_BUS_NAND0]		= { 0x082c, BIT(16) },
+ [RST_BUS_SMHC2]		= { 0x084c, BIT(18) },
+ [RST_BUS_SMHC1]		= { 0x084c, BIT(17) },
+ [RST_BUS_SMHC0]		= { 0x084c, BIT(16) },
+ [RST_BUS_SYSDAP]		= { 0x088c, BIT(16) },
+ [RST_BUS_UART7]		= { 0x090c, BIT(23) },
+ [RST_BUS_UART6]		= { 0x090c, BIT(22) },
+ [RST_BUS_UART5]		= { 0x090c, BIT(21) },
+ [RST_BUS_UART4]		= { 0x090c, BIT(20) },
+ [RST_BUS_UART3]		= { 0x090c, BIT(19) },
+ [RST_BUS_UART2]		= { 0x090c, BIT(18) },
+ [RST_BUS_UART1]		= { 0x090c, BIT(17) },
+ [RST_BUS_UART0]		= { 0x090c, BIT(16) },
+ [RST_BUS_TWI5]			= { 0x091c, BIT(21) },
+ [RST_BUS_TWI4]			= { 0x091c, BIT(20) },
+ [RST_BUS_TWI3]			= { 0x091c, BIT(19) },
+ [RST_BUS_TWI2]			= { 0x091c, BIT(18) },
+ [RST_BUS_TWI1]			= { 0x091c, BIT(17) },
+ [RST_BUS_TWI0]			= { 0x091c, BIT(16) },
+ [RST_BUS_CAN0]			= { 0x092c, BIT(16) },
+ [RST_BUS_SPIF]			= { 0x096c, BIT(19) },
+ [RST_BUS_SPI2]			= { 0x096c, BIT(18) },
+ [RST_BUS_SPI1]			= { 0x096c, BIT(17) },
+ [RST_BUS_SPI0]			= { 0x096c, BIT(16) },
+ [RST_BUS_GMAC1]		= { 0x097c, BIT(17) },
+ [RST_BUS_GMAC0]		= { 0x097c, BIT(16) },
+ [RST_BUS_IRRX]			= { 0x099c, BIT(16) },
+ [RST_BUS_IRTX]			= { 0x09cc, BIT(16) },
+ [RST_BUS_GPADC]		= { 0x09ec, BIT(16) },
+ [RST_BUS_TH]			= { 0x09fc, BIT(16) },
+ [RST_USB_PHY0_RSTN]		= { 0x0a70, BIT(30) },
+ [RST_USB_PHY1_RSTN]		= { 0x0a74, BIT(30) },
+ [RST_USB_2_PHY]		= { 0x0a8c, BIT(26) },
+ [RST_USB_2]			= { 0x0a8c, BIT(25) },
+ [RST_USB_OTG0]			= { 0x0a8c, BIT(24) },
+ [RST_USB_EHCI1]		= { 0x0a8c, BIT(21) },
+ [RST_USB_EHCI0]		= { 0x0a8c, BIT(20) },
+ [RST_USB_OHCI1]		= { 0x0a8c, BIT(17) },
+ [RST_USB_OHCI0]		= { 0x0a8c, BIT(16) },
+ [RST_BUS_LRADC]		= { 0x0a9c, BIT(16) },
+ [RST_BUS_PCIE_PE]		= { 0x0aac, BIT(18) },
+ [RST_BUS_PCIE_POWER_UP]	= { 0x0aac, BIT(17) },
+ [RST_BUS_PCIE]			= { 0x0aac, BIT(16) },
+ [RST_BUS_DPSS_TOP0]		= { 0x0abc, BIT(16) },
+ [RST_BUS_DPSS_TOP1]		= { 0x0acc, BIT(16) },
+ [RST_BUS_HDMI_SUB]		= { 0x0b1c, BIT(17) },
+ [RST_BUS_HDMI_MAIN]		= { 0x0b1c, BIT(16) },
+ [RST_BUS_DSI1]			= { 0x0b4c, BIT(17) },
+ [RST_BUS_DSI0]			= { 0x0b4c, BIT(16) },
+ [RST_BUS_VO1_TCONLCD0]		= { 0x0b7c, BIT(18) },
+ [RST_BUS_VO0_TCONLCD1]		= { 0x0b7c, BIT(17) },
+ [RST_BUS_VO0_TCONLCD0]		= { 0x0b7c, BIT(16) },
+ [RST_BUS_TCONTV1]		= { 0x0b9c, BIT(17) },
+ [RST_BUS_TCONTV]		= { 0x0b9c, BIT(16) },
+ [RST_BUS_LVDS1]		= { 0x0bac, BIT(17) },
+ [RST_BUS_LVDS0]		= { 0x0bac, BIT(16) },
+ [RST_BUS_LEDC]			= { 0x0bfc, BIT(16) },
+ [RST_BUS_CSI]			= { 0x0c1c, BIT(16) },
+ [RST_BUS_ISP]			= { 0x0c2c, BIT(16) },
+};
+/* rst_def_end */
+
+ /* ccu_def_start */
+static struct clk_hw_onecell_data sun55iw3_hw_clks = {
+        .hws    = {
+		[CLK_PLL_CPU0]			= &pll_cpu0_clk.common.hw,
+		[CLK_PLL_DDR]			= &pll_ddr_clk.common.hw,
+		[CLK_PLL_PERI0_PARENT]		= &pll_peri0_parent_clk.common.hw,
+		[CLK_PLL_PERI0_800M]		= &pll_peri0_800m_clk.common.hw,
+		[CLK_PLL_PERI0_480M]		= &pll_peri0_480m_clk.common.hw,
+		[CLK_PLL_PERI1_PARENT]		= &pll_peri1_parent_clk.common.hw,
+		[CLK_PLL_PERI1_800M]		= &pll_peri1_800m_clk.common.hw,
+		[CLK_PLL_PERI1_480M]		= &pll_peri1_480m_clk.common.hw,
+		[CLK_PLL_GPU]			= &pll_gpu_clk.common.hw,
+		[CLK_PLL_VIDEO0_2X]		= &pll_video0_2x_clk.hw,
+		[CLK_PLL_VIDEO0_1X]		= &pll_video0_1x_clk.hw,
+		[CLK_PLL_VIDEO1_2X]		= &pll_video1_2x_clk.hw,
+		[CLK_PLL_VIDEO1_1X]		= &pll_video1_1x_clk.hw,
+		[CLK_PLL_VIDEO2_2X]		= &pll_video2_2x_clk.hw,
+		[CLK_PLL_VIDEO2_1X]		= &pll_video2_1x_clk.hw,
+		[CLK_PLL_VE]			= &pll_ve_clk.common.hw,
+		[CLK_PLL_VIDEO3_2X]		= &pll_video3_2x_clk.hw,
+		[CLK_PLL_VIDEO3_1X]		= &pll_video3_1x_clk.hw,
+		[CLK_PLL_NPU_2X]		= &pll_npu_2x_clk.hw,
+		[CLK_PLL_NPU_1X]		= &pll_npu_1x_clk.hw,
+		[CLK_CPU]			= &cpu_clk.common.hw,
+		[CLK_CPU_AXI]			= &cpu_axi_clk.common.hw,
+		[CLK_CPU_APB]			= &cpu_apb_clk.common.hw,
+		[CLK_CPU_PERI]			= &cpu_peri_clk.common.hw,
+		[CLK_TRACE]			= &trace_clk.common.hw,
+		[CLK_DSU_PARENTS]		= &dsu_parents_clk.common.hw,
+		[CLK_AHB]			= &ahb_clk.common.hw,
+		[CLK_APB0]			= &apb0_clk.common.hw,
+		[CLK_APB1]			= &apb1_clk.common.hw,
+		[CLK_MBUS]			= &mbus_clk.common.hw,
+		[CLK_NSI]			= &nsi_clk.common.hw,
+		[CLK_GIC]			= &gic_clk.common.hw,
+		[CLK_DE]			= &de_clk.common.hw,
+		[CLK_DE0]			= &de0_clk.common.hw,
+		[CLK_DI]			= &di_clk.common.hw,
+		[CLK_BUS_DI]			= &bus_di_clk.common.hw,
+		[CLK_G2D]			= &g2d_clk.common.hw,
+		[CLK_BUS_G2D]			= &bus_g2d_clk.common.hw,
+		[CLK_CPU_CORE]			= &cpu_core_clk.common.hw,
+		[CLK_GPU]			= &gpu_clk.common.hw,
+		[CLK_CE]			= &ce_clk.common.hw,
+		[CLK_CE_SYS]			= &ce_sys_clk.common.hw,
+		[CLK_BUS_CE]			= &bus_ce_clk.common.hw,
+		[CLK_VE]			= &ve_clk.common.hw,
+		[CLK_BUS_VE]			= &bus_ve_clk.common.hw,
+		[CLK_NPU]			= &npu_clk.common.hw,
+		[CLK_DMA]			= &dma_clk.common.hw,
+		[CLK_MSGBOX1]			= &msgbox1_clk.common.hw,
+		[CLK_MSGBOX0]			= &msgbox0_clk.common.hw,
+		[CLK_SPINLOCK]			= &spinlock_clk.common.hw,
+		[CLK_TIMER]			= &timer_clk.common.hw,
+		[CLK_DBGSYS]			= &dbgsys_clk.common.hw,
+		[CLK_PWM]			= &pwm_clk.common.hw,
+		[CLK_IOMMU]			= &iommu_clk.common.hw,
+		[CLK_TIMER0]			= &timer0_clk.common.hw,
+		[CLK_TIMER1]			= &timer1_clk.common.hw,
+		[CLK_TIMER2]			= &timer2_clk.common.hw,
+		[CLK_TIMER3]			= &timer3_clk.common.hw,
+		[CLK_TIMER4]			= &timer4_clk.common.hw,
+		[CLK_TIMER5]			= &timer5_clk.common.hw,
+		[CLK_DRAM]			= &dram_clk.common.hw,
+		[CLK_NAND_MBUS_GATE]		= &nand_mbus_gate_clk.common.hw,
+		[CLK_NPU_MBUS_GATE]		= &npu_mbus_gate_clk.common.hw,
+		[CLK_VID_IN_MBUS_GATE]		= &vid_in_mbus_gate_clk.common.hw,
+		[CLK_VID_OUT_MBUS_GATE]		= &vid_out_mbus_gate_clk.common.hw,
+		[CLK_CE_MBUS_GATE]		= &ce_mbus_gate_clk.common.hw,
+		[CLK_VE_MBUS_GATE]		= &ve_mbus_gate_clk.common.hw,
+		[CLK_DMA_MBUS_GATE]		= &dma_mbus_gate_clk.common.hw,
+		[CLK_BUS_DRAM]			= &bus_dram_clk.common.hw,
+		[CLK_NAND0]			= &nand0_clk.common.hw,
+		[CLK_NAND0_CLK0]		= &nand0_clk0_clk.common.hw,
+		[CLK_NAND0_CLK1]		= &nand0_clk1_clk.common.hw,
+		[CLK_SMHC0]			= &smhc0_clk.common.hw,
+		[CLK_SMHC1]			= &smhc1_clk.common.hw,
+		[CLK_SMHC2]			= &smhc2_clk.common.hw,
+		[CLK_BUS_SMHC2]			= &bus_smhc2_clk.common.hw,
+		[CLK_BUS_SMHC1]			= &bus_smhc1_clk.common.hw,
+		[CLK_BUS_SMHC0]			= &bus_smhc0_clk.common.hw,
+		[CLK_SYSDAP]			= &sysdap_clk.common.hw,
+		[CLK_UART7]			= &uart7_clk.common.hw,
+		[CLK_UART6]			= &uart6_clk.common.hw,
+		[CLK_UART5]			= &uart5_clk.common.hw,
+		[CLK_UART4]			= &uart4_clk.common.hw,
+		[CLK_UART3]			= &uart3_clk.common.hw,
+		[CLK_UART2]			= &uart2_clk.common.hw,
+		[CLK_BUS_UART1]			= &bus_uart1_clk.common.hw,
+		[CLK_BUS_UART0]			= &bus_uart0_clk.common.hw,
+		[CLK_TWI5]			= &twi5_clk.common.hw,
+		[CLK_TWI4]			= &twi4_clk.common.hw,
+		[CLK_TWI3]			= &twi3_clk.common.hw,
+		[CLK_TWI2]			= &twi2_clk.common.hw,
+		[CLK_TWI1]			= &twi1_clk.common.hw,
+		[CLK_TWI0]			= &twi0_clk.common.hw,
+		[CLK_CAN0]			= &can0_clk.common.hw,
+		[CLK_SPI0]			= &spi0_clk.common.hw,
+		[CLK_SPI1]			= &spi1_clk.common.hw,
+		[CLK_SPI2]			= &spi2_clk.common.hw,
+		[CLK_SPIF]			= &spif_clk.common.hw,
+		[CLK_BUS_SPIF]			= &bus_spif_clk.common.hw,
+		[CLK_BUS_SPI2]			= &bus_spi2_clk.common.hw,
+		[CLK_BUS_SPI1]			= &bus_spi1_clk.common.hw,
+		[CLK_BUS_SPI0]			= &bus_spi0_clk.common.hw,
+		[CLK_GMAC0_25M]			= &gmac0_25m_clk.common.hw,
+		[CLK_GMAC0_25M_CLK_SRC]		= &gmac0_25m_clk_src_clk.common.hw,
+		[CLK_GMAC1_25M]			= &gmac1_25m_clk.common.hw,
+		[CLK_GMAC1_25M_CLK_SRC]		= &gmac1_25m_clk_src_clk.common.hw,
+		[CLK_GMAC1]			= &gmac1_clk.common.hw,
+		[CLK_GMAC0]			= &gmac0_clk.common.hw,
+		[CLK_IRRX]			= &irrx_clk.common.hw,
+		[CLK_BUS_IRRX]			= &bus_irrx_clk.common.hw,
+		[CLK_IRTX]			= &irtx_clk.common.hw,
+		[CLK_BUS_IRTX]			= &bus_irtx_clk.common.hw,
+		[CLK_GPADC_24M]			= &gpadc_24m_clk.common.hw,
+		[CLK_GPADC]			= &gpadc_clk.common.hw,
+		[CLK_THS]			= &ths_clk.common.hw,
+		[CLK_USB]			= &usb_clk.common.hw,
+		[CLK_USB0]			= &usb0_clk.common.hw,
+		[CLK_USB1]			= &usb1_clk.common.hw,
+		[CLK_USBOTG0]			= &usbotg0_clk.common.hw,
+		[CLK_USBEHCI1]			= &usbehci1_clk.common.hw,
+		[CLK_USBEHCI0]			= &usbehci0_clk.common.hw,
+		[CLK_USBOHCI1]			= &usbohci1_clk.common.hw,
+		[CLK_USBOHCI0]			= &usbohci0_clk.common.hw,
+		[CLK_LRADC]			= &lradc_clk.common.hw,
+		[CLK_PCIE_REF_ALT]		= &pcie_ref_alt_clk.common.hw,
+		[CLK_PCIE_REF]			= &pcie_ref_clk.common.hw,
+		[CLK_PCIE]			= &pcie_clk.common.hw,
+		[CLK_DPSS_TOP0]			= &dpss_top0_clk.common.hw,
+		[CLK_DPSS_TOP1]			= &dpss_top1_clk.common.hw,
+		[CLK_HDMI_24M]			= &hdmi_24m_clk.common.hw,
+		[CLK_HDMI_CEC]			= &hdmi_cec_clk.common.hw,
+		[CLK_HDMI]			= &hdmi_clk.common.hw,
+		[CLK_DSI0]			= &dsi0_clk.common.hw,
+		[CLK_DSI1]			= &dsi1_clk.common.hw,
+		[CLK_BUS_DSI1]			= &bus_dsi1_clk.common.hw,
+		[CLK_BUS_DSI0]			= &bus_dsi0_clk.common.hw,
+		[CLK_VO0_TCONLCD0]		= &vo0_tconlcd0_clk.common.hw,
+		[CLK_VO0_TCONLCD1]		= &vo0_tconlcd1_clk.common.hw,
+		[CLK_VO1_TCONLCD0]		= &vo1_tconlcd0_clk.common.hw,
+		[CLK_COMBPHY0]			= &combphy0_clk.common.hw,
+		[CLK_COMBPHY1]			= &combphy1_clk.common.hw,
+		[CLK_BUS_VO1_TCONLCD0]		= &bus_vo1_tconlcd0_clk.common.hw,
+		[CLK_BUS_VO0_TCONLCD1]		= &bus_vo0_tconlcd1_clk.common.hw,
+		[CLK_BUS_VO0_TCONLCD0]		= &bus_vo0_tconlcd0_clk.common.hw,
+		[CLK_TCONTV]			= &tcontv_clk.common.hw,
+		[CLK_TCONTV1]			= &tcontv1_clk.common.hw,
+		[CLK_BUS_TCONTV1]		= &bus_tcontv1_clk.common.hw,
+		[CLK_BUS_TCONTV]		= &bus_tcontv_clk.common.hw,
+		[CLK_LEDC]			= &ledc_clk.common.hw,
+		[CLK_EDP]			= &edp_clk.common.hw,
+		[CLK_BUS_LEDC]			= &bus_ledc_clk.common.hw,
+		[CLK_CSI]			= &csi_clk.common.hw,
+		[CLK_CSI_MASTER0]		= &csi_master0_clk.common.hw,
+		[CLK_CSI_MASTER1]		= &csi_master1_clk.common.hw,
+		[CLK_CSI_MASTER2]		= &csi_master2_clk.common.hw,
+		[CLK_CSI_MASTER3]		= &csi_master3_clk.common.hw,
+		[CLK_BUS_CSI]			= &bus_csi_clk.common.hw,
+		[CLK_ISP]			= &isp_clk.common.hw,
+		[CLK_DSP]			= &dsp_clk.common.hw,
+		[CLK_CPUS_HCLK_GATE]		= &cpus_hclk_gate_clk.common.hw,
+		[CLK_SPIF_MBUS_AHB_GATE]		= &spif_mbus_ahb_gate_clk.common.hw,
+		[CLK_GMAC1_MBUS_AHB_GATE]		= &gmac1_mbus_ahb_gate_clk.common.hw,
+		[CLK_GMAC0_MBUS_AHB_GATE]		= &gmac0_mbus_ahb_gate_clk.common.hw,
+		[CLK_SMHC2_MBUS_AHB_GATE]		= &smhc2_mbus_ahb_gate_clk.common.hw,
+		[CLK_SMHC1_MBUS_AHB_GATE]		= &smhc1_mbus_ahb_gate_clk.common.hw,
+		[CLK_SMHC0_MBUS_AHB_GATE]		= &smhc0_mbus_ahb_gate_clk.common.hw,
+		[CLK_USB_MBUS_AHB_GATE]		= &usb_mbus_ahb_gate_clk.common.hw,
+		[CLK_GMAC1_AHB_GATE]		= &gmac1_ahb_gate_clk.common.hw,
+		[CLK_GMAC0_AHB_GATE]		= &gmac0_ahb_gate_clk.common.hw,
+		[CLK_SMHC2_AHB_GATE]		= &smhc2_ahb_gate_clk.common.hw,
+		[CLK_SMHC1_AHB_GATE]		= &smhc1_ahb_gate_clk.common.hw,
+		[CLK_SMHC0_AHB_GATE]		= &smhc0_ahb_gate_clk.common.hw,
+		[CLK_USB_AHB_GATE]		= &usb_ahb_gate_clk.common.hw,
+		[CLK_VID_OUT_AHB_GATE]		= &vid_out_ahb_gate_clk.common.hw,
+		[CLK_VID_IN_AHB_GATE]		= &vid_in_ahb_gate_clk.common.hw,
+		[CLK_VE_AHB_GATE]		= &ve_ahb_gate_clk.common.hw,
+		[CLK_NPU_AHB_GATE]		= &npu_ahb_gate_clk.common.hw,
+		[CLK_FANOUT_25M]		= &fanout_25m_clk.common.hw,
+		[CLK_FANOUT_16M]		= &fanout_16m_clk.common.hw,
+		[CLK_FANOUT_12M]		= &fanout_12m_clk.common.hw,
+		[CLK_FANOUT_24M]		= &fanout_24m_clk.common.hw,
+		[CLK_CLK27M_FANOUT]		= &clk27m_fanout_clk.common.hw,
+		[CLK_CLK_FANOUT]		= &clk_fanout_clk.common.hw,
+		[CLK_FANOUT2]			= &fanout2_clk.common.hw,
+		[CLK_FANOUT1]			= &fanout1_clk.common.hw,
+		[CLK_FANOUT0]			= &fanout0_clk.common.hw,
+        },
+        .num = CLK_NUMBER,
+};
+/* ccu_def_end */
+
+static struct ccu_common *sun55iw3_ccu_clks[] = {
+	&pll_cpu0_clk.common,
+	&pll_ddr_clk.common,
+	&pll_peri0_parent_clk.common,
+	&pll_peri0_800m_clk.common,
+	&pll_peri0_480m_clk.common,
+	&pll_peri1_parent_clk.common,
+	&pll_peri1_800m_clk.common,
+	&pll_peri1_480m_clk.common,
+	&pll_gpu_clk.common,
+	&pll_ve_clk.common,
+	&cpu_clk.common,
+	&cpu_axi_clk.common,
+	&cpu_apb_clk.common,
+	&cpu_peri_clk.common,
+	&trace_clk.common,
+	&dsu_parents_clk.common,
+	&ahb_clk.common,
+	&apb0_clk.common,
+	&apb1_clk.common,
+	&mbus_clk.common,
+	&nsi_clk.common,
+	&gic_clk.common,
+	&de_clk.common,
+	&de0_clk.common,
+	&di_clk.common,
+	&bus_di_clk.common,
+	&g2d_clk.common,
+	&bus_g2d_clk.common,
+	&cpu_core_clk.common,
+	&gpu_clk.common,
+	&ce_clk.common,
+	&ce_sys_clk.common,
+	&bus_ce_clk.common,
+	&ve_clk.common,
+	&bus_ve_clk.common,
+	&npu_clk.common,
+	&dma_clk.common,
+	&msgbox1_clk.common,
+	&msgbox0_clk.common,
+	&spinlock_clk.common,
+	&timer_clk.common,
+	&dbgsys_clk.common,
+	&pwm_clk.common,
+	&iommu_clk.common,
+	&timer0_clk.common,
+	&timer1_clk.common,
+	&timer2_clk.common,
+	&timer3_clk.common,
+	&timer4_clk.common,
+	&timer5_clk.common,
+	&dram_clk.common,
+	&nand_mbus_gate_clk.common,
+	&npu_mbus_gate_clk.common,
+	&vid_in_mbus_gate_clk.common,
+	&vid_out_mbus_gate_clk.common,
+	&ce_mbus_gate_clk.common,
+	&ve_mbus_gate_clk.common,
+	&dma_mbus_gate_clk.common,
+	&bus_dram_clk.common,
+	&nand0_clk.common,
+	&nand0_clk0_clk.common,
+	&nand0_clk.common,
+	&nand0_clk.common,
+	&nand0_clk1_clk.common,
+	&nand0_clk.common,
+	&nand0_clk.common,
+	&smhc0_clk.common,
+	&smhc1_clk.common,
+	&smhc2_clk.common,
+	&bus_smhc2_clk.common,
+	&bus_smhc1_clk.common,
+	&bus_smhc0_clk.common,
+	&sysdap_clk.common,
+	&uart7_clk.common,
+	&uart6_clk.common,
+	&uart5_clk.common,
+	&uart4_clk.common,
+	&uart3_clk.common,
+	&uart2_clk.common,
+	&bus_uart1_clk.common,
+	&bus_uart0_clk.common,
+	&twi5_clk.common,
+	&twi4_clk.common,
+	&twi3_clk.common,
+	&twi2_clk.common,
+	&twi1_clk.common,
+	&twi0_clk.common,
+	&can0_clk.common,
+	&spi0_clk.common,
+	&spi1_clk.common,
+	&spi2_clk.common,
+	&spif_clk.common,
+	&bus_spif_clk.common,
+	&bus_spi2_clk.common,
+	&bus_spi1_clk.common,
+	&bus_spi0_clk.common,
+	&gmac0_25m_clk.common,
+	&gmac0_25m_clk_src_clk.common,
+	&gmac1_25m_clk.common,
+	&gmac1_25m_clk_src_clk.common,
+	&gmac1_clk.common,
+	&gmac0_clk.common,
+	&irrx_clk.common,
+	&bus_irrx_clk.common,
+	&irtx_clk.common,
+	&bus_irtx_clk.common,
+	&gpadc_24m_clk.common,
+	&gpadc_clk.common,
+	&ths_clk.common,
+	&usb_clk.common,
+	&usb0_clk.common,
+	&usb1_clk.common,
+	&usbotg0_clk.common,
+	&usbehci1_clk.common,
+	&usbehci0_clk.common,
+	&usbohci1_clk.common,
+	&usbohci0_clk.common,
+	&lradc_clk.common,
+	&pcie_ref_alt_clk.common,
+	&pcie_ref_clk.common,
+	&pcie_clk.common,
+	&dpss_top0_clk.common,
+	&dpss_top1_clk.common,
+	&hdmi_24m_clk.common,
+	&hdmi_cec_clk.common,
+	&hdmi_clk.common,
+	&dsi0_clk.common,
+	&dsi1_clk.common,
+	&bus_dsi1_clk.common,
+	&bus_dsi0_clk.common,
+	&vo0_tconlcd0_clk.common,
+	&vo0_tconlcd1_clk.common,
+	&vo1_tconlcd0_clk.common,
+	&combphy0_clk.common,
+	&combphy1_clk.common,
+	&bus_vo1_tconlcd0_clk.common,
+	&bus_vo0_tconlcd1_clk.common,
+	&bus_vo0_tconlcd0_clk.common,
+	&tcontv_clk.common,
+	&tcontv1_clk.common,
+	&bus_tcontv1_clk.common,
+	&bus_tcontv_clk.common,
+	&ledc_clk.common,
+	&edp_clk.common,
+	&bus_ledc_clk.common,
+	&csi_clk.common,
+	&csi_master0_clk.common,
+	&csi_master1_clk.common,
+	&csi_master2_clk.common,
+	&csi_master3_clk.common,
+	&bus_csi_clk.common,
+	&isp_clk.common,
+	&dsp_clk.common,
+	&cpus_hclk_gate_clk.common,
+	&spif_mbus_ahb_gate_clk.common,
+	&gmac1_mbus_ahb_gate_clk.common,
+	&gmac0_mbus_ahb_gate_clk.common,
+	&smhc2_mbus_ahb_gate_clk.common,
+	&smhc1_mbus_ahb_gate_clk.common,
+	&smhc0_mbus_ahb_gate_clk.common,
+	&usb_mbus_ahb_gate_clk.common,
+	&gmac1_ahb_gate_clk.common,
+	&gmac0_ahb_gate_clk.common,
+	&smhc2_ahb_gate_clk.common,
+	&smhc1_ahb_gate_clk.common,
+	&smhc0_ahb_gate_clk.common,
+	&usb_ahb_gate_clk.common,
+	&vid_out_ahb_gate_clk.common,
+	&vid_in_ahb_gate_clk.common,
+	&ve_ahb_gate_clk.common,
+	&npu_ahb_gate_clk.common,
+	&fanout_25m_clk.common,
+	&fanout_16m_clk.common,
+	&fanout_12m_clk.common,
+	&fanout_24m_clk.common,
+	&clk27m_fanout_clk.common,
+	&clk_fanout_clk.common,
+	&fanout2_clk.common,
+	&fanout2_clk.common,
+	&fanout1_clk.common,
+	&fanout1_clk.common,
+	&fanout0_clk.common,
+	&fanout0_clk.common,
+};
+
+static const struct sunxi_ccu_desc sun55iw3_ccu_desc = {
+	.ccu_clks	= sun55iw3_ccu_clks,
+	.num_ccu_clks	= ARRAY_SIZE(sun55iw3_ccu_clks),
+
+	.hw_clks	= &sun55iw3_hw_clks,
+
+	.resets		= sun55iw3_ccu_resets,
+	.num_resets	= ARRAY_SIZE(sun55iw3_ccu_resets),
+};
+
+static const u32 sun55iw3_pll_regs[] = {
+	SUN55IW3_PLL_CPU0_CTRL_REG,
+	SUN55IW3_PLL_CPU1_CTRL_REG,
+	SUN55IW3_PLL_CPU2_CTRL_REG,
+	SUN55IW3_PLL_DDR_CTRL_REG,
+	SUN55IW3_PLL_PERI0_CTRL_REG,
+	SUN55IW3_PLL_PERI1_CTRL_REG,
+	SUN55IW3_PLL_GPU_CTRL_REG,
+	SUN55IW3_PLL_VIDEO0_CTRL_REG,
+	SUN55IW3_PLL_VIDEO1_CTRL_REG,
+	SUN55IW3_PLL_VIDEO2_CTRL_REG,
+	SUN55IW3_PLL_VE_CTRL_REG,
+	SUN55IW3_PLL_VIDEO3_CTRL_REG,
+	SUN55IW3_PLL_AUDIO0_REG,
+	SUN55IW3_PLL_NPU_CTRL_REG,
+};
+
+static const u32 sun55iw3_pll_video_regs[] = {
+	SUN55IW3_PLL_VIDEO0_CTRL_REG,
+	SUN55IW3_PLL_VIDEO1_CTRL_REG,
+	SUN55IW3_PLL_VIDEO2_CTRL_REG,
+};
+
+static const u32 sun55iw3_usb_clk_regs[] = {
+	SUN55IW3_USB0_CTRL_REG,
+	SUN55IW3_USB1_CTRL_REG,
+};
+
+static int sun55iw3_ccu_probe(struct platform_device *pdev)
+{
+	void __iomem *reg;
+	int ret;
+	int i;
+
+	reg = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(reg))
+		return PTR_ERR(reg);
+
+	/* Enable the lock bits on all PLLs */
+	for (i = 0; i < ARRAY_SIZE(sun55iw3_pll_regs); i++) {
+		set_reg(reg + sun55iw3_pll_regs[i], 1, 1, 29);
+	}
+
+	/*
+	 * In order to pass the EMI certification, the SDM function of
+	 * the peripheral 1 bus is enabled, and the frequency is still
+	 * calculated using the previous division factor.
+	 */
+	set_reg(reg + SUN55IW3_PLL_PERIPH1_PATTERN0_REG, 0xd1303333, 32, 0);
+	set_reg(reg +SUN55IW3_PLL_PERI1_CTRL_REG, 1, 1, 24);
+
+	/*
+	 * Force the output divider of video PLLs to 0.
+	 *
+	 * See the comment before pll-video0 definition for the reason.
+	 */
+	for (i = 0; i < ARRAY_SIZE(sun55iw3_pll_video_regs); i++) {
+		set_reg(reg + sun55iw3_pll_video_regs[i], 0x0, 1, 0);
+	}
+
+	/* Enforce m1 = 0, m0 = 1 for Audio PLL */
+	set_reg(reg + SUN55IW3_PLL_AUDIO0_REG, 0x1, 2, 0);
+
+	for (i = 0; i < ARRAY_SIZE(sun55iw3_usb_clk_regs); i++) {
+		set_reg(reg + sun55iw3_usb_clk_regs[i], 0x0, 2, 24);
+	}
+
+	ret = sunxi_ccu_probe(pdev->dev.of_node, reg, &sun55iw3_ccu_desc);
+	if (ret)
+		return ret;
+
+	sunxi_ccu_sleep_init(reg, sun55iw3_ccu_clks,
+			     ARRAY_SIZE(sun55iw3_ccu_clks),
+			     NULL, 0);
+
+	return 0;
+}
+
+static const struct of_device_id sun55iw3_ccu_ids[] = {
+	{ .compatible = "allwinner,sun55iw3-ccu" },
+	{ }
+};
+
+static struct platform_driver sun55iw3_ccu_driver = {
+	.probe	= sun55iw3_ccu_probe,
+	.driver	= {
+		.name	= "sun55iw3-ccu",
+		.of_match_table	= sun55iw3_ccu_ids,
+	},
+};
+
+static int __init sunxi_ccu_sun55iw3_init(void)
+{
+	return platform_driver_register(&sun55iw3_ccu_driver);
+}
+core_initcall(sunxi_ccu_sun55iw3_init);
+
+static void __exit sunxi_ccu_sun55iw3_exit(void)
+{
+	return platform_driver_unregister(&sun55iw3_ccu_driver);
+}
+module_exit(sunxi_ccu_sun55iw3_exit);
+
+MODULE_DESCRIPTION("Allwinner sun55iw3 clk driver");
+MODULE_LICENSE("GPL v3");
+MODULE_VERSION("1.0.1");
diff --git a/drivers/clk/sunxi-ng/ccu-sun55iw3.h b/drivers/clk/sunxi-ng/ccu-sun55iw3.h
new file mode 100644
index 000000000..21cefcacf
--- /dev/null
+++ b/drivers/clk/sunxi-ng/ccu-sun55iw3.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021 liujuan1@allwinnertech.com
+ */
+
+#ifndef _CCU_SUN55IW3_H_
+#define _CCU_SUN55IW3_H_
+
+#include <dt-bindings/clock/sun55iw3-ccu.h>
+#include <dt-bindings/reset/sun55iw3-ccu.h>
+
+#define CLK_NUMBER		(CLK_MAX_NO + 1)
+
+#endif /* _CCU_SUN55IW3_H_ */
diff --git a/drivers/clk/sunxi-ng/ccu-sun8iw20-r.c b/drivers/clk/sunxi-ng/ccu-sun8iw20-r.c
new file mode 100644
index 000000000..47b87f92f
--- /dev/null
+++ b/drivers/clk/sunxi-ng/ccu-sun8iw20-r.c
@@ -0,0 +1,162 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2020 huangzhenwei@allwinnertech.com
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+
+#include "ccu_common.h"
+#include "ccu_reset.h"
+
+#include "ccu_div.h"
+#include "ccu_gate.h"
+#include "ccu_mp.h"
+#include "ccu_nm.h"
+
+#include "ccu-sun8iw20-r.h"
+
+static const char * const ahbs_apbs0_parents[] = { "dcxo24M", "osc32k",
+						   "iosc", "pll-periph0-div3" };
+static SUNXI_CCU_MP_WITH_MUX(r_ahb_clk, "r-ahb",
+			     ahbs_apbs0_parents, 0x000,
+			     0, 5,
+			     8, 2,
+			     24, 3,
+			     0);
+
+static SUNXI_CCU_MP_WITH_MUX(r_apb0_clk, "r-apb0",
+			     ahbs_apbs0_parents, 0x00c,
+			     0, 5,
+			     8, 2,
+			     24, 3,
+			     0);
+
+static SUNXI_CCU_GATE(r_apb0_timer_clk, "r-apb0-timer", "r-apb0",
+		      0x11c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(r_apb0_twd_clk, "r-apb0-twd", "r-apb0",
+		      0x12c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(r_ppu_clk, "r-ppu", "r-apb0",
+		      0x1ac, BIT(0), 0);
+
+static const char * const r_apb0_ir_rx_parents[] = { "osc32k", "dcxo24M" };
+static SUNXI_CCU_MP_WITH_MUX_GATE(r_apb0_ir_rx_clk, "r-apb0-ir-rx",
+				  r_apb0_ir_rx_parents, 0x1c0,
+				  0, 5,		/* M */
+				  8, 2,		/* P */
+				  24, 2,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_GATE(r_apb0_bus_ir_rx_clk, "r-apb0-bus-ir-rx", "r-apb0",
+		      0x1cc, BIT(0), 0);
+
+static SUNXI_CCU_GATE(r_ahb_bus_rtc_clk, "r-ahb-rtc", "r-ahb",
+		      0x20c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(r_apb0_cpucfg_clk, "r-apb0-cpucfg", "r-apb0",
+		      0x22c, BIT(0), 0);
+
+static struct ccu_common *sun8iw20_r_ccu_clks[] = {
+	&r_ahb_clk.common,
+	&r_apb0_clk.common,
+	&r_apb0_timer_clk.common,
+	&r_apb0_twd_clk.common,
+	&r_ppu_clk.common,
+	&r_apb0_ir_rx_clk.common,
+	&r_apb0_bus_ir_rx_clk.common,
+	&r_ahb_bus_rtc_clk.common,
+	&r_apb0_cpucfg_clk.common,
+};
+
+static struct clk_hw_onecell_data sun8iw20_r_hw_clks = {
+	.hws	= {
+		[CLK_R_AHB]		= &r_ahb_clk.common.hw,
+		[CLK_R_APB0]		= &r_apb0_clk.common.hw,
+		[CLK_R_APB0_TIMER]	= &r_apb0_timer_clk.common.hw,
+		[CLK_R_APB0_TWD]	= &r_apb0_twd_clk.common.hw,
+		[CLK_R_PPU]		= &r_ppu_clk.common.hw,
+		[CLK_R_APB0_IRRX]	= &r_apb0_ir_rx_clk.common.hw,
+		[CLK_R_APB0_BUS_IRRX]	= &r_apb0_bus_ir_rx_clk.common.hw,
+		[CLK_R_AHB_BUS_RTC]	= &r_ahb_bus_rtc_clk.common.hw,
+		[CLK_R_APB0_CPUCFG]	= &r_apb0_cpucfg_clk.common.hw,
+	},
+	.num	= CLK_NUMBER,
+};
+
+static struct ccu_reset_map sun8iw20_r_ccu_resets[] = {
+	[RST_R_APB0_TIMER]	=  { 0x11c, BIT(16) },
+	[RST_R_APB0_TWD]	=  { 0x12c, BIT(16) },
+	[RST_R_PPU]		=  { 0x1ac, BIT(16) },
+	[RST_R_APB0_BUS_IRRX]	=  { 0x1cc, BIT(16) },
+	[RST_R_AHB_BUS_RTC]	=  { 0x20c, BIT(16) },
+	[RST_R_APB0_CPUCFG]	=  { 0x22c, BIT(16) },
+};
+
+static const struct sunxi_ccu_desc sun8iw20_r_ccu_desc = {
+	.ccu_clks	= sun8iw20_r_ccu_clks,
+	.num_ccu_clks	= ARRAY_SIZE(sun8iw20_r_ccu_clks),
+
+	.hw_clks	= &sun8iw20_r_hw_clks,
+
+	.resets		= sun8iw20_r_ccu_resets,
+	.num_resets	= ARRAY_SIZE(sun8iw20_r_ccu_resets),
+};
+
+static int sun8iw20_r_ccu_probe(struct platform_device *pdev)
+{
+	void __iomem *reg;
+	int ret;
+
+	reg = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(reg))
+		return PTR_ERR(reg);
+
+	ret = sunxi_ccu_probe(pdev->dev.of_node, reg, &sun8iw20_r_ccu_desc);
+	if (ret)
+		return ret;
+
+	sunxi_ccu_sleep_init(reg, sun8iw20_r_ccu_clks,
+			     ARRAY_SIZE(sun8iw20_r_ccu_clks),
+			     NULL, 0);
+
+	return 0;
+}
+
+static const struct of_device_id sun8iw20_r_ccu_ids[] = {
+	{ .compatible = "allwinner,sun8iw20-r-ccu" },
+	{ .compatible = "allwinner,sun20iw1-r-ccu" },
+	{ }
+};
+
+static struct platform_driver sun8iw20_r_ccu_driver = {
+	.probe	= sun8iw20_r_ccu_probe,
+	.driver	= {
+		.name	= "sun8iw20-r-ccu",
+		.of_match_table	= sun8iw20_r_ccu_ids,
+	},
+};
+
+static int __init sunxi_r_ccu_sun8iw20_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&sun8iw20_r_ccu_driver);
+	if (ret)
+		pr_err("register ccu sun8iw20 failed\n");
+
+	return ret;
+}
+core_initcall(sunxi_r_ccu_sun8iw20_init);
+
+static void __exit sunxi_r_ccu_sun8iw20_exit(void)
+{
+	return platform_driver_unregister(&sun8iw20_r_ccu_driver);
+}
+module_exit(sunxi_r_ccu_sun8iw20_exit);
+
+MODULE_VERSION("0.5.0");
diff --git a/drivers/clk/sunxi-ng/ccu-sun8iw20-r.h b/drivers/clk/sunxi-ng/ccu-sun8iw20-r.h
new file mode 100644
index 000000000..c0469c58c
--- /dev/null
+++ b/drivers/clk/sunxi-ng/ccu-sun8iw20-r.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2020 frank@allwinnertech.com
+ */
+
+#ifndef _CCU_SUN8IW20_R_H
+#define _CCU_SUN8IW20_R_H
+
+#include <dt-bindings/clock/sun8iw20-r-ccu.h>
+#include <dt-bindings/reset/sun8iw20-r-ccu.h>
+
+#define CLK_NUMBER	(CLK_R_MAX_NO + 1)
+
+#endif /* _CCU_SUN8IW20_R_H */
diff --git a/drivers/clk/sunxi-ng/ccu-sun8iw20-rtc.c b/drivers/clk/sunxi-ng/ccu-sun8iw20-rtc.c
new file mode 100644
index 000000000..608cf8cbe
--- /dev/null
+++ b/drivers/clk/sunxi-ng/ccu-sun8iw20-rtc.c
@@ -0,0 +1,194 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * sunxi RTC ccu driver
+ *
+ * Copyright (c) 2020, DaLv <lvda@allwinnertech.com>
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/io.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/module.h>
+
+#include "ccu_common.h"
+#include "ccu_reset.h"
+#include "ccu_div.h"
+#include "ccu_gate.h"
+#include "ccu_mp.h"
+#include "ccu_mult.h"
+#include "ccu_nk.h"
+#include "ccu_nkm.h"
+#include "ccu_nkmp.h"
+#include "ccu_nm.h"
+#include "ccu_phase.h"
+
+#include "ccu-sun8iw20-rtc.h"
+
+/*
+ * iosc clk:
+ */
+static SUNXI_CCU_GATE(iosc_clk, "iosc", "rc-16m", 0x160, BIT(0), 0);
+
+static SUNXI_CCU_GATE_WITH_KEY(ext32k_gate_clk, "ext32k-gate",
+			       "ext-32k", 0x0,
+			       KEY_FIELD_MAGIC_NUM_RTC,
+			       BIT(4), 0);
+
+static CLK_FIXED_FACTOR(iosc_div32k_clk, "iosc-div32k", "iosc", 500, 1, 0);
+
+/*
+ * osc32k clk(losc)
+ */
+static const char * const osc32k_parents[] = { "iosc-div32k", "ext32k-gate" };
+static SUNXI_CCU_MUX_WITH_GATE_KEY(osc32k_clk, "osc32k", osc32k_parents,
+				   0x0, 0, 1,
+				   KEY_FIELD_MAGIC_NUM_RTC, 0, 0);
+
+static SUNXI_CCU_GATE_WITH_FIXED_RATE(dcxo24M_div32k_clk, "dcxo24M-div32k",
+				      "dcxo24M", 0x60,
+				      32768, BIT(16));
+/*
+ * rtc-1k clock
+ */
+static const char * const rtc32k_clk_parents[] = { "osc32k", "dcxo24M-div32k"};
+static SUNXI_CCU_MUX_WITH_GATE_KEY(rtc32k_clk, "rtc32k", rtc32k_clk_parents,
+				   0x0, 1, 1,
+				   KEY_FIELD_MAGIC_NUM_RTC, 0, 0);
+static CLK_FIXED_FACTOR(rtc_1k_clk, "rtc-1k", "rtc32k", 32, 1, 0);
+
+/* rtc-32k-fanout: only for debug */
+static const char * const rtc_32k_fanout_clk_parents[] = { "osc32k", "ext32k-gate",
+							   "dcxo24M-div32k"};
+static SUNXI_CCU_MUX_WITH_GATE(rtc_32k_fanout_clk, "rtc-32k-fanout",
+			       rtc_32k_fanout_clk_parents, 0x60, 1,
+			       2, BIT(0), 0);
+
+/* TODO: should add the div func */
+static SUNXI_CCU_GATE(rtc_spi_clk, "rtc-spi", "r-ahb", 0x310, BIT(31), 0);
+
+static struct ccu_common *sun8iw20_rtc_ccu_clks[] = {
+	&iosc_clk.common,
+	&ext32k_gate_clk.common,
+	&osc32k_clk.common,
+	&dcxo24M_div32k_clk.common,
+	&rtc32k_clk.common,
+	&rtc_32k_fanout_clk.common,
+	&rtc_spi_clk.common,
+};
+
+static struct clk_hw_onecell_data sun8iw20_rtc_ccu_hw_clks = {
+	.hws	= {
+		[CLK_IOSC]			= &iosc_clk.common.hw,
+		[CLK_EXT32K_GATE]		= &ext32k_gate_clk.common.hw,
+		[CLK_IOSC_DIV32K]		= &iosc_div32k_clk.hw,
+		[CLK_OSC32K]			= &osc32k_clk.common.hw,
+		[CLK_DCXO24M_DIV32K]		= &dcxo24M_div32k_clk.common.hw,
+		[CLK_RTC32K]			= &rtc32k_clk.common.hw,
+		[CLK_RTC_1K]			= &rtc_1k_clk.hw,
+		[CLK_RTC_32K_FANOUT]		= &rtc_32k_fanout_clk.common.hw,
+		[CLK_RTC_SPI]			= &rtc_spi_clk.common.hw,
+	},
+	.num	= CLK_NUMBER,
+};
+
+static const struct sunxi_ccu_desc sun8iw20_rtc_ccu_desc = {
+	.ccu_clks	= sun8iw20_rtc_ccu_clks,
+	.num_ccu_clks	= ARRAY_SIZE(sun8iw20_rtc_ccu_clks),
+
+	.hw_clks	= &sun8iw20_rtc_ccu_hw_clks,
+};
+
+static void clock_source_init(char __iomem *base)
+{
+	/* (1) enable DCXO */
+	/* by default, DCXO_EN = 1. We don't have to do this... */
+	set_reg(base + XO_CTRL_REG, 0x1, 1, 1);
+
+	/* (2) enable auto switch function */
+	/*
+	 * In some cases, we boot with auto switch function disabled, and try to
+	 * enable the auto switch function by rebooting.
+	 * But the rtc default value does not change unless vcc-rtc is loss.
+	 * So we should not rely on the default value of reg.
+	 * BIT(14): LOSC auto switch 32k clk source sel enable. 1: enable
+	 * BIT(15): LOSC auto switch function disable. 1: disable
+	 */
+	set_reg_key(base + LOSC_CTRL_REG,
+		    KEY_FIELD_MAGIC_NUM_RTC >> 16, 16, 16,
+		    0x1, 2, 14);
+
+	/* (3) set the parent of osc32k-sys to ext-osc32k */
+	set_reg_key(base + LOSC_CTRL_REG,
+		    KEY_FIELD_MAGIC_NUM_RTC >> 16, 16, 16,
+		    0x1, 1, 0);
+
+	/* (4) set the parent of osc32k-out to osc32k-sys */
+	/* by default, LOSC_OUT_SRC_SEL = 0x0. We don't have to do this... */
+	set_reg(base + LOSC_OUT_GATING_REG,
+		0x0, 2, 1);
+}
+
+static int sun8iw20_rtc_ccu_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct device *dev = &pdev->dev;
+	void __iomem *reg;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(dev, "Fail to get IORESOURCE_MEM\n");
+		return -EINVAL;
+	}
+
+	/*
+	 * Don't use devm_ioremap_resource() here! Or else the RTC driver will
+	 * not able to get the same resource later in rtc-sunxi.c.
+	 */
+	reg = devm_ioremap(dev, res->start, resource_size(res));
+	if (IS_ERR(reg)) {
+		dev_err(dev, "Fail to map IO resource\n");
+		return PTR_ERR(reg);
+	}
+
+	clock_source_init(reg);
+
+	return sunxi_ccu_probe(pdev->dev.of_node, reg, &sun8iw20_rtc_ccu_desc);
+}
+
+static const struct of_device_id sun8iw20_rtc_ccu_ids[] = {
+	{ .compatible = "allwinner,sun8iw20-rtc-ccu" },
+	{ .compatible = "allwinner,sun20iw1-rtc-ccu" },
+	{ }
+};
+
+static struct platform_driver sun8iw20_rtc_ccu_driver = {
+	.probe	= sun8iw20_rtc_ccu_probe,
+	.driver	= {
+		.name	= "sun8iw20-rtc-ccu",
+		.of_match_table	= sun8iw20_rtc_ccu_ids,
+	},
+};
+
+static int __init sun8iw20_rtc_ccu_init(void)
+{
+	int err;
+
+	err = platform_driver_register(&sun8iw20_rtc_ccu_driver);
+	if (err)
+		pr_err("Fail to register sunxi_rtc_ccu as platform device\n");
+
+	return err;
+}
+core_initcall(sun8iw20_rtc_ccu_init);
+
+static void __exit sun8iw20_rtc_ccu_exit(void)
+{
+	platform_driver_unregister(&sun8iw20_rtc_ccu_driver);
+}
+module_exit(sun8iw20_rtc_ccu_exit);
+
+MODULE_DESCRIPTION("sunxi RTC CCU driver");
+MODULE_AUTHOR("Da Lv <lvda@allwinnertech.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION("1.1.0");
diff --git a/drivers/clk/sunxi-ng/ccu-sun8iw20-rtc.h b/drivers/clk/sunxi-ng/ccu-sun8iw20-rtc.h
new file mode 100644
index 000000000..42e50eb9a
--- /dev/null
+++ b/drivers/clk/sunxi-ng/ccu-sun8iw20-rtc.h
@@ -0,0 +1,18 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2020 lvda@allwinnertech.com
+ */
+
+#ifndef _CCU_SUN50IW9_RTC_H_
+#define _CCU_SUN50IW9_RTC_H_
+
+#include <dt-bindings/clock/sun8iw20-rtc.h>
+
+#define LOSC_CTRL_REG			0x00
+#define KEY_FIELD_MAGIC_NUM_RTC		0x16AA0000
+#define LOSC_OUT_GATING_REG		0x60  /* Or: 32K_FOUT_CTRL_GATING_REG */
+#define XO_CTRL_REG			0x160
+
+#define CLK_NUMBER			(CLK_RTC_MAX_NO + 1)
+
+#endif /* _CCU_SUN50IW9_RTC_H_ */
diff --git a/drivers/clk/sunxi-ng/ccu-sun8iw20.c b/drivers/clk/sunxi-ng/ccu-sun8iw20.c
new file mode 100644
index 000000000..427687699
--- /dev/null
+++ b/drivers/clk/sunxi-ng/ccu-sun8iw20.c
@@ -0,0 +1,1325 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2020 huangzhenwei@allwinnertech.com
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+
+#include "ccu_common.h"
+#include "ccu_reset.h"
+
+#include "ccu_div.h"
+#include "ccu_gate.h"
+#include "ccu_mp.h"
+#include "ccu_mult.h"
+#include "ccu_nk.h"
+#include "ccu_nkm.h"
+#include "ccu_nkmp.h"
+#include "ccu_nm.h"
+
+#include "ccu-sun8iw20.h"
+
+/* ccu_des_start */
+/*
+ * The CPU PLL is actually NP clock, with P being /1, /2 or /4. However
+ * P should only be used for output frequencies lower than 288 MHz.
+ *
+ * For now we can just model it as a multiplier clock, and force P to /1.
+ *
+ * The M factor is present in the register's description, but not in the
+ * frequency formula, and it's documented as "M is only used for backdoor
+ * testing", so it's not modelled and then force to 0.
+ */
+#define SUN8IW20_PLL_CPUX_REG		0x000
+static struct ccu_mult pll_cpux_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.mult		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.common		= {
+		.reg		= 0x000,
+		.hw.init	= CLK_HW_INIT("pll-cpux", "dcxo24M",
+					      &ccu_mult_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+/* Some PLLs are input * N / div1 / P. Model them as NKMP with no K */
+#define SUN8IW20_PLL_DDR0_REG		0x010
+static struct ccu_nkmp pll_ddr0_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.p		= _SUNXI_CCU_DIV(0, 1), /* output divider */
+	.common		= {
+		.reg		= 0x010,
+		.hw.init	= CLK_HW_INIT("pll-ddr0", "dcxo24M",
+					      &ccu_nkmp_ops,
+					      CLK_SET_RATE_UNGATE |
+					      CLK_IS_CRITICAL),
+	},
+};
+
+#define SUN8IW20_PLL_PERIPH0_REG	0x020
+static struct ccu_nm pll_periph0_parent_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.common		= {
+		.reg		= 0x020,
+		.hw.init	= CLK_HW_INIT("pll-periph0-parent", "dcxo24M",
+					      &ccu_nm_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+static SUNXI_CCU_M(pll_periph0_2x_clk, "pll-periph0-2x",
+		   "pll-periph0-parent", 0x020, 16, 3, 0);
+
+static SUNXI_CCU_M(pll_periph0_800m_clk, "pll-periph0-800m",
+		   "pll-periph0-parent", 0x020, 20, 3, 0);
+
+/*
+ * For Video PLLs, the output divider is described as "used for testing"
+ * in the user manual. So it's not modelled and forced to 0.
+ */
+#define SUN8IW20_PLL_VIDEO0_REG	0x040
+static struct ccu_nm pll_video0_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.fixed_post_div	= 4,
+	.min_rate	= 288000000,
+	.max_rate	= 2400000000UL,
+	.common		= {
+		.reg		= 0x040,
+		.features	= CCU_FEATURE_FIXED_POSTDIV,
+		.hw.init	= CLK_HW_INIT("pll-video0", "dcxo24M",
+					      &ccu_nm_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+#define SUN8IW20_PLL_VIDEO1_REG	0x048
+static struct ccu_nm pll_video1_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.fixed_post_div	= 4,
+	.min_rate	= 288000000,
+	.max_rate	= 2400000000UL,
+	.common		= {
+		.reg		= 0x048,
+		.features	= CCU_FEATURE_FIXED_POSTDIV,
+		.hw.init	= CLK_HW_INIT("pll-video1", "dcxo24M",
+					      &ccu_nm_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+#define SUN8IW20_PLL_VE_REG		0x058
+static struct ccu_nkmp pll_ve_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1), /* input divider */
+	.p		= _SUNXI_CCU_DIV(0, 1), /* output divider */
+	.common		= {
+		.reg		= 0x058,
+		.hw.init	= CLK_HW_INIT("pll-ve", "dcxo24M",
+					      &ccu_nkmp_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+/*
+ * The Audio PLL has m0, m1 dividers in addition to the usual N, M
+ * factors. Since we only need 4 frequencies from this PLL: 22.5792 MHz,
+ * 24.576 MHz, 90.3168MHz and 98.304MHz ignore them for now.
+ * Enforce the default for them, which is d1 = 0, d2 = 1.
+ */
+#define SUN8IW20_PLL_AUDIO0_REG		0x078
+static struct ccu_sdm_setting pll_audio0_sdm_table[] = {
+	{ .rate = 45158400, .pattern = 0xc001bcd3, .m = 18, .n = 33 },
+	{ .rate = 49152000, .pattern = 0xc001eb85, .m = 20, .n = 40 },
+	{ .rate = 180633600, .pattern = 0xc001288d, .m = 3, .n = 22 },
+	{ .rate = 196608000, .pattern = 0xc001eb85, .m = 5, .n = 40 },
+};
+
+static struct ccu_nm pll_audio0_4x_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(16, 6),
+	.fixed_post_div	= 2,
+	.sdm		= _SUNXI_CCU_SDM(pll_audio0_sdm_table, BIT(24),
+					 0x178, BIT(31)),
+	.common		= {
+		.reg		= 0x078,
+		.features	= CCU_FEATURE_FIXED_POSTDIV |
+				  CCU_FEATURE_SIGMA_DELTA_MOD,
+		.hw.init	= CLK_HW_INIT("pll-audio0-4x", "dcxo24M",
+					      &ccu_nm_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+
+/*
+ * PLL_AUDIO1 don't need Fractional-N. The output is usually 614.4M for audio
+ * The codec-adc or dac should be divided by themself to output the 24.576M
+ */
+#define SUN8IW20_PLL_AUDIO1_REG		0x080
+static struct ccu_nm pll_audio1_clk = {
+	.enable		= BIT(27),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT_MIN(8, 8, 12),
+	.m		= _SUNXI_CCU_DIV(1, 1),
+	.common		= {
+		.reg		= 0x080,
+		.hw.init	= CLK_HW_INIT("pll-audio1", "dcxo24M",
+					      &ccu_nm_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
+static SUNXI_CCU_M(pll_audio1_div2_clk, "pll-audio1-div2", "pll-audio1", 0x080, 16, 3, 0);
+static SUNXI_CCU_M(pll_audio1_div5_clk, "pll-audio1-div5", "pll-audio1", 0x080, 20, 3, 0);
+
+static struct clk_div_table pll_cpux_div_table[] = {
+	{ .val = 0, .div = 1 },
+	{ .val = 1, .div = 2 },
+	{ .val = 2, .div = 4 },
+	{ /* Sentinel */ },
+};
+/* TODO: do not use P unless cpux-clk under 288Mhz */
+static SUNXI_CCU_DIV_TABLE(pll_cpux_div, "pll-cpux-div",
+			   "pll-cpux", 0x500, 16, 2,
+			   pll_cpux_div_table, CLK_SET_RATE_PARENT);
+
+static const char * const cpux_parents[] = { "dcxo24M", "osc32k",
+					     "iosc", "pll-cpux-div",
+					     "pll-periph0", "pll-periph0-2x",
+					     "pll-periph0-800M" };
+
+static SUNXI_CCU_MUX(cpux_clk, "cpux", cpux_parents,
+		     0x500, 24, 3, CLK_SET_RATE_PARENT | CLK_IS_CRITICAL);
+
+static SUNXI_CCU_M(axi_clk, "axi", "cpux", 0x500, 0, 2, 0);
+
+static SUNXI_CCU_M(apb_clk, "apb", "cpux", 0x500, 8, 2, 0);
+
+static const char * const psi_ahb_parents[] = { "dcxo24M", "osc32k",
+						"iosc", "pll-periph0" };
+static SUNXI_CCU_MP_WITH_MUX(psi_ahb_clk, "psi-ahb",
+			     psi_ahb_parents,
+			     0x510,
+			     0, 2,	/* M */
+			     8, 2,	/* P */
+			     24, 2,	/* mux */
+			     0);
+
+static const char * const apb0_apb1_parents[] = { "dcxo24M", "osc32k",
+						  "psi-ahb", "pll-periph0" };
+static SUNXI_CCU_MP_WITH_MUX(apb0_clk, "apb0", apb0_apb1_parents, 0x520,
+			     0, 5,	/* M */
+			     8, 2,	/* P */
+			     24, 2,	/* mux */
+			     0);
+
+static SUNXI_CCU_MP_WITH_MUX(apb1_clk, "apb1", apb0_apb1_parents, 0x524,
+			     0, 5,	/* M */
+			     8, 2,	/* P */
+			     24, 2,	/* mux */
+			     0);
+
+static const char * const de_di_g2d_parents[] = { "pll-periph0-2x", "pll-video0-4x",
+						  "pll-video1-4x", "pll-audio1-div2" };
+static SUNXI_CCU_M_WITH_MUX_GATE(de0_clk, "de0", de_di_g2d_parents, 0x600,
+				 0, 5,		/* M */
+				 24, 3,		/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_PARENT);
+
+static SUNXI_CCU_GATE(bus_de0_clk, "bus-de0", "psi-ahb",
+		      0x60c, BIT(0), 0);
+
+static SUNXI_CCU_M_WITH_MUX_GATE(di_clk, "di", de_di_g2d_parents, 0x620,
+				 0, 5,		/* M */
+				 24, 3,		/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_PARENT);
+
+static SUNXI_CCU_GATE(bus_di_clk, "bus-di", "psi-ahb",
+		      0x62c, BIT(0), 0);
+
+static SUNXI_CCU_M_WITH_MUX_GATE(g2d_clk, "g2d",
+				 de_di_g2d_parents,
+				 0x630,
+				 0, 5,		/* M */
+				 24, 3,		/* mux */
+				 BIT(31),	/* gate */
+				 0);
+
+static SUNXI_CCU_GATE(bus_g2d_clk, "bus-g2d", "psi-ahb",
+		      0x63c, BIT(0), 0);
+
+static const char * const ce_parents[] = { "dcxo24M", "pll-periph0-2x",
+					   "pll-periph0" };
+static SUNXI_CCU_MP_WITH_MUX_GATE(ce_clk, "ce", ce_parents, 0x680,
+				  0, 4,		/* M */
+				  8, 2,		/* P */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_GATE(bus_ce_clk, "bus-ce", "psi-ahb",
+		      0x68c, BIT(0), 0);
+
+static const char * const ve_parents[] = { "pll-ve", "pll-periph0-2x" };
+static SUNXI_CCU_M_WITH_MUX_GATE(ve_clk, "ve", ve_parents, 0x690,
+				 0, 5,		/* M */
+				 24, 1,		/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_PARENT);
+
+static SUNXI_CCU_GATE(bus_ve_clk, "bus-ve", "psi-ahb",
+		      0x69c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_dma_clk, "bus-dma", "psi-ahb",
+		      0x70c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_msgbox0_clk, "bus-msgbox0", "psi-ahb",
+		      0x71c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_msgbox1_clk, "bus-msgbox1", "psi-ahb",
+		      0x71c, BIT(1), 0);
+
+static SUNXI_CCU_GATE(bus_msgbox2_clk, "bus-msgbox2", "psi-ahb",
+		      0x71c, BIT(2), 0);
+
+static SUNXI_CCU_GATE(bus_spinlock_clk, "bus-spinlock", "psi-ahb",
+		      0x72c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_hstimer_clk, "bus-hstimer", "psi-ahb",
+		      0x73c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(avs_clk, "avs", "dcxo24M", 0x740, BIT(31), 0);
+
+static SUNXI_CCU_GATE(bus_dbg_clk, "bus-dbg", "psi-ahb",
+		      0x78c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_pwm_clk, "bus-pwm", "apb0", 0x7ac, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_iommu_clk, "bus-iommu", "apb0", 0x7bc, BIT(0), 0);
+
+static const char * const dram_parents[] = { "pll-ddr0", "pll-audio1-div2",
+					     "pll-periph0-2x", "pll-periph0-800m" };
+static SUNXI_CCU_MP_WITH_MUX_GATE(dram_clk, "dram-clk",
+				  dram_parents, 0x800,
+				  0, 2,			/* M */
+				  8, 2,			/* P */
+				  24, 2,		/* MUX */
+				  BIT(31), 0);
+
+static SUNXI_CCU_GATE(mbus_dma_clk, "mbus-dma", "mbus",
+		      0x804, BIT(0), 0);
+static SUNXI_CCU_GATE(mbus_ve_clk, "mbus-ve", "mbus",
+		      0x804, BIT(1), 0);
+static SUNXI_CCU_GATE(mbus_ce_clk, "mbus-ce", "mbus",
+		      0x804, BIT(2), 0);
+static SUNXI_CCU_GATE(mbus_tvin_clk, "mbus-tvin", "mbus",
+		      0x804, BIT(7), 0);
+static SUNXI_CCU_GATE(mbus_csi_clk, "mbus-csi", "mbus",
+		      0x804, BIT(8), 0);
+static SUNXI_CCU_GATE(mbus_g2d_clk, "mbus-g2d", "mbus",
+		      0x804, BIT(10), 0);
+
+static SUNXI_CCU_GATE(bus_dram_clk, "bus-dram", "psi-ahb",
+		      0x80c, BIT(0), CLK_IS_CRITICAL);
+
+/* don't use postdiv for bsp kernel */
+static const char * const mmc0_mmc1_parents[] = { "dcxo24M", "pll-periph0",
+						  "pll-periph0-2x", "pll-audio1-div2" };
+static SUNXI_CCU_MP_WITH_MUX_GATE(mmc0_clk, "mmc0", mmc0_mmc1_parents, 0x830,
+				  0, 4,		/* M */
+				  8, 2,		/* N->P */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  CLK_SET_RATE_NO_REPARENT);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(mmc1_clk, "mmc1", mmc0_mmc1_parents, 0x834,
+				  0, 4,		/* M */
+				  8, 2,		/* N */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  CLK_SET_RATE_NO_REPARENT);
+
+static const char * const mmc2_parents[] = { "dcxo24M", "pll-periph0",
+					     "pll-periph0-2x", "pll-periph0-800m",
+					     "pll-audio1-div2" };
+static SUNXI_CCU_MP_WITH_MUX_GATE(mmc2_clk, "mmc2", mmc2_parents, 0x838,
+				  0, 4,		/* M */
+				  8, 2,		/* N */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  CLK_SET_RATE_NO_REPARENT);
+
+static SUNXI_CCU_GATE(bus_mmc0_clk, "bus-mmc0", "psi-ahb", 0x84c, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_mmc1_clk, "bus-mmc1", "psi-ahb", 0x84c, BIT(1), 0);
+static SUNXI_CCU_GATE(bus_mmc2_clk, "bus-mmc2", "psi-ahb", 0x84c, BIT(2), 0);
+
+static SUNXI_CCU_GATE(bus_uart0_clk, "bus-uart0", "apb1", 0x90c, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_uart1_clk, "bus-uart1", "apb1", 0x90c, BIT(1), 0);
+static SUNXI_CCU_GATE(bus_uart2_clk, "bus-uart2", "apb1", 0x90c, BIT(2), 0);
+static SUNXI_CCU_GATE(bus_uart3_clk, "bus-uart3", "apb1", 0x90c, BIT(3), 0);
+static SUNXI_CCU_GATE(bus_uart4_clk, "bus-uart4", "apb1", 0x90c, BIT(4), 0);
+static SUNXI_CCU_GATE(bus_uart5_clk, "bus-uart5", "apb1", 0x90c, BIT(5), 0);
+
+static SUNXI_CCU_GATE(bus_i2c0_clk, "bus-i2c0", "apb1", 0x91c, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_i2c1_clk, "bus-i2c1", "apb1", 0x91c, BIT(1), 0);
+static SUNXI_CCU_GATE(bus_i2c2_clk, "bus-i2c2", "apb1", 0x91c, BIT(2), 0);
+static SUNXI_CCU_GATE(bus_i2c3_clk, "bus-i2c3", "apb1", 0x91c, BIT(3), 0);
+
+static SUNXI_CCU_GATE(bus_can0_clk, "bus-can0", "apb1", 0x92c, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_can1_clk, "bus-can1", "apb1", 0x92c, BIT(1), 0);
+
+static const char * const spi_parents[] = { "dcxo24M", "pll-periph0",
+					    "pll-periph0-2x", "pll-audio1-div2",
+					    "pll-audio1-div5" };
+static SUNXI_CCU_MP_WITH_MUX_GATE(spi0_clk, "spi0", spi_parents, 0x940,
+				  0, 4,		/* M */
+				  8, 2,		/* N */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(spi1_clk, "spi1", spi_parents, 0x944,
+				  0, 4,		/* M */
+				  8, 2,		/* N */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_GATE(bus_spi0_clk, "bus-spi0", "psi-ahb", 0x96c, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_spi1_clk, "bus-spi1", "psi-ahb", 0x96c, BIT(1), 0);
+
+static SUNXI_CCU_GATE(emac0_25m_clk, "emac0-25m", "pll-periph0", 0x970,
+		      BIT(31) | BIT(30), 0);
+
+static SUNXI_CCU_GATE(bus_emac0_clk, "bus-emac0", "psi-ahb", 0x97c, BIT(0), 0);
+
+static const char * const ir_parents[] = { "dcxo24M", "pll-periph0" };
+static SUNXI_CCU_MP_WITH_MUX_GATE(ir_tx_clk, "ir-tx", ir_parents, 0x9c0,
+				  0, 4,		/* M */
+				  8, 2,		/* N */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_GATE(bus_ir_tx_clk, "bus-ir-tx", "apb0", 0x9cc, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_gpadc_clk, "bus-gpadc", "apb0", 0x9ec, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_ths_clk, "bus-ths", "apb0", 0x9fc, BIT(0), 0);
+
+static const char * const i2s_spdif_tx_parents[] = { "pll-audio0", "pll-audio0-4x",
+						    "pll-audio1-div2", "pll-audio1-div5" };
+static SUNXI_CCU_MP_WITH_MUX_GATE(i2s0_clk, "i2s0", i2s_spdif_tx_parents, 0xa10,
+				  0, 5,		/* M */
+				  8, 2,		/* N */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(i2s1_clk, "i2s1", i2s_spdif_tx_parents, 0xa14,
+				  0, 5,		/* M */
+				  8, 2,		/* N */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(i2s2_clk, "i2s2", i2s_spdif_tx_parents, 0xa18,
+				  0, 5,		/* M */
+				  8, 2,		/* N */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static const char * const i2s2_asrc_parents[] = { "pll-audio0-4x", "pll-periph0",
+						  "pll-audio1-div2", "pll-audio1-div5" };
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(i2s2_asrc_clk, "i2s2-asrc", i2s2_asrc_parents, 0xa1c,
+				  0, 5,		/* M */
+				  8, 2,		/* N */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_GATE(bus_i2s0_clk, "bus-i2s0", "apb1", 0xa20, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_i2s1_clk, "bus-i2s1", "apb1", 0xa20, BIT(1), 0);
+static SUNXI_CCU_GATE(bus_i2s2_clk, "bus-i2s2", "apb1", 0xa20, BIT(2), 0);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(spdif_tx_clk, "spdif-tx", i2s_spdif_tx_parents, 0xa24,
+				  0, 5,		/* M */
+				  8, 2,		/* N */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static const char * const spdif_rx_parents[] = { "pll-periph0", "pll-audio1-div2",
+						 "pll-audio1-div5" };
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(spdif_rx_clk, "spdif-rx", spdif_rx_parents, 0xa28,
+				  0, 5,		/* M */
+				  8, 2,		/* N */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_GATE(bus_spdif_clk, "bus-spdif", "apb0", 0xa2c, BIT(0), 0);
+
+static const char * const dmic_codec_parents[] = { "pll-audio0", "pll-audio1-div2",
+						   "pll-audio1-div5" };
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(dmic_clk, "dmic", dmic_codec_parents, 0xa40,
+				  0, 5,		/* M */
+				  8, 2,		/* N */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_GATE(bus_dmic_clk, "bus-dmic", "apb0", 0xa4c, BIT(0), 0);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(audio_codec_dac_clk, "audio-codec-dac", dmic_codec_parents, 0xa50,
+				  0, 5,		/* M */
+				  8, 2,		/* N */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  CLK_SET_RATE_NO_REPARENT);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(audio_codec_adc_clk, "audio-codec-adc", dmic_codec_parents, 0xa54,
+				  0, 5,		/* M */
+				  8, 2,		/* N */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  CLK_SET_RATE_NO_REPARENT);
+
+static SUNXI_CCU_GATE(bus_audio_codec_clk, "bus-audio-codec", "apb0", 0xa5c, BIT(0), 0);
+
+/*
+ * There are OHCI 12M clock source selection bits for 2 USB 2.0 ports.
+ * We will force them to 0 (12M divided from 48M).
+ */
+#define SUN8IW20_USB0_CLK_REG		0xa70
+#define SUN8IW20_USB1_CLK_REG		0xa74
+
+static SUNXI_CCU_GATE(usb_ohci0_clk, "usb-ohci0", "osc12M", 0xa70, BIT(31), 0);
+
+static SUNXI_CCU_GATE(usb_ohci1_clk, "usb-ohci1", "osc12M", 0xa74, BIT(31), 0);
+
+static SUNXI_CCU_GATE(bus_ohci0_clk, "bus-ohci0", "psi-ahb", 0xa8c, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_ohci1_clk, "bus-ohci1", "psi-ahb", 0xa8c, BIT(1), 0);
+static SUNXI_CCU_GATE(bus_ehci0_clk, "bus-ehci0", "psi-ahb", 0xa8c, BIT(4), 0);
+static SUNXI_CCU_GATE(bus_ehci1_clk, "bus-ehci1", "psi-ahb", 0xa8c, BIT(5), 0);
+static SUNXI_CCU_GATE(bus_otg_clk, "bus-otg", "psi-ahb", 0xa8c, BIT(8), 0);
+
+static SUNXI_CCU_GATE(bus_lradc_clk, "bus-lradc", "psi-ahb", 0xa9c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_dpss_top0_clk, "bus-dpss-top0", "psi-ahb",
+		      0xabc, BIT(0), 0);
+
+static SUNXI_CCU_GATE(hdmi_24m_clk, "hdmi-24m", "dcxo24M", 0xb04, BIT(31), 0);
+
+static const char * const hdmi_cec_parents[] = { "osc32k", "hdmi-cec-32k" };
+static SUNXI_CCU_MUX_WITH_GATE(hdmi_cec_clk, "hdmi-cec",
+			       hdmi_cec_parents,
+			       0xb10,
+			       24, 1,			/* mux */
+			       BIT(31) | BIT(30),	/* TODO:gate peri*/
+			       0);
+
+static SUNXI_CCU_GATE(bus_hdmi_clk, "bus-hdmi", "psi-ahb", 0xb1c, BIT(0), 0);
+
+static const char * const mipi_dsi_parents[] = { "dcxo24M", "pll-periph0",
+						 "pll-video0-2x", "pll-video1-2x",
+						 "pll-audio1-div2" };
+static SUNXI_CCU_M_WITH_MUX_GATE(mipi_dsi_clk, "mipi-dsi",
+				 mipi_dsi_parents,
+				 0xb24,
+				 0, 4,		/* M */
+				 24, 3,		/* mux */
+				 BIT(31),	/* gate */
+				 0);
+
+static SUNXI_CCU_GATE(bus_mipi_dsi_clk, "bus-mipi-dsi", "psi-ahb",
+		      0xb4c, BIT(0), 0);
+
+static const char * const hdmi_tcon_tve_parents[] = { "pll-video0", "pll-video0-4x",
+						      "pll-video1", "pll-video1-4x",
+						      "pll-periph0-2x", "pll-audio1-div2" };
+static SUNXI_CCU_MP_WITH_MUX_GATE(tcon_lcd0_clk, "tcon-lcd0",
+				  hdmi_tcon_tve_parents, 0xb60,
+				  0, 4,		/* M */
+				  8, 2,		/* N */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  CLK_SET_RATE_NO_REPARENT);
+
+static SUNXI_CCU_GATE(bus_tcon_lcd0_clk, "bus-tcon-lcd0", "psi-ahb",
+		      0xb7c, BIT(0), 0);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(tcon_tv_clk, "tcon-tv",
+				  hdmi_tcon_tve_parents, 0xb80,
+				  0, 4,		/* M */
+				  8, 2,		/* N */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  CLK_SET_RATE_NO_REPARENT);
+
+static SUNXI_CCU_GATE(bus_tcon_tv_clk, "bus-tcon-tv", "psi-ahb",
+		      0xb9c, BIT(0), 0);
+
+static SUNXI_CCU_MP_WITH_MUX_GATE(tve_clk, "tve",
+				  hdmi_tcon_tve_parents, 0xbb0,
+				  0, 4,		/* M */
+				  8, 2,		/* N */
+				  24, 3,	/* mux */
+				  BIT(31),	/* gate */
+				  0);
+
+static SUNXI_CCU_GATE(bus_tve_top_clk, "bus-tve-top", "psi-ahb",
+		      0xbbc, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_tve_clk, "bus-tve", "psi-ahb",
+		      0xbbc, BIT(1), 0);
+
+static const char * const tvd_parents[] = { "dcxo24M", "pll-video0",
+					    "pll-video1", "pll-periph0" };
+static SUNXI_CCU_M_WITH_MUX_GATE(tvd_clk, "tvd",
+				 tvd_parents,
+				 0xbc0,
+				 0, 5,		/* M */
+				 24, 3,		/* mux */
+				 BIT(31),	/* gate */
+				 0);
+
+static SUNXI_CCU_GATE(bus_tvd_top_clk, "bus-tvd-top", "psi-ahb",
+		      0xbdc, BIT(0), 0);
+static SUNXI_CCU_GATE(bus_tvd_clk, "bus-tvd", "psi-ahb",
+		      0xbdc, BIT(1), 0);
+
+static const char * const ledc_parents[] = { "dcxo24M", "pll-periph0" };
+static SUNXI_CCU_MP_WITH_MUX_GATE(ledc_clk, "ledc",
+				  ledc_parents, 0xbf0,
+				  0, 4,
+				  8, 2,
+				  24, 1,
+				  BIT(31),
+				  0);
+
+static SUNXI_CCU_GATE(bus_ledc_clk, "bus-ledc", "psi-ahb",
+		      0xbfc, BIT(0), 0);
+
+static const char * const csi_top_parents[] = { "pll-periph0-2x", "pll-video0-2x",
+						"pll-video1-2x" };
+static SUNXI_CCU_M_WITH_MUX_GATE(csi_top_clk, "csi-top",
+				 csi_top_parents, 0xc04,
+				 0, 4,		/* M */
+				 24, 3,		/* mux */
+				 BIT(31),	/* gate */
+				 0);
+
+static const char * const csi0_mclk_parents[] = { "dcxo24M", "pll-periph0",
+						  "pll-video0", "pll-video1",
+						  "pll-audio-div2", "pll-audio-div5" };
+static SUNXI_CCU_M_WITH_MUX_GATE(csi0_mclk_clk, "csi0-mclk",
+				 csi0_mclk_parents, 0xc08,
+				 0, 5,		/* M */
+				 24, 3,		/* mux */
+				 BIT(31),	/* gate */
+				 CLK_SET_RATE_NO_REPARENT);
+
+static SUNXI_CCU_GATE(bus_csi_clk, "bus-csi", "psi-ahb", 0xc1c, BIT(0), 0);
+
+static const char * const tpadc_parents[] = { "dcxo24M", "pll-audio0" };
+static SUNXI_CCU_MUX_WITH_GATE(tpadc_clk, "tpadc",
+			       tpadc_parents, 0xc50,
+			       24, 3,		/* mux */
+			       BIT(31),		/* gate */
+			       0);
+
+static SUNXI_CCU_GATE(bus_tpadc_clk, "bus-tpadc", "apb0", 0xc5c, BIT(0), 0);
+
+static SUNXI_CCU_GATE(bus_tzma_clk, "bus-tzma", "apb0", 0xc6c, BIT(0), 0);
+
+static const char * const dsp_parents[] = { "dcxo24M", "osc32k",
+					    "iosc", "pll-periph0-2x" };
+static SUNXI_CCU_M_WITH_MUX_GATE(dsp_clk, "dsp", dsp_parents, 0xc70,
+				 0, 4,
+				 24, 3,
+				 BIT(31), 0);
+
+static SUNXI_CCU_GATE(bus_dsp_cfg_clk, "bus-dsp-cfg", "psi-ahb", 0xc7c, BIT(1), 0);
+
+static const char * const riscv_parents[] = { "dcxo24M", "osc32k",
+					      "iosc", "pll-periph0-800m",
+					      "pll-periph0", "pll-cpux",
+					      "pll-audio1-div2"};
+static struct ccu_div riscv_clk = {
+	.div	= _SUNXI_CCU_DIV(0, 5),
+	.mux	= _SUNXI_CCU_MUX(24, 3),
+	.common	= {
+		.reg		= 0xd00,
+		.features	= CCU_FEATURE_REPEAT_SET_MUX,
+		.hw.init	= CLK_HW_INIT_PARENTS("riscv", riscv_parents,
+						      &ccu_div_ops,
+						      CLK_SET_RATE_PARENT |
+						      CLK_SET_RATE_NO_REPARENT),
+	},
+};
+
+/* The riscv-axi clk needs to be divided by at least 2 */
+static struct clk_div_table riscv_axi_table[] = {
+	{ .val = 1, .div = 2 },
+	{ .val = 2, .div = 3 },
+	{ .val = 3, .div = 4 },
+	{ /* Sentinel */ },
+};
+static SUNXI_CCU_DIV_TABLE(riscv_axi_clk, "riscv-axi",
+			   "riscv", 0xd00, 8, 2,
+			   riscv_axi_table, 0);
+
+static SUNXI_CCU_GATE(bus_riscv_cfg_clk, "bus-riscv-cfg", "psi-ahb",
+		      0xd0c, BIT(0), 0);
+
+/* Add the cpu fanout clk */
+static SUNXI_CCU_GATE(fanout_24m_clk, "fanout-24m",
+		      "dcxo24M", 0xf30, BIT(0), 0);
+static SUNXI_CCU_GATE(fanout_12m_clk, "fanout-12m",
+		      "osc12M", 0xf30, BIT(1), 0);
+static SUNXI_CCU_GATE_WITH_PREDIV(fanout_16m_clk, "fanout-16m",
+				  "pll-periph0-2x", 0xf30,
+				  75,			/* prediv */
+				  BIT(2), 0);
+static SUNXI_CCU_GATE_WITH_PREDIV(fanout_25m_clk, "fanout-25m",
+				  "pll-periph0", 0xf30,
+				  24,			/* prediv */
+				  BIT(3), 0);
+static SUNXI_CCU_GATE_WITH_PREDIV(fanout_32k_clk, "fanout-32k",
+				  "pll-periph0-2x", 0xf30,
+				  36621,			/* prediv */
+				  BIT(4), 0);
+
+static const char * const fanout_27m_parents[] = { "pll-video0", "pll-video1" };
+static SUNXI_CCU_MP_WITH_MUX_GATE_NO_INDEX(fanout_27m_clk, "fanout-27m",
+					   fanout_27m_parents, 0xf34,
+					   8, 2,
+					   0, 5,
+					   24, 2,
+					   BIT(31), 0);
+
+static SUNXI_CCU_M_WITH_GATE(fanout_pclk, "fanout-pclk",
+			     "apb0", 0xf38, 0, 5, BIT(31), 0);
+
+static const char * const fanout_parents[] = { "fanout-32k", "fanout-12m",
+					       "fanout-16m", "fanout-24m",
+					       "fanout-25m", "fanout-27m",
+					       "fanout-pclk"};
+static SUNXI_CCU_MUX_WITH_GATE(fanout0_out_clk, "fanout0-out-clk",
+			       fanout_parents, 0xf3c,
+			       0, 3,
+			       BIT(21), 0);
+static SUNXI_CCU_MUX_WITH_GATE(fanout1_out_clk, "fanout1-out-clk",
+			       fanout_parents, 0xf3c,
+			       3, 3,
+			       BIT(22), 0);
+static SUNXI_CCU_MUX_WITH_GATE(fanout2_out_clk, "fanout2-out-clk",
+			       fanout_parents, 0xf3c,
+			       6, 3,
+			       BIT(23), 0);
+
+/* Fixed factor clocks */
+static CLK_FIXED_FACTOR_FW_NAME(osc12M_clk, "osc12M", "hosc", 2, 1, 0);
+
+static CLK_FIXED_FACTOR_HW(pll_periph0_clk, "pll-periph0",
+			   &pll_periph0_2x_clk.common.hw,
+			   2, 1, 0);
+
+/* For AHBS */
+static CLK_FIXED_FACTOR_HW(pll_periph0_div3_clk, "pll-periph0-div3",
+			   &pll_periph0_2x_clk.common.hw,
+			   6, 1, 0);
+
+static CLK_FIXED_FACTOR_HW(hdmi_cec_32k_clk, "hdmi-cec-32k",
+			   &pll_periph0_2x_clk.common.hw,
+			   36621, 1, 0);
+
+static CLK_FIXED_FACTOR_HW(mbus_clk, "mbus",
+			   &pll_ddr0_clk.common.hw,
+			   4, 1, 0);
+
+static const struct clk_hw *pll_video0_parents[] = {
+	&pll_video0_clk.common.hw
+};
+static CLK_FIXED_FACTOR_HWS(pll_video0_4x_clk, "pll-video0-4x",
+			    pll_video0_parents,
+			    1, 4, CLK_SET_RATE_PARENT);
+static CLK_FIXED_FACTOR_HWS(pll_video0_2x_clk, "pll-video0-2x",
+			    pll_video0_parents,
+			    1, 2, CLK_SET_RATE_PARENT);
+
+static const struct clk_hw *pll_video1_parents[] = {
+	&pll_video1_clk.common.hw
+};
+static CLK_FIXED_FACTOR_HWS(pll_video1_4x_clk, "pll-video1-4x",
+			    pll_video1_parents,
+			    1, 4, CLK_SET_RATE_PARENT);
+static CLK_FIXED_FACTOR_HWS(pll_video1_2x_clk, "pll-video1-2x",
+			    pll_video1_parents,
+			    1, 2, CLK_SET_RATE_PARENT);
+
+static const struct clk_hw *pll_audio0_parents[] = {
+	&pll_audio0_4x_clk.common.hw
+};
+static CLK_FIXED_FACTOR_HWS(pll_audio0_clk, "pll-audio0",
+			    pll_audio0_parents,
+			    4, 1, CLK_SET_RATE_PARENT);
+static CLK_FIXED_FACTOR_HWS(pll_audio0_2x_clk, "pll-audio0-2x",
+			    pll_audio0_parents,
+			    2, 1, CLK_SET_RATE_PARENT);
+/* ccu_des_end */
+
+static struct ccu_common *sun8iw20_ccu_clks[] = {
+	&pll_cpux_clk.common,
+	&pll_ddr0_clk.common,
+	&pll_periph0_parent_clk.common,
+	&pll_periph0_2x_clk.common,
+	&pll_periph0_800m_clk.common,
+	&pll_video0_clk.common,
+	&pll_video1_clk.common,
+	&pll_ve_clk.common,
+	&pll_audio0_4x_clk.common,
+	&pll_audio1_clk.common,
+	&pll_audio1_div2_clk.common,
+	&pll_audio1_div5_clk.common,
+	&pll_cpux_div.common,
+	&cpux_clk.common,
+	&axi_clk.common,
+	&apb_clk.common,
+	&psi_ahb_clk.common,
+	&apb0_clk.common,
+	&apb1_clk.common,
+	&de0_clk.common,
+	&bus_de0_clk.common,
+	&di_clk.common,
+	&bus_di_clk.common,
+	&g2d_clk.common,
+	&bus_g2d_clk.common,
+	&ce_clk.common,
+	&bus_ce_clk.common,
+	&ve_clk.common,
+	&bus_ve_clk.common,
+	&bus_dma_clk.common,
+	&bus_msgbox0_clk.common,
+	&bus_msgbox1_clk.common,
+	&bus_msgbox2_clk.common,
+	&bus_spinlock_clk.common,
+	&bus_hstimer_clk.common,
+	&avs_clk.common,
+	&bus_dbg_clk.common,
+	&bus_pwm_clk.common,
+	&bus_iommu_clk.common,
+	&dram_clk.common,
+	&mbus_dma_clk.common,
+	&mbus_ve_clk.common,
+	&mbus_ce_clk.common,
+	&mbus_tvin_clk.common,
+	&mbus_csi_clk.common,
+	&mbus_g2d_clk.common,
+	&bus_dram_clk.common,
+	&mmc0_clk.common,
+	&mmc1_clk.common,
+	&mmc2_clk.common,
+	&bus_mmc0_clk.common,
+	&bus_mmc1_clk.common,
+	&bus_mmc2_clk.common,
+	&bus_uart0_clk.common,
+	&bus_uart1_clk.common,
+	&bus_uart2_clk.common,
+	&bus_uart3_clk.common,
+	&bus_uart4_clk.common,
+	&bus_uart5_clk.common,
+	&bus_i2c0_clk.common,
+	&bus_i2c1_clk.common,
+	&bus_i2c2_clk.common,
+	&bus_i2c3_clk.common,
+	&bus_can0_clk.common,
+	&bus_can1_clk.common,
+	&spi0_clk.common,
+	&spi1_clk.common,
+	&bus_spi0_clk.common,
+	&bus_spi1_clk.common,
+	&emac0_25m_clk.common,
+	&bus_emac0_clk.common,
+	&ir_tx_clk.common,
+	&bus_ir_tx_clk.common,
+	&bus_gpadc_clk.common,
+	&bus_ths_clk.common,
+	&i2s0_clk.common,
+	&i2s1_clk.common,
+	&i2s2_clk.common,
+	&i2s2_asrc_clk.common,
+	&bus_i2s0_clk.common,
+	&bus_i2s1_clk.common,
+	&bus_i2s2_clk.common,
+	&spdif_tx_clk.common,
+	&spdif_rx_clk.common,
+	&bus_spdif_clk.common,
+	&dmic_clk.common,
+	&bus_dmic_clk.common,
+	&audio_codec_dac_clk.common,
+	&audio_codec_adc_clk.common,
+	&bus_audio_codec_clk.common,
+	&usb_ohci0_clk.common,
+	&usb_ohci1_clk.common,
+	&bus_ohci0_clk.common,
+	&bus_ohci1_clk.common,
+	&bus_ehci0_clk.common,
+	&bus_ehci1_clk.common,
+	&bus_otg_clk.common,
+	&bus_lradc_clk.common,
+	&bus_dpss_top0_clk.common,
+	&hdmi_24m_clk.common,
+	&hdmi_cec_clk.common,
+	&bus_hdmi_clk.common,
+	&mipi_dsi_clk.common,
+	&bus_mipi_dsi_clk.common,
+	&tcon_lcd0_clk.common,
+	&bus_tcon_lcd0_clk.common,
+	&tcon_tv_clk.common,
+	&bus_tcon_tv_clk.common,
+	&tve_clk.common,
+	&bus_tve_clk.common,
+	&bus_tve_top_clk.common,
+	&tvd_clk.common,
+	&bus_tvd_clk.common,
+	&ledc_clk.common,
+	&bus_ledc_clk.common,
+	&bus_tvd_top_clk.common,
+	&csi_top_clk.common,
+	&csi0_mclk_clk.common,
+	&bus_csi_clk.common,
+	&tpadc_clk.common,
+	&bus_tpadc_clk.common,
+	&bus_tzma_clk.common,
+	&dsp_clk.common,
+	&bus_dsp_cfg_clk.common,
+	&riscv_clk.common,
+	&riscv_axi_clk.common,
+	&bus_riscv_cfg_clk.common,
+	&fanout_24m_clk.common,
+	&fanout_12m_clk.common,
+	&fanout_16m_clk.common,
+	&fanout_25m_clk.common,
+	&fanout_32k_clk.common,
+	&fanout_27m_clk.common,
+	&fanout_pclk.common,
+	&fanout0_out_clk.common,
+	&fanout1_out_clk.common,
+	&fanout2_out_clk.common,
+};
+
+/* ccu_def_start */
+static struct clk_hw_onecell_data sun8iw20_hw_clks = {
+	.hws	= {
+		[CLK_OSC12M]		= &osc12M_clk.hw,
+		[CLK_PLL_CPUX]		= &pll_cpux_clk.common.hw,
+		[CLK_PLL_DDR0]		= &pll_ddr0_clk.common.hw,
+		[CLK_PLL_PERIPH0_PARENT] = &pll_periph0_parent_clk.common.hw,
+		[CLK_PLL_PERIPH0]	= &pll_periph0_clk.hw,
+		[CLK_PLL_PERIPH0_2X]	= &pll_periph0_2x_clk.common.hw,
+		[CLK_PLL_PERIPH0_800M]	= &pll_periph0_800m_clk.common.hw,
+		[CLK_PLL_PERIPH0_DIV3]	= &pll_periph0_div3_clk.hw,
+		[CLK_PLL_VIDEO0]	= &pll_video0_clk.common.hw,
+		[CLK_PLL_VIDEO0_2X]	= &pll_video0_2x_clk.hw,
+		[CLK_PLL_VIDEO0_4X]	= &pll_video0_4x_clk.hw,
+		[CLK_PLL_VIDEO1]	= &pll_video1_clk.common.hw,
+		[CLK_PLL_VIDEO1_2X]	= &pll_video1_2x_clk.hw,
+		[CLK_PLL_VIDEO1_4X]	= &pll_video1_4x_clk.hw,
+		[CLK_PLL_VE]		= &pll_ve_clk.common.hw,
+		[CLK_PLL_AUDIO0]	= &pll_audio0_clk.hw,
+		[CLK_PLL_AUDIO0_2X]	= &pll_audio0_2x_clk.hw,
+		[CLK_PLL_AUDIO0_4X]	= &pll_audio0_4x_clk.common.hw,
+		[CLK_PLL_AUDIO1]	= &pll_audio1_clk.common.hw,
+		[CLK_PLL_AUDIO1_DIV2]	= &pll_audio1_div2_clk.common.hw,
+		[CLK_PLL_AUDIO1_DIV5]	= &pll_audio1_div5_clk.common.hw,
+		[CLK_PLL_CPUX_DIV]	= &pll_cpux_div.common.hw,
+		[CLK_CPUX]		= &cpux_clk.common.hw,
+		[CLK_AXI]		= &axi_clk.common.hw,
+		[CLK_APB]		= &apb_clk.common.hw,
+		[CLK_PSI_AHB]		= &psi_ahb_clk.common.hw,
+		[CLK_APB0]		= &apb0_clk.common.hw,
+		[CLK_APB1]		= &apb1_clk.common.hw,
+		[CLK_MBUS]		= &mbus_clk.hw,
+		[CLK_DE0]		= &de0_clk.common.hw,
+		[CLK_BUS_DE0]		= &bus_de0_clk.common.hw,
+		[CLK_DI]		= &di_clk.common.hw,
+		[CLK_BUS_DI]		= &bus_di_clk.common.hw,
+		[CLK_G2D]		= &g2d_clk.common.hw,
+		[CLK_BUS_G2D]		= &bus_g2d_clk.common.hw,
+		[CLK_CE]		= &ce_clk.common.hw,
+		[CLK_BUS_CE]		= &bus_ce_clk.common.hw,
+		[CLK_VE]		= &ve_clk.common.hw,
+		[CLK_BUS_VE]		= &bus_ve_clk.common.hw,
+		[CLK_BUS_DMA]		= &bus_dma_clk.common.hw,
+		[CLK_BUS_MSGBOX0]	= &bus_msgbox0_clk.common.hw,
+		[CLK_BUS_MSGBOX1]	= &bus_msgbox1_clk.common.hw,
+		[CLK_BUS_MSGBOX2]	= &bus_msgbox2_clk.common.hw,
+		[CLK_BUS_SPINLOCK]	= &bus_spinlock_clk.common.hw,
+		[CLK_BUS_HSTIMER]	= &bus_hstimer_clk.common.hw,
+		[CLK_AVS]		= &avs_clk.common.hw,
+		[CLK_BUS_DBG]		= &bus_dbg_clk.common.hw,
+		[CLK_BUS_PWM]		= &bus_pwm_clk.common.hw,
+		[CLK_BUS_IOMMU]		= &bus_iommu_clk.common.hw,
+		[CLK_DRAM]		= &dram_clk.common.hw,
+		[CLK_MBUS_DMA]		= &mbus_dma_clk.common.hw,
+		[CLK_MBUS_VE]		= &mbus_ve_clk.common.hw,
+		[CLK_MBUS_CE]		= &mbus_ce_clk.common.hw,
+		[CLK_MBUS_TVIN]		= &mbus_tvin_clk.common.hw,
+		[CLK_MBUS_CSI]		= &mbus_csi_clk.common.hw,
+		[CLK_MBUS_G2D]		= &mbus_g2d_clk.common.hw,
+		[CLK_BUS_DRAM]		= &bus_dram_clk.common.hw,
+		[CLK_MMC0]		= &mmc0_clk.common.hw,
+		[CLK_MMC1]		= &mmc1_clk.common.hw,
+		[CLK_MMC2]		= &mmc2_clk.common.hw,
+		[CLK_BUS_MMC0]		= &bus_mmc0_clk.common.hw,
+		[CLK_BUS_MMC1]		= &bus_mmc1_clk.common.hw,
+		[CLK_BUS_MMC2]		= &bus_mmc2_clk.common.hw,
+		[CLK_BUS_UART0]		= &bus_uart0_clk.common.hw,
+		[CLK_BUS_UART1]		= &bus_uart1_clk.common.hw,
+		[CLK_BUS_UART2]		= &bus_uart2_clk.common.hw,
+		[CLK_BUS_UART3]		= &bus_uart3_clk.common.hw,
+		[CLK_BUS_UART4]		= &bus_uart4_clk.common.hw,
+		[CLK_BUS_UART5]		= &bus_uart5_clk.common.hw,
+		[CLK_BUS_I2C0]		= &bus_i2c0_clk.common.hw,
+		[CLK_BUS_I2C1]		= &bus_i2c1_clk.common.hw,
+		[CLK_BUS_I2C2]		= &bus_i2c2_clk.common.hw,
+		[CLK_BUS_I2C3]		= &bus_i2c3_clk.common.hw,
+		[CLK_BUS_CAN0]		= &bus_can0_clk.common.hw,
+		[CLK_BUS_CAN1]		= &bus_can1_clk.common.hw,
+		[CLK_SPI0]		= &spi0_clk.common.hw,
+		[CLK_SPI1]		= &spi1_clk.common.hw,
+		[CLK_BUS_SPI0]		= &bus_spi0_clk.common.hw,
+		[CLK_BUS_SPI1]		= &bus_spi1_clk.common.hw,
+		[CLK_EMAC0_25M]		= &emac0_25m_clk.common.hw,
+		[CLK_BUS_EMAC0]		= &bus_emac0_clk.common.hw,
+		[CLK_IR_TX]		= &ir_tx_clk.common.hw,
+		[CLK_BUS_IR_TX]		= &bus_ir_tx_clk.common.hw,
+		[CLK_BUS_GPADC]		= &bus_gpadc_clk.common.hw,
+		[CLK_BUS_THS]		= &bus_ths_clk.common.hw,
+		[CLK_I2S0]		= &i2s0_clk.common.hw,
+		[CLK_I2S1]		= &i2s1_clk.common.hw,
+		[CLK_I2S2]		= &i2s2_clk.common.hw,
+		[CLK_I2S2_ASRC]		= &i2s2_asrc_clk.common.hw,
+		[CLK_BUS_I2S0]		= &bus_i2s0_clk.common.hw,
+		[CLK_BUS_I2S1]		= &bus_i2s1_clk.common.hw,
+		[CLK_BUS_I2S2]		= &bus_i2s2_clk.common.hw,
+		[CLK_SPDIF_TX]		= &spdif_tx_clk.common.hw,
+		[CLK_SPDIF_RX]		= &spdif_rx_clk.common.hw,
+		[CLK_BUS_SPDIF]		= &bus_spdif_clk.common.hw,
+		[CLK_DMIC]		= &dmic_clk.common.hw,
+		[CLK_BUS_DMIC]		= &bus_dmic_clk.common.hw,
+		[CLK_AUDIO_DAC]		= &audio_codec_dac_clk.common.hw,
+		[CLK_AUDIO_ADC]		= &audio_codec_adc_clk.common.hw,
+		[CLK_BUS_AUDIO_CODEC]	= &bus_audio_codec_clk.common.hw,
+		[CLK_USB_OHCI0]		= &usb_ohci0_clk.common.hw,
+		[CLK_USB_OHCI1]		= &usb_ohci1_clk.common.hw,
+		[CLK_BUS_OHCI0]		= &bus_ohci0_clk.common.hw,
+		[CLK_BUS_OHCI1]		= &bus_ohci1_clk.common.hw,
+		[CLK_BUS_EHCI0]		= &bus_ehci0_clk.common.hw,
+		[CLK_BUS_EHCI1]		= &bus_ehci1_clk.common.hw,
+		[CLK_BUS_OTG]		= &bus_otg_clk.common.hw,
+		[CLK_BUS_LRADC]		= &bus_lradc_clk.common.hw,
+		[CLK_BUS_DPSS_TOP0]	= &bus_dpss_top0_clk.common.hw,
+		[CLK_HDMI_24M]		= &hdmi_24m_clk.common.hw,
+		[CLK_HDMI_CEC]		= &hdmi_cec_clk.common.hw,
+		[CLK_HDMI_CEC_32K]	= &hdmi_cec_32k_clk.hw,
+		[CLK_BUS_HDMI]		= &bus_hdmi_clk.common.hw,
+		[CLK_MIPI_DSI]		= &mipi_dsi_clk.common.hw,
+		[CLK_BUS_MIPI_DSI]	= &bus_mipi_dsi_clk.common.hw,
+		[CLK_TCON_LCD0]		= &tcon_lcd0_clk.common.hw,
+		[CLK_BUS_TCON_LCD0]	= &bus_tcon_lcd0_clk.common.hw,
+		[CLK_TCON_TV]		= &tcon_tv_clk.common.hw,
+		[CLK_BUS_TCON_TV]	= &bus_tcon_tv_clk.common.hw,
+		[CLK_TVE]		= &tve_clk.common.hw,
+		[CLK_BUS_TVE]		= &bus_tve_clk.common.hw,
+		[CLK_BUS_TVE_TOP]	= &bus_tve_top_clk.common.hw,
+		[CLK_TVD]		= &tvd_clk.common.hw,
+		[CLK_BUS_TVD]		= &bus_tvd_clk.common.hw,
+		[CLK_BUS_TVD_TOP]	= &bus_tvd_top_clk.common.hw,
+		[CLK_LEDC]		= &ledc_clk.common.hw,
+		[CLK_BUS_LEDC]		= &bus_ledc_clk.common.hw,
+		[CLK_CSI_TOP]		= &csi_top_clk.common.hw,
+		[CLK_CSI0_MCLK]		= &csi0_mclk_clk.common.hw,
+		[CLK_BUS_CSI]		= &bus_csi_clk.common.hw,
+		[CLK_TPADC]		= &tpadc_clk.common.hw,
+		[CLK_BUS_TPADC]		= &bus_tpadc_clk.common.hw,
+		[CLK_BUS_TZMA]		= &bus_tzma_clk.common.hw,
+		[CLK_DSP]		= &dsp_clk.common.hw,
+		[CLK_BUS_DSP_CFG]	= &bus_dsp_cfg_clk.common.hw,
+		[CLK_RISCV]		= &riscv_clk.common.hw,
+		[CLK_RISCV_AXI]		= &riscv_axi_clk.common.hw,
+		[CLK_BUS_RISCV_CFG]	= &bus_riscv_cfg_clk.common.hw,
+		[CLK_FANOUT_24M]	= &fanout_24m_clk.common.hw,
+		[CLK_FANOUT_12M]	= &fanout_12m_clk.common.hw,
+		[CLK_FANOUT_16M]	= &fanout_16m_clk.common.hw,
+		[CLK_FANOUT_25M]	= &fanout_25m_clk.common.hw,
+		[CLK_FANOUT_32K]	= &fanout_32k_clk.common.hw,
+		[CLK_FANOUT_27M]	= &fanout_27m_clk.common.hw,
+		[CLK_FANOUT_PCLK]	= &fanout_pclk.common.hw,
+		[CLK_FANOUT0_OUT]	= &fanout0_out_clk.common.hw,
+		[CLK_FANOUT1_OUT]	= &fanout1_out_clk.common.hw,
+		[CLK_FANOUT2_OUT]	= &fanout2_out_clk.common.hw,
+	},
+	.num = CLK_NUMBER,
+};
+/* ccu_def_end */
+
+/* rst_def_start */
+static struct ccu_reset_map sun8iw20_ccu_resets[] = {
+	[RST_MBUS]		= { 0x540, BIT(30) },
+
+	[RST_BUS_DE0]		= { 0x60c, BIT(16) },
+	[RST_BUS_DI]		= { 0x62c, BIT(16) },
+	[RST_BUS_G2D]		= { 0x63c, BIT(16) },
+	[RST_BUS_CE]		= { 0x68c, BIT(16) },
+	[RST_BUS_VE]		= { 0x69c, BIT(16) },
+	[RST_BUS_DMA]		= { 0x70c, BIT(16) },
+	[RST_BUS_MSGBOX0]	= { 0x71c, BIT(16) },
+	[RST_BUS_MSGBOX1]	= { 0x71c, BIT(17) },
+	[RST_BUS_MSGBOX2]	= { 0x71c, BIT(18) },
+	[RST_BUS_SPINLOCK]	= { 0x72c, BIT(16) },
+	[RST_BUS_HSTIMER]	= { 0x73c, BIT(16) },
+	[RST_BUS_DBG]		= { 0x78c, BIT(16) },
+	[RST_BUS_PWM]		= { 0x7ac, BIT(16) },
+	[RST_BUS_DRAM]		= { 0x80c, BIT(16) },
+	[RST_BUS_MMC0]		= { 0x84c, BIT(16) },
+	[RST_BUS_MMC1]		= { 0x84c, BIT(17) },
+	[RST_BUS_MMC2]		= { 0x84c, BIT(18) },
+	[RST_BUS_UART0]		= { 0x90c, BIT(16) },
+	[RST_BUS_UART1]		= { 0x90c, BIT(17) },
+	[RST_BUS_UART2]		= { 0x90c, BIT(18) },
+	[RST_BUS_UART3]		= { 0x90c, BIT(19) },
+	[RST_BUS_UART4]		= { 0x90c, BIT(20) },
+	[RST_BUS_UART5]		= { 0x90c, BIT(21) },
+	[RST_BUS_I2C0]		= { 0x91c, BIT(16) },
+	[RST_BUS_I2C1]		= { 0x91c, BIT(17) },
+	[RST_BUS_I2C2]		= { 0x91c, BIT(18) },
+	[RST_BUS_I2C3]		= { 0x91c, BIT(19) },
+	[RST_BUS_CAN0]		= { 0x92c, BIT(16) },
+	[RST_BUS_CAN1]		= { 0x92c, BIT(17) },
+	[RST_BUS_SPI0]		= { 0x96c, BIT(16) },
+	[RST_BUS_SPI1]		= { 0x96c, BIT(17) },
+	[RST_BUS_EMAC0]		= { 0x97c, BIT(16) },
+	[RST_BUS_IR_TX]		= { 0x9cc, BIT(16) },
+	[RST_BUS_GPADC]		= { 0x9ec, BIT(16) },
+	[RST_BUS_THS]		= { 0x9fc, BIT(16) },
+	[RST_BUS_I2S0]		= { 0xa20, BIT(16) },
+	[RST_BUS_I2S1]		= { 0xa20, BIT(17) },
+	[RST_BUS_I2S2]		= { 0xa20, BIT(18) },
+	[RST_BUS_SPDIF]		= { 0xa2c, BIT(16) },
+	[RST_BUS_DMIC]		= { 0xa4c, BIT(16) },
+	[RST_BUS_AUDIO_CODEC]	= { 0xa5c, BIT(16) },
+
+	[RST_USB_PHY0]		= { 0xa70, BIT(30) },
+	[RST_USB_PHY1]		= { 0xa74, BIT(30) },
+
+	[RST_BUS_OHCI0]		= { 0xa8c, BIT(16) },
+	[RST_BUS_OHCI1]		= { 0xa8c, BIT(17) },
+	[RST_BUS_EHCI0]		= { 0xa8c, BIT(20) },
+	[RST_BUS_EHCI1]		= { 0xa8c, BIT(21) },
+	[RST_BUS_OTG]		= { 0xa8c, BIT(24) },
+
+	[RST_BUS_LRADC]		= { 0xa9c, BIT(16) },
+	[RST_BUS_DPSS_TOP0]	= { 0xabc, BIT(16) },
+	[RST_BUS_HDMI_SUB]	= { 0xb1c, BIT(17) },
+	[RST_BUS_HDMI_MAIN]	= { 0xb1c, BIT(16) },
+	[RST_BUS_MIPI_DSI]	= { 0xb4c, BIT(16) },
+	[RST_BUS_TCON_LCD0]	= { 0xb7c, BIT(16) },
+	[RST_BUS_TCON_TV]	= { 0xb9c, BIT(16) },
+	[RST_BUS_LVDS0]		= { 0xbac, BIT(16) },
+	[RST_BUS_TVE]		= { 0xbbc, BIT(17) },
+	[RST_BUS_TVE_TOP]	= { 0xbbc, BIT(16) },
+	[RST_BUS_TVD]		= { 0xbdc, BIT(17) },
+	[RST_BUS_TVD_TOP]	= { 0xbdc, BIT(16) },
+	[RST_BUS_LEDC]		= { 0xbfc, BIT(16) },
+	[RST_BUS_CSI]		= { 0xc1c, BIT(16) },
+	[RST_BUS_TPADC]		= { 0xc5c, BIT(16) },
+	[RST_BUS_DSP]		= { 0xc7c, BIT(16) },
+	[RST_BUS_DSP_CFG]	= { 0xc7c, BIT(17) },
+	[RST_BUS_DSP_DBG]	= { 0xc7c, BIT(18) },
+	[RST_BUS_RISCV_CFG]	= { 0xd0c, BIT(16) },
+	/* TODO: RST_RISCV_SOFT */
+};
+/* rst_def_end */
+
+static const struct sunxi_ccu_desc sun8iw20_ccu_desc = {
+	.ccu_clks	= sun8iw20_ccu_clks,
+	.num_ccu_clks	= ARRAY_SIZE(sun8iw20_ccu_clks),
+
+	.hw_clks	= &sun8iw20_hw_clks,
+
+	.resets		= sun8iw20_ccu_resets,
+	.num_resets	= ARRAY_SIZE(sun8iw20_ccu_resets),
+};
+
+static const u32 pll_regs[] = {
+	SUN8IW20_PLL_CPUX_REG,
+	SUN8IW20_PLL_DDR0_REG,
+	SUN8IW20_PLL_PERIPH0_REG,
+	SUN8IW20_PLL_VIDEO0_REG,
+	SUN8IW20_PLL_VIDEO1_REG,
+	SUN8IW20_PLL_VE_REG,
+	SUN8IW20_PLL_AUDIO0_REG,
+	SUN8IW20_PLL_AUDIO1_REG,
+};
+
+static const u32 pll_video_regs[] = {
+	SUN8IW20_PLL_VIDEO0_REG,
+	SUN8IW20_PLL_VIDEO1_REG,
+};
+
+static const u32 usb2_clk_regs[] = {
+	SUN8IW20_USB0_CLK_REG,
+	SUN8IW20_USB1_CLK_REG,
+};
+
+static struct ccu_pll_nb sun8iw20_pll_cpu_nb = {
+	.common = &pll_cpux_clk.common,
+	/* copy from pll_cpux_clk */
+	.enable = BIT(27),
+	.lock   = BIT(28),
+};
+
+static struct ccu_mux_nb sun8iw20_cpu_nb = {
+	.common         = &cpux_clk.common,
+	.cm             = &cpux_clk.mux,
+	.delay_us       = 1,
+	.bypass_index   = 4, /* index of pll periph0 */
+};
+
+static struct ccu_mux_nb sun20iw1_cpu_nb = {
+	.common         = &riscv_clk.common,
+	.cm             = &riscv_clk.mux,
+	.delay_us       = 1,
+	.bypass_index   = 4, /* index of pll periph0 */
+};
+
+static int sun8iw20_ccu_probe(struct platform_device *pdev)
+{
+	void __iomem *reg;
+	u32 val;
+	int i, ret;
+
+	reg = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(reg))
+		return PTR_ERR(reg);
+
+	/* Enable the lock bits on all PLLs */
+	for (i = 0; i < ARRAY_SIZE(pll_regs); i++) {
+		val = readl(reg + pll_regs[i]);
+		val |= BIT(29);
+		writel(val, reg + pll_regs[i]);
+	}
+
+	/*
+	 * Force the output divider of video PLLs to 0.
+	 *
+	 * See the comment before pll-video0 definition for the reason.
+	 */
+	for (i = 0; i < ARRAY_SIZE(pll_video_regs); i++) {
+		val = readl(reg + pll_video_regs[i]);
+		val &= ~BIT(0);
+		writel(val, reg + pll_video_regs[i]);
+	}
+
+	/* Enforce m1 = 0, m0 = 1 for Audio0 PLL */
+	val = readl(reg + SUN8IW20_PLL_AUDIO0_REG);
+	val &= ~BIT(1);
+	val |= BIT(0);
+	writel(val, reg + SUN8IW20_PLL_AUDIO0_REG);
+
+	/* TODO: config PLL_AUDIO1 here */
+
+	/*
+	 * Force OHCI 12M clock sources to 00 (12MHz divided from 48MHz)
+	 *
+	 * This clock mux is still mysterious, and the code just enforces
+	 * it to have a valid clock parent.
+	 */
+	for (i = 0; i < ARRAY_SIZE(usb2_clk_regs); i++) {
+		val = readl(reg + usb2_clk_regs[i]);
+		val &= ~GENMASK(25, 24);
+		writel(val, reg + usb2_clk_regs[i]);
+	}
+
+	ret = sunxi_ccu_probe(pdev->dev.of_node, reg, &sun8iw20_ccu_desc);
+	if (ret)
+		return ret;
+
+	/* Gate then ungate PLL CPU after any rate changes */
+	ccu_pll_notifier_register(&sun8iw20_pll_cpu_nb);
+
+	/* a7:Reparent CPU during PLL CPU rate changes */
+	ccu_mux_notifier_register(pll_cpux_clk.common.hw.clk,
+				  &sun8iw20_cpu_nb);
+
+	/* riscv:Reparent CPU during PLL CPU rate changes */
+	ccu_mux_notifier_register(pll_cpux_clk.common.hw.clk,
+				  &sun20iw1_cpu_nb);
+
+	sunxi_ccu_sleep_init(reg, sun8iw20_ccu_clks,
+			     ARRAY_SIZE(sun8iw20_ccu_clks),
+			     NULL, 0);
+
+	return 0;
+}
+
+static const struct of_device_id sun8iw20_ccu_ids[] = {
+	{ .compatible = "allwinner,sun8iw20-ccu" },
+	{ .compatible = "allwinner,sun20iw1-ccu" },
+	{ }
+};
+
+static struct platform_driver sun8iw20_ccu_driver = {
+	.probe	= sun8iw20_ccu_probe,
+	.driver	= {
+		.name	= "sun8iw20-ccu",
+		.of_match_table	= sun8iw20_ccu_ids,
+	},
+};
+
+static int __init sunxi_ccu_sun8iw20_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&sun8iw20_ccu_driver);
+	if (ret)
+		pr_err("register ccu sun8iw20 failed\n");
+
+	return ret;
+}
+core_initcall(sunxi_ccu_sun8iw20_init);
+
+static void __exit sunxi_ccu_sun8iw20_exit(void)
+{
+	return platform_driver_unregister(&sun8iw20_ccu_driver);
+}
+module_exit(sunxi_ccu_sun8iw20_exit);
+
+MODULE_VERSION("0.5.2");
diff --git a/drivers/clk/sunxi-ng/ccu-sun8iw20.h b/drivers/clk/sunxi-ng/ccu-sun8iw20.h
new file mode 100644
index 000000000..594f933af
--- /dev/null
+++ b/drivers/clk/sunxi-ng/ccu-sun8iw20.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2020 frank@allwinnertech.com
+ */
+
+#ifndef _CCU_SUN8IW20_H_
+#define _CCU_SUN8IW20_H_
+
+#include <dt-bindings/clock/sun8iw20-ccu.h>
+#include <dt-bindings/reset/sun8iw20-ccu.h>
+
+#define CLK_NUMBER		(CLK_MAX_NO + 1)
+
+#endif /* _CCU_SUN8IW20_H_ */
diff --git a/drivers/clk/sunxi-ng/ccu_common.c b/drivers/clk/sunxi-ng/ccu_common.c
index 2e20e650b..105598be9 100644
--- a/drivers/clk/sunxi-ng/ccu_common.c
+++ b/drivers/clk/sunxi-ng/ccu_common.c
@@ -9,7 +9,9 @@
 #include <linux/clk-provider.h>
 #include <linux/iopoll.h>
 #include <linux/slab.h>
-
+#include <linux/syscore_ops.h>
+#include <linux/module.h>
+#include <linux/clkdev.h>
 #include "ccu_common.h"
 #include "ccu_gate.h"
 #include "ccu_reset.h"
@@ -78,6 +80,117 @@ int ccu_pll_notifier_register(struct ccu_pll_nb *pll_nb)
 	return clk_notifier_register(pll_nb->common->hw.clk,
 				     &pll_nb->clk_nb);
 }
+EXPORT_SYMBOL_GPL(ccu_pll_notifier_register);
+
+#ifdef CONFIG_PM_SLEEP
+
+static LIST_HEAD(ccu_reg_cache_list);
+
+struct sunxi_clock_reg_cache {
+	struct list_head node;
+	void __iomem *reg_base;
+	struct ccu_reg_dump *rdump;
+	unsigned int rd_num;
+	const struct ccu_reg_dump *rsuspend;
+	unsigned int rsuspend_num;
+};
+
+static void ccu_save(void __iomem *base, struct ccu_reg_dump *rd,
+		    unsigned int num_regs)
+{
+	for (; num_regs > 0; --num_regs, ++rd)
+		rd->value = readl(base + rd->offset);
+}
+
+static void ccu_restore(void __iomem *base,
+			const struct ccu_reg_dump *rd,
+			unsigned int num_regs)
+{
+	for (; num_regs > 0; --num_regs, ++rd)
+		writel(rd->value, base + rd->offset);
+}
+
+static struct ccu_reg_dump *ccu_alloc_reg_dump(struct ccu_common **rdump,
+					       unsigned long nr_rdump)
+{
+	struct ccu_reg_dump *rd;
+	unsigned int i;
+
+	rd = kcalloc(nr_rdump, sizeof(*rd), GFP_KERNEL);
+	if (!rd)
+		return NULL;
+
+	for (i = 0; i < nr_rdump; ++i) {
+		struct ccu_common *ccu_clks = rdump[i];
+
+		rd[i].offset = ccu_clks->reg;
+	}
+
+	return rd;
+}
+
+static int ccu_suspend(void)
+{
+	struct sunxi_clock_reg_cache *reg_cache;
+
+	list_for_each_entry(reg_cache, &ccu_reg_cache_list, node) {
+		ccu_save(reg_cache->reg_base, reg_cache->rdump,
+			 reg_cache->rd_num);
+		ccu_restore(reg_cache->reg_base, reg_cache->rsuspend,
+			    reg_cache->rsuspend_num);
+	}
+	return 0;
+}
+
+static void ccu_resume(void)
+{
+	struct sunxi_clock_reg_cache *reg_cache;
+
+	list_for_each_entry(reg_cache, &ccu_reg_cache_list, node)
+		ccu_restore(reg_cache->reg_base, reg_cache->rdump,
+				reg_cache->rd_num);
+}
+
+static struct syscore_ops sunxi_clk_syscore_ops = {
+	.suspend = ccu_suspend,
+	.resume = ccu_resume,
+};
+
+void sunxi_ccu_sleep_init(void __iomem *reg_base,
+			  struct ccu_common **rdump,
+			  unsigned long nr_rdump,
+			  const struct ccu_reg_dump *rsuspend,
+			  unsigned long nr_rsuspend)
+{
+	struct sunxi_clock_reg_cache *reg_cache;
+
+	reg_cache = kzalloc(sizeof(struct sunxi_clock_reg_cache),
+			GFP_KERNEL);
+	if (!reg_cache)
+		panic("could not allocate register reg_cache.\n");
+	reg_cache->rdump = ccu_alloc_reg_dump(rdump, nr_rdump);
+
+	if (!reg_cache->rdump)
+		panic("could not allocate register dump storage.\n");
+
+	if (list_empty(&ccu_reg_cache_list))
+		register_syscore_ops(&sunxi_clk_syscore_ops);
+
+	reg_cache->reg_base = reg_base;
+	reg_cache->rd_num = nr_rdump;
+	reg_cache->rsuspend = rsuspend;
+	reg_cache->rsuspend_num = nr_rsuspend;
+	list_add_tail(&reg_cache->node, &ccu_reg_cache_list);
+}
+#else
+void sunxi_ccu_sleep_init(void __iomem *reg_base,
+			  struct ccu_common **rdump,
+			  unsigned long nr_rdump,
+			  const struct ccu_reg_dump *rsuspend,
+			  unsigned long nr_rsuspend)
+{ }
+#endif
+EXPORT_SYMBOL_GPL(sunxi_ccu_sleep_init);
 
 int sunxi_ccu_probe(struct device_node *node, void __iomem *reg,
 		    const struct sunxi_ccu_desc *desc)
@@ -104,6 +217,12 @@ int sunxi_ccu_probe(struct device_node *node, void __iomem *reg,
 
 		name = hw->init->name;
 		ret = of_clk_hw_register(node, hw);
+
+/* add this CONFIG for clk SATA */
+#ifdef CONFIG_COMMON_CLK_DEBUG
+		clk_hw_register_clkdev(hw, name, NULL);
+#endif
+
 		if (ret) {
 			pr_err("Couldn't register clock %d - %s\n", i, name);
 			goto err_clk_unreg;
@@ -133,6 +252,8 @@ int sunxi_ccu_probe(struct device_node *node, void __iomem *reg,
 	if (ret)
 		goto err_of_clk_unreg;
 
+	pr_info("%s: sunxi ccu init OK\n", node->name);
+
 	return 0;
 
 err_of_clk_unreg:
@@ -149,3 +270,31 @@ int sunxi_ccu_probe(struct device_node *node, void __iomem *reg,
 	}
 	return ret;
 }
+
+void set_reg(char __iomem *addr, u32 val, u8 bw, u8 bs)
+{
+	u32 mask = (1UL << bw) - 1UL;
+	u32 tmp = 0;
+
+	tmp = readl(addr);
+	tmp &= ~(mask << bs);
+
+	writel(tmp | ((val & mask) << bs), addr);
+}
+
+void set_reg_key(char __iomem *addr,
+		 u32 key, u8 kbw, u8 kbs,
+		 u32 val, u8 bw, u8 bs)
+{
+	u32 mask = (1UL << bw) - 1UL;
+	u32 kmask = (1UL << kbw) - 1UL;
+	u32 tmp = 0;
+
+	tmp = readl(addr);
+	tmp &= ~(mask << bs);
+
+	writel(tmp | ((val & mask) << bs) | ((key & kmask) << kbs), addr);
+}
+EXPORT_SYMBOL_GPL(sunxi_ccu_probe);
+
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/clk/sunxi-ng/ccu_common.h b/drivers/clk/sunxi-ng/ccu_common.h
index 04e7a1220..7e1550aad 100644
--- a/drivers/clk/sunxi-ng/ccu_common.h
+++ b/drivers/clk/sunxi-ng/ccu_common.h
@@ -18,16 +18,39 @@
 #define CCU_FEATURE_MMC_TIMING_SWITCH	BIT(6)
 #define CCU_FEATURE_SIGMA_DELTA_MOD	BIT(7)
 
+/* Support key-field reg setting */
+#define CCU_FEATURE_KEY_FIELD_MOD	BIT(8)
+
+/* New formula support in MP: clk = parent / M / P */
+#define CCU_FEATURE_MP_NO_INDEX_MODE	BIT(9)
+
+/* Support fixed rate in gate-clk */
+#define CCU_FEATURE_FIXED_RATE_GATE	BIT(10)
+
+/* Some clks need config the mux reg repeatedly to fix ic bug */
+#define CCU_FEATURE_REPEAT_SET_MUX	BIT(11)
+
 /* MMC timing mode switch bit */
 #define CCU_MMC_NEW_TIMING_MODE		BIT(30)
 
 struct device_node;
 
+/**
+ * struct ccu_reg_dump: register dump of clock controller registers.
+ * @offset: clock register offset from the controller base address.
+ * @value: the value to be register at offset.
+ */
+struct ccu_reg_dump {
+	u32	offset;
+	u32	value;
+};
+
 struct ccu_common {
 	void __iomem	*base;
 	u16		reg;
 	u16		lock_reg;
 	u32		prediv;
+	u32		key_value;
 
 	unsigned long	features;
 	spinlock_t	*lock;
@@ -66,4 +89,15 @@ int ccu_pll_notifier_register(struct ccu_pll_nb *pll_nb);
 int sunxi_ccu_probe(struct device_node *node, void __iomem *reg,
 		    const struct sunxi_ccu_desc *desc);
 
+void sunxi_ccu_sleep_init(void __iomem *reg_base,
+			  struct ccu_common **rdump,
+			  unsigned long nr_rdump,
+			  const struct ccu_reg_dump *rsuspend,
+			  unsigned long nr_rsuspend);
+
+void set_reg(char __iomem *addr, u32 val, u8 bw, u8 bs);
+
+void set_reg_key(char __iomem *addr,
+		 u32 key, u8 kbw, u8 kbs,
+		 u32 val, u8 bw, u8 bs);
 #endif /* _COMMON_H_ */
diff --git a/drivers/clk/sunxi-ng/ccu_div.c b/drivers/clk/sunxi-ng/ccu_div.c
index 4c2970894..74f82a5e3 100644
--- a/drivers/clk/sunxi-ng/ccu_div.c
+++ b/drivers/clk/sunxi-ng/ccu_div.c
@@ -141,3 +141,4 @@ const struct clk_ops ccu_div_ops = {
 	.recalc_rate	= ccu_div_recalc_rate,
 	.set_rate	= ccu_div_set_rate,
 };
+EXPORT_SYMBOL_GPL(ccu_div_ops);
diff --git a/drivers/clk/sunxi-ng/ccu_frac.c b/drivers/clk/sunxi-ng/ccu_frac.c
index 44fcded8b..08d3710cf 100644
--- a/drivers/clk/sunxi-ng/ccu_frac.c
+++ b/drivers/clk/sunxi-ng/ccu_frac.c
@@ -51,7 +51,7 @@ void ccu_frac_helper_disable(struct ccu_common *common,
 
 bool ccu_frac_helper_has_rate(struct ccu_common *common,
 			      struct ccu_frac_internal *cf,
-			      unsigned long rate)
+			      u64 rate)
 {
 	if (!(common->features & CCU_FEATURE_FRACTIONAL))
 		return false;
@@ -69,7 +69,7 @@ unsigned long ccu_frac_helper_read_rate(struct ccu_common *common,
 	if (!(common->features & CCU_FEATURE_FRACTIONAL))
 		return 0;
 
-	pr_debug("%s: clock is fractional (rates %lu and %lu)\n",
+	pr_debug("%s: clock is fractional (rates %llu and %llu)\n",
 		 clk_hw_get_name(&common->hw), cf->rates[0], cf->rates[1]);
 
 	reg = readl(common->base + common->reg);
@@ -82,7 +82,7 @@ unsigned long ccu_frac_helper_read_rate(struct ccu_common *common,
 
 int ccu_frac_helper_set_rate(struct ccu_common *common,
 			     struct ccu_frac_internal *cf,
-			     unsigned long rate, u32 lock)
+			     u64 rate, u32 lock)
 {
 	unsigned long flags;
 	u32 reg, sel;
diff --git a/drivers/clk/sunxi-ng/ccu_frac.h b/drivers/clk/sunxi-ng/ccu_frac.h
index a4e8d7d0e..05e94308e 100644
--- a/drivers/clk/sunxi-ng/ccu_frac.h
+++ b/drivers/clk/sunxi-ng/ccu_frac.h
@@ -14,7 +14,7 @@ struct ccu_frac_internal {
 	u32		enable;
 	u32		select;
 
-	unsigned long	rates[2];
+	u64		rates[2];
 };
 
 #define _SUNXI_CCU_FRAC(_enable, _select, _rate1, _rate2)		\
@@ -33,13 +33,13 @@ void ccu_frac_helper_disable(struct ccu_common *common,
 
 bool ccu_frac_helper_has_rate(struct ccu_common *common,
 			      struct ccu_frac_internal *cf,
-			      unsigned long rate);
+			      u64 rate);
 
 unsigned long ccu_frac_helper_read_rate(struct ccu_common *common,
 					struct ccu_frac_internal *cf);
 
 int ccu_frac_helper_set_rate(struct ccu_common *common,
 			     struct ccu_frac_internal *cf,
-			     unsigned long rate, u32 lock);
+			     u64 rate, u32 lock);
 
 #endif /* _CCU_FRAC_H_ */
diff --git a/drivers/clk/sunxi-ng/ccu_gate.c b/drivers/clk/sunxi-ng/ccu_gate.c
index 3d5ca092b..01a3e1000 100644
--- a/drivers/clk/sunxi-ng/ccu_gate.c
+++ b/drivers/clk/sunxi-ng/ccu_gate.c
@@ -20,6 +20,11 @@ void ccu_gate_helper_disable(struct ccu_common *common, u32 gate)
 	spin_lock_irqsave(common->lock, flags);
 
 	reg = readl(common->base + common->reg);
+	/* data reading result of the keyfield bits are always 0 */
+	if (common->features & CCU_FEATURE_KEY_FIELD_MOD) {
+		reg = reg | common->key_value;
+	}
+
 	writel(reg & ~gate, common->base + common->reg);
 
 	spin_unlock_irqrestore(common->lock, flags);
@@ -43,6 +48,12 @@ int ccu_gate_helper_enable(struct ccu_common *common, u32 gate)
 	spin_lock_irqsave(common->lock, flags);
 
 	reg = readl(common->base + common->reg);
+
+	/* data reading result of the keyfield bits are always 0 */
+	if (common->features & CCU_FEATURE_KEY_FIELD_MOD) {
+		reg = reg | common->key_value;
+	}
+
 	writel(reg | gate, common->base + common->reg);
 
 	spin_unlock_irqrestore(common->lock, flags);
@@ -78,6 +89,9 @@ static unsigned long ccu_gate_recalc_rate(struct clk_hw *hw,
 	struct ccu_gate *cg = hw_to_ccu_gate(hw);
 	unsigned long rate = parent_rate;
 
+	if (cg->common.features & CCU_FEATURE_FIXED_RATE_GATE)
+		return cg->fixed_rate;
+
 	if (cg->common.features & CCU_FEATURE_ALL_PREDIV)
 		rate /= cg->common.prediv;
 
@@ -90,6 +104,9 @@ static long ccu_gate_round_rate(struct clk_hw *hw, unsigned long rate,
 	struct ccu_gate *cg = hw_to_ccu_gate(hw);
 	int div = 1;
 
+	if (cg->common.features & CCU_FEATURE_FIXED_RATE_GATE)
+		return cg->fixed_rate;
+
 	if (cg->common.features & CCU_FEATURE_ALL_PREDIV)
 		div = cg->common.prediv;
 
@@ -124,3 +141,4 @@ const struct clk_ops ccu_gate_ops = {
 	.set_rate	= ccu_gate_set_rate,
 	.recalc_rate	= ccu_gate_recalc_rate,
 };
+EXPORT_SYMBOL_GPL(ccu_gate_ops);
diff --git a/drivers/clk/sunxi-ng/ccu_gate.h b/drivers/clk/sunxi-ng/ccu_gate.h
index c386689a9..fa30b77ef 100644
--- a/drivers/clk/sunxi-ng/ccu_gate.h
+++ b/drivers/clk/sunxi-ng/ccu_gate.h
@@ -12,10 +12,56 @@
 
 struct ccu_gate {
 	u32			enable;
+	u32			fixed_rate;
 
 	struct ccu_common	common;
 };
 
+#define SUNXI_CCU_GATE_WITH_FIXED_RATE(_struct, _name, _parent, _reg,	\
+				       _fixed_rate, _gate)	\
+	struct ccu_gate _struct = {					\
+		.enable		= _gate,				\
+		.fixed_rate	= _fixed_rate,				\
+		.common	= {						\
+			.reg		= _reg,				\
+			.features	= CCU_FEATURE_FIXED_RATE_GATE,	\
+			.hw.init	= CLK_HW_INIT(_name,		\
+						      _parent,		\
+						      &ccu_gate_ops,	\
+						      0),		\
+		}							\
+	}
+
+#define SUNXI_CCU_GATE_WITH_PREDIV(_struct, _name, _parent, _reg,	\
+				   _prediv, _gate, _flags)		\
+	struct ccu_gate _struct = {					\
+		.enable	= _gate,					\
+		.common	= {						\
+			.reg		= _reg,				\
+			.prediv		= _prediv,			\
+			.features	= CCU_FEATURE_ALL_PREDIV,	\
+			.hw.init	= CLK_HW_INIT(_name,		\
+						      _parent,		\
+						      &ccu_gate_ops,	\
+						      _flags),		\
+		}							\
+	}
+
+#define SUNXI_CCU_GATE_WITH_KEY(_struct, _name, _parent, _reg,		\
+				_key_value, _gate, _flags)		\
+	struct ccu_gate _struct = {					\
+		.enable	= _gate,					\
+		.common	= {						\
+			.reg		= _reg,				\
+			.key_value	= _key_value,			\
+			.features	= CCU_FEATURE_KEY_FIELD_MOD,	\
+			.hw.init	= CLK_HW_INIT(_name,		\
+						      _parent,		\
+						      &ccu_gate_ops,	\
+						      _flags),		\
+		}							\
+	}
+
 #define SUNXI_CCU_GATE(_struct, _name, _parent, _reg, _gate, _flags)	\
 	struct ccu_gate _struct = {					\
 		.enable	= _gate,					\
diff --git a/drivers/clk/sunxi-ng/ccu_mp.c b/drivers/clk/sunxi-ng/ccu_mp.c
index fa4ecb915..838ff4d25 100644
--- a/drivers/clk/sunxi-ng/ccu_mp.c
+++ b/drivers/clk/sunxi-ng/ccu_mp.c
@@ -107,8 +107,11 @@ static unsigned long ccu_mp_round_rate(struct ccu_mux_internal *mux,
 
 	max_m = cmp->m.max ?: 1 << cmp->m.width;
 	max_p = cmp->p.max ?: 1 << ((1 << cmp->p.width) - 1);
-
-	if (!(clk_hw_get_flags(hw) & CLK_SET_RATE_PARENT)) {
+	/*
+	 * When mp-clk use the clk_round_rate, the clk shouldn't recal
+	 * parent's rate unless this clk set CLK_SET_RATE_PARENT flag.
+	 */
+	if (!(clk_hw_get_flags(&cmp->common.hw) & CLK_SET_RATE_PARENT)) {
 		ccu_mp_find_best(*parent_rate, rate, max_m, max_p, &m, &p);
 		rate = *parent_rate / p / m;
 	} else {
@@ -166,7 +169,14 @@ static unsigned long ccu_mp_recalc_rate(struct clk_hw *hw,
 	p = reg >> cmp->p.shift;
 	p &= (1 << cmp->p.width) - 1;
 
-	rate = (parent_rate >> p) / m;
+	if (unlikely(cmp->common.features & CCU_FEATURE_MP_NO_INDEX_MODE)) {
+		p += cmp->p.offset;
+		if (!p)
+			p++;
+		rate = (parent_rate / p) / m;
+	} else {
+		rate = (parent_rate >> p) / m;
+	}
 	if (cmp->common.features & CCU_FEATURE_FIXED_POSTDIV)
 		rate /= cmp->fixed_post_div;
 
@@ -196,7 +206,12 @@ static int ccu_mp_set_rate(struct clk_hw *hw, unsigned long rate,
 						  parent_rate);
 
 	max_m = cmp->m.max ?: 1 << cmp->m.width;
-	max_p = cmp->p.max ?: 1 << ((1 << cmp->p.width) - 1);
+
+	if (unlikely(cmp->common.features & CCU_FEATURE_MP_NO_INDEX_MODE))
+		max_p = cmp->p.max ?: 1 << cmp->p.width;
+	else
+		max_p = cmp->p.max ?: 1 << ((1 << cmp->p.width) - 1);
+
 
 	/* Adjust target rate according to post-dividers */
 	if (cmp->common.features & CCU_FEATURE_FIXED_POSTDIV)
@@ -210,7 +225,11 @@ static int ccu_mp_set_rate(struct clk_hw *hw, unsigned long rate,
 	reg &= ~GENMASK(cmp->m.width + cmp->m.shift - 1, cmp->m.shift);
 	reg &= ~GENMASK(cmp->p.width + cmp->p.shift - 1, cmp->p.shift);
 	reg |= (m - cmp->m.offset) << cmp->m.shift;
-	reg |= ilog2(p) << cmp->p.shift;
+
+	if (unlikely(cmp->common.features & CCU_FEATURE_MP_NO_INDEX_MODE))
+		reg |= (p - cmp->p.offset) << cmp->p.shift;
+	else
+		reg |= ilog2(p) << cmp->p.shift;
 
 	writel(reg, cmp->common.base + cmp->common.reg);
 
@@ -245,6 +264,7 @@ const struct clk_ops ccu_mp_ops = {
 	.recalc_rate	= ccu_mp_recalc_rate,
 	.set_rate	= ccu_mp_set_rate,
 };
+EXPORT_SYMBOL_GPL(ccu_mp_ops);
 
 /*
  * Support for MMC timing mode switching
diff --git a/drivers/clk/sunxi-ng/ccu_mp.h b/drivers/clk/sunxi-ng/ccu_mp.h
index b392e0d57..767ee5048 100644
--- a/drivers/clk/sunxi-ng/ccu_mp.h
+++ b/drivers/clk/sunxi-ng/ccu_mp.h
@@ -31,6 +31,26 @@ struct ccu_mp {
 	struct ccu_common	common;
 };
 
+#define SUNXI_CCU_MP_WITH_MUX_GATE_NO_INDEX(_struct, _name, _parents, _reg, \
+					   _mshift, _mwidth,		\
+					   _pshift, _pwidth,		\
+					   _muxshift, _muxwidth,	\
+					   _gate, _flags)		\
+	struct ccu_mp _struct = {					\
+		.enable	= _gate,					\
+		.m	= _SUNXI_CCU_DIV(_mshift, _mwidth),		\
+		.p	= _SUNXI_CCU_DIV(_pshift, _pwidth),		\
+		.mux	= _SUNXI_CCU_MUX(_muxshift, _muxwidth),		\
+		.common	= {						\
+			.reg		= _reg,				\
+			.features	= CCU_FEATURE_MP_NO_INDEX_MODE,	\
+			.hw.init	= CLK_HW_INIT_PARENTS(_name,	\
+							      _parents, \
+							      &ccu_mp_ops, \
+							      _flags),	\
+		}							\
+	}
+
 #define SUNXI_CCU_MP_WITH_MUX_GATE_POSTDIV(_struct, _name, _parents, _reg, \
 					   _mshift, _mwidth,		\
 					   _pshift, _pwidth,		\
diff --git a/drivers/clk/sunxi-ng/ccu_mult.c b/drivers/clk/sunxi-ng/ccu_mult.c
index 7c8cf2e04..500d0caf8 100644
--- a/drivers/clk/sunxi-ng/ccu_mult.c
+++ b/drivers/clk/sunxi-ng/ccu_mult.c
@@ -6,6 +6,7 @@
 
 #include <linux/clk-provider.h>
 #include <linux/io.h>
+#include <linux/delay.h>
 
 #include "ccu_gate.h"
 #include "ccu_mult.h"
@@ -14,12 +15,12 @@ struct _ccu_mult {
 	unsigned long	mult, min, max;
 };
 
-static void ccu_mult_find_best(unsigned long parent, unsigned long rate,
+static void ccu_mult_find_best(unsigned long parent, u64 rate,
 			       struct _ccu_mult *mult)
 {
-	int _mult;
+	u64 _mult = rate;
 
-	_mult = rate / parent;
+	do_div(_mult, parent);
 	if (_mult < mult->min)
 		_mult = mult->min;
 
@@ -100,13 +101,14 @@ static int ccu_mult_determine_rate(struct clk_hw *hw,
 					     req, ccu_mult_round_rate, cm);
 }
 
-static int ccu_mult_set_rate(struct clk_hw *hw, unsigned long rate,
+static int ccu_mult_set_rate(struct clk_hw *hw, unsigned long _rate,
 			   unsigned long parent_rate)
 {
 	struct ccu_mult *cm = hw_to_ccu_mult(hw);
 	struct _ccu_mult _cm;
 	unsigned long flags;
 	u32 reg;
+	u64 rate = _rate;
 
 	if (ccu_frac_helper_has_rate(&cm->common, &cm->frac, rate)) {
 		ccu_frac_helper_enable(&cm->common, &cm->frac);
@@ -140,6 +142,7 @@ static int ccu_mult_set_rate(struct clk_hw *hw, unsigned long rate,
 	spin_unlock_irqrestore(cm->common.lock, flags);
 
 	ccu_helper_wait_for_lock(&cm->common, cm->lock);
+	msleep(2);
 
 	return 0;
 }
@@ -170,3 +173,4 @@ const struct clk_ops ccu_mult_ops = {
 	.recalc_rate	= ccu_mult_recalc_rate,
 	.set_rate	= ccu_mult_set_rate,
 };
+EXPORT_SYMBOL_GPL(ccu_mult_ops);
diff --git a/drivers/clk/sunxi-ng/ccu_mux.c b/drivers/clk/sunxi-ng/ccu_mux.c
index 7d75da9a1..b9a711d81 100644
--- a/drivers/clk/sunxi-ng/ccu_mux.c
+++ b/drivers/clk/sunxi-ng/ccu_mux.c
@@ -188,8 +188,14 @@ int ccu_mux_helper_set_parent(struct ccu_common *common,
 	spin_lock_irqsave(common->lock, flags);
 
 	reg = readl(common->base + common->reg);
+	if (common->features & CCU_FEATURE_KEY_FIELD_MOD) {
+		reg = reg | common->key_value;
+	}
 	reg &= ~GENMASK(cm->width + cm->shift - 1, cm->shift);
 	writel(reg | (index << cm->shift), common->base + common->reg);
+	/* some clks need set mux reg repeatedly to fix ic bug */
+	if (common->features & CCU_FEATURE_REPEAT_SET_MUX)
+		writel(reg | (index << cm->shift), common->base + common->reg);
 
 	spin_unlock_irqrestore(common->lock, flags);
 
@@ -251,6 +257,7 @@ const struct clk_ops ccu_mux_ops = {
 	.determine_rate	= __clk_mux_determine_rate,
 	.recalc_rate	= ccu_mux_recalc_rate,
 };
+EXPORT_SYMBOL_GPL(ccu_mux_ops);
 
 /*
  * This clock notifier is called when the frequency of the of the parent
@@ -285,3 +292,4 @@ int ccu_mux_notifier_register(struct clk *clk, struct ccu_mux_nb *mux_nb)
 
 	return clk_notifier_register(clk, &mux_nb->clk_nb);
 }
+EXPORT_SYMBOL_GPL(ccu_mux_notifier_register);
diff --git a/drivers/clk/sunxi-ng/ccu_mux.h b/drivers/clk/sunxi-ng/ccu_mux.h
index f165395ef..8b2625f6b 100644
--- a/drivers/clk/sunxi-ng/ccu_mux.h
+++ b/drivers/clk/sunxi-ng/ccu_mux.h
@@ -47,6 +47,23 @@ struct ccu_mux {
 	struct ccu_common	common;
 };
 
+#define SUNXI_CCU_MUX_WITH_GATE_KEY(_struct, _name, _parents,		\
+				    _reg, _shift, _width,		\
+				    _key_value, _gate, _flags)		\
+	struct ccu_mux _struct = {					\
+		.enable	= _gate,					\
+		.mux	= _SUNXI_CCU_MUX(_shift, _width),		\
+		.common	= {						\
+			.reg		= _reg,				\
+			.features	= CCU_FEATURE_KEY_FIELD_MOD,	\
+			.key_value	= _key_value,			\
+			.hw.init	= CLK_HW_INIT_PARENTS(_name,	\
+							      _parents, \
+							      &ccu_mux_ops, \
+							      _flags),	\
+		}							\
+	}
+
 #define SUNXI_CCU_MUX_TABLE_WITH_GATE(_struct, _name, _parents, _table,	\
 				     _reg, _shift, _width, _gate,	\
 				     _flags)				\
diff --git a/drivers/clk/sunxi-ng/ccu_nk.c b/drivers/clk/sunxi-ng/ccu_nk.c
index aee68b00f..e6ced2dbd 100644
--- a/drivers/clk/sunxi-ng/ccu_nk.c
+++ b/drivers/clk/sunxi-ng/ccu_nk.c
@@ -15,16 +15,16 @@ struct _ccu_nk {
 	unsigned long	k, min_k, max_k;
 };
 
-static void ccu_nk_find_best(unsigned long parent, unsigned long rate,
+static void ccu_nk_find_best(unsigned long parent, u64 rate,
 			     struct _ccu_nk *nk)
 {
-	unsigned long best_rate = 0;
+	u64 best_rate = 0;
 	unsigned int best_k = 0, best_n = 0;
 	unsigned int _k, _n;
 
 	for (_k = nk->min_k; _k <= nk->max_k; _k++) {
 		for (_n = nk->min_n; _n <= nk->max_n; _n++) {
-			unsigned long tmp_rate = parent * _n * _k;
+			u64 tmp_rate = parent * _n * _k;
 
 			if (tmp_rate > rate)
 				continue;
@@ -66,7 +66,8 @@ static unsigned long ccu_nk_recalc_rate(struct clk_hw *hw,
 					unsigned long parent_rate)
 {
 	struct ccu_nk *nk = hw_to_ccu_nk(hw);
-	unsigned long rate, n, k;
+	unsigned long n, k;
+	u64 rate;
 	u32 reg;
 
 	reg = readl(nk->common.base + nk->common.reg);
@@ -85,16 +86,17 @@ static unsigned long ccu_nk_recalc_rate(struct clk_hw *hw,
 
 	rate = parent_rate * n * k;
 	if (nk->common.features & CCU_FEATURE_FIXED_POSTDIV)
-		rate /= nk->fixed_post_div;
+		do_div(rate, nk->fixed_post_div);
 
 	return rate;
 }
 
-static long ccu_nk_round_rate(struct clk_hw *hw, unsigned long rate,
+static long ccu_nk_round_rate(struct clk_hw *hw, unsigned long _rate,
 			      unsigned long *parent_rate)
 {
 	struct ccu_nk *nk = hw_to_ccu_nk(hw);
 	struct _ccu_nk _nk;
+	u64 rate = _rate;
 
 	if (nk->common.features & CCU_FEATURE_FIXED_POSTDIV)
 		rate *= nk->fixed_post_div;
@@ -108,17 +110,18 @@ static long ccu_nk_round_rate(struct clk_hw *hw, unsigned long rate,
 	rate = *parent_rate * _nk.n * _nk.k;
 
 	if (nk->common.features & CCU_FEATURE_FIXED_POSTDIV)
-		rate = rate / nk->fixed_post_div;
+		do_div(rate, nk->fixed_post_div);
 
 	return rate;
 }
 
-static int ccu_nk_set_rate(struct clk_hw *hw, unsigned long rate,
+static int ccu_nk_set_rate(struct clk_hw *hw, unsigned long _rate,
 			   unsigned long parent_rate)
 {
 	struct ccu_nk *nk = hw_to_ccu_nk(hw);
 	unsigned long flags;
 	struct _ccu_nk _nk;
+	u64 rate = _rate;
 	u32 reg;
 
 	if (nk->common.features & CCU_FEATURE_FIXED_POSTDIV)
diff --git a/drivers/clk/sunxi-ng/ccu_nkm.c b/drivers/clk/sunxi-ng/ccu_nkm.c
index b9cfee027..a2d7fc893 100644
--- a/drivers/clk/sunxi-ng/ccu_nkm.c
+++ b/drivers/clk/sunxi-ng/ccu_nkm.c
@@ -16,19 +16,19 @@ struct _ccu_nkm {
 	unsigned long	m, min_m, max_m;
 };
 
-static void ccu_nkm_find_best(unsigned long parent, unsigned long rate,
+static void ccu_nkm_find_best(unsigned long parent, u64 rate,
 			      struct _ccu_nkm *nkm)
 {
-	unsigned long best_rate = 0;
+	u64 best_rate = 0;
 	unsigned long best_n = 0, best_k = 0, best_m = 0;
 	unsigned long _n, _k, _m;
 
 	for (_k = nkm->min_k; _k <= nkm->max_k; _k++) {
 		for (_n = nkm->min_n; _n <= nkm->max_n; _n++) {
 			for (_m = nkm->min_m; _m <= nkm->max_m; _m++) {
-				unsigned long tmp_rate;
-
-				tmp_rate = parent * _n * _k / _m;
+				u64 tmp_rate;
+				tmp_rate = parent * _n * _k;
+				do_div(tmp_rate, _m);
 
 				if (tmp_rate > rate)
 					continue;
@@ -106,11 +106,12 @@ static unsigned long ccu_nkm_recalc_rate(struct clk_hw *hw,
 static unsigned long ccu_nkm_round_rate(struct ccu_mux_internal *mux,
 					struct clk_hw *hw,
 					unsigned long *parent_rate,
-					unsigned long rate,
+					unsigned long _rate,
 					void *data)
 {
 	struct ccu_nkm *nkm = data;
 	struct _ccu_nkm _nkm;
+	u64 rate = _rate;
 
 	_nkm.min_n = nkm->n.min ?: 1;
 	_nkm.max_n = nkm->n.max ?: 1 << nkm->n.width;
@@ -124,10 +125,11 @@ static unsigned long ccu_nkm_round_rate(struct ccu_mux_internal *mux,
 
 	ccu_nkm_find_best(*parent_rate, rate, &_nkm);
 
-	rate = *parent_rate * _nkm.n * _nkm.k / _nkm.m;
+	rate = *parent_rate * _nkm.n * _nkm.k;
+	do_div(rate, _nkm.m);
 
 	if (nkm->common.features & CCU_FEATURE_FIXED_POSTDIV)
-		rate /= nkm->fixed_post_div;
+		do_div(rate, nkm->fixed_post_div);
 
 	return rate;
 }
@@ -141,12 +143,13 @@ static int ccu_nkm_determine_rate(struct clk_hw *hw,
 					     req, ccu_nkm_round_rate, nkm);
 }
 
-static int ccu_nkm_set_rate(struct clk_hw *hw, unsigned long rate,
+static int ccu_nkm_set_rate(struct clk_hw *hw, unsigned long _rate,
 			   unsigned long parent_rate)
 {
 	struct ccu_nkm *nkm = hw_to_ccu_nkm(hw);
 	struct _ccu_nkm _nkm;
 	unsigned long flags;
+	u64 rate = _rate;
 	u32 reg;
 
 	if (nkm->common.features & CCU_FEATURE_FIXED_POSTDIV)
diff --git a/drivers/clk/sunxi-ng/ccu_nkmp.c b/drivers/clk/sunxi-ng/ccu_nkmp.c
index bda87b38c..3b636001d 100644
--- a/drivers/clk/sunxi-ng/ccu_nkmp.c
+++ b/drivers/clk/sunxi-ng/ccu_nkmp.c
@@ -17,7 +17,7 @@ struct _ccu_nkmp {
 	unsigned long	p, min_p, max_p;
 };
 
-static unsigned long ccu_nkmp_calc_rate(unsigned long parent,
+static u64 ccu_nkmp_calc_rate(unsigned long parent,
 					unsigned long n, unsigned long k,
 					unsigned long m, unsigned long p)
 {
@@ -29,10 +29,10 @@ static unsigned long ccu_nkmp_calc_rate(unsigned long parent,
 	return rate;
 }
 
-static void ccu_nkmp_find_best(unsigned long parent, unsigned long rate,
+static void ccu_nkmp_find_best(unsigned long parent, u64 rate,
 			       struct _ccu_nkmp *nkmp)
 {
-	unsigned long best_rate = 0;
+	u64 best_rate = 0;
 	unsigned long best_n = 0, best_k = 0, best_m = 0, best_p = 0;
 	unsigned long _n, _k, _m, _p;
 
@@ -40,7 +40,7 @@ static void ccu_nkmp_find_best(unsigned long parent, unsigned long rate,
 		for (_n = nkmp->min_n; _n <= nkmp->max_n; _n++) {
 			for (_m = nkmp->min_m; _m <= nkmp->max_m; _m++) {
 				for (_p = nkmp->min_p; _p <= nkmp->max_p; _p <<= 1) {
-					unsigned long tmp_rate;
+					u64 tmp_rate;
 
 					tmp_rate = ccu_nkmp_calc_rate(parent,
 								      _n, _k,
@@ -125,11 +125,12 @@ static unsigned long ccu_nkmp_recalc_rate(struct clk_hw *hw,
 	return rate;
 }
 
-static long ccu_nkmp_round_rate(struct clk_hw *hw, unsigned long rate,
+static long ccu_nkmp_round_rate(struct clk_hw *hw, unsigned long _rate,
 			      unsigned long *parent_rate)
 {
 	struct ccu_nkmp *nkmp = hw_to_ccu_nkmp(hw);
 	struct _ccu_nkmp _nkmp;
+	u64 rate = _rate;
 
 	if (nkmp->common.features & CCU_FEATURE_FIXED_POSTDIV)
 		rate *= nkmp->fixed_post_div;
@@ -137,7 +138,7 @@ static long ccu_nkmp_round_rate(struct clk_hw *hw, unsigned long rate,
 	if (nkmp->max_rate && rate > nkmp->max_rate) {
 		rate = nkmp->max_rate;
 		if (nkmp->common.features & CCU_FEATURE_FIXED_POSTDIV)
-			rate /= nkmp->fixed_post_div;
+			do_div(rate, nkmp->fixed_post_div);
 		return rate;
 	}
 
@@ -155,18 +156,19 @@ static long ccu_nkmp_round_rate(struct clk_hw *hw, unsigned long rate,
 	rate = ccu_nkmp_calc_rate(*parent_rate, _nkmp.n, _nkmp.k,
 				  _nkmp.m, _nkmp.p);
 	if (nkmp->common.features & CCU_FEATURE_FIXED_POSTDIV)
-		rate = rate / nkmp->fixed_post_div;
+		do_div(rate, nkmp->fixed_post_div);
 
 	return rate;
 }
 
-static int ccu_nkmp_set_rate(struct clk_hw *hw, unsigned long rate,
+static int ccu_nkmp_set_rate(struct clk_hw *hw, unsigned long _rate,
 			   unsigned long parent_rate)
 {
 	struct ccu_nkmp *nkmp = hw_to_ccu_nkmp(hw);
 	u32 n_mask = 0, k_mask = 0, m_mask = 0, p_mask = 0;
 	struct _ccu_nkmp _nkmp;
 	unsigned long flags;
+	u64 rate = _rate;
 	u32 reg;
 
 	if (nkmp->common.features & CCU_FEATURE_FIXED_POSTDIV)
@@ -230,3 +232,4 @@ const struct clk_ops ccu_nkmp_ops = {
 	.round_rate	= ccu_nkmp_round_rate,
 	.set_rate	= ccu_nkmp_set_rate,
 };
+EXPORT_SYMBOL_GPL(ccu_nkmp_ops);
diff --git a/drivers/clk/sunxi-ng/ccu_nm.c b/drivers/clk/sunxi-ng/ccu_nm.c
index e6bcc0a71..17b5c9c12 100644
--- a/drivers/clk/sunxi-ng/ccu_nm.c
+++ b/drivers/clk/sunxi-ng/ccu_nm.c
@@ -16,7 +16,7 @@ struct _ccu_nm {
 	unsigned long	m, min_m, max_m;
 };
 
-static unsigned long ccu_nm_calc_rate(unsigned long parent,
+static u64 ccu_nm_calc_rate(unsigned long parent,
 				      unsigned long n, unsigned long m)
 {
 	u64 rate = parent;
@@ -27,17 +27,17 @@ static unsigned long ccu_nm_calc_rate(unsigned long parent,
 	return rate;
 }
 
-static void ccu_nm_find_best(unsigned long parent, unsigned long rate,
+static void ccu_nm_find_best(unsigned long parent, u64 rate,
 			     struct _ccu_nm *nm)
 {
-	unsigned long best_rate = 0;
+	u64 best_rate = 0;
 	unsigned long best_n = 0, best_m = 0;
 	unsigned long _n, _m;
 
 	for (_n = nm->min_n; _n <= nm->max_n; _n++) {
 		for (_m = nm->min_m; _m <= nm->max_m; _m++) {
-			unsigned long tmp_rate = ccu_nm_calc_rate(parent,
-								  _n, _m);
+			u64 tmp_rate = ccu_nm_calc_rate(parent,
+							 _n, _m);
 
 			if (tmp_rate > rate)
 				continue;
@@ -79,7 +79,7 @@ static unsigned long ccu_nm_recalc_rate(struct clk_hw *hw,
 					unsigned long parent_rate)
 {
 	struct ccu_nm *nm = hw_to_ccu_nm(hw);
-	unsigned long rate;
+	u64 rate;
 	unsigned long n, m;
 	u32 reg;
 
@@ -87,7 +87,7 @@ static unsigned long ccu_nm_recalc_rate(struct clk_hw *hw,
 		rate = ccu_frac_helper_read_rate(&nm->common, &nm->frac);
 
 		if (nm->common.features & CCU_FEATURE_FIXED_POSTDIV)
-			rate /= nm->fixed_post_div;
+			do_div(rate, nm->fixed_post_div);
 
 		return rate;
 	}
@@ -112,16 +112,17 @@ static unsigned long ccu_nm_recalc_rate(struct clk_hw *hw,
 		rate = ccu_nm_calc_rate(parent_rate, n, m);
 
 	if (nm->common.features & CCU_FEATURE_FIXED_POSTDIV)
-		rate /= nm->fixed_post_div;
+		do_div(rate, nm->fixed_post_div);
 
 	return rate;
 }
 
-static long ccu_nm_round_rate(struct clk_hw *hw, unsigned long rate,
+static long ccu_nm_round_rate(struct clk_hw *hw, unsigned long _rate,
 			      unsigned long *parent_rate)
 {
 	struct ccu_nm *nm = hw_to_ccu_nm(hw);
 	struct _ccu_nm _nm;
+	u64 rate = _rate;
 
 	if (nm->common.features & CCU_FEATURE_FIXED_POSTDIV)
 		rate *= nm->fixed_post_div;
@@ -129,26 +130,26 @@ static long ccu_nm_round_rate(struct clk_hw *hw, unsigned long rate,
 	if (rate < nm->min_rate) {
 		rate = nm->min_rate;
 		if (nm->common.features & CCU_FEATURE_FIXED_POSTDIV)
-			rate /= nm->fixed_post_div;
+			do_div(rate, nm->fixed_post_div);
 		return rate;
 	}
 
 	if (nm->max_rate && rate > nm->max_rate) {
 		rate = nm->max_rate;
 		if (nm->common.features & CCU_FEATURE_FIXED_POSTDIV)
-			rate /= nm->fixed_post_div;
+			do_div(rate, nm->fixed_post_div);
 		return rate;
 	}
 
 	if (ccu_frac_helper_has_rate(&nm->common, &nm->frac, rate)) {
 		if (nm->common.features & CCU_FEATURE_FIXED_POSTDIV)
-			rate /= nm->fixed_post_div;
+			do_div(rate, nm->fixed_post_div);
 		return rate;
 	}
 
 	if (ccu_sdm_helper_has_rate(&nm->common, &nm->sdm, rate)) {
 		if (nm->common.features & CCU_FEATURE_FIXED_POSTDIV)
-			rate /= nm->fixed_post_div;
+			do_div(rate, nm->fixed_post_div);
 		return rate;
 	}
 
@@ -161,18 +162,19 @@ static long ccu_nm_round_rate(struct clk_hw *hw, unsigned long rate,
 	rate = ccu_nm_calc_rate(*parent_rate, _nm.n, _nm.m);
 
 	if (nm->common.features & CCU_FEATURE_FIXED_POSTDIV)
-		rate /= nm->fixed_post_div;
+		do_div(rate, nm->fixed_post_div);
 
 	return rate;
 }
 
-static int ccu_nm_set_rate(struct clk_hw *hw, unsigned long rate,
+static int ccu_nm_set_rate(struct clk_hw *hw, unsigned long _rate,
 			   unsigned long parent_rate)
 {
 	struct ccu_nm *nm = hw_to_ccu_nm(hw);
 	struct _ccu_nm _nm;
 	unsigned long flags;
 	u32 reg;
+	u64 rate = _rate;
 
 	/* Adjust target rate according to post-dividers */
 	if (nm->common.features & CCU_FEATURE_FIXED_POSTDIV)
@@ -238,3 +240,4 @@ const struct clk_ops ccu_nm_ops = {
 	.round_rate	= ccu_nm_round_rate,
 	.set_rate	= ccu_nm_set_rate,
 };
+EXPORT_SYMBOL_GPL(ccu_nm_ops);
diff --git a/drivers/clk/sunxi-ng/ccu_sdm.c b/drivers/clk/sunxi-ng/ccu_sdm.c
index 79581a1c6..d6f4202e6 100644
--- a/drivers/clk/sunxi-ng/ccu_sdm.c
+++ b/drivers/clk/sunxi-ng/ccu_sdm.c
@@ -23,7 +23,7 @@ bool ccu_sdm_helper_is_enabled(struct ccu_common *common,
 
 void ccu_sdm_helper_enable(struct ccu_common *common,
 			   struct ccu_sdm_internal *sdm,
-			   unsigned long rate)
+			   u64 rate)
 {
 	unsigned long flags;
 	unsigned int i;
@@ -89,7 +89,7 @@ void ccu_sdm_helper_disable(struct ccu_common *common,
  */
 bool ccu_sdm_helper_has_rate(struct ccu_common *common,
 			     struct ccu_sdm_internal *sdm,
-			     unsigned long rate)
+			     u64 rate)
 {
 	unsigned int i;
 
@@ -135,7 +135,7 @@ unsigned long ccu_sdm_helper_read_rate(struct ccu_common *common,
 
 int ccu_sdm_helper_get_factors(struct ccu_common *common,
 			       struct ccu_sdm_internal *sdm,
-			       unsigned long rate,
+			       u64 rate,
 			       unsigned long *m, unsigned long *n)
 {
 	unsigned int i;
diff --git a/drivers/clk/sunxi-ng/ccu_sdm.h b/drivers/clk/sunxi-ng/ccu_sdm.h
index c1a7159b8..8d0068de8 100644
--- a/drivers/clk/sunxi-ng/ccu_sdm.h
+++ b/drivers/clk/sunxi-ng/ccu_sdm.h
@@ -11,7 +11,7 @@
 #include "ccu_common.h"
 
 struct ccu_sdm_setting {
-	unsigned long	rate;
+	u64		rate;
 
 	/*
 	 * XXX We don't know what the step and bottom register fields
@@ -52,13 +52,13 @@ bool ccu_sdm_helper_is_enabled(struct ccu_common *common,
 			       struct ccu_sdm_internal *sdm);
 void ccu_sdm_helper_enable(struct ccu_common *common,
 			   struct ccu_sdm_internal *sdm,
-			   unsigned long rate);
+			   u64 rate);
 void ccu_sdm_helper_disable(struct ccu_common *common,
 			    struct ccu_sdm_internal *sdm);
 
 bool ccu_sdm_helper_has_rate(struct ccu_common *common,
 			     struct ccu_sdm_internal *sdm,
-			     unsigned long rate);
+			     u64 rate);
 
 unsigned long ccu_sdm_helper_read_rate(struct ccu_common *common,
 				       struct ccu_sdm_internal *sdm,
@@ -66,7 +66,7 @@ unsigned long ccu_sdm_helper_read_rate(struct ccu_common *common,
 
 int ccu_sdm_helper_get_factors(struct ccu_common *common,
 			       struct ccu_sdm_internal *sdm,
-			       unsigned long rate,
+			       u64 rate,
 			       unsigned long *m, unsigned long *n);
 
 #endif
diff --git a/drivers/clk/sunxi-ng/rtc-sunxi-ccu.c b/drivers/clk/sunxi-ng/rtc-sunxi-ccu.c
new file mode 100644
index 000000000..6ea6c9df4
--- /dev/null
+++ b/drivers/clk/sunxi-ng/rtc-sunxi-ccu.c
@@ -0,0 +1,550 @@
+/*
+ * sunxi RTC ccu driver
+ *
+ * Copyright (c) 2020, Martin <wuyan@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/rtc.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+
+/* set the parent of osc32k-out fixed to osc32k-sys, to simplify the clock tree */
+#define OSC32KOUT_PARENT_FIX_TO_OSC32KSYS	1
+
+#define LOSC_CTRL_REG			0x00
+#define KEY_FIELD_MAGIC			0x16AA0000
+#define LOSC_SRC_SEL			BIT(0)  /* 0: from RC16M; 1: from external OSC (ext-osc32k) */
+#define RTC_SRC_SEL			BIT(1)  /* 0: osc32k-sys; 1: dcxo24M-div-32k */
+#define LOSC_AUTO_SWT_32K_SEL_EN	BIT(14) /* LOSC auto switch 32k clk source sel enable. 1: enable */
+#define LOSC_AUTO_SWT_DISABLE		BIT(15)	/* LOSC auto switch function disable. 1: disable */
+#define EXT_LOSC_GSM			(0x2 << 2)  /* 0x8 */
+
+/* sun8iw20 does not have this register */
+#define INTOSC_CLK_AUTO_CALI_REG	0x0C
+#define RC_CLK_SRC_SEL			BIT(0)  /* 0: Normal RC; 1: Calibrated RC */
+#define RC_CALI_EN			BIT(1)  /* 0: disable; 1: enable */
+
+#define LOSC_OUT_GATING_REG		0x60  /* Or: 32K_FOUT_CTRL_GATING_REG */
+#define BIT_INDEX_LOSC_OUT_GATING	0     /* bit 0 of LOSC_OUT_GATING_REG. 0: disable output; 1: enable output */
+#define BIT_INDEX_LOSC_OUT_SRC_SEL	1     /* bit 1~2 of LOSC_OUT_GATING_REG */
+#define BIT_WIDTH_LOSC_OUT_SRC_SEL	2     /* 2 bits are used */
+#define LOSC_OUT_SRC_SEL_32K_SYS	0x0   /* 0b00: osc32k-sys */
+#define LOSC_OUT_SRC_SEL_32K_EXT	0x1   /* 0b01: ext-osc32k */
+#define LOSC_OUT_SRC_SEL_32K_DCXO	0x2   /* 0b10: dcxo24M-div-32k */
+#define LOSC_OUT_SRC_SEL_MASK		0x3   /* 0b11: bit mask */
+#define HOSC_TO_32K_DIVIDER_ENABLE	BIT(16)  /* 0: disable; 1: enable */
+
+#define XO_CTRL_REG			0x160  /* XO Control register */
+#define BIT_INDEX_CLK_REQ_ENB		31     /* bit 31 of XO_CTRL_REG. 0: enable; 1: disable */
+#define DCXO_EN				BIT(1) /* 0: disable; 1: enable */
+
+/* sun8iw20 does not have this register */
+#define CALI_CTRL_REG			0x164
+#define WAKEUP_DCXO_EN			BIT(31)  /* 0: ; 1:  */
+
+#define CLK_PARENT_CNT_MAX		3  /* the max count of a clock's parent */
+
+struct sunxi_rtc_ccu;  /* Forward declaration */
+typedef int (*clk_reg_fn)(struct sunxi_rtc_ccu *priv, int clk_index);
+
+struct clk_info {
+	char *clk_name;
+	char *parent_names[CLK_PARENT_CNT_MAX];  /* Must be NULL terminated */
+	clk_reg_fn reg_fn;  /* The function to register this clock */
+	clk_reg_fn unreg_fn;  /* The function to unregister this clock */
+};
+
+struct sunxi_rtc_ccu_hw_data {
+	bool support_cali;  /* Does the hardware support RC-16M calibration circuit? */
+	bool support_rtc_src_sel;  /* Does the RTC_SRC_SEL bit exist? */
+	struct clk_info *clk_info_table; /* Must be NULL terminated */
+};
+
+/* Driver's private resource */
+struct sunxi_rtc_ccu {
+	struct sunxi_rtc_ccu_hw_data *hw_data;
+	struct device *dev;
+	void __iomem *reg_base;
+	struct clk **clks;
+	int clks_num;
+};
+
+static void config_clock_tree(struct sunxi_rtc_ccu *priv)
+{
+	__maybe_unused struct device *dev = priv->dev;
+	struct sunxi_rtc_ccu_hw_data *hw_data = priv->hw_data;
+	void __iomem *reg_base = priv->reg_base;
+	void __iomem *reg;
+	u32 val;
+
+	/* Let's make it easier by simplify the clock tree: make it a fixed tree */
+
+	/* (1) enable DCXO */
+	/* by default, DCXO_EN = 1. We don't have to do this... */
+	reg = reg_base + XO_CTRL_REG;
+	val = readl(reg);
+	val |= DCXO_EN;
+	writel(val, reg);
+
+	/* (2) enable calibrated RC-16M, and switch to it */
+	if (hw_data->support_cali) {
+		reg = reg_base + CALI_CTRL_REG;
+		val = readl(reg);
+		val &= ~WAKEUP_DCXO_EN;
+		writel(val, reg);
+		reg = reg_base + INTOSC_CLK_AUTO_CALI_REG;
+		val = readl(reg);
+		val |= RC_CALI_EN;
+		val |= RC_CLK_SRC_SEL;
+		writel(val, reg);
+	}
+
+	/* (3) enable auto switch function */
+	/*
+	 * In some cases, we boot with auto switch function disabled, and try to
+	 * enable the auto switch function by rebooting.
+	 * But the rtc default value does not change unless vcc-rtc is loss.
+	 * So we should not rely on the default value of reg.
+	 */
+	reg = reg_base + LOSC_CTRL_REG;
+	val = readl(reg);
+	val &= ~LOSC_AUTO_SWT_DISABLE;
+	val |= LOSC_AUTO_SWT_32K_SEL_EN;
+	val |= KEY_FIELD_MAGIC;
+	writel(val, reg);
+
+	/* (4) set the parent of osc32k-sys to ext-osc32k */
+	reg = reg_base + LOSC_CTRL_REG;
+	val = readl(reg);
+	val |= LOSC_SRC_SEL;
+	val |= KEY_FIELD_MAGIC;
+	writel(val, reg);
+
+	/* (5) set the parent of rtc-32k to osc32k-sys */
+	if (hw_data->support_rtc_src_sel) {
+		/* by default, RTC_SRC_SEL = 0x0. We don't have to do this... */
+		reg = reg_base + LOSC_CTRL_REG;
+		val = readl(reg);
+		val &= ~RTC_SRC_SEL;
+		val |= KEY_FIELD_MAGIC;
+		writel(val, reg);
+	}
+
+#if OSC32KOUT_PARENT_FIX_TO_OSC32KSYS
+	/* (6) set the parent of osc32k-out to osc32k-sys */
+	/* by default, LOSC_OUT_SRC_SEL = 0x0. We don't have to do this... */
+	reg = reg_base + LOSC_OUT_GATING_REG;
+	val = readl(reg);
+	val &= ~(LOSC_OUT_SRC_SEL_MASK << BIT_INDEX_LOSC_OUT_SRC_SEL);
+	val |= (LOSC_OUT_SRC_SEL_32K_SYS << BIT_INDEX_LOSC_OUT_SRC_SEL);
+	writel(val, reg);
+#else
+	/* (6) enable dcxo24M-div-32k */
+	reg = reg_base + LOSC_OUT_GATING_REG;
+	val = readl(reg);
+	val |= HOSC_TO_32K_DIVIDER_ENABLE;
+	writel(val, reg);
+#endif
+
+	/* Now we have a fixed clock tree, we can treat as many as possible clocks as fixed clock */
+}
+
+/* dcxo24M-out: DCXO 24M output to WiFi */
+static int register_dcxo24M_out_as_gate(struct sunxi_rtc_ccu *priv, int clk_index)
+{
+	struct sunxi_rtc_ccu_hw_data *hw_data = priv->hw_data;
+	struct device *dev = priv->dev;
+	void __iomem *reg_base = priv->reg_base;
+	struct clk_info *clk_info = &(hw_data->clk_info_table[clk_index]);
+	const char *clkname;
+	char *parent_clkname;
+	void __iomem *reg;
+	int bit_idx;
+	u8 flags;
+
+	clkname = clk_info->clk_name;
+	parent_clkname = clk_info->parent_names[0];  /* There should be only one parent for gate clock */
+	reg = reg_base + XO_CTRL_REG;
+	bit_idx = BIT_INDEX_CLK_REQ_ENB;
+	flags = CLK_GATE_SET_TO_DISABLE;
+	priv->clks[clk_index] = clk_register_gate(NULL, clkname, parent_clkname, 0, reg, bit_idx, flags, NULL);
+	if (IS_ERR(priv->clks[clk_index])) {
+		dev_err(dev, "Couldn't register clk '%s'\n", clkname);
+		return PTR_ERR(priv->clks[clk_index]);
+	}
+
+	return 0;
+}
+static int unregister_dcxo24M_out_as_gate(struct sunxi_rtc_ccu *priv, int clk_index)
+{
+	clk_unregister_gate(priv->clks[clk_index]);
+	return 0;
+}
+
+/* iosc: Internal RC 16M */
+static int register_iosc_as_fixed_rate(struct sunxi_rtc_ccu *priv, int clk_index)
+{
+	struct sunxi_rtc_ccu_hw_data *hw_data = priv->hw_data;
+	struct device *dev = priv->dev;
+	struct clk_info *clk_info = &(hw_data->clk_info_table[clk_index]);
+	const char *clkname;
+	char *parent_clkname;
+	unsigned long fixed_rate;
+
+	clkname = clk_info->clk_name;
+	parent_clkname = clk_info->parent_names[0];  /* There should be only one parent for fixed rate clock */
+	fixed_rate = 16000000;
+	priv->clks[clk_index] = clk_register_fixed_rate(NULL, clkname, parent_clkname, 0, fixed_rate);
+	if (IS_ERR(priv->clks[clk_index])) {
+		dev_err(dev, "Couldn't register clk '%s'\n", clkname);
+		return PTR_ERR(priv->clks[clk_index]);
+	}
+
+	return 0;
+}
+static int unregister_iosc_as_fixed_rate(struct sunxi_rtc_ccu *priv, int clk_index)
+{
+	clk_unregister_fixed_rate(priv->clks[clk_index]);
+	return 0;
+}
+
+/* osc32k (osc32k-sys): internal 32k to the system */
+static int register_osc32k_as_fixed_rate(struct sunxi_rtc_ccu *priv, int clk_index)
+{
+	struct sunxi_rtc_ccu_hw_data *hw_data = priv->hw_data;
+	struct device *dev = priv->dev;
+	struct clk_info *clk_info = &(hw_data->clk_info_table[clk_index]);
+	const char *clkname;
+	char *parent_clkname;
+	unsigned long fixed_rate;
+
+	clkname = clk_info->clk_name;
+	parent_clkname = clk_info->parent_names[0];  /* There should be only one parent for fixed rate clock */
+	fixed_rate = 32768;
+	priv->clks[clk_index] = clk_register_fixed_rate(NULL, clkname, parent_clkname, 0, fixed_rate);
+	if (IS_ERR(priv->clks[clk_index])) {
+		dev_err(dev, "Couldn't register clk '%s'\n", clkname);
+		return PTR_ERR(priv->clks[clk_index]);
+	}
+
+	return 0;
+}
+static int unregister_osc32k_as_fixed_rate(struct sunxi_rtc_ccu *priv, int clk_index)
+{
+	clk_unregister_fixed_rate(priv->clks[clk_index]);
+	return 0;
+}
+
+/* osc32k-out: 32k output on pin */
+static int register_osc32k_out_as_gate(struct sunxi_rtc_ccu *priv, int clk_index)
+{
+	struct sunxi_rtc_ccu_hw_data *hw_data = priv->hw_data;
+	struct device *dev = priv->dev;
+	void __iomem *reg_base = priv->reg_base;
+	struct clk_info *clk_info = &(hw_data->clk_info_table[clk_index]);
+	const char *clkname;
+	char *parent_clkname;
+	void __iomem *reg;
+	int bit_idx;
+	u8 flags;
+
+	clkname = clk_info->clk_name;
+	parent_clkname = clk_info->parent_names[0];  /* There should be only one parent for gate clock */
+	reg = reg_base + LOSC_OUT_GATING_REG;
+	bit_idx = BIT_INDEX_LOSC_OUT_GATING;
+	flags = 0;
+	priv->clks[clk_index] = clk_register_gate(NULL, clkname, parent_clkname, 0, reg, bit_idx, flags, NULL);
+	if (IS_ERR(priv->clks[clk_index])) {
+		dev_err(dev, "Couldn't register clk '%s'\n", clkname);
+		return PTR_ERR(priv->clks[clk_index]);
+	}
+
+	return 0;
+}
+static int unregister_osc32k_out_as_gate(struct sunxi_rtc_ccu *priv, int clk_index)
+{
+	clk_unregister_gate(priv->clks[clk_index]);
+	return 0;
+}
+
+/* rtc-1k = osc32k / 32 */
+static int register_rtc_1k_as_fixed_factor(struct sunxi_rtc_ccu *priv, int clk_index)
+{
+	struct sunxi_rtc_ccu_hw_data *hw_data = priv->hw_data;
+	struct device *dev = priv->dev;
+	struct clk_info *clk_info = &(hw_data->clk_info_table[clk_index]);
+	const char *clkname;
+	char *parent_clkname;
+	u8 flags;
+	unsigned int mult;
+	unsigned int div;
+
+	clkname = clk_info->clk_name;
+	parent_clkname = clk_info->parent_names[0];  /* There should be only one parent for fixed factor clock */
+	flags = 0;
+	mult = 1;
+	div = 32;
+	priv->clks[clk_index] = clk_register_fixed_factor(NULL, clkname, parent_clkname, flags, mult, div);
+	if (IS_ERR(priv->clks[clk_index])) {
+		dev_err(dev, "Couldn't register clk '%s'\n", clkname);
+		return PTR_ERR(priv->clks[clk_index]);
+	}
+
+	return 0;
+}
+static int unregister_rtc_1k_as_fixed_factor(struct sunxi_rtc_ccu *priv, int clk_index)
+{
+	clk_unregister_fixed_factor(priv->clks[clk_index]);
+	return 0;
+}
+
+static int sunxi_rtc_clk_provider_register(struct sunxi_rtc_ccu *priv)
+{
+	struct sunxi_rtc_ccu_hw_data *hw_data = priv->hw_data;
+	struct clk_info *clk_info_table = hw_data->clk_info_table;
+	struct device *dev = priv->dev;
+	struct clk_hw_onecell_data *clk_data;
+	int err;
+	int i;
+
+	config_clock_tree(priv);
+
+	for (i = 0; clk_info_table[i].clk_name; i++)  /* get the clks_num */
+		priv->clks_num++;
+	priv->clks = devm_kzalloc(dev, priv->clks_num * sizeof(priv->clks), GFP_KERNEL);
+	if (!priv->clks) {
+		dev_err(dev, "Fail to alloc memory for priv->clks\n");
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < priv->clks_num; i++) {
+		dev_info(dev, "Registering clk '%s'\n", clk_info_table[i].clk_name);
+		err = clk_info_table[i].reg_fn(priv, i);
+		if (err) {
+			while (i--)
+				clk_info_table[i].unreg_fn(priv, i);
+			return err;
+		}
+	}
+
+	clk_data = devm_kzalloc(dev, struct_size(clk_data, hws, priv->clks_num), GFP_KERNEL);
+	if (!clk_data) {
+		dev_err(dev, "Fail to alloc memory for clk_data\n");
+		return -ENOMEM;
+	}
+
+	clk_data->num = priv->clks_num;
+	for (i = 0; i < clk_data->num; i++)
+		clk_data->hws[i] = __clk_get_hw(priv->clks[i]);
+	err = devm_of_clk_add_hw_provider(dev, of_clk_hw_onecell_get, clk_data);
+	if (err) {
+		dev_err(dev, "Fail to add clk provider\n");
+		return err;
+	}
+
+	return 0;
+}
+
+static void sunxi_rtc_clk_provider_unregister(struct sunxi_rtc_ccu *priv)
+{
+}
+
+static struct clk_info sun50iw10_clk_info_table[] = {
+	/* Keep it in the same order with the DT-BINDINGS in include/dt-bindings/clock/sun50iw10-rtc.h */
+	{
+		.clk_name = "dcxo24M-out",
+		.parent_names = { "dcxo24M", NULL },
+		.reg_fn = register_dcxo24M_out_as_gate,
+		.unreg_fn = unregister_dcxo24M_out_as_gate,
+	},
+	{
+		.clk_name = "iosc",
+		.parent_names = { NULL },
+		.reg_fn = register_iosc_as_fixed_rate,
+		.unreg_fn = unregister_iosc_as_fixed_rate,
+	},
+	{
+		.clk_name = "osc32k",
+		.parent_names = { NULL },
+		.reg_fn = register_osc32k_as_fixed_rate,
+		.unreg_fn = unregister_osc32k_as_fixed_rate,
+	},
+#if OSC32KOUT_PARENT_FIX_TO_OSC32KSYS
+	{
+		.clk_name = "osc32k-out",
+		.parent_names = { "osc32k", NULL },
+		.reg_fn = register_osc32k_out_as_gate,
+		.unreg_fn = unregister_osc32k_out_as_gate,
+	},
+#else
+	/* @TODO */
+#endif
+	{
+		.clk_name = "rtc-1k",
+		.parent_names = { "osc32k", NULL },
+		.reg_fn = register_rtc_1k_as_fixed_factor,
+		.unreg_fn = unregister_rtc_1k_as_fixed_factor,
+	},
+	{
+		/* sentinel */
+	},
+};
+
+static struct clk_info sun50iw12_clk_info_table[] = {
+	/* Keep it in the same order with the DT-BINDINGS in include/dt-bindings/clock/sun50iw12-rtc.h */
+	{
+		.clk_name = "dcxo24M-out",
+		.parent_names = { "dcxo24M", NULL },
+		.reg_fn = register_dcxo24M_out_as_gate,
+		.unreg_fn = unregister_dcxo24M_out_as_gate,
+	},
+#if OSC32KOUT_PARENT_FIX_TO_OSC32KSYS
+	{
+		.clk_name = "osc32k-out",
+		.parent_names = { "osc32k", NULL },
+		.reg_fn = register_osc32k_out_as_gate,
+		.unreg_fn = unregister_osc32k_out_as_gate,
+	},
+#else
+	/* @TODO */
+#endif
+	{
+		.clk_name = "rtc-1k",
+		.parent_names = { "osc32k", NULL },
+		.reg_fn = register_rtc_1k_as_fixed_factor,
+		.unreg_fn = unregister_rtc_1k_as_fixed_factor,
+	},
+	{
+		/* sentinel */
+	},
+};
+
+static struct sunxi_rtc_ccu_hw_data sun50iw10_hw_data = {
+	.support_cali = true,
+	.support_rtc_src_sel = false,
+	.clk_info_table = sun50iw10_clk_info_table,
+};
+
+static struct sunxi_rtc_ccu_hw_data sun50iw12_hw_data = {
+	.support_cali = true,
+	.support_rtc_src_sel = false,
+	.clk_info_table = sun50iw12_clk_info_table,
+};
+
+static const struct of_device_id sunxi_rtc_ccu_dt_ids[] = {
+	{ .compatible = "allwinner,sun50iw10p1-rtc-ccu", .data = &sun50iw10_hw_data },
+	{ .compatible = "allwinner,sun50iw12p1-rtc-ccu", .data = &sun50iw12_hw_data },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, sunxi_rtc_ccu_dt_ids);
+
+static int sunxi_rtc_ccu_probe(struct platform_device *pdev)
+{
+	struct sunxi_rtc_ccu *priv;
+	struct device *dev = &pdev->dev;
+	const struct of_device_id *of_id;
+	struct resource *res;
+	int err;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	of_id = of_match_device(sunxi_rtc_ccu_dt_ids, dev);
+	if (!of_id) {
+		dev_err(dev, "of_match_device() failed\n");
+		return -EINVAL;
+	}
+	priv->hw_data = (struct sunxi_rtc_ccu_hw_data *)(of_id->data);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(dev, "Fail to get IORESOURCE_MEM\n");
+		return -EINVAL;
+	}
+
+	/*
+	 * Don't use devm_ioremap_resource() here! Or else the RTC driver will
+	 * not able to get the same resource later in rtc-sunxi.c.
+	 */
+	//priv->reg_base = devm_ioremap_resource(dev, res);
+	priv->reg_base = devm_ioremap(dev, res->start, resource_size(res));
+	if (IS_ERR(priv->reg_base)) {
+		dev_err(dev, "Fail to map IO resource\n");
+		return PTR_ERR(priv->reg_base);
+	}
+
+	platform_set_drvdata(pdev, priv);
+	priv->dev = dev;
+
+	/* Register clk providers */
+	err = sunxi_rtc_clk_provider_register(priv);
+	if (err) {
+		dev_err(dev, "sunxi_rtc_clk_provider_register() failed\n");
+		return err;
+	}
+
+	dev_info(dev, "sunxi rtc-ccu probed\n");
+	return 0;
+}
+
+static int sunxi_rtc_ccu_remove(struct platform_device *pdev)
+{
+	struct sunxi_rtc_ccu *priv = platform_get_drvdata(pdev);
+
+	sunxi_rtc_clk_provider_unregister(priv);
+
+	return 0;
+}
+
+static struct platform_driver sunxi_rtc_ccu = {
+	.probe    = sunxi_rtc_ccu_probe,
+	.remove   = sunxi_rtc_ccu_remove,
+	.driver   = {
+		.name  = "sunxi-rtc-ccu",
+		.owner = THIS_MODULE,
+		.of_match_table = sunxi_rtc_ccu_dt_ids,
+	},
+};
+
+static int __init sunxi_rtc_ccu_init(void)
+{
+	int err;
+
+	err = platform_driver_register(&sunxi_rtc_ccu);
+	if (err)
+		pr_err("Fail to register sunxi_rtc_ccu as platform device\n");
+
+	return err;
+}
+core_initcall(sunxi_rtc_ccu_init);
+
+static void __exit sunxi_rtc_ccu_exit(void)
+{
+	platform_driver_unregister(&sunxi_rtc_ccu);
+}
+module_exit(sunxi_rtc_ccu_exit);
+
+MODULE_DESCRIPTION("sunxi RTC CCU driver");
+MODULE_AUTHOR("Martin <wuyan@allwinnertech.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION("1.1.0");
diff --git a/drivers/clk/sunxi/Kconfig b/drivers/clk/sunxi/Kconfig
index 3fba3d3ac..9344277ea 100644
--- a/drivers/clk/sunxi/Kconfig
+++ b/drivers/clk/sunxi/Kconfig
@@ -1,6 +1,6 @@
 # SPDX-License-Identifier: GPL-2.0-only
 menuconfig CLK_SUNXI
-	bool "Legacy clock support for Allwinner SoCs"
+	tristate "Legacy clock support for Allwinner SoCs"
 	depends on ARCH_SUNXI || COMPILE_TEST
 	default y
 
@@ -17,6 +17,17 @@ config CLK_SUNXI_CLOCKS
 	  node. Newer Device Trees and newer SoCs use the drivers
 	  controlled by CONFIG_SUNXI_CCU.
 
+config CLK_SUNXI_DDR
+	tristate "Legacy A100 ddr clock drivers"
+	default y
+	help
+	  Legacy ddr clock drivers being used on A100 SoCs.
+	  These drivers are kept around for
+	  Device Tree backward compatibility issues, in case one would
+	  still use a Device Tree with one clock provider by
+	  node. Newer Device Trees and newer SoCs use the drivers
+	  controlled by CONFIG_SUNXI_CCU.
+
 config CLK_SUNXI_PRCM_SUN6I
 	bool "Legacy A31 PRCM driver"
 	select MFD_SUN6I_PRCM
@@ -41,4 +52,11 @@ config CLK_SUNXI_PRCM_SUN9I
 	  Legacy clock driver for the A80 PRCM clocks. Those are
 	  usually needed for the PMIC communication, mostly.
 
+config CLK_SUN8IW15
+	tristate "Legacy clock support for sun8iw15p1"
+	default y
+	depends on ARCH_SUN8IW15
+	help
+	  Legacy clock driver for sun8iw15p1.
+
 endif
diff --git a/drivers/clk/sunxi/Makefile b/drivers/clk/sunxi/Makefile
index e10824c76..0de102189 100644
--- a/drivers/clk/sunxi/Makefile
+++ b/drivers/clk/sunxi/Makefile
@@ -3,9 +3,6 @@
 # Makefile for sunxi specific clk
 #
 
-obj-$(CONFIG_CLK_SUNXI) += clk-factors.o
-
-obj-$(CONFIG_CLK_SUNXI_CLOCKS) += clk-sunxi.o
 obj-$(CONFIG_CLK_SUNXI_CLOCKS) += clk-a10-codec.o
 obj-$(CONFIG_CLK_SUNXI_CLOCKS) += clk-a10-hosc.o
 obj-$(CONFIG_CLK_SUNXI_CLOCKS) += clk-a10-mod1.o
@@ -32,3 +29,10 @@ obj-$(CONFIG_CLK_SUNXI_PRCM_SUN6I)	+= clk-sun6i-ar100.o
 
 obj-$(CONFIG_CLK_SUNXI_PRCM_SUN8I)	+= clk-sun8i-apb0.o
 obj-$(CONFIG_CLK_SUNXI_PRCM_SUN8I)	+= clk-sun6i-apb0-gates.o
+
+obj-$(CONFIG_CLK_SUNXI_DDR) += clk-ddr.o
+
+obj-$(CONFIG_CLK_SUN8IW15) += clk.o
+ifneq ($(CONFIG_CLK_SUN8IW15),)
+clk-y += clk-sunxi.o clk-factors.o clk-periph.o clk-cpu.o clk-sun8iw15.o
+endif
diff --git a/drivers/clk/sunxi/clk-cpu.c b/drivers/clk/sunxi/clk-cpu.c
new file mode 100644
index 000000000..706ae6186
--- /dev/null
+++ b/drivers/clk/sunxi/clk-cpu.c
@@ -0,0 +1,161 @@
+/*
+ * Copyright (C) 2019 Allwinnertech.
+ * Author:huanghuafeng <huafenghuang@allwinnertech.com>
+ *
+ * base on clk/samsung/clk-cpu.c
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Adjustable factor-based clock implementation
+ */
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/module.h>
+#include "clk-cpu.h"
+#include "../clk-debugfs.h"
+
+static int sunxi_cpuclk_pre_rate_change(struct clk_notifier_data *ndata,
+		struct sunxi_cpuclk *cpuclk)
+{
+	int ret;
+	struct clk *clk = cpuclk->clk;
+	struct clk *parent = cpuclk->alt_parent;
+
+	ret =  clk_set_parent(clk, parent);
+	if (ret) {
+		pr_err("%s: failed to switch alternate parent %s\n",
+				__func__, parent->core->name);
+		return ret;
+	}
+
+	return ret;
+}
+
+static int sunxi_cpuclk_post_rate_change(struct clk_notifier_data *ndata,
+		struct sunxi_cpuclk *cpuclk)
+{
+	int ret;
+	struct clk *clk = cpuclk->clk;
+	struct clk *parent = cpuclk->parent;
+
+	ret =  clk_set_parent(clk, parent);
+	if (ret) {
+		pr_err("%s: failed to switch alternate parent %s\n",
+				__func__, parent->core->name);
+		return ret;
+	}
+	return ret;
+
+}
+
+/*
+ * This notifier function is called for the pre-rate and post-rate change
+ * notifications of the parent clock of cpuclk.
+ */
+static int sunxi_cpuclk_notifier_cb(struct notifier_block *nb,
+		unsigned long event, void *data)
+{
+	struct clk_notifier_data *ndata = data;
+	struct sunxi_cpuclk *cpuclk;
+	int ret = 0;
+
+	cpuclk = container_of(nb, struct sunxi_cpuclk, clk_nb);
+
+	if (event == PRE_RATE_CHANGE)
+		ret = sunxi_cpuclk_pre_rate_change(ndata, cpuclk);
+	else if (event == POST_RATE_CHANGE)
+		ret = sunxi_cpuclk_post_rate_change(ndata, cpuclk);
+
+	return notifier_from_errno(ret);
+}
+
+struct clk *sunxi_clk_register_cpu(struct periph_init_data *pd,
+	void __iomem  *base, const char *alt_parent, const char *parent)
+{
+	struct sunxi_cpuclk *cpuclk;
+	struct clk *clk;
+	struct clk_init_data init;
+	int ret;
+
+	BUG_ON((pd == NULL) && (pd->periph == NULL));
+
+	cpuclk = kzalloc(sizeof(*cpuclk), GFP_KERNEL);
+	if (!cpuclk) {
+		pr_err("%s: could not allocate cpuclk\n", __func__);
+		return ERR_PTR(-ENOMEM);
+	}
+
+#ifdef __SUNXI_ALL_CLK_IGNORE_UNUSED__
+	pd->flags |= CLK_IGNORE_UNUSED;
+#endif
+
+	cpuclk->periph = pd->periph;
+	init.name = pd->name;
+
+	init.ops = cpuclk->periph->priv_clkops
+			? cpuclk->periph->priv_clkops
+			: (&sunxi_clk_periph_ops);
+
+	init.flags = pd->flags;
+	init.parent_names = pd->parent_names;
+	init.num_parents = pd->num_parents;
+
+	/* Data in .init is copied by clk_register(), so stack variable OK */
+	cpuclk->periph->hw.init = &init;
+	cpuclk->periph->flags = init.flags;
+
+	/* fix registers */
+	cpuclk->periph->mux.reg = cpuclk->periph->mux.reg ? (base
+			+ (unsigned long __force)cpuclk->periph->mux.reg) : NULL;
+
+	cpuclk->periph->divider.reg = cpuclk->periph->divider.reg ? (base
+			+ (unsigned long __force)cpuclk->periph->divider.reg) : NULL;
+
+	cpuclk->periph->gate.enable = cpuclk->periph->gate.enable ? (base
+			+ (unsigned long __force)cpuclk->periph->gate.enable) : NULL;
+
+	cpuclk->periph->gate.reset = cpuclk->periph->gate.reset ? (base
+			+ (unsigned long __force)cpuclk->periph->gate.reset) : NULL;
+
+	cpuclk->periph->gate.bus = cpuclk->periph->gate.bus ? (base
+			+ (unsigned long __force)cpuclk->periph->gate.bus) : NULL;
+
+	cpuclk->periph->gate.dram = cpuclk->periph->gate.dram ? (base
+			+ (unsigned long __force)cpuclk->periph->gate.dram) : NULL;
+
+	cpuclk->clk_nb.notifier_call = sunxi_cpuclk_notifier_cb;
+
+	cpuclk->alt_parent = __clk_lookup(alt_parent);
+	if (IS_ERR(cpuclk->alt_parent)) {
+		pr_err("%s: could not lookup alternate parent %s\n",
+					__func__, alt_parent);
+		return cpuclk->alt_parent;
+	}
+
+	cpuclk->parent = __clk_lookup(parent);
+	if (IS_ERR(cpuclk->parent)) {
+		pr_err("%s: could not lookup parent clock %s\n",
+			__func__, parent);
+		return cpuclk->parent;
+	}
+
+	ret = clk_notifier_register(cpuclk->parent, &cpuclk->clk_nb);
+	if (ret) {
+		pr_err("%s: failed to register clock notifier for %s\n",
+			__func__, parent);
+		return ERR_PTR(ret);
+	}
+
+	clk = clk_register(NULL, &cpuclk->periph->hw);
+	if (IS_ERR(clk))
+		return clk;
+
+	cpuclk->clk = clk;
+	return clk;
+}
+
+
diff --git a/drivers/clk/sunxi/clk-cpu.h b/drivers/clk/sunxi/clk-cpu.h
new file mode 100644
index 000000000..e056d57d5
--- /dev/null
+++ b/drivers/clk/sunxi/clk-cpu.h
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2013 Allwinnertech.
+ * Author:huanghuafeng <huafenghuang@allwinnertech.com>
+ *
+ * base on clk/samsung/clk-cpu.c
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Adjustable factor-based clock implementation
+ */
+
+#ifndef __MACH_SUNXI_CLK_CPU_H
+#define __MACH_SUNXI_CLK_CPU_H
+#include "clk-sunxi.h"
+#include "clk-periph.h"
+
+struct sunxi_cpuclk {
+	struct sunxi_clk_periph *periph;
+	struct clk				*alt_parent;
+	struct clk				*parent;
+	struct clk				*clk;
+	struct notifier_block          clk_nb;
+};
+
+struct clk *sunxi_clk_register_cpu(struct periph_init_data *pd,
+	void __iomem  *base, const char *alt_parent, const char *parent);
+
+#endif /*__SUNXI_CLK_CPU_H*/
+
+
diff --git a/drivers/clk/sunxi/clk-ddr.c b/drivers/clk/sunxi/clk-ddr.c
new file mode 100644
index 000000000..3112835e4
--- /dev/null
+++ b/drivers/clk/sunxi/clk-ddr.c
@@ -0,0 +1,297 @@
+/*
+ * Allwinner DDR Clock driver.
+ *
+ * Copyright (C) 2020 Allwinner Technology, Inc.
+ *	fanqinghua <fanqinghua@allwinnertech.com>
+ *
+ * Implementation of ddr clock source driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/regmap.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+
+#define DRAM_CLK_REG			0x800
+
+#define MC_DFS_CONFIG	        0x1000
+#define MC_DFS_CMD(x)	        (0x1800 + (x) * 0x10) //x=0~63
+#define LAST_CMD				BIT(31)
+#define PADHOLD_CLR				BIT(25)
+#define PADHOLD_SET				BIT(24)
+#define CMD_CCU					BIT(19)
+#define ACC_PHY					BIT(18)
+#define CMD_WR					BIT(16)
+
+#define MC_DFS_WDATA_RDATA(x)	(0x1804 + (x) * 0x10) //x=0~63
+#define MC_DFS_DATA_MASK(x)	    (0x1808 + (x) * 0x10) //x=0~63
+#define MC_DFS_DIV				0x18b0
+#define MC_DFS_STATE			0x19b0
+
+#define DIV_SHIFT			0
+#define DIV_WIDTH			5
+
+#define DRIVER_NAME	"DDR Clock Driver"
+
+struct sunxi_ddrclk {
+	struct device *dev;
+	void __iomem	*ccmu_base;
+	void __iomem	*mctl_base;
+	unsigned int	dram_clk;
+	struct clk_hw	hw;
+	struct mutex  ddrfreq_lock;
+	spinlock_t      lock;
+};
+
+#define to_sunxi_ddrclk_hw(_hw) container_of(_hw, struct sunxi_ddrclk, hw)
+
+static inline void mdfs_conf(struct sunxi_ddrclk *ddrclk,
+								unsigned int reg,
+								unsigned int flag,
+								unsigned int data,
+								unsigned int dmask,
+								unsigned int id)
+{
+	writel_relaxed(reg | flag, ddrclk->mctl_base + MC_DFS_CMD(id));
+	writel_relaxed(data, ddrclk->mctl_base + MC_DFS_WDATA_RDATA(id));
+	writel_relaxed(dmask, ddrclk->mctl_base + MC_DFS_DATA_MASK(id));
+}
+
+void mctl_dfs(struct sunxi_ddrclk *ddrclk, unsigned int dram_freq_div)
+{
+	unsigned int cmd_id = 0, freq_id, timeout;
+	unsigned long flags;
+
+	switch (dram_freq_div) {
+	case 3:
+		freq_id = 0;
+		break;
+	case 4:
+		freq_id = 1;
+		break;
+	case 5:
+		freq_id = 2;
+		break;
+	case 7:
+		freq_id = 3;
+		break;
+	default:
+		dev_err(ddrclk->dev, "invalid dram_freq_div:%d\n", dram_freq_div);
+		return;
+	}
+
+	spin_lock_irqsave(&ddrclk->lock, flags);
+	mdfs_conf(ddrclk, 0x15 << 2, ACC_PHY | CMD_WR, (freq_id << 2) | (0x1 << 5), 0xFFFFFF03, cmd_id++);
+	mdfs_conf(ddrclk, 0x320, CMD_WR, 0x0, 0xFFFFFFFE, cmd_id++);
+	mdfs_conf(ddrclk, 0x304, CMD_WR, 0x2, 0xFFFFFFFE, cmd_id++);
+	mdfs_conf(ddrclk, 0x308, 0x0, 0x36000000, 0xC9FFFFFF, cmd_id++);
+	mdfs_conf(ddrclk, 0x30, CMD_WR, 0x20, 0xFFFFFFDF, cmd_id++);
+	mdfs_conf(ddrclk, 0x4, 0x0, 0x3, 0xFFFFFFFC, cmd_id++);
+	mdfs_conf(ddrclk, 0x15 << 2, PADHOLD_SET | ACC_PHY, (freq_id << 2) | (0x1 << 5), 0xFFFFFF00, cmd_id++);
+	mdfs_conf(ddrclk, 0x1B0, CMD_WR, (((dram_freq_div + 1) / 4 - 1) << 8) | (0x1 << 5), 0xFFFFFEDF, cmd_id++);
+	mdfs_conf(ddrclk, 0x320, CMD_WR, 0x1, 0xFFFFFFFE, cmd_id++);
+	mdfs_conf(ddrclk, 0x53 << 2, ACC_PHY | CMD_WR, 0x8, 0xFFFFFFF7, cmd_id++);
+	mdfs_conf(ddrclk, 0x16 << 2, ACC_PHY | CMD_WR, 0x0, 0xFFFFFFDF, cmd_id++);
+	mdfs_conf(ddrclk, dram_freq_div, CMD_CCU, 0x0, 0x0, cmd_id++);
+	mdfs_conf(ddrclk, 0x53 << 2, ACC_PHY | CMD_WR, 0x0, 0xFFFFFFF7, cmd_id++);
+	mdfs_conf(ddrclk, 0x60 << 2, ACC_PHY, 0x4, 0xFFFFFFFB, cmd_id++);
+	mdfs_conf(ddrclk, 0x16 << 2, ACC_PHY | CMD_WR, 0x20, 0xFFFFFFDF, cmd_id++);
+	mdfs_conf(ddrclk, 0x320, CMD_WR, 0x0, 0xFFFFFFFE, cmd_id++);
+	mdfs_conf(ddrclk, 0x0, CMD_WR, 0x20000000, 0xDFFFFFFF, cmd_id++);
+	mdfs_conf(ddrclk, 0x28, CMD_WR, ((dram_freq_div + 1) / 4 - 1) << 0, 0xFFFFFFFC, cmd_id++);
+	mdfs_conf(ddrclk, 0x1B0, CMD_WR, 0x0, 0xFFFFFFDF, cmd_id++);
+	mdfs_conf(ddrclk, 0x320, CMD_WR, 0x1, 0xFFFFFFFE, cmd_id++);
+	mdfs_conf(ddrclk, 0x324, 0x0, 0x1, 0xFFFFFFFE, cmd_id++);
+	mdfs_conf(ddrclk, 0x1BC, 0x0, 0x1, 0xFFFFFFFE, cmd_id++);
+	mdfs_conf(ddrclk, 0x4, PADHOLD_CLR, 0x3, 0xFFFFFFF0, cmd_id++);
+	mdfs_conf(ddrclk, 0x320, CMD_WR, 0x0, 0xFFFFFFFE, cmd_id++);
+	mdfs_conf(ddrclk, 0x304, CMD_WR, 0x0, 0xFFFFFFFD, cmd_id++);
+	mdfs_conf(ddrclk, 0x30, CMD_WR, 0x0, 0xFFFFFFDF, cmd_id++);
+	mdfs_conf(ddrclk, 0x4, 0x0, 0x1, 0xFFFFFFFC, cmd_id++);
+	mdfs_conf(ddrclk, 0x320, CMD_WR | LAST_CMD, 0x1, 0xFFFFFFFE, cmd_id++);
+
+	writel_relaxed(readl_relaxed(ddrclk->mctl_base + MC_DFS_CONFIG) | (0x1 << 8) | 0x1,
+					ddrclk->mctl_base + MC_DFS_CONFIG);
+	spin_unlock_irqrestore(&ddrclk->lock, flags);
+	/* Wait max 200us */
+	timeout = 20;
+	while (readl_relaxed(ddrclk->mctl_base + MC_DFS_STATE) >> 31 != 0x1) {
+		if (!timeout) {
+			dev_err(ddrclk->dev, "DRAM DFS timeout!\n");
+			return;
+		}
+		timeout--;
+		cpu_relax();
+		usleep_range(5, 10);
+	}
+}
+
+static unsigned long sunxi_ddr_clk_recalc_rate(struct clk_hw *hw,
+					       unsigned long parent_rate)
+{
+	struct sunxi_ddrclk *ddrclk = to_sunxi_ddrclk_hw(hw);
+	unsigned int reg_val, div;
+	unsigned long rate = parent_rate;
+
+	reg_val = readl_relaxed(ddrclk->mctl_base + MC_DFS_DIV);
+	if (reg_val == 0)
+		reg_val = readl_relaxed(ddrclk->ccmu_base + DRAM_CLK_REG);
+
+	div = (reg_val >> DIV_SHIFT) & GENMASK(DIV_WIDTH - 1, 0);
+	do_div(rate, div + 1);
+
+	return rate << 1;
+}
+
+static long sunxi_ddr_clk_round_rate(struct clk_hw *hw,
+				     unsigned long target_rate,
+				     unsigned long *prate)
+{
+	if (target_rate <= (*prate << 1) / 8)
+		return (*prate << 1) / 8;
+	else if (target_rate <= (*prate << 1) / 6)
+		return (*prate << 1) / 6;
+	else if (target_rate <= (*prate << 1) / 5)
+		return (*prate << 1) / 5;
+	else
+		return (*prate << 1) / 4;
+}
+
+static int sunxi_ddr_clk_set_rate(struct clk_hw *hw, unsigned long drate,
+				  unsigned long prate)
+{
+	struct sunxi_ddrclk *ddrclk = to_sunxi_ddrclk_hw(hw);
+
+	dev_info(ddrclk->dev, "prate:%ld, drate:%ld\n", prate, drate);
+	mutex_lock(&ddrclk->ddrfreq_lock);
+	mctl_dfs(ddrclk, ((prate << 1) / drate) - 1);
+	mutex_unlock(&ddrclk->ddrfreq_lock);
+
+	return 0;
+}
+
+const struct clk_ops sunxi_ddrclk_ops = {
+	.recalc_rate = sunxi_ddr_clk_recalc_rate,
+	.round_rate = sunxi_ddr_clk_round_rate,
+	.set_rate = sunxi_ddr_clk_set_rate,
+};
+
+static const struct of_device_id clk_ddr_of_match[] = {
+	{
+		.compatible = "allwinner,clock_ddr",
+	},
+	{ },
+};
+MODULE_DEVICE_TABLE(of, clk_ddr_of_match);
+
+static int ddr_clock_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct device_node *dram_np;
+	struct sunxi_ddrclk *ddrclk;
+	struct clk_init_data init;
+	struct clk *clk, *parent_clk;
+	const char *parent_name;
+	int ret = 0;
+
+	if (!np) {
+		dev_err(&pdev->dev, "failed to match ddr clock\n");
+		return -ENODEV;
+	}
+
+	ddrclk = devm_kzalloc(&pdev->dev, sizeof(*ddrclk), GFP_KERNEL);
+	if (!ddrclk)
+		return -ENOMEM;
+
+	ddrclk->dev = &pdev->dev;
+	platform_set_drvdata(pdev, ddrclk);
+
+	mutex_init(&ddrclk->ddrfreq_lock);
+	dram_np = of_find_node_by_path("/dram");
+	if (!dram_np) {
+		dev_err(&pdev->dev, "failed to find dram node\n");
+		return -ENODEV;
+	}
+
+	ret = of_property_read_u32(dram_np, "dram_clk", &ddrclk->dram_clk);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to find dram_clk\n");
+		return -ENODEV;
+	}
+
+	ddrclk->ccmu_base = devm_of_iomap(&pdev->dev, np, 0, NULL);
+	if (!ddrclk->ccmu_base) {
+		dev_err(&pdev->dev, "map ccmu failed\n");
+		return -ENODEV;
+	}
+
+	ddrclk->mctl_base = devm_of_iomap(&pdev->dev, np, 1, NULL);
+	if (!ddrclk->mctl_base) {
+		dev_err(&pdev->dev, "map mctl failed\n");
+		return -ENODEV;
+	}
+
+	parent_clk = devm_clk_get(&pdev->dev, "pll_ddr");
+	if (IS_ERR(parent_clk)) {
+		dev_err(&pdev->dev, "clk_get pll_ddr failed\n");
+		return -ENODEV;
+	}
+
+	parent_name = __clk_get_name(parent_clk);
+	if (!parent_name) {
+		dev_err(&pdev->dev, "get clk name failed\n");
+		return -ENODEV;
+	}
+
+	ddrclk->hw.init = &init;
+	init.name = "sdram";
+	init.ops = &sunxi_ddrclk_ops;
+	init.parent_names = &parent_name;
+	init.num_parents = 1;
+	init.flags |= CLK_SET_RATE_NO_REPARENT | CLK_GET_RATE_NOCACHE;
+
+	clk = devm_clk_register(&pdev->dev, &ddrclk->hw);
+	if (IS_ERR(clk)) {
+		dev_err(&pdev->dev, "clk_register failed\n");
+		return -ENODEV;
+	}
+
+	of_clk_add_provider(np, of_clk_src_simple_get, clk);
+	return 0;
+}
+
+static int ddr_clock_remove(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+
+	of_clk_del_provider(np);
+	return 0;
+}
+
+static struct platform_driver ddr_clock_driver = {
+	.probe   = ddr_clock_probe,
+	.remove  = ddr_clock_remove,
+	.driver  = {
+		.name  = DRIVER_NAME,
+		.of_match_table = clk_ddr_of_match,
+	},
+};
+
+module_platform_driver(ddr_clock_driver);
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("Allwinner DDR Clock driver");
+MODULE_ALIAS("platform:" DRIVER_NAME);
+MODULE_AUTHOR("fanqinghua <fanqinghua@allwinnertech.com>");
+MODULE_VERSION("1.0.0");
diff --git a/drivers/clk/sunxi/clk-factors.c b/drivers/clk/sunxi/clk-factors.c
index 4d8f0422b..516b13037 100644
--- a/drivers/clk/sunxi/clk-factors.c
+++ b/drivers/clk/sunxi/clk-factors.c
@@ -1,304 +1,745 @@
-// SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (C) 2013 Emilio Lpez <emilio@elopez.com.ar>
+ * Copyright (C) 2013 Allwinnertech, kevin.z.m <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
  *
  * Adjustable factor-based clock implementation
  */
 
+#include <linux/clk.h>
 #include <linux/clk-provider.h>
-#include <linux/delay.h>
-#include <linux/err.h>
-#include <linux/io.h>
-#include <linux/of_address.h>
+#include <linux/module.h>
 #include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/err.h>
 #include <linux/string.h>
+#include <linux/delay.h>
 
+#include "clk-sunxi.h"
 #include "clk-factors.h"
 
-/*
- * DOC: basic adjustable factor-based clock
- *
- * Traits of this clock:
- * prepare - clk_prepare only ensures that parents are prepared
- * enable - clk_enable only ensures that parents are enabled
- * rate - rate is adjustable.
- *        clk->rate = (parent->rate * N * (K + 1) >> P) / (M + 1)
- * parent - fixed parent.  No clk_set_parent support
- */
+static int sunxi_clk_disable_plllock(struct sunxi_clk_factors *factor)
+{
+	volatile u32 reg;
+
+	switch (factor->lock_mode) {
+	case PLL_LOCK_NEW_MODE:
+	case PLL_LOCK_OLD_MODE:
+		/* make sure pll new mode is disable */
+		reg = factor_readl(factor, factor->pll_lock_ctrl_reg);
+		reg = SET_BITS(factor->lock_en_bit, 1, reg, 0);
+		factor_writel(factor, reg, factor->pll_lock_ctrl_reg);
+
+		reg = factor_readl(factor, factor->pll_lock_ctrl_reg);
+		reg = SET_BITS(28, 1, reg, 0);
+		factor_writel(factor, reg, factor->pll_lock_ctrl_reg);
+		break;
+	case PLL_LOCK_NONE_MODE:
+		break;
+	default:
+		WARN(1, "invaild pll lock mode:%u\n", factor->lock_mode);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int sunxi_clk_is_lock(struct sunxi_clk_factors *factor)
+{
+	volatile u32 reg;
+	u32 loop = 5000;
+
+	if (factor->lock_mode >= PLL_LOCK_MODE_MAX) {
+		WARN(1, "invaild pll lock mode:%u\n", factor->lock_mode);
+		return -1;
+	}
+
+	if (factor->lock_mode == PLL_LOCK_NEW_MODE) {
+		/*
+		 * bit28 is only read, remove it.
+		 * reg = factor_readl(factor, factor->pll_lock_ctrl_reg);
+		 * reg = SET_BITS(28, 1, reg, 1);
+		 * factor_writel(factor, reg, factor->pll_lock_ctrl_reg);
+		 */
+
+		/* enable pll new mode */
+		reg = factor_readl(factor, factor->pll_lock_ctrl_reg);
+		reg = SET_BITS(factor->lock_en_bit, 1, reg, 1);
+		factor_writel(factor, reg, factor->pll_lock_ctrl_reg);
+	}
+
+	while (--loop) {
+		reg = factor_readl(factor, factor->lock_reg);
+		if (GET_BITS(factor->lock_bit, 1, reg)) {
+			udelay(20);
+			break;
+		}
 
-#define to_clk_factors(_hw) container_of(_hw, struct clk_factors, hw)
+		udelay(1);
+	}
 
-#define FACTORS_MAX_PARENTS		5
+	if (factor->lock_mode == PLL_LOCK_NEW_MODE) {
+		/* disable pll new mode */
+		reg = factor_readl(factor, factor->pll_lock_ctrl_reg);
+		reg = SET_BITS(factor->lock_en_bit, 1, reg, 0);
+		factor_writel(factor, reg, factor->pll_lock_ctrl_reg);
+
+		/*
+		 * bit28 is only read, remove it.
+		 * reg = factor_readl(factor, factor->pll_lock_ctrl_reg);
+		 * reg = SET_BITS(28, 1, reg, 0);
+		 * factor_writel(factor, reg, factor->pll_lock_ctrl_reg);
+		 */
+	}
 
-#define SETMASK(len, pos)		(((1U << (len)) - 1) << (pos))
-#define CLRMASK(len, pos)		(~(SETMASK(len, pos)))
-#define FACTOR_GET(bit, len, reg)	(((reg) & SETMASK(len, bit)) >> (bit))
+	if (!loop) {
+#if IS_ENABLED(CONFIG_FPGA_V4_PLATFORM) || IS_ENABLED(CONFIG_FPGA_V7_PLATFORM)
+		pr_err("clk %s wait lock timeout\n",
+		       clk_hw_get_name(&factor->hw));
+		return 0;
+#else
+		return -1;
+#endif
+	}
 
-#define FACTOR_SET(bit, len, reg, val) \
-	(((reg) & CLRMASK(len, bit)) | (val << (bit)))
+	return 0;
+}
 
-static unsigned long clk_factors_recalc_rate(struct clk_hw *hw,
-					     unsigned long parent_rate)
+#if !IS_ENABLED(CONFIG_ARCH_SUN8IW12P1)
+static int sunxi_clk_fators_enable(struct clk_hw *hw)
 {
-	u8 n = 1, k = 0, p = 0, m = 0;
-	u32 reg;
-	unsigned long rate;
-	struct clk_factors *factors = to_clk_factors(hw);
-	const struct clk_factors_config *config = factors->config;
-
-	/* Fetch the register value */
-	reg = readl(factors->reg);
-
-	/* Get each individual factor if applicable */
-	if (config->nwidth != SUNXI_FACTORS_NOT_APPLICABLE)
-		n = FACTOR_GET(config->nshift, config->nwidth, reg);
-	if (config->kwidth != SUNXI_FACTORS_NOT_APPLICABLE)
-		k = FACTOR_GET(config->kshift, config->kwidth, reg);
-	if (config->mwidth != SUNXI_FACTORS_NOT_APPLICABLE)
-		m = FACTOR_GET(config->mshift, config->mwidth, reg);
-	if (config->pwidth != SUNXI_FACTORS_NOT_APPLICABLE)
-		p = FACTOR_GET(config->pshift, config->pwidth, reg);
-
-	if (factors->recalc) {
-		struct factors_request factors_req = {
-			.parent_rate = parent_rate,
-			.n = n,
-			.k = k,
-			.m = m,
-			.p = p,
-		};
-
-		/* get mux details from mux clk structure */
-		if (factors->mux)
-			factors_req.parent_index =
-				(reg >> factors->mux->shift) &
-				factors->mux->mask;
-
-		factors->recalc(&factors_req);
-
-		return factors_req.rate;
+	struct sunxi_clk_factors *factor = to_clk_factor(hw);
+	struct sunxi_clk_factors_config *config = factor->config;
+	unsigned long reg;
+	unsigned long flags = 0;
+
+	/* check if the pll enabled already */
+	reg = factor_readl(factor, factor->reg);
+	if (GET_BITS(config->enshift, 1, reg)) {
+		if (factor->lock)
+			spin_lock_irqsave(factor->lock, flags);
+		sunxi_clk_disable_plllock(factor);
+		/* get factor register value */
+		reg = factor_readl(factor, factor->reg);
+		goto enable_sdm;
+	}
+
+	if (factor->lock)
+		spin_lock_irqsave(factor->lock, flags);
+
+	sunxi_clk_disable_plllock(factor);
+
+	/* get factor register value */
+	reg = factor_readl(factor, factor->reg);
+
+	/* enable the register */
+	reg = SET_BITS(config->enshift, 1, reg, 1);
+
+	/* update for pll_ddr register */
+	if (config->updshift)
+		reg = SET_BITS(config->updshift, 1, reg, 1);
+
+	if (config->out_enshift)
+		reg = SET_BITS(config->out_enshift, 1, reg, 1);
+
+	if (config->mux_inshift)
+		reg = SET_BITS(config->mux_inshift, 1, reg, 1);
+
+enable_sdm:
+	if (config->sdmwidth) {
+		factor_writel(factor, config->sdmval,
+			 (void __iomem *)config->sdmpat);
+		reg = SET_BITS(config->sdmshift, config->sdmwidth, reg, 1);
 	}
 
-	/* Calculate the rate */
-	rate = (parent_rate * (n + config->n_start) * (k + 1) >> p) / (m + 1);
+	factor_writel(factor, reg, factor->reg);
 
-	return rate;
+	if (sunxi_clk_is_lock(factor)) {
+		if (factor->lock)
+			spin_unlock_irqrestore(factor->lock, flags);
+		WARN(1, "clk %s wait lock timeout\n", clk_hw_get_name(&factor->hw));
+		return -1;
+	}
+
+	if (factor->lock)
+		spin_unlock_irqrestore(factor->lock, flags);
+
+	return 0;
 }
+#else
+#define PLL_ENABLE_INIT_FACTOR_N	80
+#define PLL_LOCK_TIMEOUT_CNT		5
 
-static int clk_factors_determine_rate(struct clk_hw *hw,
-				      struct clk_rate_request *req)
+static int sunxi_clk_fators_enable(struct clk_hw *hw)
 {
-	struct clk_factors *factors = to_clk_factors(hw);
-	struct clk_hw *parent, *best_parent = NULL;
-	int i, num_parents;
-	unsigned long parent_rate, best = 0, child_rate, best_child_rate = 0;
-
-	/* find the parent that can help provide the fastest rate <= rate */
-	num_parents = clk_hw_get_num_parents(hw);
-	for (i = 0; i < num_parents; i++) {
-		struct factors_request factors_req = {
-			.rate = req->rate,
-			.parent_index = i,
-		};
-		parent = clk_hw_get_parent_by_index(hw, i);
-		if (!parent)
-			continue;
-		if (clk_hw_get_flags(hw) & CLK_SET_RATE_PARENT)
-			parent_rate = clk_hw_round_rate(parent, req->rate);
-		else
-			parent_rate = clk_hw_get_rate(parent);
-
-		factors_req.parent_rate = parent_rate;
-		factors->get_factors(&factors_req);
-		child_rate = factors_req.rate;
-
-		if (child_rate <= req->rate && child_rate > best_child_rate) {
-			best_parent = parent;
-			best = parent_rate;
-			best_child_rate = child_rate;
-		}
+	struct sunxi_clk_factors *factor = to_clk_factor(hw);
+	struct sunxi_clk_factors_config *config = factor->config;
+	unsigned long reg;
+	unsigned long flags = 0;
+	u16 factor_n;
+	u8 i;
+
+	/* check if the pll enabled already */
+	reg = factor_readl(factor, factor->reg);
+	if (GET_BITS(config->enshift, 1, reg)) {
+		if (factor->lock)
+			spin_lock_irqsave(factor->lock, flags);
+		sunxi_clk_disable_plllock(factor);
+		goto enable_sdm;
+	}
+
+	if (factor->lock)
+		spin_lock_irqsave(factor->lock, flags);
+
+	sunxi_clk_disable_plllock(factor);
+
+	/* get factor register value */
+	reg = factor_readl(factor, factor->reg);
+	/* store the factor n */
+	factor_n = (reg >> config->nshift) & 0xFF;
+
+	/* enable the register */
+	reg = SET_BITS(config->enshift, 1, reg, 1);
+
+
+	/* config a larger value for factor_n */
+	if (config->nwidth)
+		reg = SET_BITS(config->nshift, config->nwidth, reg,
+					 PLL_ENABLE_INIT_FACTOR_N);
+
+	/* update for pll_ddr register */
+	if (config->updshift)
+		reg = SET_BITS(config->updshift, 1, reg, 1);
+
+enable_sdm:
+	if (config->sdmwidth) {
+		factor_writel(factor, config->sdmval,
+			(void __iomem *)config->sdmpat);
+		reg = SET_BITS(config->sdmshift, config->sdmwidth, reg, 1);
+	}
+
+	factor_writel(factor, reg, factor->reg);
+
+	for (i = 0; i < PLL_LOCK_TIMEOUT_CNT; i++) {
+		if (sunxi_clk_is_lock(factor) == 0)
+			break;
+
+		reg = SET_BITS(config->enshift, 1, reg, 0);
+		factor_writel(factor, reg, factor->reg);
+		udelay(1);
+		reg = SET_BITS(config->enshift, 1, reg, 1);
+		factor_writel(factor, reg, factor->reg);
 	}
+	if (i == PLL_LOCK_TIMEOUT_CNT) {
+		if (factor->lock)
+			spin_unlock_irqrestore(factor->lock, flags);
+		WARN(1, "clk %s wait lock timeout\n", clk_hw_get_name(&factor->hw));
+		return -1;
+	}
+
+	if (config->nwidth)
+		reg = SET_BITS(config->nshift, config->nwidth, reg, factor_n);
 
-	if (!best_parent)
-		return -EINVAL;
+	factor_writel(factor, reg, factor->reg);
 
-	req->best_parent_hw = best_parent;
-	req->best_parent_rate = best;
-	req->rate = best_child_rate;
+	if (sunxi_clk_is_lock(factor)) {
+		if (factor->lock)
+			spin_unlock_irqrestore(factor->lock, flags);
+		WARN(1, "clk %s wait lock timeout\n", clk_hw_get_name(&factor->hw));
+		return -1;
+	}
+
+	if (factor->lock)
+		spin_unlock_irqrestore(factor->lock, flags);
 
 	return 0;
 }
+#endif
+
+static void sunxi_clk_fators_disable(struct clk_hw *hw)
+{
+	struct sunxi_clk_factors *factor = to_clk_factor(hw);
+	struct sunxi_clk_factors_config *config = factor->config;
+	unsigned long reg;
+	unsigned long flags = 0;
+
+	if (factor->flags & CLK_NO_DISABLE)
+		return;
+
+	/* check if the pll disabled already */
+	reg = factor_readl(factor, factor->reg);
+	if (!GET_BITS(config->enshift, 1, reg))
+		return;
+
+	/* When the pll is not in use, just set it to the minimum frequency */
+	if (factor->flags & CLK_IGNORE_DISABLE) {
+		/*
+		clk_set_rate(hw->clk, 0);
+		*/
+		return;
+	}
+
+	if (factor->lock)
+		spin_lock_irqsave(factor->lock, flags);
+
+	reg = factor_readl(factor, factor->reg);
+	if (config->sdmwidth)
+		reg = SET_BITS(config->sdmshift, config->sdmwidth, reg, 0);
+
+	/* update for pll_ddr register */
+	if (config->updshift)
+		reg = SET_BITS(config->updshift, 1, reg, 1);
+
+	/* disable pll */
+	reg = SET_BITS(config->enshift, 1, reg, 0);
+	factor_writel(factor, reg, factor->reg);
+
+	/* disable pll lock if needed */
+	sunxi_clk_disable_plllock(factor);
+
+	if (factor->lock)
+		spin_unlock_irqrestore(factor->lock, flags);
+}
+
+static int sunxi_clk_fators_is_enabled(struct clk_hw *hw)
+{
+	unsigned long val;
+	struct sunxi_clk_factors *factor = to_clk_factor(hw);
+	struct sunxi_clk_factors_config *config = factor->config;
+	unsigned long reg;
+	unsigned long flags = 0;
+
+	if (factor->flags & CLK_NO_DISABLE)
+		return __clk_is_enabled(hw->clk);
+
+	if (factor->lock)
+		spin_lock_irqsave(factor->lock, flags);
+
+	reg = factor_readl(factor, factor->reg);
+	val = GET_BITS(config->enshift, 1, reg);
+
+	if (factor->lock)
+		spin_unlock_irqrestore(factor->lock, flags);
+
+	return val ? 1 : 0;
+}
 
-static int clk_factors_set_rate(struct clk_hw *hw, unsigned long rate,
-				unsigned long parent_rate)
+static unsigned long sunxi_clk_factors_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)
 {
-	struct factors_request req = {
-		.rate = rate,
-		.parent_rate = parent_rate,
-	};
-	u32 reg;
-	struct clk_factors *factors = to_clk_factors(hw);
-	const struct clk_factors_config *config = factors->config;
+	unsigned long reg;
+	struct clk_factors_value factor_val;
+	struct sunxi_clk_factors *factor = to_clk_factor(hw);
+	struct sunxi_clk_factors_config *config = factor->config;
 	unsigned long flags = 0;
 
-	factors->get_factors(&req);
+	if (!factor->calc_rate)
+		return 0;
+	if (factor->lock)
+		spin_lock_irqsave(factor->lock, flags);
 
-	if (factors->lock)
-		spin_lock_irqsave(factors->lock, flags);
+	reg = factor_readl(factor, factor->reg);
 
-	/* Fetch the register value */
-	reg = readl(factors->reg);
+	if (factor->lock)
+		spin_unlock_irqrestore(factor->lock, flags);
 
-	/* Set up the new factors - macros do not do anything if width is 0 */
-	reg = FACTOR_SET(config->nshift, config->nwidth, reg, req.n);
-	reg = FACTOR_SET(config->kshift, config->kwidth, reg, req.k);
-	reg = FACTOR_SET(config->mshift, config->mwidth, reg, req.m);
-	reg = FACTOR_SET(config->pshift, config->pwidth, reg, req.p);
+	if (config->nwidth)
+		factor_val.factorn = GET_BITS(config->nshift, config->nwidth, reg);
+	else
+		factor_val.factorn = 0xffff;
+
+	if (config->kwidth)
+		factor_val.factork = GET_BITS(config->kshift, config->kwidth, reg);
+	else
+		factor_val.factork = 0xffff;
+
+	if (config->mwidth)
+		factor_val.factorm = GET_BITS(config->mshift, config->mwidth, reg);
+	else
+		factor_val.factorm = 0xffff;
+
+	if (config->pwidth)
+		factor_val.factorp = GET_BITS(config->pshift, config->pwidth, reg);
+	else
+		factor_val.factorp = 0xffff;
+
+	if (config->d1width)
+		factor_val.factord1 = GET_BITS(config->d1shift, config->d1width, reg);
+	else
+		factor_val.factord1 = 0xffff;
+
+	if (config->d2width)
+		factor_val.factord2 = GET_BITS(config->d2shift, config->d2width, reg);
+	else
+		factor_val.factord2 = 0xffff;
+
+	if (config->frac) {
+		factor_val.frac_mode = GET_BITS(config->modeshift, 1, reg);
+		factor_val.frac_freq = GET_BITS(config->outshift, 1, reg);
+	} else {
+		factor_val.frac_mode = 0xffff;
+		factor_val.frac_freq = 0xffff;
+	}
+
+	return factor->calc_rate(parent_rate, &factor_val);
+}
+
+static long sunxi_clk_factors_round_rate(struct clk_hw *hw, unsigned long rate, unsigned long *prate)
+{
+	struct clk_factors_value factor_val;
+	struct sunxi_clk_factors *factor = to_clk_factor(hw);
+
+	if (!factor->get_factors || !factor->calc_rate)
+		return rate;
+
+	factor->get_factors(rate, *prate, &factor_val);
+	return factor->calc_rate(*prate, &factor_val);
+}
+
+static int sunxi_clk_factors_set_flat_facotrs(struct sunxi_clk_factors *factor,
+				struct clk_factors_value *values)
+{
+	struct sunxi_clk_factors_config *config = factor->config;
+	u32 reg, tmp_factor_p, tmp_factor_m;
+	unsigned long flags = 0;
 
-	/* Apply them now */
-	writel(reg, factors->reg);
+	if (factor->lock)
+		spin_lock_irqsave(factor->lock, flags);
 
-	/* delay 500us so pll stabilizes */
-	__delay((rate >> 20) * 500 / 2);
+	sunxi_clk_disable_plllock(factor);
 
-	if (factors->lock)
-		spin_unlock_irqrestore(factors->lock, flags);
+	/*get all factors from the regitsters*/
+	reg = factor_readl(factor, factor->reg);
+	tmp_factor_p = config->pwidth ? GET_BITS(config->pshift, config->pwidth, reg) : 0;
+	tmp_factor_m = config->mwidth ? GET_BITS(config->mshift, config->mwidth, reg) : 0;
+
+	/* 1).try to increase factor p first */
+	if (config->pwidth && (tmp_factor_p < values->factorp)) {
+		reg = factor_readl(factor, factor->reg);
+		reg = SET_BITS(config->pshift, config->pwidth, reg, values->factorp);
+		factor_writel(factor, reg, factor->reg);
+		if (factor->flags & CLK_RATE_FLAT_DELAY)
+			udelay(config->delay);
+	}
+
+	/* 2).try to increase factor m first */
+	if (config->mwidth && (tmp_factor_m < values->factorm)) {
+		reg = factor_readl(factor, factor->reg);
+		reg = SET_BITS(config->mshift, config->mwidth, reg, values->factorm);
+		factor_writel(factor, reg, factor->reg);
+		if (factor->flags & CLK_RATE_FLAT_DELAY)
+			udelay(config->delay);
+	}
+
+	/* 3. write factor n & k */
+	reg = factor_readl(factor, factor->reg);
+	if (config->nwidth)
+		reg = SET_BITS(config->nshift, config->nwidth, reg, values->factorn);
+	if (config->kwidth)
+		reg = SET_BITS(config->kshift, config->kwidth, reg, values->factork);
+	factor_writel(factor, reg, factor->reg);
+
+	/* 4. do pair things for 2). decease factor m */
+	if (config->mwidth && (tmp_factor_m > values->factorm)) {
+		reg = factor_readl(factor, factor->reg);
+		reg = SET_BITS(config->mshift, config->mwidth, reg, values->factorm);
+		factor_writel(factor, reg, factor->reg);
+		if (factor->flags & CLK_RATE_FLAT_DELAY)
+			udelay(config->delay);
+	}
+
+	/* 5. wait for PLL state stable */
+	if (sunxi_clk_is_lock(factor)) {
+		if (factor->lock)
+			spin_unlock_irqrestore(factor->lock, flags);
+		WARN(1, "clk %s wait lock timeout\n", clk_hw_get_name(&factor->hw));
+		return -1;
+	}
+
+	/*6.do pair things for 1).  decease factor p */
+	if (config->pwidth && (tmp_factor_p > values->factorp)) {
+		reg = factor_readl(factor, factor->reg);
+		reg = SET_BITS(config->pshift, config->pwidth, reg, values->factorp);
+		factor_writel(factor, reg, factor->reg);
+		if (factor->flags & CLK_RATE_FLAT_DELAY)
+			udelay(config->delay);
+	}
+
+	if (factor->lock)
+		spin_unlock_irqrestore(factor->lock, flags);
 
 	return 0;
 }
 
-static const struct clk_ops clk_factors_ops = {
-	.determine_rate = clk_factors_determine_rate,
-	.recalc_rate = clk_factors_recalc_rate,
-	.set_rate = clk_factors_set_rate,
-};
 
-static struct clk *__sunxi_factors_register(struct device_node *node,
-					    const struct factors_data *data,
-					    spinlock_t *lock, void __iomem *reg,
-					    unsigned long flags)
+static int sunxi_clk_factors_set_rate(struct clk_hw *hw, unsigned long rate, unsigned long parent_rate)
 {
-	struct clk *clk;
-	struct clk_factors *factors;
-	struct clk_gate *gate = NULL;
-	struct clk_mux *mux = NULL;
-	struct clk_hw *gate_hw = NULL;
-	struct clk_hw *mux_hw = NULL;
-	const char *clk_name = node->name;
-	const char *parents[FACTORS_MAX_PARENTS];
-	int ret, i = 0;
-
-	/* if we have a mux, we will have >1 parents */
-	i = of_clk_parent_fill(node, parents, FACTORS_MAX_PARENTS);
-
-	/*
-	 * some factor clocks, such as pll5 and pll6, may have multiple
-	 * outputs, and have their name designated in factors_data
+	unsigned long reg;
+	struct clk_factors_value factor_val;
+	struct sunxi_clk_factors *factor = to_clk_factor(hw);
+	struct sunxi_clk_factors_config *config = factor->config;
+	unsigned long flags = 0;
+
+	if (!factor->get_factors)
+		return 0;
+
+	/* factor_val is initialized with its original value,
+	 * it's factors(such as:M,N,K,P,d1,d2...) are Random Value.
+	 * if donot judge the return value of "factor->get_factors",
+	 * it may change the original register value.
 	 */
-	if (data->name)
-		clk_name = data->name;
-	else
-		of_property_read_string(node, "clock-output-names", &clk_name);
+	if (factor->get_factors(rate, parent_rate, &factor_val) < 0) {
+		/* cannot get right factors for clk,just break */
+		WARN(1, "clk %s set rate failed! Because cannot get right factors for clk\n", hw->init->name);
+		return 0;
+	}
 
-	factors = kzalloc(sizeof(struct clk_factors), GFP_KERNEL);
-	if (!factors)
-		goto err_factors;
+	if (factor->flags & CLK_RATE_FLAT_FACTORS)
+		return sunxi_clk_factors_set_flat_facotrs(factor, &factor_val);
 
-	/* set up factors properties */
-	factors->reg = reg;
-	factors->config = data->table;
-	factors->get_factors = data->getter;
-	factors->recalc = data->recalc;
-	factors->lock = lock;
+	if (factor->lock)
+		spin_lock_irqsave(factor->lock, flags);
+
+	sunxi_clk_disable_plllock(factor);
+
+	reg = factor_readl(factor, factor->reg);
+	if (config->sdmwidth) {
+		factor_writel(factor, config->sdmval, (void __iomem *)config->sdmpat);
+		reg = SET_BITS(config->sdmshift, config->sdmwidth, reg, 1);
+	}
+	if (config->nwidth)
+		reg = SET_BITS(config->nshift, config->nwidth, reg, factor_val.factorn);
+	if (config->kwidth)
+		reg = SET_BITS(config->kshift, config->kwidth, reg, factor_val.factork);
+	if (config->mwidth)
+		reg = SET_BITS(config->mshift, config->mwidth, reg, factor_val.factorm);
+	if (config->pwidth)
+		reg = SET_BITS(config->pshift, config->pwidth, reg, factor_val.factorp);
+	if (config->d1width)
+		reg = SET_BITS(config->d1shift, config->d1width, reg, factor_val.factord1);
+	if (config->d2width)
+		reg = SET_BITS(config->d2shift, config->d2width, reg, factor_val.factord2);
+	if (config->frac) {
+		reg = SET_BITS(config->modeshift, 1, reg, factor_val.frac_mode);
+		reg = SET_BITS(config->outshift, 1, reg, factor_val.frac_freq);
+	}
+	if (config->updshift)
+		reg = SET_BITS(config->updshift, 1, reg, 1);
+	factor_writel(factor, reg, factor->reg);
+
+#if !IS_ENABLED(CONFIG_SUNXI_CLK_DUMMY_DEBUG)
+	if (GET_BITS(config->enshift, 1, reg)) {
+		if (sunxi_clk_is_lock(factor)) {
+			if (factor->lock)
+				spin_unlock_irqrestore(factor->lock, flags);
+			WARN(1, "clk %s wait lock timeout\n", clk_hw_get_name(&factor->hw));
+			return -1;
+		}
+	}
+#endif
+
+	if (factor->lock)
+		spin_unlock_irqrestore(factor->lock, flags);
+
+	return 0;
+}
+
+static const struct clk_ops clk_factors_ops = {
+	.enable = sunxi_clk_fators_enable,
+	.disable = sunxi_clk_fators_disable,
+	.is_enabled = sunxi_clk_fators_is_enabled,
+
+	.recalc_rate = sunxi_clk_factors_recalc_rate,
+	.round_rate = sunxi_clk_factors_round_rate,
+	.set_rate = sunxi_clk_factors_set_rate,
+};
 
-	/* Add a gate if this factor clock can be gated */
-	if (data->enable) {
-		gate = kzalloc(sizeof(struct clk_gate), GFP_KERNEL);
-		if (!gate)
-			goto err_gate;
+void sunxi_clk_get_factors_ops(struct clk_ops *ops)
+{
+	memcpy(ops, &clk_factors_ops, sizeof(clk_factors_ops));
+}
 
-		factors->gate = gate;
+/*
+ * sunxi_clk_set_factor_lock_mode() - Set factor lock mode
+ */
+void sunxi_clk_set_factor_lock_mode(struct factor_init_data *factor,
+		const char *lock_mode)
+{
+	if (!strcmp(lock_mode, "new"))
+		factor->lock_mode = PLL_LOCK_NEW_MODE;
+	else if (!strcmp(lock_mode, "old"))
+		factor->lock_mode = PLL_LOCK_OLD_MODE;
+	else
+		factor->lock_mode = PLL_LOCK_NONE_MODE;
+}
 
-		/* set up gate properties */
-		gate->reg = reg;
-		gate->bit_idx = data->enable;
-		gate->lock = factors->lock;
-		gate_hw = &gate->hw;
+/**
+ * clk_register_factors - register a factors clock with
+ * the clock framework
+ * @dev: device registering this clock
+ * @name: name of this clock
+ * @parent_name: name of clock's parent
+ * @flags: framework-specific flags
+ * @reg: register address to adjust factors
+ * @config: shift and width of factors n, k, m, p, div1 and div2
+ * @get_factors: function to calculate the factors for a given frequency
+ * @lock: shared register lock for this clock
+ */
+struct clk *sunxi_clk_register_factors(struct device *dev, void __iomem *base,
+		spinlock_t *lock, struct factor_init_data *init_data)
+{
+	struct sunxi_clk_factors *factors;
+	struct clk *clk;
+	struct clk_init_data init;
+#if IS_ENABLED(CONFIG_PM_SLEEP)
+	struct sunxi_factor_clk_reg_cache *factor_clk_reg;
+
+	factor_clk_reg = kzalloc(sizeof(struct sunxi_factor_clk_reg_cache), GFP_KERNEL);
+	if (!factor_clk_reg) {
+		pr_err("%s: could not allocate factors clk reg\n", __func__);
+		return ERR_PTR(-ENOMEM);
 	}
+#endif
 
-	/* Add a mux if this factor clock can be muxed */
-	if (data->mux) {
-		mux = kzalloc(sizeof(struct clk_mux), GFP_KERNEL);
-		if (!mux)
-			goto err_mux;
 
-		factors->mux = mux;
+	/* allocate the factors */
+	factors = kzalloc(sizeof(struct sunxi_clk_factors), GFP_KERNEL);
+	if (!factors) {
+		pr_err("%s: could not allocate factors clk\n", __func__);
+		return ERR_PTR(-ENOMEM);
+	}
 
-		/* set up gate properties */
-		mux->reg = reg;
-		mux->shift = data->mux;
-		mux->mask = data->muxmask;
-		mux->lock = factors->lock;
-		mux_hw = &mux->hw;
+#ifdef __SUNXI_ALL_CLK_IGNORE_UNUSED__
+	init_data->flags |= CLK_IGNORE_UNUSED;
+#endif
+	init.name = init_data->name;
+	init.ops = init_data->priv_ops ? (init_data->priv_ops) : (&clk_factors_ops);
+	factors->priv_regops = init_data->priv_regops ? (init_data->priv_regops) : NULL;
+	init.flags = init_data->flags;
+	init.parent_names = init_data->parent_names;
+	init.num_parents = init_data->num_parents;
+
+	/* struct clk_factors assignments */
+	factors->reg = base + init_data->reg;
+	factors->lock_reg = base + init_data->lock_reg;
+	factors->lock_bit = init_data->lock_bit;
+	factors->pll_lock_ctrl_reg = base + init_data->pll_lock_ctrl_reg;
+	factors->lock_en_bit = init_data->lock_en_bit;
+	factors->lock_mode = init_data->lock_mode;
+	factors->config = init_data->config;
+	factors->config->sdmpat = factors->config->sdmpat ?  (unsigned long __force)(base + factors->config->sdmpat) : 0;
+	factors->lock = lock;
+	factors->hw.init = &init;
+	factors->get_factors = init_data->get_factors;
+	factors->calc_rate = init_data->calc_rate;
+	factors->flags = init_data->flags;
+#if IS_ENABLED(CONFIG_PM_SLEEP)
+	if (!strcmp(init.name, "pll_cpu") ||
+		!strcmp(init.name, "pll_ddr0") ||
+		!strcmp(init.name, "pll_ddr1")) {
+		kfree(factor_clk_reg);
+	} else {
+		factor_clk_reg->config_reg = factors->reg;
+		factor_clk_reg->sdmpat_reg = (void *)factors->config->sdmpat;
+		list_add_tail(&factor_clk_reg->node, &clk_factor_reg_cache_list);
 	}
+#endif
+	/* register the clock */
+	clk = clk_register(dev, &factors->hw);
+	factors->hw.init = NULL;
 
-	clk = clk_register_composite(NULL, clk_name,
-			parents, i,
-			mux_hw, &clk_mux_ops,
-			&factors->hw, &clk_factors_ops,
-			gate_hw, &clk_gate_ops, CLK_IS_CRITICAL);
 	if (IS_ERR(clk))
-		goto err_register;
-
-	ret = of_clk_add_provider(node, of_clk_src_simple_get, clk);
-	if (ret)
-		goto err_provider;
+		kfree(factors);
 
 	return clk;
+}
 
-err_provider:
-	/* TODO: The composite clock stuff will leak a bit here. */
-	clk_unregister(clk);
-err_register:
-	kfree(mux);
-err_mux:
-	kfree(gate);
-err_gate:
-	kfree(factors);
-err_factors:
-	return NULL;
+int sunxi_clk_get_common_factors(struct sunxi_clk_factors_config *f_config, struct clk_factors_value *factor,
+		struct sunxi_clk_factor_freq table[], unsigned long index, unsigned long tbl_size)
+{
+	if (index >= tbl_size/sizeof(struct sunxi_clk_factor_freq))
+		return -1;
+
+	factor->factorn = (table[index].factor>>f_config->nshift)&((1<<(f_config->nwidth))-1);
+	factor->factork = (table[index].factor>>f_config->kshift)&((1<<(f_config->kwidth))-1);
+	factor->factorm = (table[index].factor>>f_config->mshift)&((1<<(f_config->mwidth))-1);
+	factor->factorp = (table[index].factor>>f_config->pshift)&((1<<(f_config->pwidth))-1);
+	factor->factord1 = (table[index].factor>>f_config->d1shift)&((1<<(f_config->d1width))-1);
+	factor->factord2 = (table[index].factor>>f_config->d2shift)&((1<<(f_config->d2width))-1);
+
+	if (f_config->frac) {
+		factor->frac_mode = (table[index].factor>>f_config->modeshift)&1;
+		factor->frac_freq = (table[index].factor>>f_config->outshift)&1;
+	}
+
+	return 0;
 }
 
-struct clk *sunxi_factors_register(struct device_node *node,
-				   const struct factors_data *data,
-				   spinlock_t *lock,
-				   void __iomem *reg)
+static int sunxi_clk_freq_search(struct sunxi_clk_factor_freq tbl[],
+				unsigned long freq, int low, int high)
 {
-	return __sunxi_factors_register(node, data, lock, reg, 0);
+	int mid;
+	unsigned long checkfreq;
+
+	if (low > high)
+		return (high == -1) ? 0 : high;
+
+	mid = (low + high)/2;
+	checkfreq = tbl[mid].freq/1000000;
+
+	if (checkfreq == freq)
+		return mid;
+	else if (checkfreq > freq)
+		return sunxi_clk_freq_search(tbl, freq, low, mid - 1);
+	else
+		return sunxi_clk_freq_search(tbl, freq, mid + 1, high);
 }
 
-struct clk *sunxi_factors_register_critical(struct device_node *node,
-					    const struct factors_data *data,
-					    spinlock_t *lock,
-					    void __iomem *reg)
+static int sunxi_clk_freq_find(struct sunxi_clk_factor_freq tbl[],
+				unsigned long n, unsigned long freq)
 {
-	return __sunxi_factors_register(node, data, lock, reg, CLK_IS_CRITICAL);
+	int delta1, delta2;
+	int i = sunxi_clk_freq_search(tbl, freq, 0, n-1);
+
+	if (i != n-1) {
+
+		delta1 = (freq > tbl[i].freq / 1000000)
+			? (freq - tbl[i].freq / 1000000)
+			: (tbl[i].freq / 1000000 - freq);
+
+		delta2 = (freq > tbl[i+1].freq / 1000000)
+			? (freq - tbl[i+1].freq / 1000000)
+			: (tbl[i+1].freq / 1000000 - freq);
+
+		if (delta2 < delta1)
+			i++;
+	}
+
+	return i;
 }
 
-void sunxi_factors_unregister(struct device_node *node, struct clk *clk)
+int sunxi_clk_com_ftr_sr(struct sunxi_clk_factors_config *f_config,
+				struct clk_factors_value *factor,
+				struct sunxi_clk_factor_freq table[],
+				unsigned long index, unsigned long tbl_count)
 {
-	struct clk_hw *hw = __clk_get_hw(clk);
-	struct clk_factors *factors;
+	int i = sunxi_clk_freq_find(table, tbl_count, index);
 
-	if (!hw)
-		return;
+	if (i >= tbl_count)
+		return -1;
 
-	factors = to_clk_factors(hw);
+	factor->factorn = (table[i].factor >> f_config->nshift)&((1<<(f_config->nwidth))-1);
+	factor->factork = (table[i].factor>>f_config->kshift)&((1<<(f_config->kwidth))-1);
+	factor->factorm = (table[i].factor>>f_config->mshift)&((1<<(f_config->mwidth))-1);
+	factor->factorp = (table[i].factor>>f_config->pshift)&((1<<(f_config->pwidth))-1);
+	factor->factord1 = (table[i].factor>>f_config->d1shift)&((1<<(f_config->d1width))-1);
+	factor->factord2 = (table[i].factor>>f_config->d2shift)&((1<<(f_config->d2width))-1);
 
-	of_clk_del_provider(node);
-	/* TODO: The composite clock stuff will leak a bit here. */
-	clk_unregister(clk);
-	kfree(factors->mux);
-	kfree(factors->gate);
-	kfree(factors);
+	if (f_config->frac) {
+		factor->frac_mode = (table[i].factor>>f_config->modeshift)&1;
+		factor->frac_freq = (table[i].factor>>f_config->outshift)&1;
+	}
+
+	return 0;
 }
diff --git a/drivers/clk/sunxi/clk-factors.h b/drivers/clk/sunxi/clk-factors.h
index 7ad2ca924..43b5c1120 100644
--- a/drivers/clk/sunxi/clk-factors.h
+++ b/drivers/clk/sunxi/clk-factors.h
@@ -1,65 +1,380 @@
-/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2013 Allwinnertech, kevin.z.m <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Adjustable factor-based clock implementation
+ */
 #ifndef __MACH_SUNXI_CLK_FACTORS_H
 #define __MACH_SUNXI_CLK_FACTORS_H
 
 #include <linux/clk-provider.h>
-#include <linux/spinlock.h>
+#include <linux/clkdev.h>
+#include <linux/io.h>
+#include "clk-sunxi.h"
 
-#define SUNXI_FACTORS_NOT_APPLICABLE	(0)
+typedef enum pll_lock_mode {
+	PLL_LOCK_NEW_MODE = 0x0,
+	PLL_LOCK_OLD_MODE,
+	PLL_LOCK_NONE_MODE,
+	PLL_LOCK_MODE_MAX,
+} pll_lock_mode_e;
 
-struct clk_factors_config {
+/**
+ * struct clk_factors_value - factor value
+ *
+ * @factorn:    factor-n value
+ * @factork:    factor-k value
+ * @factorm:    factor-m value
+ * @factorp:    factor-p value
+ * @factord1:   factor-d1 value
+ * @factord2:   factor-d2 value
+ * @frac_mode:  fraction mode value
+ * @frac_freq:  fraction frequnecy value
+ */
+struct clk_factors_value {
+	u16 factorn;
+	u16 factork;
+
+	u16 factorm;
+	u16 factorp;
+
+	u16 factord1;
+	u16 factord2;
+
+	u16 frac_mode;
+	u16 frac_freq;
+};
+
+
+/**
+ * struct sunxi_clk_factors_config - factor config
+ *
+ * @nshift:     shift to factor-n bit field
+ * @nwidth:     width of factor-n bit field
+ * @kshift:     shift to factor-k bit field
+ * @kwidth:     width of factor-k bit field
+ * @mshift:     shift to factor-m bit field
+ * @mwidth:     width of factor-m bit field
+ * @pshift:     shift to factor-p bit field
+ * @pwidth:     width of factor-p bit field
+ * @d1shift:    shift to factor-d1 bit field
+ * @d1width:    width of factor-d1 bit field
+ * @d2shift:    shift to factor-d2 bit field
+ * @d2width:    width of factor-d2 bit field
+ * @frac:       flag of fraction
+ * @outshift:   shift to frequency select bit field
+ * @modeshift:  shift to fraction/integer mode select
+ * @enshift:    shift to factor enable bit field
+ * @lockshift:  shift to factor lock status bit filed
+ * @sdmshift:   shift to factor sdm enable bit filed
+ * @sdmwidth    shift to factor sdm width bit filed
+ * @sdmpat      sdmpat reg address offset
+ * @sdmval      sdm default value
+ * @updshift    shift to update bit (especial for ddr/ddr0/ddr1)
+ * @delay       for flat factors delay.
+ * @mux_inshift shift to multiplexer(multiple 24M source clocks) bit field
+ * @out_enshift shift to enable pll clock output bit field
+ */
+struct sunxi_clk_factors_config {
 	u8 nshift;
 	u8 nwidth;
 	u8 kshift;
 	u8 kwidth;
+
 	u8 mshift;
 	u8 mwidth;
 	u8 pshift;
 	u8 pwidth;
-	u8 n_start;
+
+	u8 d1shift;
+	u8 d1width;
+	u8 d2shift;
+	u8 d2width;
+
+	u8 frac;
+	u8 outshift;
+	u8 modeshift;
+	u8 enshift;
+
+	u8 lockshift;
+	u8 sdmshift;
+	u8 sdmwidth;
+
+	unsigned long sdmpat;
+	u32 sdmval;
+
+	u32 updshift;
+	u32 delay;
+
+	u32 mux_inshift;
+	u32 out_enshift;
 };
 
-struct factors_request {
-	unsigned long rate;
-	unsigned long parent_rate;
-	u8 parent_index;
-	u8 n;
-	u8 k;
-	u8 m;
-	u8 p;
+struct sunxi_clk_factor_freq {
+	u32 factor;
+	u32 freq;
 };
 
-struct factors_data {
-	int enable;
-	int mux;
-	int muxmask;
-	const struct clk_factors_config *table;
-	void (*getter)(struct factors_request *req);
-	void (*recalc)(struct factors_request *req);
-	const char *name;
+/**
+ * struct factor_init_data - factor init data
+ *
+ * @name:       name of the clock
+ * @parent_name:name of the parent
+ * @num_parents:counter of the parents
+ * @flags:      factor optimal configurations
+ * @reg:        register address for the factor
+ * @lock_reg:   register address for check if the pll has locked
+ * @lock_bit:   bit offset of the lock_reg, to check if the the pll has locked
+ * @pll_lock_ctrl_reg: pll lock control register, this function is first used on
+ *              the sun50i, to enable the function of pll hardlock
+ * @lock_en_bit:bit offset of the pll_lock_ctrl_reg, to enable the function
+ * @config:     configuration of the factor
+ * @get_factors:function for get factors parameter under a given frequency
+ * @calc_rate:  function for calculate the factor frequency
+ * @priv_ops:   private operations hook for the special factor
+ * @priv_regops:register operation hook for read/write the register
+ *
+ */
+struct factor_init_data {
+	const char          *name;
+	const char          **parent_names;
+	int                 num_parents;
+	unsigned long       flags;
+	u64                 reg;
+	u64                 lock_reg;
+	unsigned char       lock_bit;
+	u64                 pll_lock_ctrl_reg;
+	unsigned char       lock_en_bit;
+	pll_lock_mode_e     lock_mode;
+	struct sunxi_clk_factors_config *config;
+	int (*get_factors)(u32 rate, u32 parent_rate, struct clk_factors_value *factor);
+	unsigned long (*calc_rate)(u32 parent_rate, struct clk_factors_value *factor);
+	struct clk_ops *priv_ops;
+	struct sunxi_reg_ops *priv_regops;
 };
 
-struct clk_factors {
-	struct clk_hw hw;
-	void __iomem *reg;
-	const struct clk_factors_config *config;
-	void (*get_factors)(struct factors_request *req);
-	void (*recalc)(struct factors_request *req);
+/**
+ * struct sunxi_clk_factors - factor clock
+ *
+ * @hw:         handle between common and hardware-specific interfaces
+ * @dev:        device handle who register this clock
+ * @flags:      factor optimal configurations
+ * @reg:        register address for the factor
+ * @lock_reg:   register address for check if the pll has locked
+ * @lock_bit:   bit offset of the lock_reg, to check if the the pll has locked
+ * @pll_lock_ctrl_reg: pll lock control register, this function is first used on
+ *              the sun50i, to enable the function of pll hardlock
+ * @lock_en_bit:bit offset of the pll_lock_ctrl_reg, to enable the function
+ * @get_factor: function for get factors parameter under a given frequency
+ * @calc_rate:  function for calculate the factor frequency
+ * @lock:       lock for protecting the factors operations
+ * @priv_ops:   private operations hook for the special factor
+ *
+ */
+struct sunxi_clk_factors {
+	struct clk_hw       hw;
+	struct device       *dev;
+	unsigned long       flags;
+	void __iomem        *reg;
+	void __iomem        *lock_reg;
+	unsigned char       lock_bit;
+	void __iomem        *pll_lock_ctrl_reg;
+	unsigned char       lock_en_bit;
+	pll_lock_mode_e     lock_mode;
+	struct sunxi_clk_factors_config *config;
+	int (*get_factors)(u32 rate, u32 parent_rate, struct clk_factors_value *factor);
+	unsigned long (*calc_rate)(u32 parent_rate, struct clk_factors_value *factor);
 	spinlock_t *lock;
-	/* for cleanup */
-	struct clk_mux *mux;
-	struct clk_gate *gate;
+	struct sunxi_reg_ops *priv_regops;
+};
+
+struct sunxi_clk_pat_item {
+	char *name;
+	char *patname;
 };
 
-struct clk *sunxi_factors_register(struct device_node *node,
-				   const struct factors_data *data,
-				   spinlock_t *lock,
-				   void __iomem *reg);
-struct clk *sunxi_factors_register_critical(struct device_node *node,
-					    const struct factors_data *data,
-					    spinlock_t *lock,
-					    void __iomem *reg);
+static inline u32 factor_readl(struct sunxi_clk_factors *factor, void __iomem *reg)
+{
+	return ((unsigned long *)factor->priv_regops)
+			? factor->priv_regops->reg_readl(reg)
+			: readl(reg);
+}
+
+static inline void factor_writel(struct sunxi_clk_factors *factor,
+			unsigned int val, void __iomem *reg)
+{
+	(((unsigned long *)factor->priv_regops)
+		? factor->priv_regops->reg_writel(val, reg)
+		: writel(val, reg));
+}
+
+void sunxi_clk_get_factors_ops(struct clk_ops *ops);
+
+struct clk *sunxi_clk_register_factors(struct device *dev,
+		void __iomem *base, spinlock_t *lock,
+		struct factor_init_data *init_data);
+
+#define SUNXI_CLK_FACTORS(name, _nshift, _nwidth, _kshift, _kwidth,	\
+		_mshift, _mwidth,  _pshift, _pwidth, _d1shift, _d1width, \
+		_d2shift, _d2width, _frac, _outshift, _modeshift,	\
+		_enshift, _sdmshift, _sdmwidth, _sdmpat, _sdmval)     \
+	static struct sunxi_clk_factors_config sunxi_clk_factor_##name = {            \
+		.nshift = _nshift,  \
+		.nwidth = _nwidth,  \
+		.kshift = _kshift,  \
+		.kwidth = _kwidth,  \
+		.mshift = _mshift,  \
+		.mwidth = _mwidth,  \
+		.pshift = _pshift,  \
+		.pwidth = _pwidth,  \
+		.d1shift = _d1shift,    \
+		.d1width = _d1width,    \
+		.d2shift = _d2shift,    \
+		.d2width = _d2width,    \
+		.frac = _frac,          \
+		.outshift = _outshift,  \
+		.modeshift = _modeshift,\
+		.enshift = _enshift,    \
+		.sdmshift = _sdmshift,  \
+		.sdmwidth = _sdmwidth,  \
+		.sdmpat = _sdmpat,      \
+		.sdmval = _sdmval,      \
+		.updshift = 0,           \
+		.mux_inshift = 0,       \
+		.out_enshift = 0,       \
+	}
+
+#define FACTOR_ALL(nv, ns, nw, kv, ks, kw, mv, ms, mw, \
+		   pv, ps, pw, d1v, d1s, d1w, d2v, d2s, d2w) \
+		  ((((nv & ((1 << nw) - 1)) << ns) | \
+		    ((kv & ((1 << kw) - 1)) << ks) | \
+		    ((mv & ((1 << mw) - 1)) << ms) | \
+		    ((pv & ((1 << pw) - 1)) << ps) | \
+		    ((d1v & ((1 << d1w) - 1)) << d1s) | \
+		    ((d2v & ((1 << d2w) - 1)) << d2s)))
+
+#define SUNXI_CLK_FACTORS_UPDATE(name, _nshift, _nwidth, _kshift, _kwidth, \
+		_mshift, _mwidth,  _pshift, _pwidth, _d1shift, _d1width, \
+		_d2shift, _d2width, _frac, _outshift, _modeshift, \
+		_enshift, _sdmshift, _sdmwidth, _sdmpat, _sdmval, _updshift)   \
+	static struct sunxi_clk_factors_config sunxi_clk_factor_##name = {       \
+		.nshift = _nshift,  \
+		.nwidth = _nwidth,  \
+		.kshift = _kshift,  \
+		.kwidth = _kwidth,  \
+		.mshift = _mshift,  \
+		.mwidth = _mwidth,  \
+		.pshift = _pshift,  \
+		.pwidth = _pwidth,  \
+		.d1shift = _d1shift,    \
+		.d1width = _d1width,    \
+		.d2shift = _d2shift,    \
+		.d2width = _d2width,    \
+		.frac = _frac,          \
+		.outshift = _outshift,  \
+		.modeshift = _modeshift,\
+		.enshift = _enshift,    \
+		.sdmshift = _sdmshift,  \
+		.sdmwidth = _sdmwidth,  \
+		.sdmpat = _sdmpat,      \
+		.sdmval = _sdmval,      \
+		.updshift = _updshift,  \
+		.mux_inshift = 0, \
+		.out_enshift = 0, \
+	}
+
+#define SUNXI_CLK_FACTORS_DELAY(name, _nshift, _nwidth, _kshift, _kwidth, \
+		_mshift, _mwidth, _pshift, _pwidth, _d1shift, _d1width, \
+		_d2shift, _d2width, _frac, _outshift, _modeshift, \
+		_enshift, _sdmshift, _sdmwidth, _sdmpat, _sdmval, _delay)     \
+	static struct sunxi_clk_factors_config sunxi_clk_factor_##name = {	\
+		.nshift = _nshift,  \
+		.nwidth = _nwidth,  \
+		.kshift = _kshift,  \
+		.kwidth = _kwidth,  \
+		.mshift = _mshift,  \
+		.mwidth = _mwidth,  \
+		.pshift = _pshift,  \
+		.pwidth = _pwidth,  \
+		.d1shift = _d1shift,    \
+		.d1width = _d1width,    \
+		.d2shift = _d2shift,    \
+		.d2width = _d2width,    \
+		.frac = _frac,          \
+		.outshift = _outshift,  \
+		.modeshift = _modeshift,\
+		.enshift = _enshift,    \
+		.sdmshift = _sdmshift,  \
+		.sdmwidth = _sdmwidth,  \
+		.sdmpat = _sdmpat,      \
+		.sdmval = _sdmval,      \
+		.delay = _delay         \
+	}
+
+#define SUNXI_CLK_FACTORS1(name, _nshift, _nwidth, _kshift, _kwidth, \
+		_mshift, _mwidth, _pshift, _pwidth, _d1shift, _d1width, \
+		_d2shift, _d2width, _frac, _outshift, _modeshift, \
+		_enshift, _sdmshift, _sdmwidth, _sdmpat, _sdmval, \
+		_mux_inshift, _out_enshift)                        \
+	static struct sunxi_clk_factors_config sunxi_clk_factor_##name = { \
+		.nshift = _nshift,  \
+		.nwidth = _nwidth,  \
+		.kshift = _kshift,  \
+		.kwidth = _kwidth,  \
+		.mshift = _mshift,  \
+		.mwidth = _mwidth,  \
+		.pshift = _pshift,  \
+		.pwidth = _pwidth,  \
+		.d1shift = _d1shift,    \
+		.d1width = _d1width,    \
+		.d2shift = _d2shift,    \
+		.d2width = _d2width,    \
+		.frac = _frac,  \
+		.outshift = _outshift,  \
+		.modeshift = _modeshift,     \
+		.enshift = _enshift,    \
+		.sdmshift = _sdmshift,    \
+		.sdmwidth = _sdmwidth,    \
+		.sdmpat  = _sdmpat,    \
+		.sdmval  = _sdmval,    \
+		.updshift = 0,         \
+		.mux_inshift = _mux_inshift, \
+		.out_enshift = _out_enshift, \
+	}
+
+#define FACTOR_SIZEOF(name) (sizeof(factor_pll##name##_tbl)/ \
+			     sizeof(struct sunxi_clk_factor_freq))
+
+#define FACTOR_SEARCH(name) (sunxi_clk_com_ftr_sr( \
+		&sunxi_clk_factor_pll_##name, factor, \
+		factor_pll##name##_tbl, index, \
+		FACTOR_SIZEOF(name)))
+
+#define F_N8X7_M0X4(nv, mv) \
+	FACTOR_ALL(nv, 8, 7, 0,  0, 0, mv, 0, 4, 0,  0,  0, 0, 0, 0, 0, 0, 0)
+#define F_N8X5_K4X2(nv, kv) \
+	FACTOR_ALL(nv, 8, 5, kv, 4, 2, 0,  0, 0, 0,  0,  0, 0, 0, 0, 0, 0, 0)
+#define F_N8X7_M0X2(nv, mv) \
+	FACTOR_ALL(nv, 8, 7, 0,  0, 0, mv, 0, 2, 0,  0,  0, 0, 0, 0, 0, 0, 0)
+#define F_N8X5_K4X2_M0X2(nv, kv, mv) \
+	FACTOR_ALL(nv, 8, 5, kv, 4, 2, mv, 0, 2, 0,  0,  0, 0, 0, 0, 0, 0, 0)
+#define F_N8X5_K4X2_M0X2_P16x2(nv, kv, mv, pv) \
+	FACTOR_ALL(nv, 8, 5, kv, 4, 2, mv, 0, 2, pv, 16, 2, 0, 0, 0, 0, 0, 0)
+
+int sunxi_clk_get_common_factors(struct sunxi_clk_factors_config *f_config,
+			struct clk_factors_value *factor,
+			struct sunxi_clk_factor_freq table[],
+			unsigned long index, unsigned long tbl_size);
+
+int sunxi_clk_com_ftr_sr(struct sunxi_clk_factors_config *f_config,
+			struct clk_factors_value *factor,
+			struct sunxi_clk_factor_freq table[],
+			unsigned long index, unsigned long tbl_count);
 
-void sunxi_factors_unregister(struct device_node *node, struct clk *clk);
+void sunxi_clk_set_factor_lock_mode(struct factor_init_data *factor,
+			const char *lock_mode);
 
 #endif
diff --git a/drivers/clk/sunxi/clk-periph.c b/drivers/clk/sunxi/clk-periph.c
new file mode 100644
index 000000000..cae2f7e75
--- /dev/null
+++ b/drivers/clk/sunxi/clk-periph.c
@@ -0,0 +1,763 @@
+/*
+ * Copyright (C) 2013 Allwinnertech, kevin.z.m <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Adjustable factor-based clock implementation
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/module.h>
+#include "clk-sunxi.h"
+#include "clk-periph.h"
+
+#define NEW_RATE_CALCULATE 1
+
+static u8 sunxi_clk_periph_get_parent(struct clk_hw *hw)
+{
+	u8 parent;
+	unsigned long reg, flags = 0;
+	struct sunxi_clk_periph *periph = to_clk_periph(hw);
+
+	if (!periph->mux.reg)
+		return 0;
+
+	if (periph->lock)
+		spin_lock_irqsave(periph->lock, flags);
+
+	reg = periph_readl(periph, periph->mux.reg);
+	parent = GET_BITS(periph->mux.shift, periph->mux.width, reg);
+
+	if (periph->lock)
+		spin_unlock_irqrestore(periph->lock, flags);
+
+	return parent;
+}
+
+
+static int sunxi_clk_periph_set_parent(struct clk_hw *hw, u8 index)
+{
+	unsigned long reg, flags = 0;
+	struct sunxi_clk_periph *periph = to_clk_periph(hw);
+
+	if (periph->flags & CLK_READONLY)
+		return 0;
+
+	if (!periph->mux.reg)
+		return 0;
+
+	if (periph->lock)
+		spin_lock_irqsave(periph->lock, flags);
+
+	reg = periph_readl(periph, periph->mux.reg);
+	reg = SET_BITS(periph->mux.shift, periph->mux.width, reg, index);
+	periph_writel(periph, reg, periph->mux.reg);
+
+	if (periph->lock)
+		spin_unlock_irqrestore(periph->lock, flags);
+
+	return 0;
+}
+
+static int __sunxi_clk_periph_enable_shared(struct sunxi_clk_periph *periph)
+{
+	unsigned long reg;
+	struct sunxi_clk_periph_gate *gate = &periph->gate;
+
+	if (!periph->com_gate->val) {
+		/* de-assert module */
+		if (gate->reset && !(periph->flags & CLK_IGNORE_AUTORESET)
+				&& IS_SHARE_RST_GATE(periph)) {
+#if IS_ENABLED(CONFIG_ARCH_SUN8IW18P1)
+			if (!strcmp(periph->com_gate->name, "codec")) {
+				pr_debug("reset audio codec, assert and then de-assert!!\n");
+				reg = periph_readl(periph, gate->reset);
+				reg = SET_BITS(gate->rst_shift, 1, reg, 0);
+				periph_writel(periph, reg, gate->reset);
+			}
+			reg = periph_readl(periph, gate->reset);
+			reg = SET_BITS(gate->rst_shift, 1, reg, 1);
+			periph_writel(periph, reg, gate->reset);
+#else
+			reg = periph_readl(periph, gate->reset);
+			reg = SET_BITS(gate->rst_shift, 1, reg, 1);
+			periph_writel(periph, reg, gate->reset);
+#endif
+		}
+		/* enable bus gating */
+		if (gate->bus && IS_SHARE_BUS_GATE(periph)) {
+			reg = periph_readl(periph, gate->bus);
+			reg = SET_BITS(gate->bus_shift, 1, reg, 1);
+			periph_writel(periph, reg, gate->bus);
+		}
+
+		/* enable module gating */
+		if (gate->enable && IS_SHARE_MOD_GATE(periph)) {
+			reg = periph_readl(periph, gate->enable);
+			reg = SET_BITS(gate->enb_shift, 1, reg, 1);
+			periph_writel(periph, reg, gate->enable);
+		}
+
+		/* enable dram gating */
+		if (gate->dram && IS_SHARE_MBUS_GATE(periph)) {
+			reg = periph_readl(periph, gate->dram);
+			reg = SET_BITS(gate->ddr_shift, 1, reg, 1);
+			periph_writel(periph, reg, gate->dram);
+		}
+	}
+	periph->com_gate->val |= 1 << periph->com_gate_off;
+
+	return 0;
+}
+
+static int __sunxi_clk_periph_enable(struct clk_hw *hw)
+{
+	unsigned long reg;
+	struct sunxi_clk_periph *periph = to_clk_periph(hw);
+	struct sunxi_clk_periph_gate *gate = &periph->gate;
+
+	/* de-assert module */
+	if (gate->reset && !(periph->flags & CLK_IGNORE_AUTORESET) && !IS_SHARE_RST_GATE(periph)) {
+		reg = periph_readl(periph, gate->reset);
+		reg = SET_BITS(gate->rst_shift, 1, reg, 1);
+		periph_writel(periph, reg, gate->reset);
+	}
+
+	/* enable bus gating */
+	if (gate->bus && !IS_SHARE_BUS_GATE(periph)) {
+		reg = periph_readl(periph, gate->bus);
+		reg = SET_BITS(gate->bus_shift, 1, reg, 1);
+		periph_writel(periph, reg, gate->bus);
+	}
+
+	/* enable module gating */
+	if (gate->enable && !IS_SHARE_MOD_GATE(periph)) {
+		reg = periph_readl(periph, gate->enable);
+		if (periph->flags & CLK_REVERT_ENABLE)
+			reg = SET_BITS(gate->enb_shift, 1, reg, 0);
+		else
+			reg = SET_BITS(gate->enb_shift, 1, reg, 1);
+		periph_writel(periph, reg, gate->enable);
+	}
+
+	/* enable dram gating */
+	if (gate->dram && !IS_SHARE_MBUS_GATE(periph)) {
+		reg = periph_readl(periph, gate->dram);
+		reg = SET_BITS(gate->ddr_shift, 1, reg, 1);
+		periph_writel(periph, reg, gate->dram);
+	}
+
+	return 0;
+}
+
+static int sunxi_clk_periph_enable(struct clk_hw *hw)
+{
+	unsigned long flags = 0;
+	int ret = 0;
+	struct sunxi_clk_periph *periph = to_clk_periph(hw);
+
+	if (periph->flags & CLK_READONLY)
+		return 0;
+
+	if (periph->lock)
+		spin_lock_irqsave(periph->lock, flags);
+
+	/* if common gate exist, enable it first */
+	if (periph->com_gate)
+		ret = __sunxi_clk_periph_enable_shared(periph);
+	if (!ret)
+		ret = __sunxi_clk_periph_enable(hw);
+
+	if (periph->lock)
+		spin_unlock_irqrestore(periph->lock, flags);
+
+	return ret;
+}
+
+static int __sunxi_clk_periph_is_enabled(struct clk_hw *hw)
+{
+	int state = 1;
+	unsigned long reg;
+	struct sunxi_clk_periph *periph = to_clk_periph(hw);
+	struct sunxi_clk_periph_gate *gate = &periph->gate;
+
+	/* enable bus gating */
+	if (gate->bus) {
+		reg = periph_readl(periph, gate->bus);
+		state &= GET_BITS(gate->bus_shift, 1, reg);
+	}
+
+	/* enable module gating */
+	if (gate->enable) {
+		reg = periph_readl(periph, gate->enable);
+		state &= GET_BITS(gate->enb_shift, 1, reg);
+	}
+
+	/* de-assert module */
+	if (gate->reset) {
+		reg = periph_readl(periph, gate->reset);
+		state &= GET_BITS(gate->rst_shift, 1, reg);
+	}
+
+	/* enable dram gating */
+	if (gate->dram) {
+		reg = periph_readl(periph, gate->dram);
+		state &= GET_BITS(gate->ddr_shift, 1, reg);
+	}
+
+	return state;
+}
+
+static int sunxi_clk_periph_is_enabled(struct clk_hw *hw)
+{
+	int state = 0;
+	unsigned long flags = 0;
+	struct sunxi_clk_periph *periph = to_clk_periph(hw);
+
+	if (periph->lock)
+		spin_lock_irqsave(periph->lock, flags);
+
+	state = __sunxi_clk_periph_is_enabled(hw);
+
+	if (periph->lock)
+		spin_unlock_irqrestore(periph->lock, flags);
+
+	return state;
+}
+
+static void __sunxi_clk_periph_disable_shared(struct sunxi_clk_periph *periph)
+{
+	unsigned long reg;
+	struct sunxi_clk_periph_gate *gate = &periph->gate;
+
+	if (!periph->com_gate->val)
+		return;
+
+	periph->com_gate->val &= ~(1 << periph->com_gate_off);
+
+	if (!periph->com_gate->val) {
+		/* disable dram gating */
+		if (gate->dram && IS_SHARE_MBUS_GATE(periph)) {
+			reg = periph_readl(periph, gate->dram);
+			reg = SET_BITS(gate->ddr_shift, 1, reg, 0);
+			periph_writel(periph, reg, gate->dram);
+		}
+
+		/* disable module gating */
+		if (gate->enable && IS_SHARE_MOD_GATE(periph)) {
+			reg = periph_readl(periph, gate->enable);
+			reg = SET_BITS(gate->enb_shift, 1, reg, 0);
+			periph_writel(periph, reg, gate->enable);
+		}
+
+		/* disable bus gating */
+		if (gate->bus && IS_SHARE_BUS_GATE(periph)) {
+			reg = periph_readl(periph, gate->bus);
+			reg = SET_BITS(gate->bus_shift, 1, reg, 0);
+			periph_writel(periph, reg, gate->bus);
+		}
+
+		/* assert module */
+		if (gate->reset && !(periph->flags & CLK_IGNORE_AUTORESET) && IS_SHARE_RST_GATE(periph)) {
+#if IS_ENABLED(CONFIG_ARCH_SUN8IW18P1)
+			if (!strcmp(periph->com_gate->name, "codec")) {
+				pr_debug("don't reset audio codec, keep de-assert\n");
+			} else {
+				reg = periph_readl(periph, gate->reset);
+				reg = SET_BITS(gate->rst_shift, 1, reg, 0);
+				periph_writel(periph, reg, gate->reset);
+			}
+#else
+			reg = periph_readl(periph, gate->reset);
+			reg = SET_BITS(gate->rst_shift, 1, reg, 0);
+			periph_writel(periph, reg, gate->reset);
+#endif
+		}
+	}
+
+}
+
+static void __sunxi_clk_periph_disable(struct clk_hw *hw)
+{
+	unsigned long reg;
+	struct sunxi_clk_periph *periph = to_clk_periph(hw);
+	struct sunxi_clk_periph_gate *gate = &periph->gate;
+
+	/* disable dram gating */
+	if (gate->dram && !IS_SHARE_MBUS_GATE(periph)) {
+		reg = periph_readl(periph, gate->dram);
+		reg = SET_BITS(gate->ddr_shift, 1, reg, 0);
+		periph_writel(periph, reg, gate->dram);
+	}
+
+	/* disable module gating */
+	if (gate->enable && !IS_SHARE_MOD_GATE(periph)) {
+		reg = periph_readl(periph, gate->enable);
+		if (periph->flags & CLK_REVERT_ENABLE)
+			reg = SET_BITS(gate->enb_shift, 1, reg, 1);
+		else
+			reg = SET_BITS(gate->enb_shift, 1, reg, 0);
+
+		periph_writel(periph, reg, gate->enable);
+	}
+
+	/* disable bus gating */
+	if (gate->bus && !IS_SHARE_BUS_GATE(periph)) {
+		reg = periph_readl(periph, gate->bus);
+		reg = SET_BITS(gate->bus_shift, 1, reg, 0);
+		periph_writel(periph, reg, gate->bus);
+	}
+
+	/* assert module */
+	if (gate->reset && !(periph->flags & CLK_IGNORE_AUTORESET) && !IS_SHARE_RST_GATE(periph)) {
+		reg = periph_readl(periph, gate->reset);
+		reg = SET_BITS(gate->rst_shift, 1, reg, 0);
+		periph_writel(periph, reg, gate->reset);
+	}
+}
+
+static void sunxi_clk_periph_disable(struct clk_hw *hw)
+{
+	unsigned long flags = 0;
+	struct sunxi_clk_periph *periph = to_clk_periph(hw);
+
+	if (periph->flags & CLK_READONLY)
+		return;
+
+	if (periph->lock)
+		spin_lock_irqsave(periph->lock, flags);
+
+	__sunxi_clk_periph_disable(hw);
+
+	/* if common gate exist, disable it */
+	if (periph->com_gate)
+		__sunxi_clk_periph_disable_shared(periph);
+
+	if (periph->lock)
+		spin_unlock_irqrestore(periph->lock, flags);
+}
+
+static unsigned long sunxi_clk_periph_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)
+{
+	unsigned long reg, flags = 0;
+	struct sunxi_clk_periph *periph = to_clk_periph(hw);
+	struct sunxi_clk_periph_div *divider = &periph->divider;
+	unsigned long div, div_m = 0, div_n = 0;
+	u64 rate = parent_rate;
+
+	if (!divider->reg)
+		return parent_rate;
+
+	if (periph->lock)
+		spin_lock_irqsave(periph->lock, flags);
+
+	reg = periph_readl(periph, divider->reg);
+	if (divider->mwidth)
+		div_m = GET_BITS(divider->mshift, divider->mwidth, reg);
+	if (divider->nwidth)
+		div_n = GET_BITS(divider->nshift, divider->nwidth, reg);
+	div = (div_m+1) * (1<<div_n);
+	do_div(rate, div);
+
+	if (periph->lock)
+		spin_unlock_irqrestore(periph->lock, flags);
+
+	return rate;
+}
+
+static long sunxi_clk_periph_round_rate(struct clk_hw *hw, unsigned long rate, unsigned long *prate)
+{
+	struct sunxi_clk_periph *periph = to_clk_periph(hw);
+	struct sunxi_clk_periph_div *divider = &periph->divider;
+#ifdef NEW_RATE_CALCULATE
+	unsigned long i = 0, factor_m = 0, factor_n = 0, found = 0;
+#endif
+	unsigned long div, div_m = 0, div_n = 0;
+	u64 parent_rate = (*prate+rate/2-1);
+
+	if (!rate)
+		return -1;
+
+	do_div(parent_rate, rate);
+	div = parent_rate;
+	if (!div)
+		return *prate;
+
+	parent_rate = *prate;
+	div_m = 1<<divider->mwidth;
+	if (divider->nwidth) {
+		div_n = 1<<divider->nwidth;
+		div_n = 1<<(div_n-1);
+	} else
+		div_n = 1;
+
+#ifndef NEW_RATE_CALCULATE
+	if (div <= div_m) {
+		do_div(parent_rate, div);
+	} else if ((div <= div_m*2) && (div_n >= 2)) {
+		div &= ~(1<<0);
+		do_div(parent_rate, div);
+	} else if ((div <= div_m*4) && (div_n >= 4)) {
+		div &= ~(3<<0);
+		do_div(parent_rate, div);
+	} else if ((div <= div_m*8) && (div_n >= 8)) {
+		div &= ~(7<<0);
+		do_div(parent_rate, div);
+	} else if ((div <= div_m*16) && (div_n >= 16)) {
+		div &= ~(15<<0);
+		do_div(parent_rate, div);
+	} else if ((div <= div_m*32) && (div_n >= 32)) {
+		div &= ~(31<<0);
+		do_div(parent_rate, div);
+	} else if ((div <= div_m*64) && (div_n >= 64)) {
+		div &= ~(63<<0);
+		do_div(parent_rate, div);
+	} else if ((div <= div_m*128) && (div_n >= 128)) {
+		div &= ~(127<<0);
+		do_div(parent_rate, div);
+	} else {
+		do_div(parent_rate, div_m*div_n);
+	}
+#else
+	/* NEW_RATE_CALCULATE */
+	while (i < (1 << divider->nwidth)) {
+		if (div <= div_m) {
+			factor_m = div-1;
+			factor_n = i;
+			do_div(parent_rate, (factor_m+1)*(1 << factor_n));
+			found = 1;
+			break;
+		}
+		div = div >> 1;
+		i++;
+
+		if (!div) {
+			factor_m = 0;
+			factor_n = i;
+			do_div(parent_rate, (factor_m+1)*(1 << factor_n));
+			found = 1;
+			break;
+		}
+	}
+	if (!found) {
+		factor_m = (div > div_m ? div_m : div) - 1;
+		factor_n = (1<<divider->nwidth) - 1;
+		do_div(parent_rate, (factor_m+1) * (1 << factor_n));
+	}
+#endif
+
+	return parent_rate;
+}
+
+static int __sunxi_clk_periph_set_rate(struct clk_hw *hw, unsigned long rate, unsigned long parent_rate)
+{
+#ifdef NEW_RATE_CALCULATE
+	unsigned long i = 0, factor_m = 0, factor_n = 0, found = 0;
+#endif
+	unsigned long reg;
+	struct sunxi_clk_periph *periph = to_clk_periph(hw);
+	struct sunxi_clk_periph_div *divider = &periph->divider;
+	unsigned long div, div_m = 0, div_n = 0;
+	u64 tmp_rate = parent_rate;
+
+	if (periph->flags & CLK_READONLY)
+		return 0;
+
+	if (!divider->reg)
+		return 0;
+
+	do_div(tmp_rate, rate);
+	div = tmp_rate;
+	if (!div) {
+		div_m = div_n = 0;
+	} else {
+		div_m = 1<<divider->mwidth;
+		div_n = (1<<divider->nwidth) - 1;
+
+		if (div > (div_m<<div_n)) {
+			WARN(1, "clk %s rate is too large : %lu\n", hw->init->name, rate);
+			div = div_m<<div_n;
+		}
+#ifndef NEW_RATE_CALCULATE
+		if (div < div_m) {
+			div_m = div;
+			div_n = 0;
+		} else if ((div < div_m*2) && (div_n > 0)) {
+			div_n = 1;
+			div_m = div>>1;
+		} else if ((div < div_m*4) && (div_n > 1)) {
+			div_n = 2;
+			div_m = div>>2;
+		} else if ((div < div_m*8) && (div_n > 2)) {
+			div_n = 3;
+			div_m = div>>3;
+		} else if ((div < div_m*16) && (div_n > 3)) {
+			div_n = 4;
+			div_m = div>>4;
+		} else if ((div < div_m*32) && (div_n > 4)) {
+			div_n = 5;
+			div_m = div>>5;
+		} else if ((div < div_m*64) && (div_n > 5)) {
+			div_n = 6;
+			div_m = div>>6;
+		} else if ((div < div_m*128) && (div_n > 6)) {
+			div_n = 7;
+			div_m = div>>7;
+		} else {
+			div_m = (1 << divider->mwidth);
+			div_n = (1 << divider->nwidth) - 1;
+		}
+		if (div_m)
+			div_m--;
+#else
+		found = 0;
+		while (i < (1<<divider->nwidth)) {
+			if (div <= div_m) {
+				factor_m = div-1;
+				factor_n = i;
+				found = 1;
+				break;
+			}
+			div = div >> 1;
+			i++;
+			if (!div) {
+				factor_m = 0;
+				factor_n = i;
+				found = 1;
+				break;
+			}
+		}
+
+		if (!found) {
+			factor_m = (div > div_m ? div_m : div) - 1;
+			factor_n = (1 << divider->nwidth) - 1;
+		}
+		div_m = factor_m;
+		div_n = factor_n;
+#endif
+	}
+
+	reg = periph_readl(periph, divider->reg);
+	if (divider->mwidth)
+		reg = SET_BITS(divider->mshift, divider->mwidth, reg, div_m);
+	if (divider->nwidth)
+		reg = SET_BITS(divider->nshift, divider->nwidth, reg, div_n);
+	periph_writel(periph, reg, divider->reg);
+
+	return 0;
+}
+
+static int sunxi_clk_periph_set_rate(struct clk_hw *hw, unsigned long rate, unsigned long parent_rate)
+{
+	unsigned long flags = 0;
+	int ret = 0;
+	struct sunxi_clk_periph *periph = to_clk_periph(hw);
+
+	if (periph->lock)
+		spin_lock_irqsave(periph->lock, flags);
+
+	ret = __sunxi_clk_periph_set_rate(hw, rate, parent_rate);
+
+	if (periph->lock)
+		spin_unlock_irqrestore(periph->lock, flags);
+
+	return ret;
+}
+
+const struct clk_ops sunxi_clk_periph_ops = {
+
+	.get_parent = sunxi_clk_periph_get_parent,
+	.set_parent = sunxi_clk_periph_set_parent,
+
+	.recalc_rate = sunxi_clk_periph_recalc_rate,
+	.round_rate = sunxi_clk_periph_round_rate,
+	.set_rate = sunxi_clk_periph_set_rate,
+
+	.is_enabled = sunxi_clk_periph_is_enabled,
+	.enable = sunxi_clk_periph_enable,
+	.disable = sunxi_clk_periph_disable,
+};
+
+void sunxi_clk_get_periph_ops(struct clk_ops *ops)
+{
+	memcpy(ops, &sunxi_clk_periph_ops, sizeof(sunxi_clk_periph_ops));
+}
+
+struct clk *sunxi_clk_register_periph(struct periph_init_data *pd,
+		void __iomem  *base)
+{
+	struct clk *clk;
+	struct clk_init_data init;
+	struct sunxi_clk_periph *periph;
+#if IS_ENABLED(CONFIG_PM_SLEEP)
+	struct sunxi_periph_clk_reg_cache *periph_clk_reg;
+#endif
+
+	BUG_ON((pd == NULL) && (pd->periph == NULL));
+
+#if IS_ENABLED(CONFIG_PM_SLEEP)
+	periph_clk_reg = kzalloc(sizeof(struct sunxi_periph_clk_reg_cache), GFP_KERNEL);
+	if (!periph_clk_reg) {
+		pr_err("%s: could not allocate periph clk reg\n", __func__);
+		return ERR_PTR(-ENOMEM);
+	}
+#endif
+
+#ifdef __SUNXI_ALL_CLK_IGNORE_UNUSED__
+	pd->flags |= CLK_IGNORE_UNUSED;
+#endif
+
+	periph = pd->periph;
+	init.name = pd->name;
+
+	init.ops = periph->priv_clkops
+			? periph->priv_clkops
+			: (&sunxi_clk_periph_ops);
+
+	init.flags = pd->flags;
+	init.parent_names = pd->parent_names;
+	init.num_parents = pd->num_parents;
+
+	/* Data in .init is copied by clk_register(), so stack variable OK */
+	periph->hw.init = &init;
+	periph->flags = init.flags;
+
+	/* fix registers */
+	periph->mux.reg = periph->mux.reg ? (base
+			+ (unsigned long __force)periph->mux.reg) : NULL;
+
+	periph->divider.reg = periph->divider.reg ? (base
+			+ (unsigned long __force)periph->divider.reg) : NULL;
+
+	periph->gate.enable = periph->gate.enable ? (base
+			+ (unsigned long __force)periph->gate.enable) : NULL;
+
+	periph->gate.reset = periph->gate.reset ? (base
+			+ (unsigned long __force)periph->gate.reset) : NULL;
+
+	periph->gate.bus = periph->gate.bus ? (base
+			+ (unsigned long __force)periph->gate.bus) : NULL;
+
+	periph->gate.dram = periph->gate.dram ? (base
+			+ (unsigned long __force)periph->gate.dram) : NULL;
+
+#if IS_ENABLED(CONFIG_PM_SLEEP)
+	if (!strcmp(init.name, "cpu")  || !strcmp(init.name, "axi") ||
+		 !strcmp(init.name, "cpuapb") || !strcmp(init.name, "ahb1") ||
+		 !strcmp(init.name, "ahb2")) {
+		kfree(periph_clk_reg);
+	} else {
+		periph_clk_reg->mux_reg = periph->mux.reg ? periph->mux.reg : NULL;
+		periph_clk_reg->divider_reg = periph->divider.reg ? periph->divider.reg : NULL;
+		periph_clk_reg->gate_enable_reg = periph->gate.enable ? periph->gate.enable : NULL;
+		periph_clk_reg->gate_reset_reg = periph->gate.reset ? periph->gate.reset : NULL;
+		periph_clk_reg->gate_bus_reg = periph->gate.bus ? periph->gate.bus : NULL;
+		periph_clk_reg->gate_dram_reg = periph->gate.dram ? periph->gate.dram : NULL;
+		list_add_tail(&periph_clk_reg->node, &clk_periph_reg_cache_list);
+	}
+#endif
+	clk = clk_register(NULL, &periph->hw);
+	if (IS_ERR(clk))
+		return clk;
+
+	return clk;
+}
+
+int sunxi_periph_reset_deassert(struct clk *c)
+{
+	struct clk_hw *hw = __clk_get_hw(c);
+	struct sunxi_clk_periph *periph = to_clk_periph(hw);
+	struct sunxi_clk_periph_gate *gate = &periph->gate;
+	unsigned long reg, flag = 0;
+	unsigned long flags = 0;
+
+	if (periph->flags & CLK_READONLY)
+		return 0;
+
+	if ((periph->com_gate && periph->com_gate->val)
+		&& (periph->com_gate->val & periph->com_gate->mask) != (1 << periph->com_gate_off))
+		return 1;
+
+	if (periph->lock)
+		spin_lock_irqsave(periph->lock, flags);
+
+	if (gate->dram) {
+		reg = periph_readl(periph, gate->dram);
+		flag = GET_BITS(gate->ddr_shift, 1, reg);
+		/* disable dram access */
+		reg = SET_BITS(gate->ddr_shift, 1, reg, 0);
+		periph_writel(periph, reg, gate->dram);
+	}
+
+	if (gate->reset) {
+		reg = periph_readl(periph, gate->reset);
+		reg = SET_BITS(gate->rst_shift, 1, reg, 1);
+		periph_writel(periph, reg, gate->reset);
+	}
+
+	/* enable dram access if it is needed */
+	if (gate->dram && flag) {
+		reg = periph_readl(periph, gate->dram);
+		reg = SET_BITS(gate->ddr_shift, 1, reg, 1);
+		periph_writel(periph, reg, gate->dram);
+	}
+
+	if (periph->lock)
+		spin_unlock_irqrestore(periph->lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(sunxi_periph_reset_deassert);
+
+int sunxi_periph_reset_assert(struct clk *c)
+{
+	struct clk_hw *hw = __clk_get_hw(c);
+	struct sunxi_clk_periph *periph = to_clk_periph(hw);
+	struct sunxi_clk_periph_gate *gate = &periph->gate;
+	unsigned long reg, flag = 0;
+	unsigned long flags = 0;
+
+	if (periph->flags & CLK_READONLY)
+		return 0;
+
+	if ((periph->com_gate && periph->com_gate->val)
+		&& (periph->com_gate->val & periph->com_gate->mask) != (1 << periph->com_gate_off))
+		return 1;
+
+	if (periph->lock)
+		spin_lock_irqsave(periph->lock, flags);
+
+	/* disable dram access */
+	if (gate->dram) {
+		reg = periph_readl(periph, gate->dram);
+		flag = GET_BITS(gate->ddr_shift, 1, reg);
+		reg = SET_BITS(gate->ddr_shift, 1, reg, 0);
+		periph_writel(periph, reg, gate->dram);
+	}
+
+	/* assert reset of periph */
+	if (gate->reset) {
+		reg = periph_readl(periph, gate->reset);
+		reg = SET_BITS(gate->rst_shift, 1, reg, 0);
+		periph_writel(periph, reg, gate->reset);
+	}
+
+	/* enable dram access if it is needed */
+	if (gate->dram && flag) {
+		reg = periph_readl(periph, gate->dram);
+		reg = SET_BITS(gate->ddr_shift, 1, reg, 1);
+		periph_writel(periph, reg, gate->dram);
+	}
+
+	if (periph->lock)
+		spin_unlock_irqrestore(periph->lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(sunxi_periph_reset_assert);
diff --git a/drivers/clk/sunxi/clk-periph.h b/drivers/clk/sunxi/clk-periph.h
new file mode 100644
index 000000000..51b00656e
--- /dev/null
+++ b/drivers/clk/sunxi/clk-periph.h
@@ -0,0 +1,204 @@
+/*
+ * Copyright (C) 2013 Allwinnertech, kevin.z.m <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Adjustable periph-based clock implementation
+ */
+#ifndef __MACH_SUNXI_CLK_PERIPH_H
+#define __MACH_SUNXI_CLK_PERIPH_H
+
+#include <linux/clk-provider.h>
+#include <linux/clkdev.h>
+#include <linux/io.h>
+#include <asm/div64.h>
+
+/**
+ * struct sunxi_clk_periph_gate - peripheral gate clock
+ *
+ * @flags:      hardware-specific flags
+ * @enable:     enable register
+ * @reset:      reset register
+ * @bus:        bus gating resiter
+ * @dram:       dram gating register
+ * @enb_shift:  enable gate bit shift
+ * @rst_shift:  reset gate bit shift
+ * @bus_shift:  bus gate bit shift
+ * @ddr_shift:  dram gate bit shift
+ *
+ * Flags:
+ * SUNXI_PERIPH_NO_GATE - this flag indicates that module gate is not allowed for this module.
+ * SUNXI_PERIPH_NO_RESET - This flag indicates that reset is not allowed for this module.
+ * SUNXI_PERIPH_NO_BUS_GATE - This flag indicates that bus gate is not allowed for this module.
+ * SUNXI_PERIPH_NO_DDR_GATE - This flag indicates that dram gate is not allowed for this module.
+ */
+struct sunxi_clk_periph_gate {
+	u32             flags;
+	void __iomem    *enable;
+	void __iomem    *reset;
+	void __iomem    *bus;
+	void __iomem    *dram;
+	u8              enb_shift;
+	u8              rst_shift;
+	u8              bus_shift;
+	u8              ddr_shift;
+};
+
+/**
+ * struct sunxi_clk_periph_div - periph divider clock
+ *
+ * @reg:        register containing divider
+ * @mshift:     shift to the divider-m bit field, div = (m+1)
+ * @mwidth:     width of the divider-m bit field
+ * @nshift:     shift to the divider-n bit field, div = (1<<n)
+ * @nwidth:     width of the divider-n bit field
+ * @lock:       register lock
+ *
+ * Flags:
+ */
+struct sunxi_clk_periph_div {
+	void __iomem    *reg;
+	u8              mshift;
+	u8              mwidth;
+	u8              nshift;
+	u8              nwidth;
+	spinlock_t      *lock;
+};
+
+
+/**
+ * struct sunxi_clk_periph_mux - multiplexer clock
+ *
+ * @reg:        register controlling multiplexer
+ * @shift:      shift to multiplexer bit field
+ * @width:      width of mutliplexer bit field
+ * @lock:       register lock
+ *
+ * Clock with multiple selectable parents.  Implements .get_parent, .set_parent
+ * and .recalc_rate
+ *
+ */
+struct sunxi_clk_periph_mux {
+	void __iomem    *reg;
+	u8              shift;
+	u8              width;
+	spinlock_t      *lock;
+};
+
+struct sunxi_clk_comgate {
+	const u8        *name;
+	u16             val;
+	u16             mask;
+	u8              share;
+	u8              res;
+};
+
+#define BUS_GATE_SHARE  0x01
+#define RST_GATE_SHARE  0x02
+#define MBUS_GATE_SHARE 0x04
+#define MOD_GATE_SHARE  0x08
+
+#define IS_SHARE_BUS_GATE(x)  (x->com_gate?((x->com_gate->share & BUS_GATE_SHARE)?1:0):0)
+#define IS_SHARE_RST_GATE(x)  (x->com_gate?((x->com_gate->share & RST_GATE_SHARE)?1:0):0)
+#define IS_SHARE_MBUS_GATE(x) (x->com_gate?((x->com_gate->share & MBUS_GATE_SHARE)?1:0):0)
+#define IS_SHARE_MOD_GATE(x)  (x->com_gate?((x->com_gate->share & MOD_GATE_SHARE)?1:0):0)
+
+/**
+ * struct sunxi-clk-periph - peripheral clock
+ *
+ * @hw:         handle between common and hardware-specific interfaces
+ * @flags:      flags used across common struct clk, please take refference of the clk-provider.h
+ * @lock:       lock for protecting the periph clock operations
+ * @mux:        mux clock
+ * @gate:       gate clock
+ * @divider:    divider clock
+ * @com_gate:       the shared clock
+ * @com_gate_off:   bit shift to mark the flag in the com_gate
+ * @priv_clkops:    divider clock ops
+ * @priv_regops:    gate clock ops
+ */
+struct sunxi_clk_periph {
+	struct clk_hw                   hw;
+	unsigned long                   flags;
+	spinlock_t                      *lock;
+
+	struct sunxi_clk_periph_mux     mux;
+	struct sunxi_clk_periph_gate    gate;
+	struct sunxi_clk_periph_div     divider;
+	struct sunxi_clk_comgate       *com_gate;
+	u8                              com_gate_off;
+	struct clk_ops                 *priv_clkops;
+	struct sunxi_reg_ops           *priv_regops;
+};
+
+struct periph_init_data {
+	const char              *name;
+	unsigned long           flags;
+	const char              **parent_names;
+	int                     num_parents;
+	struct sunxi_clk_periph *periph;
+};
+
+static inline u32 periph_readl(struct sunxi_clk_periph *periph, void __iomem *reg)
+{
+	return (((unsigned long)periph->priv_regops) \
+			? periph->priv_regops->reg_readl(reg) \
+			: readl(reg));
+}
+
+static inline void periph_writel(struct sunxi_clk_periph *periph, unsigned int val, void __iomem *reg)
+{
+	(((unsigned long)periph->priv_regops) \
+		? periph->priv_regops->reg_writel(val, reg) \
+		: writel(val, reg));
+}
+
+extern const struct clk_ops sunxi_clk_periph_ops;
+
+struct clk *sunxi_clk_register_periph(struct periph_init_data *pd,
+					void __iomem  *base);
+
+int sunxi_periph_reset_deassert(struct clk *c);
+int sunxi_periph_reset_assert(struct clk *c);
+void sunxi_clk_get_periph_ops(struct clk_ops *ops);
+
+#define to_clk_periph(_hw) container_of(_hw, struct sunxi_clk_periph, hw)
+
+#define SUNXI_CLK_PERIPH(name, _mux_reg, _mux_shift, _mux_width,  \
+			_div_reg, _div_mshift, _div_mwidth, _div_nshift, _div_nwidth,   \
+			_gate_flags, _enable_reg, _reset_reg, _bus_gate_reg, _drm_gate_reg, \
+			_enable_shift, _reset_shift, _bus_gate_shift, _dram_gate_shift, _lock, _com_gate, _com_gate_off) \
+static struct sunxi_clk_periph sunxi_clk_periph_##name = {      \
+	.lock = _lock,                                          \
+															\
+	.mux = {                                                \
+		.reg = (void __iomem  *)_mux_reg,                   \
+		.shift = _mux_shift,                                \
+		.width = _mux_width,                                \
+	},                                                      \
+															\
+	.divider = {                                            \
+		.reg = (void __iomem  *)_div_reg,                   \
+		.mshift = _div_mshift,                              \
+		.mwidth = _div_mwidth,                              \
+		.nshift = _div_nshift,                              \
+		.nwidth = _div_nwidth,                              \
+	},                                                      \
+	.gate = {                                               \
+		.flags = _gate_flags,                               \
+		.enable = (void __iomem  *)_enable_reg,             \
+		.reset = (void __iomem  *)_reset_reg,               \
+		.bus = (void __iomem  *)_bus_gate_reg,              \
+		.dram = (void __iomem  *)_drm_gate_reg,             \
+		.enb_shift = _enable_shift,                         \
+		.rst_shift = _reset_shift,                          \
+		.bus_shift = _bus_gate_shift,                       \
+		.ddr_shift = _dram_gate_shift,                      \
+	},                                                      \
+	.com_gate = _com_gate,                                  \
+	.com_gate_off = _com_gate_off,                          \
+}
+
+#endif /* __MACH_SUNXI_CLK_PERIPH_H */
diff --git a/drivers/clk/sunxi/clk-sun8iw15.c b/drivers/clk/sunxi/clk-sun8iw15.c
new file mode 100644
index 000000000..843fc45d0
--- /dev/null
+++ b/drivers/clk/sunxi/clk-sun8iw15.c
@@ -0,0 +1,681 @@
+/*
+ * Copyright (C) 2016 Allwinnertech
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/clk-provider.h>
+#include <linux/clkdev.h>
+#include <linux/delay.h>
+#include <linux/clk/sunxi.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include "clk-sunxi.h"
+#include "clk-factors.h"
+#include "clk-periph.h"
+#include "clk-sun8iw15.h"
+#include "clk-sun8iw15_tbl.c"
+
+#define FACTOR_SIZEOF(name) (sizeof(factor_pll##name##_tbl)/ \
+			     sizeof(struct sunxi_clk_factor_freq))
+
+#define FACTOR_SEARCH(name) (sunxi_clk_com_ftr_sr( \
+		&sunxi_clk_factor_pll_##name, factor, \
+		factor_pll##name##_tbl, index, \
+		FACTOR_SIZEOF(name)))
+
+#ifndef CONFIG_EVB_PLATFORM
+	#define LOCKBIT(x) 31
+#else
+	#define LOCKBIT(x) x
+#endif
+
+/** pll input select **
+ * SUNXI_PLL_24M_INPUT   --pll_24m input
+ * SUNXI_PLL_HOSC_INPUT  --hosc input
+ */
+#define SUNXI_PLL_HOSC_INPUT
+
+DEFINE_SPINLOCK(clk_lock);
+void __iomem *sunxi_clk_base;
+void __iomem *sunxi_clk_cpus_base;
+void __iomem *sunxi_clk_rtc_base;
+int sunxi_clk_maxreg = SUNXI_CLK_MAX_REG;
+int cpus_clk_maxreg = CPUS_CLK_MAX_REG;
+
+#if defined SUNXI_PLL_HOSC_INPUT
+/*                                ns  nw  ks  kw  ms  mw  ps  pw  d1s d1w d2s d2w {frac   out mode}   en-s    sdmss   sdmsw   sdmpat          sdmval*/
+SUNXI_CLK_FACTORS1(pll_cpu,        8,  8,  0,  0,  0,  0,  16, 2,  0,  0,  0,  0,    0,    0,  0,      31,     0,      0,      0,              0,           23,  27);
+SUNXI_CLK_FACTORS1(pll_ddr,        8,  8,  0,  0,  0,  0,  0,  0,  1,  1,  0,  1,    0,    0,  0,      31,     24,     0,      PLL_DDRPAT,     0xd1303333,  23,  27);
+SUNXI_CLK_FACTORS1(pll_periph0,    8,  8,  0,  0,  0,  0,  0,  0,  1,  1,  0,  1,    0,    0,  0,      31,     0,      0,      0,              0,           23,  27);
+SUNXI_CLK_FACTORS1(pll_periph1,    8,  8,  0,  0,  0,  0,  0,  0,  1,  1,  0,  1,    0,    0,  0,      31,     24,     0,      PLL_PERI1PAT0,  0xd1303333,  23,  27);
+SUNXI_CLK_FACTORS1(pll_gpu,        8,  8,  0,  0,  0,  0,  0,  0,  1,  1,  0,  1,    0,    0,  0,      31,     24,     0,      PLL_GPUPAT0,    0xd1303333,  23,  27);
+SUNXI_CLK_FACTORS1(pll_video0,     8,  8,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,    0,    0,  0,      31,     24,     0,      PLL_VIDEO0PAT0, 0xd1303333,  23,  27);
+SUNXI_CLK_FACTORS1(pll_video1,     8,  8,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,    0,    0,  0,      31,     24,     0,      PLL_VIDEO1PAT0, 0xd1303333,  23,  27);
+SUNXI_CLK_FACTORS1(pll_ve,         8,  8,  0,  0,  0,  0,  0,  0,  1,  1,  0,  1,    0,    0,  0,      31,     24,     0,      PLL_VEPAT0,     0xd1303333,  23,  27);
+SUNXI_CLK_FACTORS1(pll_de,         8,  8,  0,  0,  0,  0,  0,  0,  1,  1,  0,  1,    0,    0,  0,      31,     24,     0,      PLL_DEPAT0,     0xd1303333,  23,  27);
+SUNXI_CLK_FACTORS1(pll_audio,      8,  8,  0,  0,  0,  0,  16, 6,  1,  1,  0,  1,    0,    0,  0,      31,     24,     1,      PLL_AUDIOPAT0,  0xc00121ff,  23,  27);
+SUNXI_CLK_FACTORS1(pll_24m,        8,  8,  0,  0,  0,  0,  16, 6,  1,  1,  0,  1,    0,    0,  0,      31,     24,     0,      0,              0xc00121ff,  23,  27);
+#elif defined SUNXI_PLL_24M_INPUT
+/*                                ns  nw  ks  kw  ms  mw  ps  pw  d1s d1w d2s d2w {frac   out mode}   en-s    sdmss   sdmsw   sdmpat          sdmval*/
+SUNXI_CLK_FACTORS1(pll_cpu,        8,  8,  0,  0,  0,  0,  16, 2,  0,  0,  0,  0,    0,    0,  0,      31,     0,      0,      0,              0,           0,  27);
+SUNXI_CLK_FACTORS1(pll_ddr,        8,  8,  0,  0,  0,  0,  0,  0,  1,  1,  0,  1,    0,    0,  0,      31,     24,     0,      PLL_DDRPAT,     0xd1303333,  0,  27);
+SUNXI_CLK_FACTORS1(pll_periph0,    8,  8,  0,  0,  0,  0,  0,  0,  1,  1,  0,  1,    0,    0,  0,      31,     0,      0,      0,              0,           0,  27);
+SUNXI_CLK_FACTORS1(pll_periph1,    8,  8,  0,  0,  0,  0,  0,  0,  1,  1,  0,  1,    0,    0,  0,      31,     24,     0,      PLL_PERI1PAT0,  0xd1303333,  0,  27);
+SUNXI_CLK_FACTORS1(pll_gpu,        8,  8,  0,  0,  0,  0,  0,  0,  1,  1,  0,  1,    0,    0,  0,      31,     24,     0,      PLL_GPUPAT0,    0xd1303333,  0,  27);
+SUNXI_CLK_FACTORS1(pll_video0,     8,  8,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,    0,    0,  0,      31,     24,     0,      PLL_VIDEO0PAT0, 0xd1303333,  0,  27);
+SUNXI_CLK_FACTORS1(pll_video1,     8,  8,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,    0,    0,  0,      31,     24,     0,      PLL_VIDEO1PAT0, 0xd1303333,  0,  27);
+SUNXI_CLK_FACTORS1(pll_ve,         8,  8,  0,  0,  0,  0,  0,  0,  1,  1,  0,  1,    0,    0,  0,      31,     24,     0,      PLL_VEPAT0,     0xd1303333,  0,  27);
+SUNXI_CLK_FACTORS1(pll_de,         8,  8,  0,  0,  0,  0,  0,  0,  1,  1,  0,  1,    0,    0,  0,      31,     24,     0,      PLL_DEPAT0,     0xd1303333,  0,  27);
+SUNXI_CLK_FACTORS1(pll_audio,      8,  8,  0,  0,  0,  0,  16, 6,  1,  1,  0,  1,    0,    0,  0,      31,     24,     1,      PLL_AUDIOPAT0,  0xc00121ff,  0,  27);
+SUNXI_CLK_FACTORS1(pll_24m,        8,  8,  0,  0,  0,  0,  16, 6,  1,  1,  0,  1,    0,    0,  0,      31,     24,     0,      0,              0xc00121ff,  0,  27);
+#endif
+
+static int get_factors_pll_cpu(u32 rate, u32 parent_rate,
+		struct clk_factors_value *factor)
+{
+
+	int index;
+	u64 tmp_rate;
+
+	if (!factor)
+		return -1;
+	tmp_rate = rate > pllcpu_max ? pllcpu_max : rate;
+	do_div(tmp_rate, 1000000);
+	index = tmp_rate;
+
+	if (FACTOR_SEARCH(cpu))
+		return -1;
+
+	return 0;
+}
+
+static int get_factors_pll_ddr(u32 rate, u32 parent_rate,
+		struct clk_factors_value *factor)
+{
+	int index;
+	u64 tmp_rate;
+
+	if (!factor)
+		return -1;
+
+	tmp_rate = rate > pllddr_max ? pllddr_max : rate;
+	do_div(tmp_rate, 1000000);
+	index = tmp_rate;
+
+	if (FACTOR_SEARCH(ddr))
+		return -1;
+
+	return 0;
+}
+
+static int get_factors_pll_periph0(u32 rate, u32 parent_rate,
+		struct clk_factors_value *factor)
+{
+	int index;
+	u64 tmp_rate;
+
+	if (!factor)
+		return -1;
+
+	tmp_rate = rate > pllperiph0_max ? pllperiph0_max : rate;
+	do_div(tmp_rate, 1000000);
+	index = tmp_rate;
+
+	if (FACTOR_SEARCH(periph0))
+		return -1;
+
+	return 0;
+}
+
+static int get_factors_pll_periph1(u32 rate, u32 parent_rate,
+		struct clk_factors_value *factor)
+{
+	int index;
+	u64 tmp_rate;
+
+	if (!factor)
+		return -1;
+
+	tmp_rate = rate > pllperiph1_max ? pllperiph1_max : rate;
+	do_div(tmp_rate, 1000000);
+	index = tmp_rate;
+
+	if (FACTOR_SEARCH(periph1))
+		return -1;
+
+	return 0;
+}
+
+static int get_factors_pll_gpu(u32 rate, u32 parent_rate,
+		struct clk_factors_value *factor)
+{
+	u64 tmp_rate;
+	int index;
+
+	if (!factor)
+		return -1;
+
+	tmp_rate = rate > pllgpu_max ? pllgpu_max : rate;
+	do_div(tmp_rate, 1000000);
+	index = tmp_rate;
+
+	if (FACTOR_SEARCH(gpu))
+		return -1;
+
+	return 0;
+}
+
+static int get_factors_pll_video0(u32 rate, u32 parent_rate,
+		struct clk_factors_value *factor)
+{
+	u64 tmp_rate;
+	int index;
+
+	if (!factor)
+		return -1;
+
+	tmp_rate = rate > pllvideo0_max ? pllvideo0_max : rate;
+	do_div(tmp_rate, 1000000);
+	index = tmp_rate;
+
+	if (FACTOR_SEARCH(video0))
+		return -1;
+
+	return 0;
+}
+
+static int get_factors_pll_video1(u32 rate, u32 parent_rate,
+		struct clk_factors_value *factor)
+{
+	u64 tmp_rate;
+	int index;
+
+	if (!factor)
+		return -1;
+
+	tmp_rate = rate > pllvideo1_max ? pllvideo1_max : rate;
+	do_div(tmp_rate, 1000000);
+	index = tmp_rate;
+
+	if (FACTOR_SEARCH(video1))
+		return -1;
+
+	return 0;
+}
+
+static int get_factors_pll_ve(u32 rate, u32 parent_rate,
+		struct clk_factors_value *factor)
+{
+	u64 tmp_rate;
+	int index;
+
+	if (!factor)
+		return -1;
+
+	tmp_rate = rate > pllve_max ? pllve_max : rate;
+	do_div(tmp_rate, 1000000);
+	index = tmp_rate;
+
+	if (FACTOR_SEARCH(ve))
+		return -1;
+
+	return 0;
+}
+
+static int get_factors_pll_de(u32 rate, u32 parent_rate,
+		struct clk_factors_value *factor)
+{
+	u64 tmp_rate;
+	int index;
+
+	if (!factor)
+		return -1;
+
+	tmp_rate = rate > pllde_max ? pllde_max : rate;
+	do_div(tmp_rate, 1000000);
+	index = tmp_rate;
+
+	if (FACTOR_SEARCH(de))
+		return -1;
+
+	return 0;
+}
+
+/*    pll_cpux: 24*N/P (P=2^factorp)  */
+static unsigned long calc_rate_pll_cpu(u32 parent_rate,
+		struct clk_factors_value *factor)
+{
+	u64 tmp_rate = (parent_rate ? parent_rate : 24000000);
+	tmp_rate = tmp_rate * (factor->factorn + 1);
+	do_div(tmp_rate, (1 << factor->factorp));
+	return (unsigned long)tmp_rate;
+}
+
+/*    pll_ddr: 24*N/D1/D2    */
+static unsigned long calc_rate_pll_ddr(u32 parent_rate,
+		struct clk_factors_value *factor)
+{
+	u64 tmp_rate = (parent_rate ? parent_rate : 24000000);
+	tmp_rate = tmp_rate * (factor->factorn + 1);
+	do_div(tmp_rate, (factor->factord1 + 1) * (factor->factord2 + 1));
+	return (unsigned long)tmp_rate;
+}
+
+/*    pll_periph0/pll_periph1: 24*N/D1/D2/2    */
+static unsigned long calc_rate_pll_periph(u32 parent_rate,
+		struct clk_factors_value *factor)
+{
+	u64 tmp_rate = (parent_rate ? parent_rate : 24000000);
+	tmp_rate = tmp_rate * (factor->factorn + 1);
+	do_div(tmp_rate, 2 * (factor->factord1 + 1) * (factor->factord2 + 1));
+	return (unsigned long)tmp_rate;
+}
+
+/*    pll_video0/pll_video1: 24*N/D1/4    */
+static unsigned long calc_rate_video(u32 parent_rate,
+		struct clk_factors_value *factor)
+{
+	u64 tmp_rate = (parent_rate ? parent_rate : 24000000);
+	tmp_rate = tmp_rate * (factor->factorn + 1);
+	do_div(tmp_rate, 4 * (factor->factord1 + 1));
+	return (unsigned long)tmp_rate;
+}
+
+/*    pll_media: 24*N/D1/D2    */
+/*	media include VE, DE, GPU*/
+static unsigned long calc_rate_media(u32 parent_rate,
+		struct clk_factors_value *factor)
+{
+	u64 tmp_rate = (parent_rate ? parent_rate : 24000000);
+	tmp_rate = tmp_rate * (factor->factorn + 1);
+	do_div(tmp_rate, (factor->factord1 + 1) * (factor->factord2 + 1));
+	return (unsigned long)tmp_rate;
+}
+
+/*
+ *    pll_audio: 24*N/D1/D2/P
+ *
+ *    NOTE: pll_audiox4 = 24*N/D1/2
+ *          pll_audiox2 = 24*N/D1/4
+ *
+ *    pll_audiox4=2*pll_audiox2=4*pll_audio only when D2*P=8
+ */
+static unsigned long calc_rate_audio(u32 parent_rate,
+		struct clk_factors_value *factor)
+{
+	u64 tmp_rate = (parent_rate ? parent_rate : 24000000);
+	if ((factor->factorn == 21) &&
+			(factor->factorp == 11) &&
+			(factor->factord1 == 0) &&
+			(factor->factord2 == 1))
+		return 22579200;
+	else if ((factor->factorn == 23) &&
+			(factor->factorp == 11) &&
+			(factor->factord1 == 0) &&
+			(factor->factord2 == 1))
+		return 24576000;
+	else {
+		tmp_rate = tmp_rate * (factor->factorn + 1);
+		do_div(tmp_rate, ((factor->factorp + 1) *
+				(factor->factord1 + 1) *
+				(factor->factord2 + 1)));
+		return (unsigned long)tmp_rate;
+	}
+}
+
+static int get_factors_pll_audio(u32 rate, u32 parent_rate,
+		struct clk_factors_value *factor)
+{
+	if (rate == 22579200) {
+		factor->factorn = 21;
+		factor->factorp = 11;
+		factor->factord1 = 0;
+		factor->factord2 = 1;
+		sunxi_clk_factor_pll_audio.sdmval = 0xC001288D;
+	} else if (rate == 24576000) {
+		factor->factorn = 23;
+		factor->factorp = 11;
+		factor->factord1 = 0;
+		factor->factord2 = 1;
+		sunxi_clk_factor_pll_audio.sdmval = 0xC00126E9;
+	} else
+		return -1;
+
+	return 0;
+}
+
+static const char *hosc_parents[] = {"hosc"};
+struct factor_init_data sunxi_factos[] = {
+	/* name         parent        parent_num, flags                 reg          lock_reg     lock_bit     pll_lock_ctrl_reg lock_en_bit lock_mode           config                         get_factors               calc_rate              priv_ops*/
+	{"pll_cpu",     hosc_parents, 1,          CLK_GET_RATE_NOCACHE, PLL_CPU,     PLL_CPU,     LOCKBIT(28), PLL_CPU,     29,          PLL_LOCK_NEW_MODE, &sunxi_clk_factor_pll_cpu,     &get_factors_pll_cpu,     &calc_rate_pll_cpu,    (struct clk_ops *)NULL},
+	{"pll_ddr",     hosc_parents, 1,          CLK_GET_RATE_NOCACHE, PLL_DDR,     PLL_DDR,     LOCKBIT(28), PLL_DDR,     29,          PLL_LOCK_NEW_MODE, &sunxi_clk_factor_pll_ddr,    &get_factors_pll_ddr,    &calc_rate_pll_ddr,    (struct clk_ops *)NULL},
+	{"pll_periph0", hosc_parents, 1,          0,                    PLL_PERIPH0, PLL_PERIPH0, LOCKBIT(28), PLL_PERIPH0, 29,          PLL_LOCK_NEW_MODE, &sunxi_clk_factor_pll_periph0, &get_factors_pll_periph0, &calc_rate_pll_periph, (struct clk_ops *)NULL},
+	{"pll_periph1", hosc_parents, 1,          0,                    PLL_PERIPH1, PLL_PERIPH1, LOCKBIT(28), PLL_PERIPH1, 29,          PLL_LOCK_NEW_MODE, &sunxi_clk_factor_pll_periph1, &get_factors_pll_periph1, &calc_rate_pll_periph, (struct clk_ops *)NULL},
+	{"pll_gpu",     hosc_parents, 1,          0,                    PLL_GPU,     PLL_GPU,     LOCKBIT(28), PLL_GPU,     29,          PLL_LOCK_NEW_MODE, &sunxi_clk_factor_pll_gpu,     &get_factors_pll_gpu,     &calc_rate_media,      (struct clk_ops *)NULL},
+	{"pll_video0",  hosc_parents, 1,          0,                    PLL_VIDEO0,  PLL_VIDEO0,  LOCKBIT(28), PLL_VIDEO0,  29,          PLL_LOCK_NEW_MODE, &sunxi_clk_factor_pll_video0,  &get_factors_pll_video0,  &calc_rate_video,      (struct clk_ops *)NULL},
+	{"pll_video1",  hosc_parents, 1,          0,                    PLL_VIDEO1,  PLL_VIDEO1,  LOCKBIT(28), PLL_VIDEO1,  29,          PLL_LOCK_NEW_MODE, &sunxi_clk_factor_pll_video1,  &get_factors_pll_video1,  &calc_rate_video,      (struct clk_ops *)NULL},
+	{"pll_ve",      hosc_parents, 1,          0,                    PLL_VE,      PLL_VE,      LOCKBIT(28), PLL_VE,      29,          PLL_LOCK_NEW_MODE, &sunxi_clk_factor_pll_ve,      &get_factors_pll_ve,      &calc_rate_media,      (struct clk_ops *)NULL},
+	{"pll_de",      hosc_parents, 1,          0,                    PLL_DE,      PLL_DE,      LOCKBIT(28), PLL_DE,      29,          PLL_LOCK_NEW_MODE, &sunxi_clk_factor_pll_de,      &get_factors_pll_de,      &calc_rate_media,      (struct clk_ops *)NULL},
+	{"pll_audio",   hosc_parents, 1,          0,                    PLL_AUDIO,   PLL_AUDIO,   LOCKBIT(28), PLL_AUDIO,   29,          PLL_LOCK_NEW_MODE, &sunxi_clk_factor_pll_audio,   &get_factors_pll_audio,   &calc_rate_audio,      (struct clk_ops *)NULL},
+	{"pll_24m",     hosc_parents, 1,          0,                    PLL_24M,     PLL_24M,     LOCKBIT(28), PLL_24M,     29,          PLL_LOCK_NEW_MODE, &sunxi_clk_factor_pll_24m,   NULL,   NULL,      (struct clk_ops *)NULL},
+};
+
+static const char *cpu_parents[] = {"hosc", "losc", "iosc", "pll_cpu", "pll_24m", "", "", ""};
+static const char *axi_parents[] = {"cpu"};
+static const char *cpuapb_parents[] = {"cpu"};
+static const char *psi_parents[] = {"hosc", "losc", "iosc", "pll_periph0", "pll_24m", "", "", ""};
+static const char *ahb1_parents[] = {"psi"};
+static const char *ahb2_parents[] = {"psi"};
+static const char *ahb3_parents[] = {"hosc", "losc", "psi", "pll_periph0", "pll_24m", "", "", ""};
+static const char *apb1_parents[] = {"hosc", "losc", "psi", "pll_periph0", "pll_24m", "", "", ""};
+static const char *apb2_parents[] = {"hosc", "losc", "psi", "pll_periph0", "pll_24m", "", "", ""};
+static const char *mbus_parents[] = {"hosc", "pll_periph0x2", "pll_ddr", "pll_periph0x4"};
+static const char *de_parents[] = {"pll_de", "pll_periph0x2"};
+static const char *eink_parents[] = {"pll_de", "pll_periph0x2"};
+static const char *g2d_parents[] = {"pll_de", "pll_periph0x2"};
+static const char *gpu_parents[] = {"pll_gpu", ""};
+static const char *ce_parents[] = {"hosc", "pll_periph0x2"};
+static const char *ve_parents[] = {"pll_ve", ""};
+static const char *emce_parents[] = {"hosc", "pll_periph0x2"};
+static const char *ahb1mod_parents[] = {"ahb1"};
+static const char *ahb3mod_parents[] = {"ahb3"};
+static const char *apb1mod_parents[] = {"apb1"};
+static const char *apb2mod_parents[] = {"apb2"};
+static const char *sdram_parents[] = {"pll_ddr", "", "", ""};
+static const char *nand_parents[] = {"hosc", "pll_periph0", "pll_periph1", "pll_periph0x2", "pll_periph1x2", "", "", ""};
+static const char *smhc_parents[] = {"hosc", "pll_periph0x2", "pll_periph1x2", "", "", "", "", ""};
+static const char *spi_parents[] = {"hosc", "pll_periph0", "pll_periph1", "pll_periph0x2", "pll_periph1x2", "", "", ""};
+static const char *audio_parents[] = {"pll_audio", "pll_audiox2", "pll_audiox4", ""};
+static const char *usbohci_12m_parents[] = {"osc48md4", "hoscd2", "losc", "iosc"};
+static const char *mipi_dphy_parents[] = {"pll_video0", "pll_video0x4", "pll_video1", ""};
+static const char *mipi_host_parents[] = {"pll_periph0", "pll_periph0x2", "hosc", ""};
+static const char *tcon_lcd_parents[] = {"pll_video0", "pll_video0x4", "pll_video1", "", "", "", "", ""};
+static const char *lvds_parents[]	= {"hosc"};
+static const char *csi_top_parents[] = {"pll_video0", "", "pll_ve", "pll_periph0", "pll_video1", "", "", ""};
+static const char *csi_master_parents[] = {"hosc", "pll_video0", "pll_periph0", "pll_periph1", "", "pll_video1", "", ""};
+static const char *cpurcpus_pll_parents[] = {"pll_periph0"};
+static const char *cpurcpus_parents[] = {"hosc", "losc", "iosc", "cpurcpus_pll"};
+static const char *cpurahbs_parents[] = {"cpurcpus"};
+static const char *cpurapbs1_parents[] = {"cpurahbs"};
+static const char *cpurapbs2_pll_parents[] = {"pll_periph0"};
+static const char *cpurapbs2_parents[] = {"hosc", "losc", "iosc", "cpurapbs2_pll"};
+static const char *cpurpio_parents[] = {"cpurapbs1"};
+static const char *losc_parents[] = {"losc"};
+static const char *spwm_parents[] = {"hosc", "losc", "iosc", ""};
+
+struct sunxi_clk_comgate com_gates[] = {
+{"nand",    0, 0x3, BUS_GATE_SHARE|RST_GATE_SHARE|MBUS_GATE_SHARE, 0},
+{"codec",   0, 0x3, BUS_GATE_SHARE|RST_GATE_SHARE, 0},
+{"mipi0",   0, 0x3, BUS_GATE_SHARE|RST_GATE_SHARE, 0},
+{"eink",    0, 0x7, BUS_GATE_SHARE|RST_GATE_SHARE, 0},
+{"csi",     0, 0x7, BUS_GATE_SHARE|RST_GATE_SHARE|MBUS_GATE_SHARE, 0},
+};
+
+/*
+SUNXI_CLK_PERIPH(name,           mux_reg,         mux_sft, mux_wid,      div_reg,            div_msft,  div_mwid,   div_nsft,   div_nwid,   gate_flag,  en_reg,          rst_reg,         bus_gate_reg,  drm_gate_reg,  en_sft,     rst_sft,    bus_gate_sft,   dram_gate_sft, lock,      com_gate,         com_gate_off)
+*/
+SUNXI_CLK_PERIPH(cpu,            CPU_CFG,         24,      3,            0,                  0,         0,          0,          0,          0,          0,               0,               0,             0,             0,          0,          0,              0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(axi,            0,               0,       0,            CPU_CFG,            0,         2,          0,          0,          0,          0,               0,               0,             0,             0,          0,          0,              0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(cpuapb,         0,               0,       0,            CPU_CFG,            8,         2,          0,          0,          0,          0,               0,               0,             0,             0,          0,          0,              0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(psi,            PSI_CFG,         24,      2,            PSI_CFG,            0,         2,          8,          2,          0,          0,               PSI_GATE,        PSI_GATE,      0,             0,          16,         0,              0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(ahb1,           0,               0,       0,            0,                  0,         0,          0,          0,          0,          0,               0,               0,             0,             0,          0,          0,              0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(ahb2,           0,               0,       0,            0,                  0,         0,          0,          0,          0,          0,               0,               0,             0,             0,          0,          0,              0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(ahb3,           AHB3_CFG,        24,      3,            AHB3_CFG,           0,         2,          8,          2,          0,          0,               0,               0,             0,             0,          0,          0,              0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(apb1,           APB1_CFG,        24,      3,            APB1_CFG,           0,         2,          8,          2,          0,          0,               0,               0,             0,             0,          0,          0,              0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(apb2,           APB2_CFG,        24,      3,            APB2_CFG,           0,         2,          8,          2,          0,          0,               0,               0,             0,             0,          0,          0,              0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(mbus,           MBUS_CFG,        24,      2,            MBUS_CFG,           0,         3,          0,          0,          0,          MBUS_CFG,        MBUS_CFG,        0,             0,             31,         30,         0,              0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(de,             DE_CFG,          24,      1,            DE_CFG,             0,         4,          0,          0,          0,          DE_CFG,          DE_GATE,         DE_GATE,       0,             31,         16,         0,              0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(ee,             EE_CFG,          24,      1,            EE_CFG,             0,         4,          0,          0,          0,          EE_CFG,          EINK_GATE,       EINK_GATE,    MBUS_GATE,      31,         16,         0,             16,             &clk_lock, &com_gates[3],          0);
+SUNXI_CLK_PERIPH(edma,           EDMA_CFG,        24,      1,            EDMA_CFG,           0,         4,          0,          0,          0,          EDMA_CFG,        EINK_GATE,       EINK_GATE,    MBUS_GATE,      31,         16,         0,             17,             &clk_lock, &com_gates[3],          1);
+SUNXI_CLK_PERIPH(g2d,            G2D_CFG,         24,      1,            G2D_CFG,            0,         4,          0,          0,          0,          G2D_CFG,         G2D_GATE,        G2D_GATE,      MBUS_GATE,     31,         16,         0,	       10,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(gpu,            GPU_CFG,         24,      1,            GPU_CFG,            0,         3,          0,          0,          0,          GPU_CFG,         GPU_GATE,        GPU_GATE,      0,             31,         16,         0,              0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(ce,             CE_CFG,          24,      1,            CE_CFG,             0,         4,          8,          2,          0,          CE_CFG,          CE_GATE,         CE_GATE,       MBUS_GATE,     31,         16,         0,              2,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(ve,             VE_CFG,          24,      1,            VE_CFG,             0,         3,          0,          0,          0,          VE_CFG,          VE_GATE,         VE_GATE,       MBUS_GATE,     31,         16,         0,              1,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(emce,           EMCE_CFG,        24,      1,            EMCE_CFG,           0,         4,          8,          2,          0,          EMCE_CFG,        EMCE_GATE,       EMCE_GATE,     MBUS_GATE,     31,         16,         0,              24,            &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(dma,            0,                0,      0,            0,                  0,         0,          0,          0,          0,          0,               DMA_GATE,        DMA_GATE,      MBUS_GATE,     0,          16,         0,              0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(msgbox,         0,               0,       0,            0,                  0,         0,          0,          0,          0,          0,               MSGBOX_GATE,     MSGBOX_GATE,   0,             0,          16,         0,              0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(hwspinlock_rst, 0,               0,       0,            0,                  0,         0,          0,          0,          0,          0,               SPINLOCK_GATE,   0,             0,             0,          16,         0,              0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(hwspinlock_bus, 0,               0,       0,            0,                  0,         0,          0,          0,          0,          0,               0,               SPINLOCK_GATE, 0,             0,          0,          0,              0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(hstimer,        0,               0,       0,            0,                  0,         0,          0,          0,          0,          0,               HSTIMER_GATE,    HSTIMER_GATE,     0,          0,          16,         0,              0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(avs,            0,               0,       0,            0,                  0,         0,          0,          0,          0,          AVS_CFG,         0,               0,                0,          31,         0,          0,              0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(dbgsys,         0,               0,       0,            0,                  0,         0,          0,          0,          0,          0,               DBGSYS_GATE,     DBGSYS_GATE,      0,          0,          16,         0,              0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(pwm,            0,               0,       0,            0,                  0,         0,          0,          0,          0,          0,               PWM_GATE,        PWM_GATE,         0,          0,          16,         0,              0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(iommu,          0,               0,       0,            0,                  0,         0,          0,          0,          0,          0,               0,               IOMMU_GATE,       0,          0,          0,          0,              0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(sdram,          DRAM_CFG,        24,      2,            DRAM_CFG,           0,         2,          0,          0,          0,          0,               DRAM_GATE,       DRAM_GATE,        0,          0,          16,         0,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(nand0,          NAND0_CFG,       24,      3,            NAND0_CFG,          0,         4,          8,          2,          0,          NAND0_CFG,       NAND_GATE,      NAND_GATE,         MBUS_GATE,  31,         16,         0,             5,             &clk_lock, &com_gates[0],    0);
+SUNXI_CLK_PERIPH(nand1,          NAND1_CFG,       24,      3,            NAND1_CFG,          0,         4,          8,          2,          0,          NAND1_CFG,       NAND_GATE,      NAND_GATE,         MBUS_GATE,  31,         16,         0,             5,             &clk_lock, &com_gates[0],    1);
+SUNXI_CLK_PERIPH(sdmmc0_mod,     SMHC0_CFG,       24,      2,            SMHC0_CFG,          0,         4,          8,          2,          0,          SMHC0_CFG,       0,              0,                 0,          31,         0,          0,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(sdmmc0_rst,     0,               0,       0,            0,                  0,         0,          0,          0,          0,          0,               SMHC_GATE,      0,                 0,          0,          16,         0,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(sdmmc0_bus,     0,               0,       0,            0,                  0,         0,          0,          0,          0,          0,               0,              SMHC_GATE,         0,          0,          0,         0,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(sdmmc1_mod,     SMHC1_CFG,       24,      2,            SMHC1_CFG,          0,         4,          8,          2,          0,          SMHC1_CFG,       0,              0,                 0,          31,         0,          0,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(sdmmc1_rst,     0,               0,       0,            0,                  0,         0,          0,          0,          0,          0,               SMHC_GATE,      0,                 0,          0,          17,         0,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(sdmmc1_bus,     0,               0,       0,            0,                  0,         0,          0,          0,          0,          0,               0,              SMHC_GATE,         0,          0,          0,          1,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(sdmmc2_mod,     SMHC2_CFG,       24,      2,            SMHC2_CFG,          0,         4,          8,          2,          0,          SMHC2_CFG,       0,              0,                 0,          31,         0,          0,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(sdmmc2_rst,     0,               0,       0,            0,                  0,         0,          0,          0,          0,          0,               SMHC_GATE,      0,                 0,          0,          18,         0,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(sdmmc2_bus,     0,               0,       0,            0,                  0,         0,          0,          0,          0,          0,               0,              SMHC_GATE,         0,          0,          0,          2,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(uart0,          0,               0,       0,            0,                  0,         0,          0,          0,          0,          0,               UART_GATE,      UART_GATE,          0,         0,          16,         0,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(uart1,          0,               0,       0,            0,                  0,         0,          0,          0,          0,          0,               UART_GATE,      UART_GATE,          0,         0,          17,         1,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(uart2,          0,               0,       0,            0,                  0,         0,          0,          0,          0,          0,               UART_GATE,      UART_GATE,          0,         0,          18,         2,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(uart3,          0,               0,       0,            0,                  0,         0,          0,          0,          0,          0,               UART_GATE,      UART_GATE,          0,         0,          19,         3,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(uart4,          0,               0,       0,            0,                  0,         0,          0,          0,          0,          0,               UART_GATE,      UART_GATE,          0,         0,          20,         4,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(twi0,           0,               0,       0,            0,                  0,         0,          0,          0,          0,          0,               TWI_GATE,       TWI_GATE,           0,         0,          16,         0,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(twi1,           0,               0,       0,            0,                  0,         0,          0,          0,          0,          0,               TWI_GATE,       TWI_GATE,           0,         0,          17,         1,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(twi2,           0,               0,       0,            0,                  0,         0,          0,          0,          0,          0,               TWI_GATE,       TWI_GATE,           0,         0,          18,         2,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(spi0,           SPI0_CFG,        24,      3,            SPI0_CFG,           0,         4,          8,          2,          0,          SPI0_CFG,        SPI_GATE,       SPI_GATE,          0,          31,         16,         0,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(spi1,           SPI1_CFG,        24,      3,            SPI1_CFG,           0,         4,          8,          2,          0,          SPI1_CFG,        SPI_GATE,       SPI_GATE,          0,          31,         17,         1,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(gpadc,          0,               0,       0,            0,                  0,         0,          0,          0,          0,          0,               GPADC_GATE,      GPADC_GATE,       0,          0,          16,         0,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(ths,            0,               0,       0,            0,                  0,         0,          0,          0,          0,          0,               THS_GATE,        THS_GATE,         0,          0,          16,         0,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(i2s0,           I2S0_CFG,        24,      2,            I2S0_CFG,           0,         0,          8,          2,          0,          I2S0_CFG,        I2S_GATE,        I2S_GATE,         0,          31,         16,         0,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(i2s1,           I2S1_CFG,        24,      2,            I2S1_CFG,           0,         0,          8,          2,          0,          I2S1_CFG,        I2S_GATE,        I2S_GATE,         0,          31,         17,         1,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(dmic,           DMIC_CFG,        24,      2,            DMIC_CFG,           0,         0,          8,          2,          0,          DMIC_CFG,        DMIC_GATE,       DMIC_GATE,        0,          31,         16,         0,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(codec_1x,       CODEC_1X_CFG,    24,      2,            CODEC_1X_CFG,       0,         4,          0,          0,          0,          CODEC_1X_CFG,    CODEC_GATE,      CODEC_GATE,       0,          31,         16,         0,             0,             &clk_lock, &com_gates[1],    0);
+SUNXI_CLK_PERIPH(codec_4x,       CODEC_4X_CFG,    24,      2,            CODEC_4X_CFG,       0,         4,          0,          0,          0,          CODEC_4X_CFG,    CODEC_GATE,      CODEC_GATE,       0,          31,         16,         0,             0,             &clk_lock, &com_gates[1],    1);
+SUNXI_CLK_PERIPH(usbphy0,        0,               0,       0,            0,                  0,         0,          0,          0,          0,          USB0_CFG,        USB0_CFG,        0,                0,          29,         30,         0,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(usbphy1,        0,               0,       0,            0,                  0,         0,          0,          0,          0,          USB1_CFG,        USB1_CFG,        0,                0,          29,         30,         0,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(usbohci0,       0,               0,       0,            0,                  0,         0,          0,          0,          0,          USB0_CFG,        USB_GATE,        USB_GATE,         0,          31,         16,         0,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(usbohci0_12m,   USB0_CFG,        24,      2,            0,                  0,         0,          0,          0,          0,          0,               0,               0,                0,          0,          0,          0,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(usbohci1,       0,               0,       0,            0,                  0,         0,          0,          0,          0,          USB1_CFG,        USB_GATE,        USB_GATE,         0,          31,         17,         1,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(usbohci1_12m,   USB1_CFG,        24,      2,            0,                  0,         0,          0,          0,          0,          0,               0,               0,                0,          0,          0,          0,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(usbehci0,       0,               0,       0,            0,                  0,         0,          0,          0,          0,          0,               USB_GATE,        USB_GATE,         0,          0,          20,         4,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(usbehci1,       0,               0,       0,            0,                  0,         0,          0,          0,          0,          0,               USB_GATE,        USB_GATE,         0,          0,          21,         5,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(usbotg,         0,               0,       0,            0,                  0,         0,          0,          0,          0,          0,               USB_GATE,        USB_GATE,         0,          0,          24,         8,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(mipi_dphy0,     MIPI_DPHY0_CFG,  24,      2,            MIPI_DPHY0_CFG,     0,         4,          8,          2,          0,          MIPI_DPHY0_CFG,  MIPI_GATE,       MIPI_GATE,         0,         31,         16,         0,            17,             &clk_lock, &com_gates[2],    0);
+SUNXI_CLK_PERIPH(mipi_host0,     MIPI_HOST0_CFG,  24,      2,            MIPI_HOST0_CFG,     0,         4,          0,          0,          0,          MIPI_HOST0_CFG,  MIPI_GATE,       MIPI_GATE,        0,          31,         16,         0,            17,             &clk_lock, &com_gates[2],    1);
+SUNXI_CLK_PERIPH(display_top,    0,               0,       0,            0,                  0,         0,          0,          0,          0,          0,               DISPLAY_TOP_GATE, DISPLAY_TOP_GATE, 0,         0,          16,         0,            0,              &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(tcon_lcd0,      TCON_LCD0_CFG,   24,      3,            0,                  0,         0,          0,          0,          0,          TCON_LCD0_CFG,   TCON_LCD_GATE,   TCON_LCD_GATE, 0,             31,         16,         0,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(lvds0,           0,               0,       0,            0,                  0,         0,          0,          0,          0,          0,               LVDS_GATE,        0,            0,             0,          16,         0,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(csi_mipi,       0,               0,       0,            0,                  0,          0,          0,          0,          0,         CSI_MISC_CFG,    0,               0,            0,              8,            0,         0,            0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(csi_misc,       0,               0,       0,            0,                  0,         0,          0,          0,          0,          CSI_MISC_CFG,    CSI_GATE,        CSI_GATE,      MBUS_GATE,     0,          16,         0,             8,             &clk_lock, &com_gates[4],    0);
+SUNXI_CLK_PERIPH(csi_top,        CSI_TOP_CFG,     24,      3,            CSI_TOP_CFG,        0,         4,          0,          0,          0,          CSI_TOP_CFG,     CSI_GATE,        CSI_GATE,      MBUS_GATE,     31,         16,         0,             8,             &clk_lock, &com_gates[4],    1);
+SUNXI_CLK_PERIPH(csi_master,     CSI_MASTER_CFG,  24,      3,            CSI_MASTER_CFG,     0,         5,          0,          0,          0,          CSI_MASTER_CFG,  CSI_GATE,        CSI_GATE,      MBUS_GATE,     31,         16,         0,             8,             &clk_lock, &com_gates[4],    2);
+SUNXI_CLK_PERIPH(pio,            0,               0,       0,            0,                  0,         0,          0,          0,          0,          0,               0,               0,             0,             0,          0,          0,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(cpurcpus_pll,   0,               0,       0,            CPUS_CFG,           0,         5,          0,          0,          0,          0,               0,               0,             0,             0,          0,          0,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(cpurcpus,       CPUS_CFG,        24,      2,            CPUS_CFG,           0,         0,          8,          2,          0,          0,               0,               0,             0,             0,          0,          0,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(cpurahbs,       0,               0,       0,            0,                  0,         0,          0,          0,          0,          0,               0,               0,             0,             0,          0,          0,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(cpurapbs1,      0,               0,       0,            CPUS_APBS1_CFG,     0,         2,          0,          0,          0,          0,               0,               0,             0,             0,          0,          0,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(cpurapbs2_pll,  0,               0,       0,            CPUS_APBS2_CFG,     0,         5,          0,          0,          0,          0,               0,               0,             0,             0,          0,          0,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(cpurapbs2,      CPUS_APBS2_CFG,  24,      2,            CPUS_APBS2_CFG,     0,         0,          8,          2,          0,          0,               0,               0,             0,             0,          0,          0,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(losc_out,       0,               0,       0,            0,                  0,         0,          0,          0,          0,          0,               0,               LOSC_OUT_GATE, 0,             0,          0,          0,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(cpurpio,        0,               0,       0,            0,                  0,         0,          0,          0,          0,          0,               0,               0,             0,             0,          0,          0,             0,             &clk_lock, NULL,             0);
+SUNXI_CLK_PERIPH(spwm,           CPUS_PWM_CFG,    24,      2,            0,                  0,         0,          0,          0,          0,          CPUS_PWM_CFG,    CPUS_PWM_GATE,   CPUS_PWM_GATE, 0,             31,        16,         0,             0,             &clk_lock, NULL,             0);
+
+struct periph_init_data sunxi_periphs_init[] = {
+	{"cpu",            CLK_GET_RATE_NOCACHE, cpu_parents,            ARRAY_SIZE(cpu_parents),            &sunxi_clk_periph_cpu              },
+	{"axi",            0,                    axi_parents,            ARRAY_SIZE(axi_parents),            &sunxi_clk_periph_axi              },
+	{"cpuapb",         0,                    cpuapb_parents,         ARRAY_SIZE(cpuapb_parents),         &sunxi_clk_periph_cpuapb           },
+	{"psi",            0,                    psi_parents,            ARRAY_SIZE(psi_parents),            &sunxi_clk_periph_psi              },
+	{"ahb1",           0,                    ahb1_parents,           ARRAY_SIZE(ahb1_parents),           &sunxi_clk_periph_ahb1             },
+	{"ahb2",           0,                    ahb2_parents,           ARRAY_SIZE(ahb2_parents),           &sunxi_clk_periph_ahb2             },
+	{"ahb3",           0,                    ahb3_parents,           ARRAY_SIZE(ahb3_parents),           &sunxi_clk_periph_ahb3             },
+	{"apb1",           0,                    apb1_parents,           ARRAY_SIZE(apb1_parents),           &sunxi_clk_periph_apb1             },
+	{"apb2",           0,                    apb2_parents,           ARRAY_SIZE(apb2_parents),           &sunxi_clk_periph_apb2             },
+	{"mbus",           0,                    mbus_parents,           ARRAY_SIZE(mbus_parents),           &sunxi_clk_periph_mbus             },
+	{"de",             0,                    de_parents,             ARRAY_SIZE(de_parents),             &sunxi_clk_periph_de               },
+	{"ee",             0,                    eink_parents,           ARRAY_SIZE(de_parents),             &sunxi_clk_periph_ee               },
+	{"edma",           0,                    eink_parents,           ARRAY_SIZE(de_parents),             &sunxi_clk_periph_edma             },
+	{"gpu",            0,                    gpu_parents,            ARRAY_SIZE(gpu_parents),            &sunxi_clk_periph_gpu              },
+	{"g2d",            0,                    g2d_parents,            ARRAY_SIZE(g2d_parents),            &sunxi_clk_periph_g2d              },
+	{"ce",             0,                    ce_parents,             ARRAY_SIZE(ce_parents),             &sunxi_clk_periph_ce               },
+	{"ve",             0,                    ve_parents,             ARRAY_SIZE(ve_parents),             &sunxi_clk_periph_ve               },
+	{"emce",           0,                    emce_parents,           ARRAY_SIZE(emce_parents),           &sunxi_clk_periph_emce             },
+	{"dma",            0,                    ahb1mod_parents,        ARRAY_SIZE(ahb1mod_parents),        &sunxi_clk_periph_dma              },
+	{"msgbox",         0,                    ahb1mod_parents,        ARRAY_SIZE(ahb1mod_parents),        &sunxi_clk_periph_msgbox           },
+	{"hwspinlock_rst", 0,                    ahb1mod_parents,        ARRAY_SIZE(ahb1mod_parents),        &sunxi_clk_periph_hwspinlock_rst   },
+	{"hwspinlock_bus", 0,                    ahb1mod_parents,        ARRAY_SIZE(ahb1mod_parents),        &sunxi_clk_periph_hwspinlock_bus   },
+	{"hstimer",        0,                    ahb1mod_parents,        ARRAY_SIZE(ahb1mod_parents),        &sunxi_clk_periph_hstimer          },
+	{"avs",            0,                    hosc_parents,           ARRAY_SIZE(hosc_parents),           &sunxi_clk_periph_avs              },
+	{"dbgsys",         0,                    ahb1mod_parents,        ARRAY_SIZE(ahb1mod_parents),        &sunxi_clk_periph_dbgsys           },
+	{"pwm",            0,                    apb1mod_parents,        ARRAY_SIZE(apb1mod_parents),        &sunxi_clk_periph_pwm              },
+	{"iommu",          0,                    ahb1mod_parents,        ARRAY_SIZE(ahb1mod_parents),        &sunxi_clk_periph_iommu            },
+	{"sdram",          0,                    sdram_parents,          ARRAY_SIZE(sdram_parents),          &sunxi_clk_periph_sdram            },
+	{"nand0",          0,                    nand_parents,           ARRAY_SIZE(nand_parents),           &sunxi_clk_periph_nand0            },
+	{"nand1",          0,                    nand_parents,           ARRAY_SIZE(nand_parents),           &sunxi_clk_periph_nand1            },
+	{"sdmmc0_mod",     0,                    smhc_parents,           ARRAY_SIZE(smhc_parents),           &sunxi_clk_periph_sdmmc0_mod       },
+	{"sdmmc0_rst",     0,                    smhc_parents,           ARRAY_SIZE(smhc_parents),           &sunxi_clk_periph_sdmmc0_rst       },
+	{"sdmmc0_bus",     0,                    smhc_parents,           ARRAY_SIZE(smhc_parents),           &sunxi_clk_periph_sdmmc0_bus       },
+	{"sdmmc1_mod",     0,                    smhc_parents,           ARRAY_SIZE(smhc_parents),           &sunxi_clk_periph_sdmmc1_mod       },
+	{"sdmmc1_rst",     0,                    smhc_parents,           ARRAY_SIZE(smhc_parents),           &sunxi_clk_periph_sdmmc1_rst       },
+	{"sdmmc1_bus",     0,                    smhc_parents,           ARRAY_SIZE(smhc_parents),           &sunxi_clk_periph_sdmmc1_bus       },
+	{"sdmmc2_mod",     0,                    smhc_parents,           ARRAY_SIZE(smhc_parents),           &sunxi_clk_periph_sdmmc2_mod       },
+	{"sdmmc2_rst",     0,                    smhc_parents,           ARRAY_SIZE(smhc_parents),           &sunxi_clk_periph_sdmmc2_rst       },
+	{"sdmmc2_bus",     0,                    smhc_parents,           ARRAY_SIZE(smhc_parents),           &sunxi_clk_periph_sdmmc2_bus       },
+	{"uart0",          0,                    apb2mod_parents,        ARRAY_SIZE(apb2mod_parents),        &sunxi_clk_periph_uart0            },
+	{"uart1",          0,                    apb2mod_parents,        ARRAY_SIZE(apb2mod_parents),        &sunxi_clk_periph_uart1            },
+	{"uart2",          0,                    apb2mod_parents,        ARRAY_SIZE(apb2mod_parents),        &sunxi_clk_periph_uart2            },
+	{"uart3",          0,                    apb2mod_parents,        ARRAY_SIZE(apb2mod_parents),        &sunxi_clk_periph_uart3            },
+	{"uart4",          0,                    apb2mod_parents,        ARRAY_SIZE(apb2mod_parents),        &sunxi_clk_periph_uart4            },
+	{"twi0",           0,                    apb2mod_parents,        ARRAY_SIZE(apb2mod_parents),        &sunxi_clk_periph_twi0             },
+	{"twi1",           0,                    apb2mod_parents,        ARRAY_SIZE(apb2mod_parents),        &sunxi_clk_periph_twi1             },
+	{"twi2",           0,                    apb2mod_parents,        ARRAY_SIZE(apb2mod_parents),        &sunxi_clk_periph_twi2             },
+	{"spi0",           0,                    spi_parents,            ARRAY_SIZE(spi_parents),            &sunxi_clk_periph_spi0             },
+	{"spi1",           0,                    spi_parents,            ARRAY_SIZE(spi_parents),            &sunxi_clk_periph_spi1             },
+	{"ths",            0,                    apb1mod_parents,        ARRAY_SIZE(apb1mod_parents),        &sunxi_clk_periph_ths              },
+	{"gpadc",          0,                    apb1mod_parents,        ARRAY_SIZE(apb1mod_parents),        &sunxi_clk_periph_gpadc            },
+	{"i2s0",           0,                    audio_parents,          ARRAY_SIZE(audio_parents),          &sunxi_clk_periph_i2s0             },
+	{"i2s1",           0,                    audio_parents,          ARRAY_SIZE(audio_parents),          &sunxi_clk_periph_i2s1             },
+	{"dmic",           0,                    audio_parents,          ARRAY_SIZE(audio_parents),          &sunxi_clk_periph_dmic             },
+	{"codec_1x",       0,                    audio_parents,          ARRAY_SIZE(audio_parents),          &sunxi_clk_periph_codec_1x         },
+	{"codec_4x",       0,                    audio_parents,          ARRAY_SIZE(audio_parents),          &sunxi_clk_periph_codec_4x         },
+	{"usbphy0",        0,                    hosc_parents,           ARRAY_SIZE(hosc_parents),           &sunxi_clk_periph_usbphy0          },
+	{"usbphy1",        0,                    hosc_parents,           ARRAY_SIZE(hosc_parents),           &sunxi_clk_periph_usbphy1          },
+	{"usbohci0",       0,                    ahb3mod_parents,        ARRAY_SIZE(ahb3mod_parents),        &sunxi_clk_periph_usbohci0         },
+	{"usbohci0_12m",   0,                    usbohci_12m_parents,    ARRAY_SIZE(usbohci_12m_parents),    &sunxi_clk_periph_usbohci0_12m     },
+	{"usbohci1",       0,                    ahb3mod_parents,        ARRAY_SIZE(ahb3mod_parents),        &sunxi_clk_periph_usbohci1         },
+	{"usbohci1_12m",   0,                    usbohci_12m_parents,    ARRAY_SIZE(usbohci_12m_parents),    &sunxi_clk_periph_usbohci1_12m     },
+	{"usbehci0",       0,                    ahb3mod_parents,        ARRAY_SIZE(ahb3mod_parents),        &sunxi_clk_periph_usbehci0         },
+	{"usbehci1",       0,                    ahb3mod_parents,        ARRAY_SIZE(ahb3mod_parents),        &sunxi_clk_periph_usbehci1         },
+	{"usbotg",         0,                    ahb3mod_parents,        ARRAY_SIZE(ahb3mod_parents),        &sunxi_clk_periph_usbotg           },
+	{"mipi_dphy0",     0,                    mipi_dphy_parents,      ARRAY_SIZE(mipi_dphy_parents),      &sunxi_clk_periph_mipi_dphy0       },
+	{"mipi_host0",     0,                    mipi_host_parents,      ARRAY_SIZE(mipi_host_parents),      &sunxi_clk_periph_mipi_host0       },
+	{"display_top",    0,                    ahb3mod_parents,        ARRAY_SIZE(ahb3mod_parents),        &sunxi_clk_periph_display_top      },
+	{"tcon_lcd0",      0,                    tcon_lcd_parents,       ARRAY_SIZE(tcon_lcd_parents),       &sunxi_clk_periph_tcon_lcd0        },
+	{"lvds0",          0,                    lvds_parents,           ARRAY_SIZE(lvds_parents),           &sunxi_clk_periph_lvds0             },
+	{"csi_mipi",       0,                    hosc_parents,           ARRAY_SIZE(hosc_parents),           &sunxi_clk_periph_csi_mipi         },
+	{"csi_misc",       0,                    hosc_parents,           ARRAY_SIZE(hosc_parents),           &sunxi_clk_periph_csi_misc         },
+	{"csi_top",        0,                    csi_top_parents,        ARRAY_SIZE(csi_top_parents),        &sunxi_clk_periph_csi_top          },
+	{"csi_master",     0,                    csi_master_parents,     ARRAY_SIZE(csi_master_parents),     &sunxi_clk_periph_csi_master       },
+	{"pio",            0,                    apb1mod_parents,        ARRAY_SIZE(apb1mod_parents),        &sunxi_clk_periph_pio              },
+};
+
+struct periph_init_data sunxi_periphs_cpus_init[] = {
+	{"cpurcpus_pll",    CLK_GET_RATE_NOCACHE|CLK_READONLY,  cpurcpus_pll_parents,   ARRAY_SIZE(cpurcpus_pll_parents),   &sunxi_clk_periph_cpurcpus_pll  },
+	{"cpurcpus",        CLK_GET_RATE_NOCACHE|CLK_READONLY,  cpurcpus_parents,       ARRAY_SIZE(cpurcpus_parents),       &sunxi_clk_periph_cpurcpus      },
+	{"cpurahbs",        CLK_GET_RATE_NOCACHE|CLK_READONLY,  cpurahbs_parents,       ARRAY_SIZE(cpurahbs_parents),       &sunxi_clk_periph_cpurahbs      },
+	{"cpurapbs1",       CLK_GET_RATE_NOCACHE|CLK_READONLY,  cpurapbs1_parents,      ARRAY_SIZE(cpurapbs1_parents),      &sunxi_clk_periph_cpurapbs1     },
+	{"cpurapbs2_pll",   CLK_GET_RATE_NOCACHE|CLK_READONLY,  cpurapbs2_pll_parents,  ARRAY_SIZE(cpurapbs2_pll_parents),  &sunxi_clk_periph_cpurapbs2_pll },
+	{"cpurapbs2",       CLK_GET_RATE_NOCACHE|CLK_READONLY,  cpurapbs2_parents,      ARRAY_SIZE(cpurapbs2_parents),      &sunxi_clk_periph_cpurapbs2     },
+	{"losc_out",        0,                                  losc_parents,           ARRAY_SIZE(losc_parents),           &sunxi_clk_periph_losc_out      },
+	{"cpurpio",         CLK_GET_RATE_NOCACHE|CLK_READONLY,  cpurpio_parents,        ARRAY_SIZE(cpurpio_parents),        &sunxi_clk_periph_cpurpio       },
+	{"spwm",            0,                                  spwm_parents,           ARRAY_SIZE(spwm_parents),           &sunxi_clk_periph_spwm          },
+};
+
+
+/*
+ * sunxi_clk_get_factor_by_name() - Get factor clk init config
+ */
+struct factor_init_data *sunxi_clk_get_factor_by_name(const char *name)
+{
+	struct factor_init_data *factor;
+	int i;
+
+	/* get pll clk init config */
+	for (i = 0; i < ARRAY_SIZE(sunxi_factos); i++) {
+		factor = &sunxi_factos[i];
+		if (strcmp(name, factor->name))
+			continue;
+		return factor;
+	}
+
+	return NULL;
+}
+
+struct periph_init_data *sunxi_clk_get_periph_rtc_by_name(const char *name)
+{
+	return NULL;
+}
+/*
+ * sunxi_clk_get_periph_by_name() - Get periph clk init config
+ */
+struct periph_init_data *sunxi_clk_get_periph_by_name(const char *name)
+{
+	struct periph_init_data *perpih;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(sunxi_periphs_init); i++) {
+		perpih = &sunxi_periphs_init[i];
+		if (strcmp(name, perpih->name))
+			continue;
+		return perpih;
+	}
+
+	return NULL;
+}
+
+/*
+ * sunxi_clk_get_periph_cpus_by_name() - Get periph clk init config
+ */
+struct periph_init_data *sunxi_clk_get_periph_cpus_by_name(const char *name)
+{
+	struct periph_init_data *perpih;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(sunxi_periphs_cpus_init); i++) {
+		perpih = &sunxi_periphs_cpus_init[i];
+		if (strcmp(name, perpih->name))
+			continue;
+		return perpih;
+	}
+
+	return NULL;
+}
+struct periph_init_data *sunxi_cpus_clk_get_periph_by_name(const char *name)
+{
+	struct periph_init_data *perpih;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(sunxi_periphs_cpus_init); i++) {
+		perpih = &sunxi_periphs_cpus_init[i];
+		if (strcmp(name, perpih->name))
+			continue;
+		return perpih;
+	}
+
+	return NULL;
+}
+
+void sunxi_clocks_init(struct device_node *node)
+{
+	sunxi_clk_base = of_iomap(node, 0);
+	sunxi_clk_cpus_base = of_iomap(node, 1);
+	sunxi_clk_periph_losc_out.gate.bus = of_iomap(node, 2);
+	/*do some initialize arguments here*/
+	sunxi_clk_factor_initlimits();
+}
+void sunxi_cpu_clocks_init(struct device_node *node) {}
diff --git a/drivers/clk/sunxi/clk-sun8iw15.h b/drivers/clk/sunxi/clk-sun8iw15.h
new file mode 100644
index 000000000..8d65d4a50
--- /dev/null
+++ b/drivers/clk/sunxi/clk-sun8iw15.h
@@ -0,0 +1,180 @@
+/*
+ * Copyright (C) 2016 Allwinnertech
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Adjustable factor-based clock implementation
+ */
+#ifndef __MACH_SUNXI_CLK_SUN8IW15_H
+#define __MACH_SUNXI_CLK_SUN8IW15_H
+
+#include <linux/clk-provider.h>
+#include <linux/clkdev.h>
+#include <linux/io.h>
+#include "clk-factors.h"
+
+#define IO_ADDRESS(x) (void __iomem *)(((x) & 0x0fffffff) + \
+					(((x) >> 4) & 0x0f000000) + \
+					0xf0000000)
+
+/* CCMU Register List */
+#define PLL_CPU             0x0000
+#define PLL_DDR             0x0010
+#define PLL_PERIPH0         0x0020
+#define PLL_PERIPH1         0x0028
+#define PLL_GPU             0x0030
+#define PLL_VIDEO0          0x0040
+#define PLL_VIDEO1          0x0048
+#define PLL_VE              0x0058
+#define PLL_DE              0x0060
+#define PLL_AUDIO           0x0078
+#define PLL_24M             0x00b8
+
+#define PLL_DDRPAT          0x0110
+#define PLL_PERI0PAT0       0x0120
+#define PLL_PERI0PAT1       0x0124
+#define PLL_PERI1PAT0       0x0128
+#define PLL_PERI1PAT1       0x012C
+#define PLL_GPUPAT0         0x0130
+#define PLL_GPUPAT1         0x0134
+#define PLL_VIDEO0PAT0      0x0140
+#define PLL_VIDEO0PAT1      0x0144
+#define PLL_VIDEO1PAT0      0x0148
+#define PLL_VIDEO1PAT1      0x014C
+#define PLL_VEPAT0          0x0158
+#define PLL_VEPAT1          0x015C
+#define PLL_DEPAT0          0x0160
+#define PLL_DEPAT1          0x0164
+#define PLL_AUDIOPAT0       0x0178
+#define PLL_AUDIOPAT1       0x017C
+
+
+#define CPU_CFG             0x0500
+#define PSI_CFG             0x0510
+#define AHB3_CFG            0x051C
+#define APB1_CFG            0x0520
+#define APB2_CFG            0x0524
+#define MBUS_CFG            0x0540
+
+/* Accelerator */
+#define DE_CFG              0x0600
+#define DE_GATE             0x060C
+#define EE_CFG              0x0610
+#define EDMA_CFG            0x0640
+#define EINK_GATE           0x061C
+#define G2D_CFG             0x0630
+#define G2D_GATE            0x063C
+#define GPU_CFG             0x0670
+#define GPU_GATE            0x067C
+#define CE_CFG              0x0680
+#define CE_GATE             0x068C
+#define VE_CFG              0x0690
+#define VE_GATE             0x069C
+#define EMCE_CFG            0x06B0
+#define EMCE_GATE           0x06BC
+
+/* SYS Resource */
+#define DMA_GATE            0x070C
+#define MSGBOX_GATE         0x071C
+#define SPINLOCK_GATE       0x072C
+#define HSTIMER_GATE        0x073C
+#define AVS_CFG             0x0740
+#define DBGSYS_GATE         0x078C
+#define PSI_GATE            0x079C
+#define PWM_GATE            0x07AC
+#define IOMMU_GATE          0x07BC
+
+/* Storage Medium */
+#define DRAM_CFG            0x0800
+#define MBUS_GATE           0x0804
+#define DRAM_GATE           0x080C
+#define NAND0_CFG           0x0810
+#define NAND1_CFG           0x0814
+#define NAND_GATE           0x082C
+#define SMHC0_CFG           0x0830
+#define SMHC1_CFG           0x0834
+#define SMHC2_CFG           0x0838
+#define SMHC_GATE           0x084C
+
+/* Common Interface */
+#define UART_GATE           0x090C
+#define TWI_GATE            0x091C
+#define SCR_GATE            0x093C
+#define SPI0_CFG            0x0940
+#define SPI1_CFG            0x0944
+#define SPI_GATE            0x096C
+#define GPADC_GATE          0x09EC
+#define THS_GATE            0x09FC
+#define I2S0_CFG            0x0A10
+#define I2S1_CFG            0x0A14
+#define I2S_GATE            0x0A1C
+#define DMIC_CFG            0x0A40
+#define DMIC_GATE           0x0A4C
+#define CODEC_1X_CFG        0x0A50
+#define CODEC_4X_CFG        0x0A54
+#define CODEC_GATE          0x0A5C
+#define USB0_CFG            0x0A70
+#define USB1_CFG            0x0A74
+#define USB_GATE            0x0A8C
+
+/* Display Interface */
+#define MIPI_DPHY0_CFG      0x0B20
+#define MIPI_HOST0_CFG      0x0B24
+#define MIPI_GATE           0x0B4C
+#define DISPLAY_TOP_GATE    0x0B5C
+#define TCON_LCD0_CFG       0x0B60
+#define TCON_LCD_GATE       0x0B7C
+#define LVDS_GATE           0x0BAC
+#define CSI_MISC_CFG        0x0C00
+#define CSI_TOP_CFG         0x0C04
+#define CSI_MASTER_CFG      0x0C08
+#define CSI_GATE            0x0C2C
+#define SUNXI_CLK_MAX_REG   0x0C2C
+
+/* DISPLL Register List */
+#define PLL_DIS_CFG0        0x0000
+#define PLL_DIS_CFG1        0x0004
+#define PLL_DIS_TUN0        0x0008
+#define PLL_DIS_TUN1        0x000C
+#define PLL_DIS_PAT0        0x0010
+#define PLL_DIS_PAT1        0x0014
+#define PLL_DIS_SSC         0x0018
+#define PLL_DIS_DIV         0x0020
+
+/* PRCM Register List */
+#define CPUS_CFG            0x0000
+#define CPUS_APBS1_CFG      0x000C
+#define CPUS_APBS2_CFG      0x0010
+#define CPUS_TIMER_GATE     0x011C
+#define CPUS_TWDOG_GATE     0x012C
+#define CPUS_PWM_CFG        0x0130
+#define CPUS_PWM_GATE       0x013C
+#define CPUS_UART_GATE      0x018C
+#define CPUS_TWI_GATE       0x019C
+#define CPUS_RSB_GATE       0x01BC
+#define CPUS_RTC_GATE       0x020C
+#define CPUS_CLK_MAX_REG    0x020C
+
+/* RTC Register List */
+#define LOSC_OUT_GATE       0x0060
+
+#define F_N8X8_P16x2(nv, pv)      (FACTOR_ALL(nv, 8, 8, 0, 0, 0, 0, 0, 0, pv, 16, 2, 0, 0, 0, 0, 0, 0))
+#define F_N8X8_D1V1X1_D2V0X1(nv, d1v, d2v) (FACTOR_ALL(nv, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, d1v, 1, 1, d2v, 0, 1))
+#define F_N8X8_D1V1X1(nv, d1v)             (FACTOR_ALL(nv, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, d1v, 1, 1, 0, 0, 0))
+#define F_N8X8_D1V4X2_D2V0X2(nv, d1v, d2v) (FACTOR_ALL(nv, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, d1v, 4, 2, d2v, 0, 2))
+#define F_N8X8_P16X6_D1V1X1_D2V0X1(nv, pv, d1v, d2v) (FACTOR_ALL(nv, 8, 8, 0, 0, 0, 0, 0, 0, pv, 16, 6, d1v, 1, 1, d2v, 0, 1))
+
+#define PLLCPU(n, p, freq)        {F_N8X8_P16x2(n, p), freq}
+#define PLLDDR(n, d1, d2, freq)     {F_N8X8_D1V1X1_D2V0X1(n, d1, d2), freq}
+#define PLLPERIPH0(n, d1, d2, freq)  {F_N8X8_D1V1X1_D2V0X1(n, d1, d2), freq}
+#define PLLPERIPH1(n, d1, d2, freq)  {F_N8X8_D1V1X1_D2V0X1(n, d1, d2), freq}
+#define PLLGPU(n, d1, d2, freq)      {F_N8X8_D1V1X1_D2V0X1(n, d1, d2), freq}
+#define PLLVIDEO0(n, d1, freq)       {F_N8X8_D1V1X1(n, d1), freq}
+#define PLLVIDEO1(n, d1, freq)       {F_N8X8_D1V1X1(n, d1), freq}
+#define PLLVE(n, d1, d2, freq)       {F_N8X8_D1V1X1_D2V0X1(n, d1, d2), freq}
+#define PLLDE(n, d1, d2, freq)       {F_N8X8_D1V1X1_D2V0X1(n, d1, d2), freq}
+#define PLLAUDIO(n, p, d1, d2, freq) {F_N8X8_P16X6_D1V1X1_D2V0X1(n, p, d1, d2), freq}
+
+#endif
diff --git a/drivers/clk/sunxi/clk-sun8iw15_tbl.c b/drivers/clk/sunxi/clk-sun8iw15_tbl.c
new file mode 100644
index 000000000..2cb492483
--- /dev/null
+++ b/drivers/clk/sunxi/clk-sun8iw15_tbl.c
@@ -0,0 +1,617 @@
+/*
+ * Copyright (C) 2016 Allwinnertech
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Adjustable factor-based clock implementation
+ */
+
+#include "clk-sun8iw15.h"
+
+/*
+ * freq table from hardware, need follow rules
+ * 1)   each table  named as
+ *      factor_pll1_tbl
+ *      factor_pll2_tbl
+ *      ...
+ * 2) for each table line
+ *      a) follow the format PLLx(n, k, m, p, d1, d2, freq), and keep the
+ *         factors order
+ *      b) if any factor not used, skip it
+ *      c) the factor is the value to write registers, not means factor + 1
+ *
+ *      example
+ *      PLL1(9, 0, 0, 2, 60000000) means PLL1(n, k, m, p, freq)
+ *      PLLVIDEO0(3, 0, 96000000) means PLLVIDEO0(n, m, freq)
+ *
+ */
+
+/* PLLCPU(n, m, p, freq)	F_N8X8_M0X2_P16x2 */
+struct sunxi_clk_factor_freq factor_pllcpu_tbl[] = {
+PLLCPU(11,     2,     72000000U),
+PLLCPU(31,     2,     192000000U),
+PLLCPU(11,     0,     288000000U),
+PLLCPU(15,     0,     384000000U),
+PLLCPU(40,     1,     492000000U),
+PLLCPU(24,     0,     600000000U),
+PLLCPU(64,     1,     780000000U),
+PLLCPU(72,     1,     876000000U),
+PLLCPU(80,     1,     972000000U),
+PLLCPU(44,     0,     1080000000U),
+PLLCPU(46,     0,     1128000000U),
+PLLCPU(48,     0,     1176000000U),
+PLLCPU(49,     0,     1200000000U),
+PLLCPU(51,     0,     1248000000U),
+PLLCPU(53,     0,     1296000000U),
+PLLCPU(54,     0,     1320000000U),
+PLLCPU(58,     0,     1416000000U),
+PLLCPU(122,    1,     1476000000U),
+PLLCPU(124,    1,     1500000000U),
+PLLCPU(62,     0,     1512000000U),
+PLLCPU(63,     0,     1536000000U),
+PLLCPU(132,    1,     1596000000U),
+PLLCPU(134,    1,     1620000000U),
+PLLCPU(138,    1,     1668000000U),
+PLLCPU(73,     0,     1776000000U),
+PLLCPU(74,     0,     1800000000U),
+PLLCPU(76,     0,     1848000000U),
+PLLCPU(160,    1,     1932000000U),
+PLLCPU(81,     0,     1968000000U),
+PLLCPU(166,    1,     2004000000U),
+PLLCPU(84,     0,     2040000000U),
+};
+/*n  m1   m0   freq */
+/* PLLDDR(n, d1, d2, freq)	F_N8X8_D1V1X1_D2V0X1 */
+struct sunxi_clk_factor_freq factor_pllddr_tbl[] = {
+PLLDDR(23,     0,     1,     288000000U),
+PLLDDR(29,     0,     1,     360000000U),
+PLLDDR(18,     0,     0,     456000000U),
+PLLDDR(90,     1,     1,     546000000U),
+PLLDDR(24,     0,     0,     600000000U),
+PLLDDR(58,     0,     1,     708000000U),
+PLLDDR(34,     0,     0,     840000000U),
+PLLDDR(39,     0,     0,     960000000U),
+PLLDDR(44,     0,     0,     1080000000U),
+PLLDDR(84,     0,     0,     2040000000U),
+};
+
+/* PLLPERIPH0(n, d1, d2, freq)	F_N8X8_D1V1X1_D2V0X1 */
+struct sunxi_clk_factor_freq factor_pllperiph0_tbl[] = {
+PLLPERIPH0(49,     1,     1,     300000000U),
+PLLPERIPH0(56,     1,     1,     342000000U),
+PLLPERIPH0(31,     0,     1,     384000000U),
+PLLPERIPH0(19,     0,     0,     480000000U),
+PLLPERIPH0(23,     0,     0,     576000000U),
+PLLPERIPH0(24,     0,     0,     600000000U),
+PLLPERIPH0(25,     0,     0,     624000000U),
+PLLPERIPH0(52,     0,     1,     636000000U),
+};
+
+/* PLLPERIPH1(n, d1, d2, freq)	F_N8X8_D1V1X1_D2V0X1 */
+struct sunxi_clk_factor_freq factor_pllperiph1_tbl[] = {
+PLLPERIPH1(49,     1,     1,     300000000U),
+PLLPERIPH1(56,     1,     1,     342000000U),
+PLLPERIPH1(31,     0,     1,     384000000U),
+PLLPERIPH1(19,     0,     0,     480000000U),
+PLLPERIPH1(23,     0,     0,     576000000U),
+PLLPERIPH1(24,     0,     0,     600000000U),
+PLLPERIPH1(25,     0,     0,     624000000U),
+PLLPERIPH1(52,     0,     1,     636000000U),
+};
+
+/* PLLGPU(n, d1, d2, freq)	F_N8X8_D1V1X1_D2V0X1 */
+struct sunxi_clk_factor_freq factor_pllgpu_tbl[] = {
+PLLGPU(23,     0,     1,     288000000U),
+PLLGPU(24,     0,     1,     300000000U),
+PLLGPU(25,     0,     1,     312000000U),
+PLLGPU(26,     0,     1,     324000000U),
+PLLGPU(27,     0,     1,     336000000U),
+PLLGPU(28,     0,     1,     348000000U),
+PLLGPU(29,     0,     1,     360000000U),
+PLLGPU(30,     0,     1,     372000000U),
+PLLGPU(15,     0,     0,     384000000U),
+PLLGPU(32,     0,     1,     396000000U),
+PLLGPU(16,     0,     0,     408000000U),
+PLLGPU(34,     0,     1,     420000000U),
+PLLGPU(17,     0,     0,     432000000U),
+PLLGPU(36,     0,     1,     444000000U),
+PLLGPU(18,     0,     0,     456000000U),
+PLLGPU(38,     0,     1,     468000000U),
+PLLGPU(19,     0,     0,     480000000U),
+PLLGPU(40,     0,     1,     492000000U),
+PLLGPU(20,     0,     0,     504000000U),
+PLLGPU(42,     0,     1,     516000000U),
+PLLGPU(21,     0,     0,     528000000U),
+PLLGPU(44,     0,     1,     540000000U),
+PLLGPU(22,     0,     0,     552000000U),
+PLLGPU(46,     0,     1,     564000000U),
+PLLGPU(23,     0,     0,     576000000U),
+PLLGPU(48,     0,     1,     588000000U),
+PLLGPU(24,     0,     0,     600000000U),
+PLLGPU(50,     0,     1,     612000000U),
+PLLGPU(25,     0,     0,     624000000U),
+PLLGPU(52,     0,     1,     636000000U),
+PLLGPU(26,     0,     0,     648000000U),
+PLLGPU(54,     0,     1,     660000000U),
+PLLGPU(27,     0,     0,     672000000U),
+};
+
+/* PLLVIDEO0(n, d1, freq)	F_N8X8_D1V1X1 */
+struct sunxi_clk_factor_freq factor_pllvideo0_tbl[] = {
+PLLVIDEO0(23,     1,     72000000U),
+PLLVIDEO0(24,     1,     75000000U),
+PLLVIDEO0(25,     1,     78000000U),
+PLLVIDEO0(26,     1,     81000000U),
+PLLVIDEO0(13,     0,     84000000U),
+PLLVIDEO0(28,     1,     87000000U),
+PLLVIDEO0(14,     0,     90000000U),
+PLLVIDEO0(30,     1,     93000000U),
+PLLVIDEO0(15,     0,     96000000U),
+PLLVIDEO0(32,     1,     99000000U),
+PLLVIDEO0(16,     0,     102000000U),
+PLLVIDEO0(34,     1,     105000000U),
+PLLVIDEO0(17,     0,     108000000U),
+PLLVIDEO0(36,     1,     111000000U),
+PLLVIDEO0(18,     0,     114000000U),
+PLLVIDEO0(38,     1,     117000000U),
+PLLVIDEO0(19,     0,     120000000U),
+PLLVIDEO0(40,     1,     123000000U),
+PLLVIDEO0(20,     0,     126000000U),
+PLLVIDEO0(42,     1,     129000000U),
+PLLVIDEO0(21,     0,     132000000U),
+PLLVIDEO0(44,     1,     135000000U),
+PLLVIDEO0(22,     0,     138000000U),
+PLLVIDEO0(46,     1,     141000000U),
+PLLVIDEO0(23,     0,     144000000U),
+PLLVIDEO0(48,     1,     147000000U),
+PLLVIDEO0(24,     0,     150000000U),
+PLLVIDEO0(50,     1,     153000000U),
+PLLVIDEO0(25,     0,     156000000U),
+PLLVIDEO0(52,     1,     159000000U),
+PLLVIDEO0(26,     0,     162000000U),
+PLLVIDEO0(54,     1,     165000000U),
+PLLVIDEO0(27,     0,     168000000U),
+PLLVIDEO0(56,     1,     171000000U),
+PLLVIDEO0(28,     0,     174000000U),
+PLLVIDEO0(58,     1,     177000000U),
+PLLVIDEO0(29,     0,     180000000U),
+PLLVIDEO0(60,     1,     183000000U),
+PLLVIDEO0(30,     0,     186000000U),
+PLLVIDEO0(62,     1,     189000000U),
+PLLVIDEO0(31,     0,     192000000U),
+PLLVIDEO0(64,     1,     195000000U),
+PLLVIDEO0(32,     0,     198000000U),
+PLLVIDEO0(66,     1,     201000000U),
+PLLVIDEO0(33,     0,     204000000U),
+PLLVIDEO0(68,     1,     207000000U),
+PLLVIDEO0(34,     0,     210000000U),
+PLLVIDEO0(70,     1,     213000000U),
+PLLVIDEO0(35,     0,     216000000U),
+PLLVIDEO0(72,     1,     219000000U),
+PLLVIDEO0(36,     0,     222000000U),
+PLLVIDEO0(74,     1,     225000000U),
+PLLVIDEO0(37,     0,     228000000U),
+PLLVIDEO0(76,     1,     231000000U),
+PLLVIDEO0(38,     0,     234000000U),
+PLLVIDEO0(78,     1,     237000000U),
+PLLVIDEO0(39,     0,     240000000U),
+PLLVIDEO0(80,     1,     243000000U),
+PLLVIDEO0(40,     0,     246000000U),
+PLLVIDEO0(82,     1,     249000000U),
+PLLVIDEO0(41,     0,     252000000U),
+PLLVIDEO0(84,     1,     255000000U),
+PLLVIDEO0(42,     0,     258000000U),
+PLLVIDEO0(86,     1,     261000000U),
+PLLVIDEO0(43,     0,     264000000U),
+PLLVIDEO0(88,     1,     267000000U),
+PLLVIDEO0(44,     0,     270000000U),
+PLLVIDEO0(90,     1,     273000000U),
+PLLVIDEO0(45,     0,     276000000U),
+PLLVIDEO0(92,     1,     279000000U),
+PLLVIDEO0(46,     0,     282000000U),
+PLLVIDEO0(94,     1,     285000000U),
+PLLVIDEO0(47,     0,     288000000U),
+PLLVIDEO0(96,     1,     291000000U),
+PLLVIDEO0(48,     0,     294000000U),
+PLLVIDEO0(98,     1,     297000000U),
+PLLVIDEO0(49,     0,     300000000U),
+PLLVIDEO0(100,     1,     303000000U),
+PLLVIDEO0(50,     0,     306000000U),
+PLLVIDEO0(102,     1,     309000000U),
+PLLVIDEO0(51,     0,     312000000U),
+PLLVIDEO0(104,     1,     315000000U),
+PLLVIDEO0(52,     0,     318000000U),
+PLLVIDEO0(106,     1,     321000000U),
+PLLVIDEO0(53,     0,     324000000U),
+PLLVIDEO0(108,     1,     327000000U),
+PLLVIDEO0(54,     0,     330000000U),
+PLLVIDEO0(110,     1,     333000000U),
+PLLVIDEO0(55,     0,     336000000U),
+PLLVIDEO0(112,     1,     339000000U),
+PLLVIDEO0(56,     0,     342000000U),
+PLLVIDEO0(114,     1,     345000000U),
+PLLVIDEO0(57,     0,     348000000U),
+PLLVIDEO0(116,     1,     351000000U),
+PLLVIDEO0(58,     0,     354000000U),
+PLLVIDEO0(118,     1,     357000000U),
+PLLVIDEO0(59,     0,     360000000U),
+PLLVIDEO0(120,     1,     363000000U),
+PLLVIDEO0(60,     0,     366000000U),
+PLLVIDEO0(122,     1,     369000000U),
+PLLVIDEO0(61,     0,     372000000U),
+PLLVIDEO0(124,     1,     375000000U),
+PLLVIDEO0(62,     0,     378000000U),
+PLLVIDEO0(126,     1,     381000000U),
+PLLVIDEO0(63,     0,     384000000U),
+PLLVIDEO0(128,     1,     387000000U),
+PLLVIDEO0(64,     0,     390000000U),
+PLLVIDEO0(130,     1,     393000000U),
+PLLVIDEO0(65,     0,     396000000U),
+PLLVIDEO0(132,     1,     399000000U),
+PLLVIDEO0(66,     0,     402000000U),
+PLLVIDEO0(134,     1,     405000000U),
+PLLVIDEO0(67,     0,     408000000U),
+PLLVIDEO0(136,     1,     411000000U),
+PLLVIDEO0(68,     0,     414000000U),
+PLLVIDEO0(138,     1,     417000000U),
+PLLVIDEO0(69,     0,     420000000U),
+PLLVIDEO0(140,     1,     423000000U),
+PLLVIDEO0(70,     0,     426000000U),
+PLLVIDEO0(142,     1,     429000000U),
+PLLVIDEO0(71,     0,     432000000U),
+PLLVIDEO0(144,     1,     435000000U),
+PLLVIDEO0(72,     0,     438000000U),
+PLLVIDEO0(146,     1,     441000000U),
+PLLVIDEO0(73,     0,     444000000U),
+PLLVIDEO0(148,     1,     447000000U),
+PLLVIDEO0(74,     0,     450000000U),
+PLLVIDEO0(150,     1,     453000000U),
+PLLVIDEO0(75,     0,     456000000U),
+PLLVIDEO0(152,     1,     459000000U),
+PLLVIDEO0(76,     0,     462000000U),
+PLLVIDEO0(154,     1,     465000000U),
+PLLVIDEO0(77,     0,     468000000U),
+PLLVIDEO0(156,     1,     471000000U),
+PLLVIDEO0(78,     0,     474000000U),
+PLLVIDEO0(158,     1,     477000000U),
+PLLVIDEO0(79,     0,     480000000U),
+PLLVIDEO0(160,     1,     483000000U),
+PLLVIDEO0(80,     0,     486000000U),
+PLLVIDEO0(162,     1,     489000000U),
+PLLVIDEO0(81,     0,     492000000U),
+PLLVIDEO0(164,     1,     495000000U),
+PLLVIDEO0(82,     0,     498000000U),
+PLLVIDEO0(166,     1,     501000000U),
+PLLVIDEO0(83,     0,     504000000U),
+PLLVIDEO0(168,     1,     507000000U),
+PLLVIDEO0(84,     0,     510000000U),
+PLLVIDEO0(170,     1,     513000000U),
+PLLVIDEO0(85,     0,     516000000U),
+PLLVIDEO0(172,     1,     519000000U),
+PLLVIDEO0(86,     0,     522000000U),
+PLLVIDEO0(174,     1,     525000000U),
+PLLVIDEO0(87,     0,     528000000U),
+PLLVIDEO0(176,     1,     531000000U),
+PLLVIDEO0(88,     0,     534000000U),
+PLLVIDEO0(178,     1,     537000000U),
+PLLVIDEO0(89,     0,     540000000U),
+};
+
+/* PLLVIDEO1(n, d1, freq)	F_N8X8_D1V1X1 */
+struct sunxi_clk_factor_freq factor_pllvideo1_tbl[] = {
+PLLVIDEO1(23,     1,     72000000U),
+PLLVIDEO1(24,     1,     75000000U),
+PLLVIDEO1(25,     1,     78000000U),
+PLLVIDEO1(26,     1,     81000000U),
+PLLVIDEO1(13,     0,     84000000U),
+PLLVIDEO1(28,     1,     87000000U),
+PLLVIDEO1(14,     0,     90000000U),
+PLLVIDEO1(30,     1,     93000000U),
+PLLVIDEO1(15,     0,     96000000U),
+PLLVIDEO1(32,     1,     99000000U),
+PLLVIDEO1(16,     0,     102000000U),
+PLLVIDEO1(34,     1,     105000000U),
+PLLVIDEO1(17,     0,     108000000U),
+PLLVIDEO1(36,     1,     111000000U),
+PLLVIDEO1(18,     0,     114000000U),
+PLLVIDEO1(38,     1,     117000000U),
+PLLVIDEO1(19,     0,     120000000U),
+PLLVIDEO1(40,     1,     123000000U),
+PLLVIDEO1(20,     0,     126000000U),
+PLLVIDEO1(42,     1,     129000000U),
+PLLVIDEO1(21,     0,     132000000U),
+PLLVIDEO1(44,     1,     135000000U),
+PLLVIDEO1(22,     0,     138000000U),
+PLLVIDEO1(46,     1,     141000000U),
+PLLVIDEO1(23,     0,     144000000U),
+PLLVIDEO1(48,     1,     147000000U),
+PLLVIDEO1(24,     0,     150000000U),
+PLLVIDEO1(50,     1,     153000000U),
+PLLVIDEO1(25,     0,     156000000U),
+PLLVIDEO1(52,     1,     159000000U),
+PLLVIDEO1(26,     0,     162000000U),
+PLLVIDEO1(54,     1,     165000000U),
+PLLVIDEO1(27,     0,     168000000U),
+PLLVIDEO1(56,     1,     171000000U),
+PLLVIDEO1(28,     0,     174000000U),
+PLLVIDEO1(58,     1,     177000000U),
+PLLVIDEO1(29,     0,     180000000U),
+PLLVIDEO1(60,     1,     183000000U),
+PLLVIDEO1(30,     0,     186000000U),
+PLLVIDEO1(62,     1,     189000000U),
+PLLVIDEO1(31,     0,     192000000U),
+PLLVIDEO1(64,     1,     195000000U),
+PLLVIDEO1(32,     0,     198000000U),
+PLLVIDEO1(66,     1,     201000000U),
+PLLVIDEO1(33,     0,     204000000U),
+PLLVIDEO1(68,     1,     207000000U),
+PLLVIDEO1(34,     0,     210000000U),
+PLLVIDEO1(70,     1,     213000000U),
+PLLVIDEO1(35,     0,     216000000U),
+PLLVIDEO1(72,     1,     219000000U),
+PLLVIDEO1(36,     0,     222000000U),
+PLLVIDEO1(74,     1,     225000000U),
+PLLVIDEO1(37,     0,     228000000U),
+PLLVIDEO1(76,     1,     231000000U),
+PLLVIDEO1(38,     0,     234000000U),
+PLLVIDEO1(78,     1,     237000000U),
+PLLVIDEO1(39,     0,     240000000U),
+PLLVIDEO1(80,     1,     243000000U),
+PLLVIDEO1(40,     0,     246000000U),
+PLLVIDEO1(82,     1,     249000000U),
+PLLVIDEO1(41,     0,     252000000U),
+PLLVIDEO1(84,     1,     255000000U),
+PLLVIDEO1(42,     0,     258000000U),
+PLLVIDEO1(86,     1,     261000000U),
+PLLVIDEO1(43,     0,     264000000U),
+PLLVIDEO1(88,     1,     267000000U),
+PLLVIDEO1(44,     0,     270000000U),
+PLLVIDEO1(90,     1,     273000000U),
+PLLVIDEO1(45,     0,     276000000U),
+PLLVIDEO1(92,     1,     279000000U),
+PLLVIDEO1(46,     0,     282000000U),
+PLLVIDEO1(94,     1,     285000000U),
+PLLVIDEO1(47,     0,     288000000U),
+PLLVIDEO1(96,     1,     291000000U),
+PLLVIDEO1(48,     0,     294000000U),
+PLLVIDEO1(98,     1,     297000000U),
+PLLVIDEO1(49,     0,     300000000U),
+PLLVIDEO1(100,     1,     303000000U),
+PLLVIDEO1(50,     0,     306000000U),
+PLLVIDEO1(102,     1,     309000000U),
+PLLVIDEO1(51,     0,     312000000U),
+PLLVIDEO1(104,     1,     315000000U),
+PLLVIDEO1(52,     0,     318000000U),
+PLLVIDEO1(106,     1,     321000000U),
+PLLVIDEO1(53,     0,     324000000U),
+PLLVIDEO1(108,     1,     327000000U),
+PLLVIDEO1(54,     0,     330000000U),
+PLLVIDEO1(110,     1,     333000000U),
+PLLVIDEO1(55,     0,     336000000U),
+PLLVIDEO1(112,     1,     339000000U),
+PLLVIDEO1(56,     0,     342000000U),
+PLLVIDEO1(114,     1,     345000000U),
+PLLVIDEO1(57,     0,     348000000U),
+PLLVIDEO1(116,     1,     351000000U),
+PLLVIDEO1(58,     0,     354000000U),
+PLLVIDEO1(118,     1,     357000000U),
+PLLVIDEO1(59,     0,     360000000U),
+PLLVIDEO1(120,     1,     363000000U),
+PLLVIDEO1(60,     0,     366000000U),
+PLLVIDEO1(122,     1,     369000000U),
+PLLVIDEO1(61,     0,     372000000U),
+PLLVIDEO1(124,     1,     375000000U),
+PLLVIDEO1(62,     0,     378000000U),
+PLLVIDEO1(126,     1,     381000000U),
+PLLVIDEO1(63,     0,     384000000U),
+PLLVIDEO1(128,     1,     387000000U),
+PLLVIDEO1(64,     0,     390000000U),
+PLLVIDEO1(130,     1,     393000000U),
+PLLVIDEO1(65,     0,     396000000U),
+PLLVIDEO1(132,     1,     399000000U),
+PLLVIDEO1(66,     0,     402000000U),
+PLLVIDEO1(134,     1,     405000000U),
+PLLVIDEO1(67,     0,     408000000U),
+PLLVIDEO1(136,     1,     411000000U),
+PLLVIDEO1(68,     0,     414000000U),
+PLLVIDEO1(138,     1,     417000000U),
+PLLVIDEO1(69,     0,     420000000U),
+PLLVIDEO1(140,     1,     423000000U),
+PLLVIDEO1(70,     0,     426000000U),
+PLLVIDEO1(142,     1,     429000000U),
+PLLVIDEO1(71,     0,     432000000U),
+PLLVIDEO1(144,     1,     435000000U),
+PLLVIDEO1(72,     0,     438000000U),
+PLLVIDEO1(146,     1,     441000000U),
+PLLVIDEO1(73,     0,     444000000U),
+PLLVIDEO1(148,     1,     447000000U),
+PLLVIDEO1(74,     0,     450000000U),
+PLLVIDEO1(150,     1,     453000000U),
+PLLVIDEO1(75,     0,     456000000U),
+PLLVIDEO1(152,     1,     459000000U),
+PLLVIDEO1(76,     0,     462000000U),
+PLLVIDEO1(154,     1,     465000000U),
+PLLVIDEO1(77,     0,     468000000U),
+PLLVIDEO1(156,     1,     471000000U),
+PLLVIDEO1(78,     0,     474000000U),
+PLLVIDEO1(158,     1,     477000000U),
+PLLVIDEO1(79,     0,     480000000U),
+PLLVIDEO1(160,     1,     483000000U),
+PLLVIDEO1(80,     0,     486000000U),
+PLLVIDEO1(162,     1,     489000000U),
+PLLVIDEO1(81,     0,     492000000U),
+PLLVIDEO1(164,     1,     495000000U),
+PLLVIDEO1(82,     0,     498000000U),
+PLLVIDEO1(166,     1,     501000000U),
+PLLVIDEO1(83,     0,     504000000U),
+PLLVIDEO1(168,     1,     507000000U),
+PLLVIDEO1(84,     0,     510000000U),
+PLLVIDEO1(170,     1,     513000000U),
+PLLVIDEO1(85,     0,     516000000U),
+PLLVIDEO1(172,     1,     519000000U),
+PLLVIDEO1(86,     0,     522000000U),
+PLLVIDEO1(174,     1,     525000000U),
+PLLVIDEO1(87,     0,     528000000U),
+PLLVIDEO1(176,     1,     531000000U),
+PLLVIDEO1(88,     0,     534000000U),
+PLLVIDEO1(178,     1,     537000000U),
+PLLVIDEO1(89,     0,     540000000U),
+};
+
+/* PLLVE(n, d1, d2, freq)	F_N8X8_D1V1X1_D2V0X1 */
+struct sunxi_clk_factor_freq factor_pllve_tbl[] = {
+PLLVE(23,     0,     1,     288000000U),
+PLLVE(24,     0,     1,     300000000U),
+PLLVE(25,     0,     1,     312000000U),
+PLLVE(26,     0,     1,     324000000U),
+PLLVE(27,     0,     1,     336000000U),
+PLLVE(28,     0,     1,     348000000U),
+PLLVE(29,     0,     1,     360000000U),
+PLLVE(30,     0,     1,     372000000U),
+PLLVE(15,     0,     0,     384000000U),
+PLLVE(32,     0,     1,     396000000U),
+PLLVE(16,     0,     0,     408000000U),
+PLLVE(34,     0,     1,     420000000U),
+PLLVE(17,     0,     0,     432000000U),
+PLLVE(36,     0,     1,     444000000U),
+PLLVE(18,     0,     0,     456000000U),
+PLLVE(38,     0,     1,     468000000U),
+PLLVE(19,     0,     0,     480000000U),
+PLLVE(40,     0,     1,     492000000U),
+PLLVE(20,     0,     0,     504000000U),
+PLLVE(42,     0,     1,     516000000U),
+PLLVE(21,     0,     0,     528000000U),
+PLLVE(44,     0,     1,     540000000U),
+PLLVE(22,     0,     0,     552000000U),
+PLLVE(46,     0,     1,     564000000U),
+PLLVE(23,     0,     0,     576000000U),
+PLLVE(48,     0,     1,     588000000U),
+PLLVE(24,     0,     0,     600000000U),
+PLLVE(50,     0,     1,     612000000U),
+PLLVE(25,     0,     0,     624000000U),
+PLLVE(52,     0,     1,     636000000U),
+PLLVE(26,     0,     0,     648000000U),
+PLLVE(54,     0,     1,     660000000U),
+PLLVE(27,     0,     0,     672000000U),
+PLLVE(56,     0,     1,     684000000U),
+PLLVE(28,     0,     0,     696000000U),
+PLLVE(58,     0,     1,     708000000U),
+PLLVE(29,     0,     0,     720000000U),
+PLLVE(60,     0,     1,     732000000U),
+PLLVE(30,     0,     0,     744000000U),
+PLLVE(62,     0,     1,     756000000U),
+PLLVE(31,     0,     0,     768000000U),
+PLLVE(64,     0,     1,     780000000U),
+PLLVE(32,     0,     0,     792000000U),
+PLLVE(66,     0,     1,     804000000U),
+PLLVE(33,     0,     0,     816000000U),
+PLLVE(68,     0,     1,     828000000U),
+PLLVE(34,     0,     0,     840000000U),
+PLLVE(70,     0,     1,     852000000U),
+PLLVE(35,     0,     0,     864000000U),
+PLLVE(72,     0,     1,     876000000U),
+PLLVE(36,     0,     0,     888000000U),
+PLLVE(74,     0,     1,     900000000U),
+PLLVE(37,     0,     0,     912000000U),
+PLLVE(76,     0,     1,     924000000U),
+PLLVE(38,     0,     0,     936000000U),
+PLLVE(78,     0,     1,     948000000U),
+PLLVE(39,     0,     0,     960000000U),
+PLLVE(80,     0,     1,     972000000U),
+PLLVE(40,     0,     0,     984000000U),
+PLLVE(82,     0,     1,     996000000U),
+PLLVE(41,     0,     0,     1008000000U),
+};
+
+/* PLLDE(n, d1, d2, freq)	F_N8X8_D1V1X1_D2V0X1 */
+struct sunxi_clk_factor_freq factor_pllde_tbl[] = {
+PLLDE(23,     0,     1,     288000000U),
+PLLDE(24,     0,     1,     300000000U),
+PLLDE(25,     0,     1,     312000000U),
+PLLDE(26,     0,     1,     324000000U),
+PLLDE(27,     0,     1,     336000000U),
+PLLDE(28,     0,     1,     348000000U),
+PLLDE(29,     0,     1,     360000000U),
+PLLDE(30,     0,     1,     372000000U),
+PLLDE(15,     0,     0,     384000000U),
+PLLDE(32,     0,     1,     396000000U),
+PLLDE(16,     0,     0,     408000000U),
+PLLDE(34,     0,     1,     420000000U),
+PLLDE(17,     0,     0,     432000000U),
+PLLDE(36,     0,     1,     444000000U),
+PLLDE(18,     0,     0,     456000000U),
+PLLDE(38,     0,     1,     468000000U),
+PLLDE(19,     0,     0,     480000000U),
+PLLDE(40,     0,     1,     492000000U),
+PLLDE(20,     0,     0,     504000000U),
+PLLDE(42,     0,     1,     516000000U),
+PLLDE(21,     0,     0,     528000000U),
+PLLDE(44,     0,     1,     540000000U),
+PLLDE(22,     0,     0,     552000000U),
+PLLDE(46,     0,     1,     564000000U),
+PLLDE(23,     0,     0,     576000000U),
+PLLDE(48,     0,     1,     588000000U),
+PLLDE(24,     0,     0,     600000000U),
+PLLDE(50,     0,     1,     612000000U),
+PLLDE(25,     0,     0,     624000000U),
+PLLDE(52,     0,     1,     636000000U),
+PLLDE(26,     0,     0,     648000000U),
+PLLDE(54,     0,     1,     660000000U),
+PLLDE(27,     0,     0,     672000000U),
+PLLDE(56,     0,     1,     684000000U),
+PLLDE(28,     0,     0,     696000000U),
+PLLDE(58,     0,     1,     708000000U),
+PLLDE(29,     0,     0,     720000000U),
+PLLDE(60,     0,     1,     732000000U),
+PLLDE(30,     0,     0,     744000000U),
+PLLDE(62,     0,     1,     756000000U),
+PLLDE(31,     0,     0,     768000000U),
+PLLDE(64,     0,     1,     780000000U),
+PLLDE(32,     0,     0,     792000000U),
+PLLDE(66,     0,     1,     804000000U),
+PLLDE(33,     0,     0,     816000000U),
+PLLDE(68,     0,     1,     828000000U),
+PLLDE(34,     0,     0,     840000000U),
+PLLDE(70,     0,     1,     852000000U),
+PLLDE(35,     0,     0,     864000000U),
+PLLDE(72,     0,     1,     876000000U),
+PLLDE(36,     0,     0,     888000000U),
+PLLDE(74,     0,     1,     900000000U),
+PLLDE(37,     0,     0,     912000000U),
+PLLDE(76,     0,     1,     924000000U),
+PLLDE(38,     0,     0,     936000000U),
+PLLDE(78,     0,     1,     948000000U),
+PLLDE(39,     0,     0,     960000000U),
+PLLDE(80,     0,     1,     972000000U),
+PLLDE(40,     0,     0,     984000000U),
+PLLDE(82,     0,     1,     996000000U),
+PLLDE(41,     0,     0,     1008000000U),
+PLLDE(84,     0,     1,     1020000000U),
+PLLDE(42,     0,     0,     1032000000U),
+PLLDE(86,     0,     1,     1044000000U),
+PLLDE(43,     0,     0,     1056000000U),
+PLLDE(88,     0,     1,     1068000000U),
+PLLDE(44,     0,     0,     1080000000U),
+};
+
+static unsigned int pllcpu_max, pllddr_max, pllperiph0_max,
+		    pllperiph1_max, pllgpu_max, pllvideo0_max, pllvideo1_max,
+		    pllve_max, pllde_max;
+
+#define PLL_MAX_ASSIGN(name) (pll##name##_max = \
+	factor_pll##name##_tbl[ARRAY_SIZE(factor_pll##name##_tbl)-1].freq)
+
+void sunxi_clk_factor_initlimits(void)
+{
+	PLL_MAX_ASSIGN(cpu);
+	PLL_MAX_ASSIGN(ddr);
+	PLL_MAX_ASSIGN(periph0);
+	PLL_MAX_ASSIGN(periph1);
+	PLL_MAX_ASSIGN(gpu);
+	PLL_MAX_ASSIGN(video0);
+	PLL_MAX_ASSIGN(video1);
+	PLL_MAX_ASSIGN(ve);
+	PLL_MAX_ASSIGN(de);
+}
diff --git a/drivers/clk/sunxi/clk-sunxi.c b/drivers/clk/sunxi/clk-sunxi.c
index e1aa1fbac..770358cf1 100644
--- a/drivers/clk/sunxi/clk-sunxi.c
+++ b/drivers/clk/sunxi/clk-sunxi.c
@@ -1,1167 +1,444 @@
-// SPDX-License-Identifier: GPL-2.0-or-later
 /*
- * Copyright 2013 Emilio Lpez
+ * Copyright (C) 2016-2020 Allwinnertech
+ * Wim Hwang <huangwei@allwinnertech.com>
  *
- * Emilio Lpez <emilio@elopez.com.ar>
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
  */
 
 #include <linux/clk.h>
 #include <linux/clk-provider.h>
 #include <linux/clkdev.h>
-#include <linux/io.h>
+#include <linux/clk/sunxi.h>
+#include <linux/clk/clk-conf.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
-#include <linux/reset-controller.h>
-#include <linux/slab.h>
-#include <linux/spinlock.h>
-#include <linux/log2.h>
-
+#include <linux/syscore_ops.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include "clk-sunxi.h"
 #include "clk-factors.h"
+#include "clk-periph.h"
+#include "clk-cpu.h"
 
-static DEFINE_SPINLOCK(clk_lock);
-
-/* Maximum number of parents our clocks have */
-#define SUNXI_MAX_PARENTS	5
+#if IS_ENABLED(CONFIG_PM_SLEEP)
+/*list head use for standby*/
+LIST_HEAD(clk_periph_reg_cache_list);
+LIST_HEAD(clk_factor_reg_cache_list);
+#endif
 
-/**
- * sun4i_get_pll1_factors() - calculates n, k, m, p factors for PLL1
- * PLL1 rate is calculated as follows
- * rate = (parent_rate * n * (k + 1) >> p) / (m + 1);
- * parent_rate is always 24Mhz
+struct clock_provider {
+	void (*clk_init_cb)(struct device_node *);
+	struct device_node *np;
+	struct list_head node;
+};
+/*
+ * of_sunxi_clocks_init() - Clocks initialize
  */
-
-static void sun4i_get_pll1_factors(struct factors_request *req)
+static void of_sunxi_clocks_init(struct device_node *node)
 {
-	u8 div;
-
-	/* Normalize value to a 6M multiple */
-	div = req->rate / 6000000;
-	req->rate = 6000000 * div;
-
-	/* m is always zero for pll1 */
-	req->m = 0;
-
-	/* k is 1 only on these cases */
-	if (req->rate >= 768000000 || req->rate == 42000000 ||
-			req->rate == 54000000)
-		req->k = 1;
-	else
-		req->k = 0;
-
-	/* p will be 3 for divs under 10 */
-	if (div < 10)
-		req->p = 3;
-
-	/* p will be 2 for divs between 10 - 20 and odd divs under 32 */
-	else if (div < 20 || (div < 32 && (div & 1)))
-		req->p = 2;
-
-	/* p will be 1 for even divs under 32, divs under 40 and odd pairs
-	 * of divs between 40-62 */
-	else if (div < 40 || (div < 64 && (div & 2)))
-		req->p = 1;
-
-	/* any other entries have p = 0 */
-	else
-		req->p = 0;
-
-	/* calculate a suitable n based on k and p */
-	div <<= req->p;
-	div /= (req->k + 1);
-	req->n = div / 4;
+	/* do some soc special init here */
+	sunxi_clocks_init(node);
 }
 
-/**
- * sun6i_a31_get_pll1_factors() - calculates n, k and m factors for PLL1
- * PLL1 rate is calculated as follows
- * rate = parent_rate * (n + 1) * (k + 1) / (m + 1);
- * parent_rate should always be 24MHz
- */
-static void sun6i_a31_get_pll1_factors(struct factors_request *req)
+static void of_sunxi_fixed_clk_setup(struct device_node *node)
 {
-	/*
-	 * We can operate only on MHz, this will make our life easier
-	 * later.
-	 */
-	u32 freq_mhz = req->rate / 1000000;
-	u32 parent_freq_mhz = req->parent_rate / 1000000;
-
-	/*
-	 * Round down the frequency to the closest multiple of either
-	 * 6 or 16
-	 */
-	u32 round_freq_6 = rounddown(freq_mhz, 6);
-	u32 round_freq_16 = round_down(freq_mhz, 16);
-
-	if (round_freq_6 > round_freq_16)
-		freq_mhz = round_freq_6;
-	else
-		freq_mhz = round_freq_16;
-
-	req->rate = freq_mhz * 1000000;
-
-	/* If the frequency is a multiple of 32 MHz, k is always 3 */
-	if (!(freq_mhz % 32))
-		req->k = 3;
-	/* If the frequency is a multiple of 9 MHz, k is always 2 */
-	else if (!(freq_mhz % 9))
-		req->k = 2;
-	/* If the frequency is a multiple of 8 MHz, k is always 1 */
-	else if (!(freq_mhz % 8))
-		req->k = 1;
-	/* Otherwise, we don't use the k factor */
-	else
-		req->k = 0;
-
-	/*
-	 * If the frequency is a multiple of 2 but not a multiple of
-	 * 3, m is 3. This is the first time we use 6 here, yet we
-	 * will use it on several other places.
-	 * We use this number because it's the lowest frequency we can
-	 * generate (with n = 0, k = 0, m = 3), so every other frequency
-	 * somehow relates to this frequency.
-	 */
-	if ((freq_mhz % 6) == 2 || (freq_mhz % 6) == 4)
-		req->m = 2;
-	/*
-	 * If the frequency is a multiple of 6MHz, but the factor is
-	 * odd, m will be 3
-	 */
-	else if ((freq_mhz / 6) & 1)
-		req->m = 3;
-	/* Otherwise, we end up with m = 1 */
-	else
-		req->m = 1;
+	struct clk *clk;
+	const char *clk_name = node->name;
+	u32 rate;
 
-	/* Calculate n thanks to the above factors we already got */
-	req->n = freq_mhz * (req->m + 1) / ((req->k + 1) * parent_freq_mhz)
-		 - 1;
+	if (of_property_read_u32(node, "clock-frequency", &rate))
+		return;
 
-	/*
-	 * If n end up being outbound, and that we can still decrease
-	 * m, do it.
-	 */
-	if ((req->n + 1) > 31 && (req->m + 1) > 1) {
-		req->n = (req->n + 1) / 2 - 1;
-		req->m = (req->m + 1) / 2 - 1;
+	if (of_property_read_string(node, "clock-output-names", &clk_name)) {
+		pr_err("%s:get clock-output-names failed in %s node\n",
+						__func__, node->full_name);
+		return;
 	}
-}
-
-/**
- * sun8i_a23_get_pll1_factors() - calculates n, k, m, p factors for PLL1
- * PLL1 rate is calculated as follows
- * rate = (parent_rate * (n + 1) * (k + 1) >> p) / (m + 1);
- * parent_rate is always 24Mhz
- */
-
-static void sun8i_a23_get_pll1_factors(struct factors_request *req)
-{
-	u8 div;
-
-	/* Normalize value to a 6M multiple */
-	div = req->rate / 6000000;
-	req->rate = 6000000 * div;
-
-	/* m is always zero for pll1 */
-	req->m = 0;
-
-	/* k is 1 only on these cases */
-	if (req->rate >= 768000000 || req->rate == 42000000 ||
-			req->rate == 54000000)
-		req->k = 1;
-	else
-		req->k = 0;
-
-	/* p will be 2 for divs under 20 and odd divs under 32 */
-	if (div < 20 || (div < 32 && (div & 1)))
-		req->p = 2;
-
-	/* p will be 1 for even divs under 32, divs under 40 and odd pairs
-	 * of divs between 40-62 */
-	else if (div < 40 || (div < 64 && (div & 2)))
-		req->p = 1;
-
-	/* any other entries have p = 0 */
-	else
-		req->p = 0;
-
-	/* calculate a suitable n based on k and p */
-	div <<= req->p;
-	div /= (req->k + 1);
-	req->n = div / 4 - 1;
-}
-
-/**
- * sun4i_get_pll5_factors() - calculates n, k factors for PLL5
- * PLL5 rate is calculated as follows
- * rate = parent_rate * n * (k + 1)
- * parent_rate is always 24Mhz
- */
-
-static void sun4i_get_pll5_factors(struct factors_request *req)
-{
-	u8 div;
-
-	/* Normalize value to a parent_rate multiple (24M) */
-	div = req->rate / req->parent_rate;
-	req->rate = req->parent_rate * div;
-
-	if (div < 31)
-		req->k = 0;
-	else if (div / 2 < 31)
-		req->k = 1;
-	else if (div / 3 < 31)
-		req->k = 2;
-	else
-		req->k = 3;
-
-	req->n = DIV_ROUND_UP(div, (req->k + 1));
-}
-
-/**
- * sun6i_a31_get_pll6_factors() - calculates n, k factors for A31 PLL6x2
- * PLL6x2 rate is calculated as follows
- * rate = parent_rate * (n + 1) * (k + 1)
- * parent_rate is always 24Mhz
- */
-
-static void sun6i_a31_get_pll6_factors(struct factors_request *req)
-{
-	u8 div;
-
-	/* Normalize value to a parent_rate multiple (24M) */
-	div = req->rate / req->parent_rate;
-	req->rate = req->parent_rate * div;
-
-	req->k = div / 32;
-	if (req->k > 3)
-		req->k = 3;
-
-	req->n = DIV_ROUND_UP(div, (req->k + 1)) - 1;
-}
-
-/**
- * sun5i_a13_get_ahb_factors() - calculates m, p factors for AHB
- * AHB rate is calculated as follows
- * rate = parent_rate >> p
- */
-
-static void sun5i_a13_get_ahb_factors(struct factors_request *req)
-{
-	u32 div;
-
-	/* divide only */
-	if (req->parent_rate < req->rate)
-		req->rate = req->parent_rate;
-
-	/*
-	 * user manual says valid speed is 8k ~ 276M, but tests show it
-	 * can work at speeds up to 300M, just after reparenting to pll6
-	 */
-	if (req->rate < 8000)
-		req->rate = 8000;
-	if (req->rate > 300000000)
-		req->rate = 300000000;
-
-	div = order_base_2(DIV_ROUND_UP(req->parent_rate, req->rate));
-
-	/* p = 0 ~ 3 */
-	if (div > 3)
-		div = 3;
-
-	req->rate = req->parent_rate >> div;
 
-	req->p = div;
-}
-
-#define SUN6I_AHB1_PARENT_PLL6	3
-
-/**
- * sun6i_a31_get_ahb_factors() - calculates m, p factors for AHB
- * AHB rate is calculated as follows
- * rate = parent_rate >> p
- *
- * if parent is pll6, then
- * parent_rate = pll6 rate / (m + 1)
- */
-
-static void sun6i_get_ahb1_factors(struct factors_request *req)
-{
-	u8 div, calcp, calcm = 1;
-
-	/*
-	 * clock can only divide, so we will never be able to achieve
-	 * frequencies higher than the parent frequency
-	 */
-	if (req->parent_rate && req->rate > req->parent_rate)
-		req->rate = req->parent_rate;
-
-	div = DIV_ROUND_UP(req->parent_rate, req->rate);
-
-	/* calculate pre-divider if parent is pll6 */
-	if (req->parent_index == SUN6I_AHB1_PARENT_PLL6) {
-		if (div < 4)
-			calcp = 0;
-		else if (div / 2 < 4)
-			calcp = 1;
-		else if (div / 4 < 4)
-			calcp = 2;
-		else
-			calcp = 3;
-
-		calcm = DIV_ROUND_UP(div, 1 << calcp);
-	} else {
-		calcp = __roundup_pow_of_two(div);
-		calcp = calcp > 3 ? 3 : calcp;
+	clk = clk_register_fixed_rate(NULL, clk_name, NULL, CLK_IS_ROOT, rate);
+	if (!IS_ERR(clk)) {
+		clk_register_clkdev(clk, clk_name, NULL);
+		of_clk_add_provider(node, of_clk_src_simple_get, clk);
 	}
-
-	req->rate = (req->parent_rate / calcm) >> calcp;
-	req->p = calcp;
-	req->m = calcm - 1;
-}
-
-/**
- * sun6i_ahb1_recalc() - calculates AHB clock rate from m, p factors and
- *			 parent index
- */
-static void sun6i_ahb1_recalc(struct factors_request *req)
-{
-	req->rate = req->parent_rate;
-
-	/* apply pre-divider first if parent is pll6 */
-	if (req->parent_index == SUN6I_AHB1_PARENT_PLL6)
-		req->rate /= req->m + 1;
-
-	/* clk divider */
-	req->rate >>= req->p;
 }
 
-/**
- * sun4i_get_apb1_factors() - calculates m, p factors for APB1
- * APB1 rate is calculated as follows
- * rate = (parent_rate >> p) / (m + 1);
- */
-
-static void sun4i_get_apb1_factors(struct factors_request *req)
+static void of_sunxi_fixed_factor_clk_setup(struct device_node *node)
 {
-	u8 calcm, calcp;
-	int div;
-
-	if (req->parent_rate < req->rate)
-		req->rate = req->parent_rate;
-
-	div = DIV_ROUND_UP(req->parent_rate, req->rate);
+	struct clk *clk;
+	const char *clk_name = node->name;
+	const char *parent_name;
+	u32 div, mult;
 
-	/* Invalid rate! */
-	if (div > 32)
+	if (of_property_read_u32(node, "clock-div", &div)) {
+		pr_err("%s Fixed factor clock <%s> must have a clock-div property\n",
+			__func__, node->name);
 		return;
+	}
 
-	if (div <= 4)
-		calcp = 0;
-	else if (div <= 8)
-		calcp = 1;
-	else if (div <= 16)
-		calcp = 2;
-	else
-		calcp = 3;
+	if (of_property_read_u32(node, "clock-mult", &mult)) {
+		pr_err("%s Fixed factor clock <%s> must have a clokc-mult property\n",
+			__func__, node->name);
+		return;
+	}
 
-	calcm = (div >> calcp) - 1;
+	if (of_property_read_string(node, "clock-output-names", &clk_name)) {
+		pr_err("%s:get clock-output-names failed in %s node\n",
+						__func__, node->full_name);
+		return;
+	}
+	parent_name = of_clk_get_parent_name(node, 0);
 
-	req->rate = (req->parent_rate >> calcp) / (calcm + 1);
-	req->m = calcm;
-	req->p = calcp;
+	clk = clk_register_fixed_factor(NULL, clk_name, parent_name, 0,
+					mult, div);
+	if (!IS_ERR(clk)) {
+		clk_register_clkdev(clk, clk_name, NULL);
+		of_clk_add_provider(node, of_clk_src_simple_get, clk);
+	}
 }
 
-
-
-
-/**
- * sun7i_a20_get_out_factors() - calculates m, p factors for CLK_OUT_A/B
- * CLK_OUT rate is calculated as follows
- * rate = (parent_rate >> p) / (m + 1);
+/*
+ * of_sunxi_pll_clk_setup() - Setup function for pll factors clk
  */
-
-static void sun7i_a20_get_out_factors(struct factors_request *req)
+static void of_sunxi_pll_clk_setup(struct device_node *node)
 {
-	u8 div, calcm, calcp;
-
-	/* These clocks can only divide, so we will never be able to achieve
-	 * frequencies higher than the parent frequency */
-	if (req->rate > req->parent_rate)
-		req->rate = req->parent_rate;
-
-	div = DIV_ROUND_UP(req->parent_rate, req->rate);
+	struct clk *clk;
+	const char *clk_name = node->name;
+	const char *lock_mode = NULL;
+	struct factor_init_data *factor;
 
-	if (div < 32)
-		calcp = 0;
-	else if (div / 2 < 32)
-		calcp = 1;
-	else if (div / 4 < 32)
-		calcp = 2;
-	else
-		calcp = 3;
+	if (of_property_read_string(node, "clock-output-names", &clk_name)) {
+		pr_err("%s:get clock-output-names failed in %s node\n",
+						__func__, node->full_name);
+		return;
+	}
+	factor = sunxi_clk_get_factor_by_name(clk_name);
+	if (!factor) {
+		pr_err("clk %s not found in %s\n", clk_name, __func__);
+		return;
+	}
 
-	calcm = DIV_ROUND_UP(div, 1 << calcp);
+	if (!of_property_read_string(node, "lock-mode", &lock_mode))
+		sunxi_clk_set_factor_lock_mode(factor, lock_mode);
 
-	req->rate = (req->parent_rate >> calcp) / calcm;
-	req->m = calcm - 1;
-	req->p = calcp;
+	clk = sunxi_clk_register_factors(NULL, sunxi_clk_base,
+					 &clk_lock, factor);
+	if (!IS_ERR(clk)) {
+		clk_register_clkdev(clk, clk_name, NULL);
+		of_clk_add_provider(node, of_clk_src_simple_get, clk);
+	}
 }
 
-/**
- * sunxi_factors_clk_setup() - Setup function for factor clocks
+/*
+ * of_sunxi_cpus_pll_clk_setup() - Setup function for prcm pll factors clk
  */
-
-static const struct clk_factors_config sun4i_pll1_config = {
-	.nshift = 8,
-	.nwidth = 5,
-	.kshift = 4,
-	.kwidth = 2,
-	.mshift = 0,
-	.mwidth = 2,
-	.pshift = 16,
-	.pwidth = 2,
-};
-
-static const struct clk_factors_config sun6i_a31_pll1_config = {
-	.nshift	= 8,
-	.nwidth = 5,
-	.kshift = 4,
-	.kwidth = 2,
-	.mshift = 0,
-	.mwidth = 2,
-	.n_start = 1,
-};
-
-static const struct clk_factors_config sun8i_a23_pll1_config = {
-	.nshift = 8,
-	.nwidth = 5,
-	.kshift = 4,
-	.kwidth = 2,
-	.mshift = 0,
-	.mwidth = 2,
-	.pshift = 16,
-	.pwidth = 2,
-	.n_start = 1,
-};
-
-static const struct clk_factors_config sun4i_pll5_config = {
-	.nshift = 8,
-	.nwidth = 5,
-	.kshift = 4,
-	.kwidth = 2,
-};
-
-static const struct clk_factors_config sun6i_a31_pll6_config = {
-	.nshift	= 8,
-	.nwidth = 5,
-	.kshift = 4,
-	.kwidth = 2,
-	.n_start = 1,
-};
-
-static const struct clk_factors_config sun5i_a13_ahb_config = {
-	.pshift = 4,
-	.pwidth = 2,
-};
-
-static const struct clk_factors_config sun6i_ahb1_config = {
-	.mshift = 6,
-	.mwidth = 2,
-	.pshift = 4,
-	.pwidth = 2,
-};
-
-static const struct clk_factors_config sun4i_apb1_config = {
-	.mshift = 0,
-	.mwidth = 5,
-	.pshift = 16,
-	.pwidth = 2,
-};
-
-/* user manual says "n" but it's really "p" */
-static const struct clk_factors_config sun7i_a20_out_config = {
-	.mshift = 8,
-	.mwidth = 5,
-	.pshift = 20,
-	.pwidth = 2,
-};
-
-static const struct factors_data sun4i_pll1_data __initconst = {
-	.enable = 31,
-	.table = &sun4i_pll1_config,
-	.getter = sun4i_get_pll1_factors,
-};
-
-static const struct factors_data sun6i_a31_pll1_data __initconst = {
-	.enable = 31,
-	.table = &sun6i_a31_pll1_config,
-	.getter = sun6i_a31_get_pll1_factors,
-};
-
-static const struct factors_data sun8i_a23_pll1_data __initconst = {
-	.enable = 31,
-	.table = &sun8i_a23_pll1_config,
-	.getter = sun8i_a23_get_pll1_factors,
-};
-
-static const struct factors_data sun7i_a20_pll4_data __initconst = {
-	.enable = 31,
-	.table = &sun4i_pll5_config,
-	.getter = sun4i_get_pll5_factors,
-};
-
-static const struct factors_data sun4i_pll5_data __initconst = {
-	.enable = 31,
-	.table = &sun4i_pll5_config,
-	.getter = sun4i_get_pll5_factors,
-};
-
-static const struct factors_data sun6i_a31_pll6_data __initconst = {
-	.enable = 31,
-	.table = &sun6i_a31_pll6_config,
-	.getter = sun6i_a31_get_pll6_factors,
-};
-
-static const struct factors_data sun5i_a13_ahb_data __initconst = {
-	.mux = 6,
-	.muxmask = BIT(1) | BIT(0),
-	.table = &sun5i_a13_ahb_config,
-	.getter = sun5i_a13_get_ahb_factors,
-};
-
-static const struct factors_data sun6i_ahb1_data __initconst = {
-	.mux = 12,
-	.muxmask = BIT(1) | BIT(0),
-	.table = &sun6i_ahb1_config,
-	.getter = sun6i_get_ahb1_factors,
-	.recalc = sun6i_ahb1_recalc,
-};
-
-static const struct factors_data sun4i_apb1_data __initconst = {
-	.mux = 24,
-	.muxmask = BIT(1) | BIT(0),
-	.table = &sun4i_apb1_config,
-	.getter = sun4i_get_apb1_factors,
-};
-
-static const struct factors_data sun7i_a20_out_data __initconst = {
-	.enable = 31,
-	.mux = 24,
-	.muxmask = BIT(1) | BIT(0),
-	.table = &sun7i_a20_out_config,
-	.getter = sun7i_a20_get_out_factors,
-};
-
-static struct clk * __init sunxi_factors_clk_setup(struct device_node *node,
-						   const struct factors_data *data)
+static void of_sunxi_cpus_pll_clk_setup(struct device_node *node)
 {
-	void __iomem *reg;
+	struct clk *clk;
+	const char *clk_name = node->name;
+	const char *lock_mode = NULL;
+	struct factor_init_data *factor;
 
-	reg = of_iomap(node, 0);
-	if (!reg) {
-		pr_err("Could not get registers for factors-clk: %pOFn\n",
-		       node);
-		return NULL;
+	if (of_property_read_string(node, "clock-output-names", &clk_name)) {
+		pr_err("%s:get clock-output-names failed in %s node\n",
+						__func__, node->full_name);
+		return;
+	}
+	factor = sunxi_clk_get_factor_by_name(clk_name);
+	if (!factor) {
+		pr_err("clk %s not found in %s\n", clk_name, __func__);
+		return;
 	}
 
-	return sunxi_factors_register(node, data, &clk_lock, reg);
-}
-
-static void __init sun4i_pll1_clk_setup(struct device_node *node)
-{
-	sunxi_factors_clk_setup(node, &sun4i_pll1_data);
-}
-CLK_OF_DECLARE(sun4i_pll1, "allwinner,sun4i-a10-pll1-clk",
-	       sun4i_pll1_clk_setup);
-
-static void __init sun6i_pll1_clk_setup(struct device_node *node)
-{
-	sunxi_factors_clk_setup(node, &sun6i_a31_pll1_data);
-}
-CLK_OF_DECLARE(sun6i_pll1, "allwinner,sun6i-a31-pll1-clk",
-	       sun6i_pll1_clk_setup);
-
-static void __init sun8i_pll1_clk_setup(struct device_node *node)
-{
-	sunxi_factors_clk_setup(node, &sun8i_a23_pll1_data);
-}
-CLK_OF_DECLARE(sun8i_pll1, "allwinner,sun8i-a23-pll1-clk",
-	       sun8i_pll1_clk_setup);
-
-static void __init sun7i_pll4_clk_setup(struct device_node *node)
-{
-	sunxi_factors_clk_setup(node, &sun7i_a20_pll4_data);
-}
-CLK_OF_DECLARE(sun7i_pll4, "allwinner,sun7i-a20-pll4-clk",
-	       sun7i_pll4_clk_setup);
-
-static void __init sun5i_ahb_clk_setup(struct device_node *node)
-{
-	sunxi_factors_clk_setup(node, &sun5i_a13_ahb_data);
-}
-CLK_OF_DECLARE(sun5i_ahb, "allwinner,sun5i-a13-ahb-clk",
-	       sun5i_ahb_clk_setup);
-
-static void __init sun6i_ahb1_clk_setup(struct device_node *node)
-{
-	sunxi_factors_clk_setup(node, &sun6i_ahb1_data);
-}
-CLK_OF_DECLARE(sun6i_a31_ahb1, "allwinner,sun6i-a31-ahb1-clk",
-	       sun6i_ahb1_clk_setup);
-
-static void __init sun4i_apb1_clk_setup(struct device_node *node)
-{
-	sunxi_factors_clk_setup(node, &sun4i_apb1_data);
-}
-CLK_OF_DECLARE(sun4i_apb1, "allwinner,sun4i-a10-apb1-clk",
-	       sun4i_apb1_clk_setup);
+	if (!of_property_read_string(node, "lock-mode", &lock_mode))
+		sunxi_clk_set_factor_lock_mode(factor, lock_mode);
 
-static void __init sun7i_out_clk_setup(struct device_node *node)
-{
-	sunxi_factors_clk_setup(node, &sun7i_a20_out_data);
+	clk = sunxi_clk_register_factors(NULL, sunxi_clk_cpus_base,
+					 &clk_lock, factor);
+	if (!IS_ERR(clk)) {
+		clk_register_clkdev(clk, clk_name, NULL);
+		of_clk_add_provider(node, of_clk_src_simple_get, clk);
+	}
 }
-CLK_OF_DECLARE(sun7i_out, "allwinner,sun7i-a20-out-clk",
-	       sun7i_out_clk_setup);
-
 
-/**
- * sunxi_mux_clk_setup() - Setup function for muxes
+/*
+ * of_sunxi_periph_clk_setup() - Setup function for periph clk
  */
-
-#define SUNXI_MUX_GATE_WIDTH	2
-
-struct mux_data {
-	u8 shift;
-};
-
-static const struct mux_data sun4i_cpu_mux_data __initconst = {
-	.shift = 16,
-};
-
-static const struct mux_data sun6i_a31_ahb1_mux_data __initconst = {
-	.shift = 12,
-};
-
-static const struct mux_data sun8i_h3_ahb2_mux_data __initconst = {
-	.shift = 0,
-};
-
-static struct clk * __init sunxi_mux_clk_setup(struct device_node *node,
-					       const struct mux_data *data,
-					       unsigned long flags)
+static void of_sunxi_periph_clk_setup(struct device_node *node)
 {
 	struct clk *clk;
 	const char *clk_name = node->name;
-	const char *parents[SUNXI_MAX_PARENTS];
-	void __iomem *reg;
-	int i;
-
-	reg = of_iomap(node, 0);
-	if (!reg) {
-		pr_err("Could not map registers for mux-clk: %pOF\n", node);
-		return NULL;
-	}
+	struct periph_init_data *periph;
 
-	i = of_clk_parent_fill(node, parents, SUNXI_MAX_PARENTS);
 	if (of_property_read_string(node, "clock-output-names", &clk_name)) {
-		pr_err("%s: could not read clock-output-names from \"%pOF\"\n",
-		       __func__, node);
-		goto out_unmap;
+		pr_err("%s:get clock-output-names failed in %s node\n",
+						__func__, node->full_name);
+		return;
 	}
 
-	clk = clk_register_mux(NULL, clk_name, parents, i,
-			       CLK_SET_RATE_PARENT | flags, reg,
-			       data->shift, SUNXI_MUX_GATE_WIDTH,
-			       0, &clk_lock);
-
-	if (IS_ERR(clk)) {
-		pr_err("%s: failed to register mux clock %s: %ld\n", __func__,
-		       clk_name, PTR_ERR(clk));
-		goto out_unmap;
+	periph = sunxi_clk_get_periph_by_name(clk_name);
+	if (!periph) {
+		pr_err("clk %s not found in %s\n", clk_name, __func__);
+		return;
 	}
 
-	if (of_clk_add_provider(node, of_clk_src_simple_get, clk)) {
-		pr_err("%s: failed to add clock provider for %s\n",
-		       __func__, clk_name);
-		clk_unregister_divider(clk);
-		goto out_unmap;
+	if (!strcmp(clk_name, "losc_out")) {
+		clk = sunxi_clk_register_periph(periph, 0);
+	} else
+		clk = sunxi_clk_register_periph(periph,
+					sunxi_clk_base);
+	if (!IS_ERR(clk)) {
+		clk_register_clkdev(clk, clk_name, NULL);
+		of_clk_add_provider(node, of_clk_src_simple_get, clk);
 	}
-
-	return clk;
-out_unmap:
-	iounmap(reg);
-	return NULL;
-}
-
-static void __init sun4i_cpu_clk_setup(struct device_node *node)
-{
-	/* Protect CPU clock */
-	sunxi_mux_clk_setup(node, &sun4i_cpu_mux_data, CLK_IS_CRITICAL);
-}
-CLK_OF_DECLARE(sun4i_cpu, "allwinner,sun4i-a10-cpu-clk",
-	       sun4i_cpu_clk_setup);
-
-static void __init sun6i_ahb1_mux_clk_setup(struct device_node *node)
-{
-	sunxi_mux_clk_setup(node, &sun6i_a31_ahb1_mux_data, 0);
 }
-CLK_OF_DECLARE(sun6i_ahb1_mux, "allwinner,sun6i-a31-ahb1-mux-clk",
-	       sun6i_ahb1_mux_clk_setup);
 
-static void __init sun8i_ahb2_clk_setup(struct device_node *node)
+/*
+ * of_sunxi_cpu_clk_setup() - Setup function for cpu clk
+ */
+static void of_sunxi_cpu_clk_setup(struct device_node *node)
 {
-	sunxi_mux_clk_setup(node, &sun8i_h3_ahb2_mux_data, 0);
+	sunxi_cpu_clocks_init(node);
 }
-CLK_OF_DECLARE(sun8i_ahb2, "allwinner,sun8i-h3-ahb2-clk",
-	       sun8i_ahb2_clk_setup);
-
 
 /**
- * sunxi_divider_clk_setup() - Setup function for simple divider clocks
+ * of_periph_cpus_clk_setup() - Setup function for periph cpus clk
  */
-
-struct div_data {
-	u8	shift;
-	u8	pow;
-	u8	width;
-	const struct clk_div_table *table;
-};
-
-static const struct div_data sun4i_axi_data __initconst = {
-	.shift	= 0,
-	.pow	= 0,
-	.width	= 2,
-};
-
-static const struct clk_div_table sun8i_a23_axi_table[] __initconst = {
-	{ .val = 0, .div = 1 },
-	{ .val = 1, .div = 2 },
-	{ .val = 2, .div = 3 },
-	{ .val = 3, .div = 4 },
-	{ .val = 4, .div = 4 },
-	{ .val = 5, .div = 4 },
-	{ .val = 6, .div = 4 },
-	{ .val = 7, .div = 4 },
-	{ } /* sentinel */
-};
-
-static const struct div_data sun8i_a23_axi_data __initconst = {
-	.width	= 3,
-	.table	= sun8i_a23_axi_table,
-};
-
-static const struct div_data sun4i_ahb_data __initconst = {
-	.shift	= 4,
-	.pow	= 1,
-	.width	= 2,
-};
-
-static const struct clk_div_table sun4i_apb0_table[] __initconst = {
-	{ .val = 0, .div = 2 },
-	{ .val = 1, .div = 2 },
-	{ .val = 2, .div = 4 },
-	{ .val = 3, .div = 8 },
-	{ } /* sentinel */
-};
-
-static const struct div_data sun4i_apb0_data __initconst = {
-	.shift	= 8,
-	.pow	= 1,
-	.width	= 2,
-	.table	= sun4i_apb0_table,
-};
-
-static void __init sunxi_divider_clk_setup(struct device_node *node,
-					   const struct div_data *data)
+void of_sunxi_periph_cpus_clk_setup(struct device_node *node)
 {
 	struct clk *clk;
 	const char *clk_name = node->name;
-	const char *clk_parent;
-	void __iomem *reg;
-
-	reg = of_iomap(node, 0);
-	if (!reg) {
-		pr_err("Could not map registers for mux-clk: %pOF\n", node);
-		return;
-	}
-
-	clk_parent = of_clk_get_parent_name(node, 0);
+	struct periph_init_data *periph;
 
 	if (of_property_read_string(node, "clock-output-names", &clk_name)) {
-		pr_err("%s: could not read clock-output-names from \"%pOF\"\n",
-		       __func__, node);
-		goto out_unmap;
-	}
-
-	clk = clk_register_divider_table(NULL, clk_name, clk_parent, 0,
-					 reg, data->shift, data->width,
-					 data->pow ? CLK_DIVIDER_POWER_OF_TWO : 0,
-					 data->table, &clk_lock);
-	if (IS_ERR(clk)) {
-		pr_err("%s: failed to register divider clock %s: %ld\n",
-		       __func__, clk_name, PTR_ERR(clk));
-		goto out_unmap;
+		pr_err("%s:get clock-output-names failed in %s node\n",
+						__func__, node->full_name);
+		return;
 	}
 
-	if (of_clk_add_provider(node, of_clk_src_simple_get, clk)) {
-		pr_err("%s: failed to add clock provider for %s\n",
-		       __func__, clk_name);
-		goto out_unregister;
+	periph = sunxi_clk_get_periph_cpus_by_name(clk_name);
+	if (!periph) {
+		pr_err("clk %s not found in %s\n", clk_name, __func__);
+		return;
 	}
 
-	if (clk_register_clkdev(clk, clk_name, NULL)) {
-		of_clk_del_provider(node);
-		goto out_unregister;
+	/* register clk */
+	if (!strcmp(clk_name, "losc_out") ||
+				!strcmp(clk_name, "dcxo_out") ||
+				!strcmp(clk_name, "r_dma") ||
+				!strcmp(clk_name, "hosc32k")) {
+		clk = sunxi_clk_register_periph(periph, 0);
+	} else
+		clk = sunxi_clk_register_periph(periph,
+					sunxi_clk_cpus_base);
+
+	if (!IS_ERR(clk)) {
+		clk_register_clkdev(clk, clk_name, NULL);
+		of_clk_add_provider(node, of_clk_src_simple_get, clk);
+		return;
 	}
 
-	return;
-out_unregister:
-	clk_unregister_divider(clk);
-
-out_unmap:
-	iounmap(reg);
-}
-
-static void __init sun4i_ahb_clk_setup(struct device_node *node)
-{
-	sunxi_divider_clk_setup(node, &sun4i_ahb_data);
-}
-CLK_OF_DECLARE(sun4i_ahb, "allwinner,sun4i-a10-ahb-clk",
-	       sun4i_ahb_clk_setup);
-
-static void __init sun4i_apb0_clk_setup(struct device_node *node)
-{
-	sunxi_divider_clk_setup(node, &sun4i_apb0_data);
-}
-CLK_OF_DECLARE(sun4i_apb0, "allwinner,sun4i-a10-apb0-clk",
-	       sun4i_apb0_clk_setup);
-
-static void __init sun4i_axi_clk_setup(struct device_node *node)
-{
-	sunxi_divider_clk_setup(node, &sun4i_axi_data);
+	pr_err("clk %s not found in %s\n", clk_name, __func__);
 }
-CLK_OF_DECLARE(sun4i_axi, "allwinner,sun4i-a10-axi-clk",
-	       sun4i_axi_clk_setup);
-
-static void __init sun8i_axi_clk_setup(struct device_node *node)
-{
-	sunxi_divider_clk_setup(node, &sun8i_a23_axi_data);
-}
-CLK_OF_DECLARE(sun8i_axi, "allwinner,sun8i-a23-axi-clk",
-	       sun8i_axi_clk_setup);
-
-
-
-/**
- * sunxi_gates_clk_setup() - Setup function for leaf gates on clocks
- */
-
-#define SUNXI_GATES_MAX_SIZE	64
-
-struct gates_data {
-	DECLARE_BITMAP(mask, SUNXI_GATES_MAX_SIZE);
-};
-
-/**
- * sunxi_divs_clk_setup() helper data
- */
-
-#define SUNXI_DIVS_MAX_QTY	4
-#define SUNXI_DIVISOR_WIDTH	2
-
-struct divs_data {
-	const struct factors_data *factors; /* data for the factor clock */
-	int ndivs; /* number of outputs */
-	/*
-	 * List of outputs. Refer to the diagram for sunxi_divs_clk_setup():
-	 * self or base factor clock refers to the output from the pll
-	 * itself. The remaining refer to fixed or configurable divider
-	 * outputs.
-	 */
-	struct {
-		u8 self; /* is it the base factor clock? (only one) */
-		u8 fixed; /* is it a fixed divisor? if not... */
-		struct clk_div_table *table; /* is it a table based divisor? */
-		u8 shift; /* otherwise it's a normal divisor with this shift */
-		u8 pow;   /* is it power-of-two based? */
-		u8 gate;  /* is it independently gateable? */
-		bool critical;
-	} div[SUNXI_DIVS_MAX_QTY];
-};
-
-static struct clk_div_table pll6_sata_tbl[] = {
-	{ .val = 0, .div = 6, },
-	{ .val = 1, .div = 12, },
-	{ .val = 2, .div = 18, },
-	{ .val = 3, .div = 24, },
-	{ } /* sentinel */
-};
-
-static const struct divs_data pll5_divs_data __initconst = {
-	.factors = &sun4i_pll5_data,
-	.ndivs = 2,
-	.div = {
-		/* Protect PLL5_DDR */
-		{ .shift = 0, .pow = 0, .critical = true }, /* M, DDR */
-		{ .shift = 16, .pow = 1, }, /* P, other */
-		/* No output for the base factor clock */
-	}
-};
-
-static const struct divs_data pll6_divs_data __initconst = {
-	.factors = &sun4i_pll5_data,
-	.ndivs = 4,
-	.div = {
-		{ .shift = 0, .table = pll6_sata_tbl, .gate = 14 }, /* M, SATA */
-		{ .fixed = 2 }, /* P, other */
-		{ .self = 1 }, /* base factor clock, 2x */
-		{ .fixed = 4 }, /* pll6 / 4, used as ahb input */
-	}
-};
-
-static const struct divs_data sun6i_a31_pll6_divs_data __initconst = {
-	.factors = &sun6i_a31_pll6_data,
-	.ndivs = 2,
-	.div = {
-		{ .fixed = 2 }, /* normal output */
-		{ .self = 1 }, /* base factor clock, 2x */
-	}
-};
 
 /**
- * sunxi_divs_clk_setup() - Setup function for leaf divisors on clocks
- *
- * These clocks look something like this
- *            ________________________
- *           |         ___divisor 1---|----> to consumer
- * parent >--|  pll___/___divisor 2---|----> to consumer
- *           |        \_______________|____> to consumer
- *           |________________________|
+ * of_periph_rtc_clk_setup() - Setup function for periph rtc clk
  */
-
-static struct clk ** __init sunxi_divs_clk_setup(struct device_node *node,
-						 const struct divs_data *data)
+void of_sunxi_periph_rtc_clk_setup(struct device_node *node)
 {
-	struct clk_onecell_data *clk_data;
-	const char *parent;
-	const char *clk_name;
-	struct clk **clks, *pclk;
-	struct clk_hw *gate_hw, *rate_hw;
-	const struct clk_ops *rate_ops;
-	struct clk_gate *gate = NULL;
-	struct clk_fixed_factor *fix_factor;
-	struct clk_divider *divider;
-	struct factors_data factors = *data->factors;
-	char *derived_name = NULL;
-	void __iomem *reg;
-	int ndivs = SUNXI_DIVS_MAX_QTY, i = 0;
-	int flags, clkflags;
-
-	/* if number of children known, use it */
-	if (data->ndivs)
-		ndivs = data->ndivs;
+	struct clk *clk;
+	const char *clk_name = node->name;
+	struct periph_init_data *periph;
 
-	/* Try to find a name for base factor clock */
-	for (i = 0; i < ndivs; i++) {
-		if (data->div[i].self) {
-			of_property_read_string_index(node, "clock-output-names",
-						      i, &factors.name);
-			break;
-		}
+	if (of_property_read_string(node, "clock-output-names", &clk_name)) {
+		pr_err("%s:get clock-output-names failed in %s node\n",
+						__func__, node->full_name);
+		return;
 	}
-	/* If we don't have a .self clk use the first output-name up to '_' */
-	if (factors.name == NULL) {
-		char *endp;
 
-		of_property_read_string_index(node, "clock-output-names",
-						      0, &clk_name);
-		endp = strchr(clk_name, '_');
-		if (endp) {
-			derived_name = kstrndup(clk_name, endp - clk_name,
-						GFP_KERNEL);
-			if (!derived_name)
-				return NULL;
-			factors.name = derived_name;
-		} else {
-			factors.name = clk_name;
-		}
+	periph = sunxi_clk_get_periph_rtc_by_name(clk_name);
+	if (!periph) {
+		pr_err("clk %s not found in %s\n", clk_name, __func__);
+		return;
 	}
 
-	/* Set up factor clock that we will be dividing */
-	pclk = sunxi_factors_clk_setup(node, &factors);
-	if (!pclk)
-		return NULL;
-
-	parent = __clk_get_name(pclk);
-	kfree(derived_name);
+	/* register clk */
+	clk = sunxi_clk_register_periph(periph,
+					sunxi_clk_rtc_base);
 
-	reg = of_iomap(node, 0);
-	if (!reg) {
-		pr_err("Could not map registers for divs-clk: %pOF\n", node);
-		return NULL;
+	if (!IS_ERR(clk)) {
+		clk_register_clkdev(clk, clk_name, NULL);
+		of_clk_add_provider(node, of_clk_src_simple_get, clk);
+		return;
 	}
 
-	clk_data = kmalloc(sizeof(struct clk_onecell_data), GFP_KERNEL);
-	if (!clk_data)
-		goto out_unmap;
-
-	clks = kcalloc(ndivs, sizeof(*clks), GFP_KERNEL);
-	if (!clks)
-		goto free_clkdata;
-
-	clk_data->clks = clks;
-
-	/* It's not a good idea to have automatic reparenting changing
-	 * our RAM clock! */
-	clkflags = !strcmp("pll5", parent) ? 0 : CLK_SET_RATE_PARENT;
-
-	for (i = 0; i < ndivs; i++) {
-		if (of_property_read_string_index(node, "clock-output-names",
-						  i, &clk_name) != 0)
-			break;
-
-		/* If this is the base factor clock, only update clks */
-		if (data->div[i].self) {
-			clk_data->clks[i] = pclk;
+	pr_err("clk %s not found in %s\n", clk_name, __func__);
+}
+
+#if IS_ENABLED(CONFIG_PM_SLEEP)
+void sunxi_factor_clk_save(struct sunxi_factor_clk_reg_cache *factor_clk_reg)
+{
+	factor_clk_reg->config_value = readl(factor_clk_reg->config_reg);
+	if (factor_clk_reg->sdmpat_reg)
+		factor_clk_reg->sdmpat_value = readl(factor_clk_reg->sdmpat_reg);
+}
+
+void sunxi_factor_clk_restore(struct sunxi_factor_clk_reg_cache *factor_clk_reg)
+{
+	if (factor_clk_reg->sdmpat_reg)
+		writel(factor_clk_reg->sdmpat_value, factor_clk_reg->sdmpat_reg);
+	writel(factor_clk_reg->config_value, factor_clk_reg->config_reg);
+
+}
+
+void sunxi_periph_clk_save(struct sunxi_periph_clk_reg_cache *periph_clk_reg)
+{
+	if (periph_clk_reg->gate_dram_reg)
+		periph_clk_reg->gate_dram_value = readl(periph_clk_reg->gate_dram_reg);
+	if (periph_clk_reg->gate_reset_reg)
+		periph_clk_reg->gate_reset_value = readl(periph_clk_reg->gate_reset_reg);
+	if (periph_clk_reg->gate_enable_reg)
+		periph_clk_reg->gate_enable_value = readl(periph_clk_reg->gate_enable_reg);
+	if (periph_clk_reg->divider_reg)
+		periph_clk_reg->divider_value = readl(periph_clk_reg->divider_reg);
+	if (periph_clk_reg->mux_reg)
+		periph_clk_reg->mux_value = readl(periph_clk_reg->mux_reg);
+	if (periph_clk_reg->gate_bus_reg)
+		periph_clk_reg->gate_bus_value = readl(periph_clk_reg->gate_bus_reg);
+}
+
+void sunxi_periph_clk_restore(struct sunxi_periph_clk_reg_cache *periph_clk_reg)
+{
+	/* we should take care of the order, fix me */
+	if (periph_clk_reg->gate_dram_reg)
+		writel(periph_clk_reg->gate_dram_value, periph_clk_reg->gate_dram_reg);
+	if (periph_clk_reg->gate_reset_reg)
+		writel(periph_clk_reg->gate_reset_value, periph_clk_reg->gate_reset_reg);
+	if (periph_clk_reg->gate_enable_reg)
+		writel(periph_clk_reg->gate_enable_value, periph_clk_reg->gate_enable_reg);
+	if (periph_clk_reg->divider_reg)
+		writel(periph_clk_reg->divider_value, periph_clk_reg->divider_reg);
+	if (periph_clk_reg->mux_reg)
+		writel(periph_clk_reg->mux_value, periph_clk_reg->mux_reg);
+	if (periph_clk_reg->gate_bus_reg)
+		writel(periph_clk_reg->gate_bus_value, periph_clk_reg->gate_bus_reg);
+}
+#endif
+
+#ifndef MODULE
+CLK_OF_DECLARE(sunxi_clocks_init, "allwinner,clk-init", of_sunxi_clocks_init);
+CLK_OF_DECLARE(sunxi_fixed_clk, "allwinner,fixed-clock", of_sunxi_fixed_clk_setup);
+CLK_OF_DECLARE(sunxi_pll_clk, "allwinner,pll-clock", of_sunxi_pll_clk_setup);
+CLK_OF_DECLARE(sunxi_cpus_pll_clk, "allwinner,cpus-pll-clock", of_sunxi_cpus_pll_clk_setup);
+CLK_OF_DECLARE(sunxi_fixed_factor_clk, "allwinner,fixed-factor-clock", of_sunxi_fixed_factor_clk_setup);
+CLK_OF_DECLARE(sunxi_cpu_clk, "allwinner,cpu-clock", of_sunxi_cpu_clk_setup);
+CLK_OF_DECLARE(sunxi_periph_clk, "allwinner,periph-clock", of_sunxi_periph_clk_setup);
+CLK_OF_DECLARE(periph_cpus_clk, "allwinner,periph-cpus-clock", of_sunxi_periph_cpus_clk_setup);
+CLK_OF_DECLARE(periph_rtc_clk, "allwinner,periph-rtc-clock", of_sunxi_periph_rtc_clk_setup);
+#else
+static const struct of_device_id sunxi_clock_init_tab[] = {
+	{ .compatible = "allwinner,clk-init",
+	  .data = of_sunxi_clocks_init,
+	},
+	{ .compatible = "allwinner,fixed-clock",
+	  .data = of_sunxi_fixed_clk_setup,
+	},
+	{ .compatible = "allwinner,pll-clock",
+	  .data = of_sunxi_pll_clk_setup,
+	},
+	{ .compatible = "allwinner,cpus-pll-clock",
+	  .data = of_sunxi_cpus_pll_clk_setup,
+	},
+	{ .compatible = "allwinner,fixed-factor-clock",
+	  .data = of_sunxi_fixed_factor_clk_setup,
+	},
+	{ .compatible = "allwinner,cpu-clock",
+	  .data = of_sunxi_cpu_clk_setup,
+	},
+	{ .compatible = "allwinner,periph-clock",
+	  .data = of_sunxi_periph_clk_setup,
+	},
+	{ .compatible = "allwinner,periph-cpus-clock",
+	  .data = of_sunxi_periph_cpus_clk_setup,
+	},
+	{ .compatible = "allwinner,periph-rtc-clock",
+	  .data = of_sunxi_periph_rtc_clk_setup,
+	},
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, sunxi_clock_init_tab);
+
+static int of_clocks_init(struct platform_device *pdev)
+{
+	const struct of_device_id *match;
+	const struct of_device_id *matches = sunxi_clock_init_tab;
+	struct device_node *np;
+	struct clock_provider *clk_provider, *next;
+	bool is_init_done;
+	bool force = false;
+	LIST_HEAD(clk_provider_list);
+
+	/* First prepare the list of the clocks providers */
+	for_each_matching_node_and_match(np, matches, &match) {
+		struct clock_provider *parent;
+
+		if (!of_device_is_available(np))
 			continue;
-		}
-
-		gate_hw = NULL;
-		rate_hw = NULL;
-		rate_ops = NULL;
-
-		/* If this leaf clock can be gated, create a gate */
-		if (data->div[i].gate) {
-			gate = kzalloc(sizeof(*gate), GFP_KERNEL);
-			if (!gate)
-				goto free_clks;
 
-			gate->reg = reg;
-			gate->bit_idx = data->div[i].gate;
-			gate->lock = &clk_lock;
-
-			gate_hw = &gate->hw;
+		parent = kzalloc(sizeof(*parent), GFP_KERNEL);
+		if (!parent) {
+			list_for_each_entry_safe(clk_provider, next,
+						 &clk_provider_list, node) {
+				list_del(&clk_provider->node);
+				of_node_put(clk_provider->np);
+				kfree(clk_provider);
+			}
+			of_node_put(np);
+			return -EINVAL;
 		}
-
-		/* Leaves can be fixed or configurable divisors */
-		if (data->div[i].fixed) {
-			fix_factor = kzalloc(sizeof(*fix_factor), GFP_KERNEL);
-			if (!fix_factor)
-				goto free_gate;
-
-			fix_factor->mult = 1;
-			fix_factor->div = data->div[i].fixed;
-
-			rate_hw = &fix_factor->hw;
-			rate_ops = &clk_fixed_factor_ops;
-		} else {
-			divider = kzalloc(sizeof(*divider), GFP_KERNEL);
-			if (!divider)
-				goto free_gate;
-
-			flags = data->div[i].pow ? CLK_DIVIDER_POWER_OF_TWO : 0;
-
-			divider->reg = reg;
-			divider->shift = data->div[i].shift;
-			divider->width = SUNXI_DIVISOR_WIDTH;
-			divider->flags = flags;
-			divider->lock = &clk_lock;
-			divider->table = data->div[i].table;
-
-			rate_hw = &divider->hw;
-			rate_ops = &clk_divider_ops;
-		}
-
-		/* Wrap the (potential) gate and the divisor on a composite
-		 * clock to unify them */
-		clks[i] = clk_register_composite(NULL, clk_name, &parent, 1,
-						 NULL, NULL,
-						 rate_hw, rate_ops,
-						 gate_hw, &clk_gate_ops,
-						 clkflags |
-						 (data->div[i].critical ?
-							CLK_IS_CRITICAL : 0));
-
-		WARN_ON(IS_ERR(clk_data->clks[i]));
+		parent->clk_init_cb = match->data;
+		parent->np = of_node_get(np);
+		list_add_tail(&parent->node, &clk_provider_list);
 	}
 
-	/* Adjust to the real max */
-	clk_data->clk_num = i;
+	while (!list_empty(&clk_provider_list)) {
+		is_init_done = false;
+		list_for_each_entry_safe(clk_provider, next,
+					&clk_provider_list, node) {
+				clk_provider->clk_init_cb(clk_provider->np);
+				of_clk_set_defaults(clk_provider->np, true);
+
+				list_del(&clk_provider->node);
+				of_node_put(clk_provider->np);
+				kfree(clk_provider);
+				is_init_done = true;
+		}
 
-	if (of_clk_add_provider(node, of_clk_src_onecell_get, clk_data)) {
-		pr_err("%s: failed to add clock provider for %s\n",
-		       __func__, clk_name);
-		goto free_gate;
+		/*
+		 * We didn't manage to initialize any of the
+		 * remaining providers during the last loop, so now we
+		 * initialize all the remaining ones unconditionally
+		 * in case the clock parent was not mandatory
+		 */
+		if (!is_init_done)
+			force = true;
 	}
-
-	return clks;
-free_gate:
-	kfree(gate);
-free_clks:
-	kfree(clks);
-free_clkdata:
-	kfree(clk_data);
-out_unmap:
-	iounmap(reg);
-	return NULL;
-}
-
-static void __init sun4i_pll5_clk_setup(struct device_node *node)
-{
-	sunxi_divs_clk_setup(node, &pll5_divs_data);
+	return 0;
 }
-CLK_OF_DECLARE(sun4i_pll5, "allwinner,sun4i-a10-pll5-clk",
-	       sun4i_pll5_clk_setup);
 
-static void __init sun4i_pll6_clk_setup(struct device_node *node)
-{
-	sunxi_divs_clk_setup(node, &pll6_divs_data);
-}
-CLK_OF_DECLARE(sun4i_pll6, "allwinner,sun4i-a10-pll6-clk",
-	       sun4i_pll6_clk_setup);
-
-static void __init sun6i_pll6_clk_setup(struct device_node *node)
-{
-	sunxi_divs_clk_setup(node, &sun6i_a31_pll6_divs_data);
-}
-CLK_OF_DECLARE(sun6i_pll6, "allwinner,sun6i-a31-pll6-clk",
-	       sun6i_pll6_clk_setup);
-
-/*
- * sun6i display
- *
- * rate = parent_rate / (m + 1);
- */
-static void sun6i_display_factors(struct factors_request *req)
-{
-	u8 m;
-
-	if (req->rate > req->parent_rate)
-		req->rate = req->parent_rate;
-
-	m = DIV_ROUND_UP(req->parent_rate, req->rate);
-
-	req->rate = req->parent_rate / m;
-	req->m = m - 1;
-}
-
-static const struct clk_factors_config sun6i_display_config = {
-	.mshift = 0,
-	.mwidth = 4,
+static struct platform_driver sunxi_clk_init_driver = {
+	.driver = {
+		.name	= "sunxi-clk-init",
+		.of_match_table = sunxi_clock_init_tab,
+	},
+	.probe = of_clocks_init,
 };
-
-static const struct factors_data sun6i_display_data __initconst = {
-	.enable = 31,
-	.mux = 24,
-	.muxmask = BIT(2) | BIT(1) | BIT(0),
-	.table = &sun6i_display_config,
-	.getter = sun6i_display_factors,
-};
-
-static void __init sun6i_display_setup(struct device_node *node)
-{
-	sunxi_factors_clk_setup(node, &sun6i_display_data);
-}
-CLK_OF_DECLARE(sun6i_display, "allwinner,sun6i-a31-display-clk",
-	       sun6i_display_setup);
+module_platform_driver(sunxi_clk_init_driver);
+MODULE_LICENSE("GPL");
+#endif
diff --git a/drivers/clk/sunxi/clk-sunxi.h b/drivers/clk/sunxi/clk-sunxi.h
new file mode 100644
index 000000000..1366d9ee5
--- /dev/null
+++ b/drivers/clk/sunxi/clk-sunxi.h
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2013 Allwinnertech, kevin.z.m <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Adjustable factor-based clock implementation
+ */
+#ifndef __MACH_SUNXI_CLK_SUNXI_H
+#define __MACH_SUNXI_CLK_SUNXI_H
+
+#define CLK_FLAGS_BIT_MAX		(14)  /* the max bit used in include/linux/clk-provider.h */
+#define CLK_IS_ROOT			BIT(CLK_FLAGS_BIT_MAX + 1)
+#define CLK_IGNORE_AUTORESET    	BIT(CLK_FLAGS_BIT_MAX + 2)
+#define CLK_REVERT_ENABLE		BIT(CLK_FLAGS_BIT_MAX + 3)
+#define CLK_IGNORE_SYNCBOOT     	BIT(CLK_FLAGS_BIT_MAX + 4)
+#define CLK_READONLY			BIT(CLK_FLAGS_BIT_MAX + 5)
+#define CLK_IGNORE_DISABLE		BIT(CLK_FLAGS_BIT_MAX + 6)
+#define CLK_RATE_FLAT_FACTORS		BIT(CLK_FLAGS_BIT_MAX + 7)
+#define CLK_RATE_FLAT_DELAY		BIT(CLK_FLAGS_BIT_MAX + 8)
+#define CLK_NO_DISABLE			BIT(CLK_FLAGS_BIT_MAX + 9)
+#define CLK_IGNORE_ENABLE_DISABLE	BIT(CLK_FLAGS_BIT_MAX + 10)
+
+#define to_clk_factor(_hw) container_of(_hw, struct sunxi_clk_factors, hw)
+
+#define SETMASK(width, shift)   ((width?((-1U) >> (32-width)):0)  << (shift))
+#define CLRMASK(width, shift)   (~(SETMASK(width, shift)))
+#define GET_BITS(shift, width, reg)     \
+	(((reg) & SETMASK(width, shift)) >> (shift))
+#define SET_BITS(shift, width, reg, val) \
+	(((reg) & CLRMASK(width, shift)) | (val << (shift)))
+
+#define __SUNXI_ALL_CLK_IGNORE_UNUSED__  1
+
+struct sunxi_reg_ops {
+	u32 (*reg_readl)(void __iomem *reg);
+	void (*reg_writel)(u32 val, void __iomem *reg);
+};
+
+#if IS_ENABLED(CONFIG_PM_SLEEP)
+struct sunxi_factor_clk_reg_cache {
+	struct list_head node;
+	void __iomem *config_reg;
+	u32	config_value;
+	void __iomem *sdmpat_reg;
+	u32 sdmpat_value;
+};
+
+struct sunxi_periph_clk_reg_cache {
+	struct list_head node;
+	void __iomem *mux_reg;
+	u32	mux_value;
+	void __iomem *divider_reg;
+	u32 divider_value;
+	void __iomem *gate_enable_reg;
+	u32 gate_enable_value;
+	void __iomem *gate_reset_reg;
+	u32 gate_reset_value;
+	void __iomem *gate_bus_reg;
+	u32 gate_bus_value;
+	void __iomem *gate_dram_reg;
+	u32 gate_dram_value;
+};
+
+extern struct list_head clk_periph_reg_cache_list;
+extern struct list_head clk_factor_reg_cache_list;
+
+void sunxi_factor_clk_save(struct sunxi_factor_clk_reg_cache *factor_clk_reg);
+void sunxi_factor_clk_restore(struct sunxi_factor_clk_reg_cache *factor_clk_reg);
+void sunxi_periph_clk_save(struct sunxi_periph_clk_reg_cache *periph_clk_reg);
+void sunxi_periph_clk_restore(struct sunxi_periph_clk_reg_cache *periph_clk_reg);
+#endif
+
+extern spinlock_t clk_lock;
+extern void __iomem *sunxi_clk_base;
+extern void __iomem *sunxi_clk_cpus_base;
+extern void __iomem *sunxi_clk_rtc_base;
+
+void sunxi_clocks_init(struct device_node *node);
+void sunxi_cpu_clocks_init(struct device_node *node);
+
+struct factor_init_data *sunxi_clk_get_factor_by_name(const char *name);
+struct periph_init_data *sunxi_clk_get_periph_by_name(const char *name);
+struct periph_init_data *sunxi_clk_get_periph_rtc_by_name(const char *name);
+struct periph_init_data *sunxi_clk_get_periph_cpus_by_name(const char *name);
+#endif
-- 
2.17.1

